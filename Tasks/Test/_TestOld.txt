
		//class HiddenForm :Form
		//{
		//	protected override void SetVisibleCore(bool value)
		//	{
		//		if(!this.IsHandleCreated) {
		//			this.CreateHandle();
		//			value = false;   // Prevent window from becoming visible
		//		}
		//		base.SetVisibleCore(value);
		//	}
		//}




////Perf.SpinCPU(); //does nothing
//long t1 = Stopwatch.GetTimestamp();

////TODO: instead could simply allocate unmanaged memory with Marshal methods and pass to domains with childDomain.SetData
//_sm = new OurSharedMemory();
//_sm.Create("Catkeys_SM_Tasks", 1024 * 1024);

//if(true) //compiler
//{
//	_sm.x->perf.AddTicksFirst(t1);
//	_sm.x->perf.Next();

//	IntPtr ev = Api.CreateEvent(Zero, false, false, null);

//	_sm.x->eventCompilerStartup = ev;

//	//Mes("before");

//	var thr = new Thread(_AppDomainThread);
//	thr.Start();

//	_sm.x->perf.Next();

//	Api.WaitForSingleObject(ev, ~0U);
//	//Thread.Sleep(100);
//	Api.CloseHandle(ev);

//	_sm.x->perf.Next();
//	_sm.x->perf.Write();

//	_hwndCompiler = _sm.x->hwndCompiler;

//	for(int i = 0; i < 1; i++) {
//		_hwndCompiler.Send(Api.WM_USER, Zero, Marshal.StringToBSTR("test"));
//	}

//	//Mes("in");

//	_hwndCompiler.Send(Api.WM_CLOSE);
//	//Environment.Exit(0);

//	//Mes("after");
//	//return;
//}

////Thread.Sleep(100);

////for(int i = 0; i<5; i++) {
////	var thr2 = new Thread(_AppDomainThread2);
////	thr2.Start();
////	Thread.Sleep(100);
////	if(i%10!=9) continue;
////	//Perf.First();
////	thr2=null;
////	GC.Collect(); //releases a lot. Without it, GC runs when Task Manager shows 100 MB.
////				  //GC.Collect(2, GCCollectionMode.Optimized); //collects at 26 MB; without - at 36 MB
////}
////Mes("exit");	//static void _AppDomainThread2()

//{
//	Perf.First();
//	var domain = AppDomain.CreateDomain("Compiler");
//	Perf.Next();
//	domain.ExecuteAssembly(@"C:\Test\test1.exe");
//	Perf.Next();
//	AppDomain.Unload(domain);
//	Perf.NextWrite();
//}

//static void _AppDomainThread()
//{
//	//_DomainCallback();

//	var domain = AppDomain.CreateDomain("Compiler");
//	//var domain=AppDomain.CreateDomain("Compiler", AppDomain.CurrentDomain.Evidence, new AppDomainSetup { LoaderOptimization = LoaderOptimization.MultiDomain }); //by default makes faster, but makes much slower when we use LoaderOptimization attribute on Main(). Assemblies will not be unloaded when appdomain unloaded (will use many MB of memory).
//	//System.IO.Pipes.AnonymousPipeClientStream
//	//childDomain.SetData("hPipe", handle.ToString());
//	unsafe { _sm.x->perf.Next(); }

//	domain.DoCallBack(_DomainCallback);
//	//domain.ExecuteAssembly(Paths.CombineApp("Compiler.exe"));
//	//domain.DoCallBack(Compiler.Compiler.Main); //faster than ExecuteAssembly by 3-4 ms
//	AppDomain.Unload(domain);
//	domain = null;
//	//Out("_AppDomainThread() ended");
//	GC.Collect(); //releases a lot
//				  //Mes("MinimizeMemory");
//				  //Misc.MinimizeMemory(); //does nothing

//	//tested:
//	//Currently speed and memory is similar in both cases - when compiler is in this assembly and when in another.
//	//But will need to test later, when this assembly will be big.
//	//Not using LoaderOptimization.MultiDomain, because then does not unload assemblies of unloaded domains (then uses much memory, and there is no sense to execute compiler in a separate domain).
//}


////[MethodImpl(MethodImplOptions.NoOptimization)]
//static unsafe void _DomainCallback()
//{
//	//if(AppDomain.CurrentDomain.FriendlyName!="Compiler") return;
//	long t1 = Stopwatch.GetTimestamp();

//	_sm = new OurSharedMemory();
//	_sm.Open("Catkeys_SM_Tasks");

//	_sm.x->perf.AddTicksNext(t1);
//	_sm.x->perf.Next();

//	//=AppDomain.CurrentDomain.GetData("hPipe")

//	_wndClassCompiler = new Wnd.Misc.RegisterClass();
//	_wndClassCompiler.Register("Catkeys_Compiler", _WndProcCompiler);

//	_sm.x->perf.Next();

//	Wnd w = Api.CreateWindowEx(0, "Catkeys_Compiler", null, Api.WS_POPUP, 0, 0, 0, 0, Wnd.Misc.SpecHwnd.Message, Zero, Zero, Zero);

//	_sm.x->perf.Next();

//	_SHMEM* x = _sm.x;
//	x->hwndCompiler = w;
//	Api.SetEvent(x->eventCompilerStartup);

//	//message loop
//	//Application.Run(); //By default would add several ms to the startup time. Same speed if Main() has the LoaderOptimization attribute. Also may be not completely compatible with native wndproc. Also in some cases adds several MB to the working set.
//	Api.MSG m;
//	while(Api.GetMessage(out m, Wnd0, 0, 0) > 0) { Api.DispatchMessage(ref m); }
//}

//struct _SHMEM
//{
//	public IntPtr eventCompilerStartup;
//	public Wnd hwndCompiler;
//	public Perf.PerfInstance perf;
//}

////We don't use MemoryMappedFile because it is very slow. Creating/writing is 1500, opening/reading is 5000.
////With this class - 1300 and 600 (because of JIT). With ngen - 60 and 20 (same as in C++).
//unsafe class OurSharedMemory :Util.SharedMemoryFast
//{
//	public _SHMEM* x { get { return (_SHMEM*)_mem; } }
//}

//static OurSharedMemory _sm;
//static Wnd _hwndCompiler;



////class DialogVariables { public string lb3, c4; public string[] au; }
////class DialogVariables { public object lb3, c4, au; }
////here class is better than struct, because:
////Don't need ref;
////Can be used with modeless dialogs.

////const string S1="one"+NL+"two"; //ok
////const string S2=$"one{NL}two"; //error


//static void ShowDialog(object v)
//{
//	FieldInfo[] a = v.GetType().GetFields();
//	foreach(FieldInfo f in a) {
//		Out(f.Name);
//		//Out(f.FieldType.Equals(typeof(string)));
//		switch(Type.GetTypeCode(f.FieldType)) {
//		case TypeCode.String: Out("string"); break;
//		case TypeCode.Object: Out("object"); break;
//		}
//	}
//}

////delegate void Dee(GCHandle x);

////static void Mee(GCHandle x)
////{
////Out("here"); return;
//////Out(x.IsAllocated);
////Out(GCHandle.ToIntPtr(x));
////if(GCHandle.ToIntPtr(x)==Zero) Out("null");
////else {
////string s=(x.Target as string);
////Out(s);
////}
////}
//delegate void Dee(object x);


//delegate void Del(int t);
////delegate void Del0();

//class TestIndexers
//{
//	//public int this[int i]
//	//{
//	//get { return i*i; }
//	//set { Out($"{i} {value}"); }
//	//}
//	//public int this[int i, int j=1]
//	//{
//	//	get { return i*j; }
//	//	set { Out($"{i} {j} {value}"); }
//	//}
//	public string this[string s]
//	{
//		get { return s + " ?"; }
//		set { Out($"{s} {value}"); }
//	}

//	//static TestIndexers ti_=new TestIndexers();
//	//public static TestIndexers Hotkey => ti_;
//	//or
//	public static readonly TestIndexers Hotkey = new TestIndexers();
//}

////[MethodImpl(MethodImplOptions.NoInlining)]
////static void TestCallersVariables()
////{
////	Perf.First();
////	StackFrame frame = new StackFrame(1);
////	var method = frame.GetMethod();
////	MethodBody mb=method.GetMethodBody();
////	int n=0;
////	foreach(LocalVariableInfo v in mb.LocalVariables) {
////		//Out(v.LocalType.ToString());
////		if(v.LocalType.Name=="Wnd") {
////			n++;
////			//v.
////		}
////	}
////	Out(n);
////}


//[Trigger.Hotkey("Ctrl+K")]
//public static void Function1(HotkeyTriggers.Message m) { Out("script"); }



//TestUnmanaged();

//StackTrace stackTrace = new StackTrace();
//Out(stackTrace.GetFrame(1).GetMethod().Name);
////Out(stackTrace.GetFrame(1).GetFileLineNumber()); //always 0, even in Debug build
//Out(stackTrace.GetFrame(1).GetFileName()); //null
////Out(stackTrace.GetFrame(1).GetMethod(). //nothing useful




//Dee f=Mee;
////f(GCHandle.Alloc("test"));
////f(GCHandle.FromIntPtr(Zero));
//f("test");
//f(5);


//return;

//UIntPtr ki=1;

//switch(2)
//{
//	case 1:
//	int hdh=8;
//	break;
//	case 2:
//	int koop=8;
//Out(hdh);
//	break;
//}

//Out(hdh);

//Out($"one{_}two");
//Out("three"+_+"four");
//Out("one" RN "two"); //error
//Out($"one{}two"); //error


////str controls="3"
////var d=new DialogVariables("3") { lb3="oooo" };
////var d=new DialogVariables("3");
//var d=new DialogVariables();
//d.lb3="oooo";
//d.c4=7;
//d.au=new string[] { "one", "two" };
////d.au={ "one", "two" }; //error
//ShowDialog(d);
//return;


//static void AnotherThread()
//{
//	//Show.TaskDialog("another thread", "", "", x:1);
//	MessageBox.Show("another thread");
//	Out("after msgbox in another thread");
//}

//[DllImport("comctl32.dll", EntryPoint = "TaskDialog")]
//static extern int _TaskDialog(Wnd hWndParent, IntPtr hInstance, string pszWindowTitle, string pszMainInstruction, string pszContent, TDButton dwCommonButtons, LPARAM pszIcon, out int pnButton);

//static int TD(string s, bool asy)
//{
//	int r = 0;
//	for(int i = 0; i < 100; i++) {
//		int hr = _TaskDialog(Wnd0, Zero, "Test", s, null, TDButton.Cancel, 0, out r);
//		//OutList(hr, r, asy);
//		if(hr == 0 || hr == Api.E_INVALIDARG) break;
//		Time.WaitMS(20);
//	}
//	return r;
//}



////string ss = "gggggg.txt";
////Out(ss.Like_(false, "*.exe", "*.txt"));

////string ss = "5ggggg.txt";
////Out(ss.LikeEx_(false, "#*.exe", "#*.txt"));

////string ss = "5ggggg.txt";
////Out(ss.Equals_(false, "moo.exe", "5ggggg.txt"));

////string ss = "5ggggg.txt";
////Out(ss.EndsWith_(false, ".exe", ".txt"));

////string ss = "file.txt";
////Out(ss.StartsWith_(false, "kkk", "file."));

//string ss = "file.txt";
////Out(ss.RegexIs_(".*.TXT"));
////Out(ss.RegexIs_(".*.txt", RegexOptions.IgnoreCase));
////Out(ss.RegexIs_(0, ".*.TXT", ".*.txt"));
////Out(ss.RegexIs_(RegexOptions.IgnoreCase, ".*.TXT", ".*.txt"));
//ss = "gggg.exe\naaa.txt\nbbb.txt";
////Out(ss.RegexMatch_(".*.TXT"));
////Out(ss.RegexMatch_(".*.TXT", RegexOptions.IgnoreCase));
////Output.Write(ss.RegexMatches_(".*.TXT"));
////Output.Write(ss.RegexMatches_(".*.TXT", RegexOptions.IgnoreCase));

//Out(ss.RegexReplace_(@"\.txt\b", ".moo"));
//Out(ss.RegexReplace_(@"\.txt\b", m=> { return ".boo"; }));

////var au = new int[] {1, 2, 3 };
////var au = new List<int> {1, 2, 3 };
////var au = new Dictionary<string, string>() { { "A", "B" }, { "C", "D" } };
////Output.Write(au, ", ");

//return;




//Out(AppDomain.CurrentDomain.FriendlyName);

//new Thread(AnotherThread).Start();

//Show.TaskDialog("appdomain primary thread", "", "e");

////Thread.CurrentThread.Abort();
////AppDomain.Unload(AppDomain.CurrentDomain);
//Out("after TaskDialog");

//return;

//Show.TaskDialog("", "<a href=\"test\">test</a>", onLinkClick: ed =>
//{
//	Wnd z = ed.hwnd;
//	string s = null;
//	Perf.First(100);
//	for(int j = 0; j<8; j++) {
//		for(int i=0; i<1000; i++) s= z.ClassName;
//		//for(int i=0; i<1000; i++) s= z.Name;
//		//for(int i = 0; i<1000; i++) s= z.ControlText;
//		//for(int i = 0; i<1000; i++) s= z.ControlTextLength;
//		Perf.Next();
//	}
//	Perf.Write();
//	Out(s);
//}
//);

//return;

////Time.Wait(1);
//Wnd z = Wnd.Find("Untitled - Notepad");
////z=(Wnd)2098486; //Inno
////z=(Wnd)395896; //Static
////z=(Wnd)1510052; //Edit

////z.Name = "MMMMMMMMGGGG"; return;

////string m = z.Name;
////string m = z.GetControlText();
////OutList(m==null, m=="", m);
////return;

//Out(z);

//string cn = null;
////cn= z.ControlText; OutList(cn.Length, cn); return;
//int nt = 0;

//Perf.First(100);
//for(int j = 0; j<8; j++) {
//	//for(int i=0; i<1000; i++) cn= z.ClassName;
//	//for(int i=0; i<1000; i++) cn= z.Name;
//	for(int i = 0; i<1000; i++) cn= z.GetControlText();
//	Perf.Next();
//}
//Perf.Write();
//Out(cn);
//Out(nt);

//Wnd ww = Wnd.Find("Untitled - Notepad");
//ww.MoveInScreen(100, 100);
//return;

//OutFunc();
//Out(FunctionName());
//Output.WriteHex((sbyte)(-10));
//OutList(1, "mmm", true, null, 5.6);
//Out("ff");
//Print(5);
//PrintList(1, 2, 3);
//return;

//Output.Clear();
//Screen s = null;
////Output.Write(s);
////Console.WriteLine(s);
//Info("stri");
//Info(5);
//Info(true);
//Info(new char[] { 'a', 'b' });
//Info(new string[] { "aaa", "bbb" });
//Info(new int[] { 'a', 'b' });
//Info(new Dictionary<string, string>() { { "A", "B" }, { "C", "D" } });
//Out("----------");
//Print("stri");
//Print(5);
//Print(true);
//Print(new char[] { 'a', 'b' });
//Print(new string[] { "aaa", "bbb" });
//Print(new int[] { 'a', 'b' });
//Print(new Dictionary<string, string>() { { "A", "B" }, { "C", "D" } });

////Perf.First(100);
////for(int j=0; j<5; j++) {
////	for(int i = 0; i<1000; i++) Info2("ff");
////	Perf.Next();
////}
////Perf.Write();

//return;




//Wait(2);
//Info("bla");
//Out("bla");
//Say("bla");
//Print("bla");
//OW("bla");

//Info("bla"); Warning("bla"); Error("bla");



//Wnd w = Wnd.Find("Untitled - Notepad");
////Wnd w2 = Wnd.Find("Registry Editor");

////w.MoveInScreen(0, 0, null, limitSize:true, rawXY:false);
////w.EnsureInScreen(null, limitSize:true, workArea:true);

//RECT k=new RECT(0, 1700, 5000, 400, true);
////RECT k=new RECT(-1, -1, 500, 400, true);

////Wnd.RectMoveInScreen(ref k, limitSize:true);
//Wnd.RectEnsureInScreen(ref k, limitSize:true);
//Out(k);

////w=Wnd.Misc.SpecHwnd.NoTopmost;
//Out(Screen_.FromObject(w));

////Screen s1 = Screen_.FromObject(w);
////Screen s2 = Screen_.FromObject(w);
//Screen s1 = Screen.PrimaryScreen;
//Screen s2 = Screen.PrimaryScreen;
//Out(s1==s2);
//Out(s1.Equals(s2));


//IntPtr hm = DisplayMonitor.GetHandle(w);
////hm=DisplayMonitor.GetHandle(2);
////hm=DisplayMonitor.GetHandle(DisplayMonitor.OfMouse);
////hm=DisplayMonitor.GetHandle(new POINT(2000, 2000));
////hm=DisplayMonitor.GetHandle(new RECT(2000, 2000, 100, 100, true));
//Out(hm);

//for(int z=0; z<2; z++) {
//	Screen[] ad = Screen.AllScreens;
//	foreach(Screen k in ad) {
//		RECT rr = k.Bounds;
//		Out(rr);
//	}
//	Show.MessageDialog("aaa");
//}

//Perf.First(100);
//for(int rep1=0; rep1<5; rep1++) {
//	//for(int rep2=0; rep2<100; rep2++) { RECT u1 = DisplayMonitor.GetRectangle(2); }
//	for(int rep2=0; rep2<100; rep2++) { RECT u2 = ScreenFromIndex(2).Bounds; }
//	Perf.Next();
//}
//Perf.Write();

//Screen k = ScreenFromIndex(1);
//Out(k.Bounds);


//return;

//RECT r1; System.Drawing.Rectangle r2;

//Api.GetWindowRect(w, out r1);
//GetWindowRect(w, out r2);

//OutList(r1, r2);

//return;


//var r1 = new RECT();
//var r2 = r1;
//var r3 = RECT.LTRB(1, 8, 10, 50);
//var r4 = RECT.LTWH(1, 8, 10, 50);
//var r5 = new RECT() { left=2, top=20, Width=2, Height=10 };

//Out(r2==r1);

//Out(r3);
//Out(r4);
//Out(r5);

//return;

//Wnd w = Wnd.Misc.SpecHwnd.Bottom;
//Out(w.Equals(Wnd.Misc.SpecHwnd.Bottom));
//Wnd w2 = w;
//Out(w.Equals(w2));
////Wnd w = Wnd0;
////Out(w.Equals(Wnd0));

//Wnd wg = Wnd.Get.FirstToplevel();

//return;

//int eon, x = "ab 99 hjk".ToInt_(2, out eon);
//OutList(x, eon);
//int x = "ab 99 hjk".ToInt_(2);
//int x = " 99 hjk".ToInt_();
//OutList(x);
//int eon, x = " 99 hjk".ToInt_(out eon);
//OutList(x, eon);

//return;

//#if NEWRESULT
//try {
//Thread.Sleep(5000);

//Api.MessageBox(Wnd0, "dd", "ggg", 0x40000);
//return;

//Script.Option.dialogRtlLayout=true;
//Script.Option.dialogTopmostIfNoOwner=true;

//var asm = Assembly.GetEntryAssembly(); //fails if DoCallBack or CreateInstance, OK if ExecuteAssembly
//var asm = Assembly.GetExecutingAssembly(); //OK
//Out(asm!=null);
//Out(asm.Location);
////var rm = new System.Resources.ResourceManager("", asm);
////Out(rm);
//return;

//ScriptOptions.DisplayName="Script display name";
//Out(Assembly.GetEntryAssembly().FullName); //exception

//Wnd ko = Wnd0;
////ko = Wnd.Misc.SpecHwnd.Topmost;
//Out(ko == null);
//Out(null==ko);
//Wnd? mo = null, mo2=null;
//Out(ko == mo);
//Out(mo == mo2);
//POINT po = new POINT();
//Out(po == null);
////int io = 0;
////Out(io == null);
//IntPtr pi = Zero;
//Out(pi == null);
//return;

//Out(sizeof(WPARAM));

////void* b = (void*)1000000;
////IntPtr b = (IntPtr)(-1);
////UIntPtr b = (UIntPtr)(0xffffffff);
//int b = -1;
////uint b = 0xffffffff;
////byte b = 5;
////sbyte b = -5;
////ushort b = 5;
////short b = -5;
////char b = 'A';
////WPARAM b = -1;

////IntPtr b=(IntPtr)(-1);
////UIntPtr b=(UIntPtr)(0xffffffff);
////uint b = 5;
////char b = 'A';

//LPARAM x;
//x=b;
////x=1000;
//b=x;

////uint u =0xffffffff;
////int x = (int)u;
////WPARAM y = u;

//Out("OK");
//Out($"{x} {b}");
////Out($"{x} {((int)b).ToString()}");
////Out(x==-1);
////Out(x+4);


////string s = " 10 more";
//string s = "-10 more";
////string s = "0x10 more";
////string s = "-0x10";
//s=" 15 text";

////Out(Convert.ToInt32(s));
////Out(int.Parse(s));
////Out(SplitNumberString(ref s));
////Out($"'{s}'");

//int len, r = s.ToInt_(out len);
//Out($"{r} 0x{r:X} {len}");

//string tail;
//r=s.ToInt_(out tail);
//Out($"{r} 0x{r:X} '{tail}' {tail==null}");

//Perf.SpinCPU();
//int i, j, n1=0, n2=0;
//for(j=0; j<4; j++) {
//	Perf.First();
//	for(i=0; i<1000; i++) n1+=int.Parse(s);
//	Perf.Next();
//	for(i=0; i<1000; i++) n2+=ToInt_(s, out len);
//	Perf.NextWrite();
//}
//Out($"{n1} {n2} {len}");

//string[] a = { "one", "two" };
//Out(a);

//var d = new Dictionary<int, int>() { { 1, 1 }, { 2, 2 } };
//Out(d);

//var k = new Dictionary<string, string>() { { "A", "B" }, { "C", "D" } };
////Out(k);
//Output.Write(k);

//Redirect();
//Thread.Sleep(100);

//Output.Writer=new MooWriter();

//Perf.SpinCPU();
//int i, n=10;
//for(int j=0; j<3; j++) {

//	Perf.First();
//	for(i=0; i<n; i++) Out("out");
//	Perf.Next();
//	for(i=0; i<n; i++) Console.WriteLine("con");
//	//Perf.Next();
//	//for(i=0; i<n; i++) Trace.WriteLine("tra");
//	Perf.NextWrite();
//}
//speed: Write unbuffered 35, Console.WriteLine 30, Trace.WriteLine (debug mode) 900

////Perf.First(100);
////Output.AlwaysOutput=true;
//Output.RedirectConsoleOutput();
//Output.RedirectDebugOutput();
////Perf.NextWrite();

////Console.Write("{0} {1}", 1, true);
////return;
//Out("out");
//Console.WriteLine("con");
//Trace.WriteLine("tra");
////Thread.Sleep(1000); try { Console.Clear(); } catch { Out("exc"); }
//Debug.WriteLine("deb");

////Output.Clear();


//var e = new Exception("failed");
//var e = new ArgumentException(null, "paramName");
//var e = new FormatException();
//var e = new InvalidOperationException();
//var e = new NotImplementedException();
//var e = new NotSupportedException();
//var e = new OperationCanceledException();
//var e = new TimeoutException();
//var e = new WaitTimeoutException();
//var e = new WaitTimeoutException(null, new Exception("inner"));
//var e = new WaitTimeoutException();
//Out(e.Message);


//Out(1);
//Input.Key("Ctrl+K");
//Cat.Key("Ctrl+K");

//Show.MessageDialog("dddd");
//Meow.MessageDialog("dddd");

//Test_str();

//Out($"{(int)Control.ModifierKeys:X}");
//Out($"{(int)Keys.Control:X}");
//Out($"{(int)K.Control:X}");
//Keys("");
//Key("");
//SendKeys


//Out((IntPtr)WndSpec.NoTopmost);
//Out(Wnd.Find("Untitled - Notepad"));

//TestUtil.Test_str();

//string s = "file.txt";
//Out(s.likeS("*.txt"));

////Out(s.Reverse());

//switch(s) {
//case "*.txt":
//	Out("txt");
//	break;
//case "*.moo":
//	Out("moo");
//	break;
//default:
//	Out("none");
//	break;
//}

//if(s.likeI("*.txt")) {
//	Out("txt");
//} else if(s.likeI("*.moo")) {
//	Out("moo");
//} else {
//	Out("none");
//}

//if(s.endsWithI(".txt")) {
//	Out("txt");
//} else if(s.endsWithI(".moo")) {
//	Out("moo");
//} else {
//	Out("none");
//}

//if(Regex.IsMatch(s, "one")) {
//	Out("txt");
//} else if(Regex.IsMatch(s, "two")) {
//	Out("moo");
//} else {
//	Out("none");
//}


//Out(K.A);
//Keys("dd");
//Text("uu");

//Trigger.Hotkey["Ctrl+K"] =O=> { Out("lambda"); };
//Trigger.Hotkey["Ctrl+K"] = delegate(HotkeyTriggers.Message m) { Out("delegate"); };

//HotkeyTriggers.TestFireTrigger();

//var k=new TestIndexers();
//Out(k[3]); k[7]=5;
//Out(k[3, 4]); k[7, 2]=5;
//Out(k[3]); k[7]=5;
//Out(k["AAA"]); k["BBB"]="C";
//TestIndexers.Hotkey["test"]="moo";



////var thr=new Thread(AppDomainThread);
////thr.Start();
//AppDomainThread();
////Uuoo(1);
////Uuoo(2);
////Uuoo(3);
//MessageBox.Show("main domain, tid="+Thread.CurrentThread.ManagedThreadId.ToString());


//System.AppDomain.CreateDomain(
//System.Collections.ArrayList k=new System.Collections.ArrayList();
//k.Add(object
//System.Collections.Hashtable t=new System.Collections.Hashtable();
//t.Add(
//System.Collections.Generic.HashSet<

//		return;
//			//Out(OptParam(b:5));

//			//try { Out(1); }catch {}

//			//for(int j=0; j<5; j++)
//			//{
//			//	TestLocal();
//			//	//Out("returned");
//			//	//GC.Collect(0, GCCollectionMode.Forced, true);
//			//	Perf.First();
//			//	GC.Collect();
//			//	Perf.Next();
//			//	//Out("collected");
//			//	GC.WaitForFullGCComplete();
//			//	//Out("waited");
//			//}

//			//long g1, g2;
//			//g1=Stopwatch.GetTimestamp();
//			//Perf.First();
//			////Thread.Sleep(1000);
//			//g2=Stopwatch.GetTimestamp();

//			//Out(g2-g1);
//			//return;

//			string script = @"
//import System
////import System.Runtime.InteropServices
//import Moo
//import Catkeys.Winapi

////[DllImport(""user32.dll"")]
////def MessageBox(hWnd as int, text as string, caption as string, type as int) as int:
////	pass

//static def Main():
//	i =8
//	print ""Hello, World!""
//	api.MessageBox(0, ""text $(i)"", ""cap"", 0);

//	print Class1.Add(1, 2);

//	//print ""Press a key . . . mm""; Console.ReadKey(true)
//";
////static def stringManip(item as string):
////	return ""'${item}' ? What the hell are you talking about ? ""
////";

//			for (int i = 0; i < 1; i++)
//			{
//				Stopwatch sw = new Stopwatch();
//				long t1, t2 = 0, t3 = 0, t4 = 0, t5 = 0;

//				sw.Start();
//				BooCompiler compiler = new BooCompiler();
//				//compiler.Parameters.Input.Add(new StringInput("_script_", "print('Hello!')"));
//				compiler.Parameters.Input.Add(new StringInput("Script", script + "//" + i.ToString()));
//				compiler.Parameters.Pipeline = new CompileToMemory();
//				//compiler.Parameters.Pipeline = new CompileToFile();
//				//compiler.Parameters.Ducky = true;
//				//Out(compiler.Parameters.BooAssembly.FullName);
//				//Out(compiler.Parameters.Debug);
//				compiler.Parameters.Debug = false; //default true; 20% faster when Release
//				//compiler.Parameters.Environment.Provide.
//				//compiler.Parameters.GenerateInMemory=false; //default is true even if new CompileToFile()
//				//Out(compiler.Parameters.GenerateInMemory);
//				//Out(compiler.Parameters.OutputAssembly);
//				//compiler.Parameters.OutputAssembly=@"q:\test\boo.dll";

//				compiler.Parameters.AddAssembly(Assembly.LoadFile(@"Q:\test\Moo.dll")); //ok
//				//compiler.Parameters.LoadAssembly(@"Q:\test\Moo.dll", true); //no effect
//				//compiler.Parameters.LoadReferencesFromPackage(@"Q:\test\Moo.dll"); //error
//				//compiler.Parameters.References.Add(Assembly.LoadFile(@"Q:\test\Moo.dll")); //ok
//				compiler.Parameters.AddAssembly(Assembly.LoadFile(@"C:\Users\G\Documents\SharpDevelop Projects\Test\Winapi\bin\Release\Winapi.dll"));

//				CompilerContext context = compiler.Run();
//				t1 = sw.ElapsedTicks;
//				//Note that the following code might throw an error if the Boo script had bugs.
//				//Poke context.Errors to make sure.
//				if (context.GeneratedAssembly != null)
//				{
//					//SaveAssembly(context.GeneratedAssembly, @"q:\test\boo.exe");
//					//Out(context.GeneratedAssembly.FullName);
//					//Out(context.GeneratedAssembly.EntryPoint.ToString()); //void Main()
//					//Out(context.GeneratedAssembly.);

//					Type scriptModule = context.GeneratedAssembly.GetType("ScriptModule");
//					//Out(scriptModule == null);
//					MethodInfo met = scriptModule.GetMethod("Main");

//					//MethodInfo[] a = scriptModule.GetMethods();
//					//foreach(MethodInfo m in a)
//					//{
//					//Out(m.Name);
//					//}

//					met.Invoke(null, null);

//					//string output = (string)stringManip.Invoke(null, new object[] { "Tag" });
//					//Out(output);
//				}
//				else
//				{
//					foreach (CompilerError error in context.Errors)
//						Out(error);
//				}

//				double f = Stopwatch.Frequency / 1000000.0;
//				Out("speed: {0} {1} {2} {3} {4}", (long)(t1 / f), (long)((t2 - t1) / f), (long)((t3 - t2) / f), (long)((t4 - t3) / f), (long)((t5 - t4) / f));
//			}
//			Out("Press a key . . . ");
//			Console.ReadKey(true);
//}

//static void SaveAssembly(Assembly a, string file)
//{
//	using (FileStream stream = new FileStream(file, FileMode.Create))
//	{
//		BinaryFormatter formatter = new BinaryFormatter();

//		formatter.Serialize(stream, a); //error, assembly not marked as serializable
//	}
//}
