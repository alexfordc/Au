




#if true
	public class Types<T1, T2>
	{
		public object obj;

		public Types(object obj) { this.obj = obj; }

		public static implicit operator Types<T1, T2>(T1 x) { return new Types<T1, T2>(x); }
		public static implicit operator Types<T1, T2>(T2 x) { return new Types<T1, T2>(x); }
	}

	public class Types<T1, T2, T3>
	{
		public object obj;

		public Types(object obj) { this.obj = obj; }

		public static implicit operator Types<T1, T2, T3>(T1 x) { return new Types<T1, T2, T3>(x); }
		public static implicit operator Types<T1, T2, T3>(T2 x) { return new Types<T1, T2, T3>(x); }
		public static implicit operator Types<T1, T2, T3>(T3 x) { return new Types<T1, T2, T3>(x); }
	}

	static void TestTypes(Types<string, IEnumerable<string>> x = null)
	{
		switch(x?.obj) {
		case string s: PrintList("string", s); break;
		case IEnumerable<string> a: PrintList("IEnumerable<string>", a); break;
		default: Print("null"); break;
		}
	}

	static void TestTypes2(Types<int, double> x = null)
	{
		switch(x?.obj) {
		case int i: PrintList("int", i); break;
		case double d: PrintList("double", d); break;
		default: Print("null"); break;
		}
	}

	static void TestTypes3(Types<int, double, string> x)
	{
		switch(x?.obj) {
		case int i: PrintList("int", i); break;
		case double d: PrintList("double", d); break;
		case string s: PrintList("string", s); break;
		default: Print("null"); break;
		}
	}

	static void TestTypes4(Types<int, int?> x)
	{
		switch(x?.obj) {
		case int i: PrintList("int", i); break;
		default: Print("null"); break;
		}
	}
#else
	public struct Types<T1, T2>
	{
		public object obj;

		public Types(object obj) { this.obj = obj; }

		public static implicit operator Types<T1, T2>(T1 x) { return new Types<T1, T2>(x); }
		public static implicit operator Types<T1, T2>(T2 x) { return new Types<T1, T2>(x); }
	}

	public struct Types<T1, T2, T3>
	{
		public object obj;

		public Types(object obj) { this.obj = obj; }

		public static implicit operator Types<T1, T2, T3>(T1 x) { return new Types<T1, T2, T3>(x); }
		public static implicit operator Types<T1, T2, T3>(T2 x) { return new Types<T1, T2, T3>(x); }
		public static implicit operator Types<T1, T2, T3>(T3 x) { return new Types<T1, T2, T3>(x); }
	}

	static void TestTypes(Types<string, IEnumerable<string>> x = default(Types<string, IEnumerable<string>>))
	{
		switch(x.obj) {
		case string s: PrintList("string", s); break;
		case IEnumerable<string> a: PrintList("IEnumerable<string>", a); break;
		default: Print("null"); break;
		}
	}

	static void TestTypes2(Types<int, double> x = default(Types<int, double>))
	{
		switch(x.obj) {
		case int i: PrintList("int", i); break;
		case double d: PrintList("double", d); break;
		default: Print("null"); break;
		}
	}

	static void TestTypes3(Types<int, double, string> x)
	{
		switch(x.obj) {
		case int i: PrintList("int", i); break;
		case double d: PrintList("double", d); break;
		case string s: PrintList("string", s); break;
		default: Print("null"); break;
		}
	}

	static void TestTypes4(Types<int, int?> x)
	{
		switch(x.obj) {
		case int i: PrintList("int", i); break;
		default: Print("null"); break;
		}
	}
#endif

	static void TestMultiTypeParam()
	{
		TestTypes("S");
		TestTypes(new string[] { "S0", "S1" });
		TestTypes(new List<string>() { "L0", "L1" });
		//TestTypes(null);
		//TestMultiTypeParam(5);
		TestTypes(default(Types<string, IEnumerable<string>>));
		Print("----");

		TestTypes2(3);
		TestTypes2(3.5);
		//TestTypes2(null);
		//int? n = 7;
		//TestTypes2(n);
		Print("----");

		TestTypes3(3);
		TestTypes3(3.5);
		TestTypes3("S");
		//TestTypes3(null);
		//TestTypes3(n);
		Print("----");

		TestTypes4(3);
		int? n = 7;
		TestTypes4(n);
		TestTypes4(null);
		Print("----");

		TestTypes();
		TestTypes2();
		Print("----");

		//TestTypes(10.5);
		TestTypes2(10.5);
	}


	//static void Fu<T>(T x)
	//{
	//	Print(x);
	//}

	//static void FuWhere<T>(T x) where T: String
	//{
	//	Print(x);
	//}

	//static void TestGenericParam()
	//{
	//	Fu("S");
	//	Fu(1);
	//}



	public struct TypesS<T1, T2>
	{
		public object obj;

		public TypesS(object obj) { this.obj = obj; }

		public static implicit operator TypesS<T1, T2>(T1 x) { return new TypesS<T1, T2>(x); }
		public static implicit operator TypesS<T1, T2>(T2 x) { return new TypesS<T1, T2>(x); }

		//public static implicit operator Types<T1, T2>(float? x) { return new Types<T1, T2>(null); }
		//public static implicit operator Types<T1, T2>(double? x) { return new Types<T1, T2>(null); }
	}


	[MethodImpl(MethodImplOptions.NoInlining)]
	static bool SpeedObj(object x)
	{
		switch(x) {
		case string s: return s is null;
		case IEnumerable<string> a: return a is null;
		default: return false;
		}
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	static bool SpeedS(TypesS<string, IEnumerable<string>> x)
	{
		switch(x.obj) {
		case string s: return s is null;
		case IEnumerable<string> a: return a is null;
		default: return false;
		}
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	static bool SpeedC(Types<string, IEnumerable<string>> x)
	{
		switch(x?.obj) {
		case string s: return s is null;
		case IEnumerable<string> a: return a is null;
		default: return false;
		}
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	static bool SpeedObj2(object x)
	{
		switch(x) {
		case int s: return s==0;
		case double a: return a==0.0;
		default: return false;
		}
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	static bool SpeedS2(TypesS<int, double> x)
	{
		switch(x.obj) {
		case int s: return s==0;
		case double a: return a==0.0;
		default: return false;
		}
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	static bool SpeedC2(Types<int, double> x)
	{
		switch(x?.obj) {
		case int s: return s==0;
		case double a: return a==0.0;
		default: return false;
		}
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	static bool SpeedS3(TypesS<string, IEnumerable<string>>? x=null)
	{
		switch(x?.obj) {
		case string s: return s is null;
		case IEnumerable<string> a: return a is null;
		default: return false;
		}
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	static bool SpeedS4(TypesS<int, double>? x)
	{
		switch(x?.obj) {
		case int s: return s==0;
		case double a: return a==0.0;
		default: return false;
		}
	}

	static void TestMultiTypeParamSpeed()
	{
		int r = 0;
		string s = "kkkk";
		var a = new string[] { "A", "B" };
		int m = 7;
		double d = 3.4;

		for(int i = 0; i < 5; i++) {
			Perf.First();
			for(int j = 0; j < 1000; j++) {
				if(SpeedObj(s)) r++;
				if(SpeedObj(a)) r++;
				//if(SpeedObj(null)) r++;
			}
			Perf.Next();
			for(int j = 0; j < 1000; j++) {
				if(SpeedS(s)) r++;
				if(SpeedS(a)) r++;
				//if(Speed1(null)) r++;
				//if(SpeedS((string)null)) r++;
			}
			Perf.Next();
			for(int j = 0; j < 1000; j++) {
				if(SpeedC(s)) r++;
				if(SpeedC(a)) r++;
				//if(SpeedC(null)) r++;
			}
			Perf.Next();
			for(int j = 0; j < 1000; j++) {
				if(SpeedObj2(m)) r++;
				if(SpeedObj2(d)) r++;
				//if(SpeedObj(null)) r++;
			}
			Perf.Next();
			for(int j = 0; j < 1000; j++) {
				if(SpeedS2(m)) r++;
				if(SpeedS2(d)) r++;
			}
			Perf.Next();
			for(int j = 0; j < 1000; j++) {
				if(SpeedC2(m)) r++;
				if(SpeedC2(d)) r++;
			}
			Perf.Next();
			for(int j = 0; j < 1000; j++) {
				if(SpeedS3(s)) r++;
				if(SpeedS3(a)) r++;
			}
			Perf.Next();
			for(int j = 0; j < 1000; j++) {
				if(SpeedS4(m)) r++;
				if(SpeedS4(d)) r++;
			}
			Perf.NW();
		}

		Print(r);
	}



	[MethodImpl(MethodImplOptions.NoInlining)]
	static void TypesNullable(TypesS<string, IEnumerable<string>>? x = null)
	{
		switch(x?.obj) {
		case string s: Print(s); break;
		case IEnumerable<string> a: Print(a); break;
		default: Print("null"); break;
		}
	}

	static void TestTypesNullable()
	{
		TypesNullable("S");
		TypesNullable(new string[] { "a", "b" });
		string s = null;
		TypesNullable(s);
		TypesNullable();
	}







#if false //struct much slower
		/// <summary>
		/// Used with <see cref="Match_"/>. 
		/// </summary>
		public struct MatchContext
		{
			//internal Regex rx;
			//internal _MatchContext[] multi;
			internal object x; //Regex or _MatchContext[]
			internal int offset;
			internal byte type; //0 wild, 1 text, 2 regex, 3 multi
			internal bool c;
			internal bool n;
		}

		public static unsafe bool Match_(this string t, string wildcardExpression, ref MatchContext context)
		{
			var w = wildcardExpression;
			if(w == null) return t == null;
			if(t == null) return false;

			int lenW = w.Length;
			bool ignoreCase = true, not = false;

			if(context.offset == 0 && lenW >= 3 && w[0] == '*' && w[1] == '*') {
				var c = new MatchContext();
				for(int i = 2; i < lenW; i++) {
					switch(w[i]) {
					case 't': c.type = 1; break;
					case 'r': c.type = 2; break;
					case 'm': c.type = 3; break;
					case 'c': c.c = true; break;
					case 'n': c.n = true; break;
					case '|': c.offset = ++i; goto g1;
					}
				}
				g1:
				if(c.offset > 0) {
					//var s = (c.type>=2) ? w.Substring(c.offset) : null;
					switch(c.type) {
					//case 1:
					//	c.x = s;
					//	break;
					case 2:
						c.x = new Regex(w.Substring(c.offset), c.c ? RegexOptions.CultureInvariant : (RegexOptions.CultureInvariant | RegexOptions.IgnoreCase));
						break;
					case 3:

						break;
					}
					context = c;
				}
			}

			if(context.offset > 0) {
				lenW -= context.offset;
				ignoreCase = !context.c; not = context.n;
				switch(context.type) {
				case 1:
					//return not != (lenW == t.Length && (context.x as string).Equals_(t, ignoreCase));
					return not != (lenW == t.Length && w.EndsWith_(t, ignoreCase));
				case 2:
					return (context.x as Regex).IsMatch(t);
				case 3:
					break;
				}
			}

			if(lenW == 0) return t.Length == 0;
			if(lenW == 1 && w[0] == '*') return true;
			if(t.Length == 0) return false;

			fixed (char* tt = t, ww = w) {
				return not != __WildcardCmp(tt, ww + context.offset, t.Length, lenW, ignoreCase ? Util.LibProcessMemory.Ptr->str.GetCaseTable() : null);
			}
		}
#else
		class _MatchContext
		{
			//internal Regex rx;
			//internal _MatchContext[] multi;
			internal object x; //Regex or _MatchContext[]
			internal int offset;
			internal byte type; //0 wild, 1 text, 2 regex, 3 multi
			internal bool c;
			internal bool n;
		}

		public static unsafe bool Match_(this string t, string wildcardExpression, ref object context)
		{
			var w = wildcardExpression;
			if(w == null) return t == null;
			if(t == null) return false;

			int lenW = w.Length, offsW = 0;
			bool ignoreCase = true, not = false;

			_MatchContext c = null;
			if(context != null) c = context as _MatchContext;
			else if(lenW >= 3 && w[0] == '*' && w[1] == '*') {
				context = c = new _MatchContext();
				for(int i = 2; i < lenW; i++) {
					switch(w[i]) {
					case 't': c.type = 1; break;
					case 'r': c.type = 2; break;
					case 'm': c.type = 3; break;
					case 'c': c.c = true; break;
					case 'n': c.n = true; break;
					case '|': c.offset = ++i; goto g1;
					}
				}
				g1:
				if(c.offset > 0) {
					var s = (c.type >= 2) ? w.Substring(c.offset) : null;
					switch(c.type) {
					//case 1:
					//	c.x = s;
					//	break;
					case 2:
						c.x = new Regex(s, c.c ? RegexOptions.CultureInvariant : (RegexOptions.CultureInvariant | RegexOptions.IgnoreCase));
						break;
					case 3:
						//var a = s.Split(new string[] { "[]" }, StringSplitOptions.None);
						//var multi = new _MatchContext[a.Length];
						//for(int i = 0; i < a.Length; i++) {
						//	multi[i] = new _MatchContext(a[i]);
						//}
						//c.x = multi;
						break;
					}
				}
			}

			if(c != null && c.offset > 0) {
				offsW = c.offset; lenW -= c.offset;
				ignoreCase = !c.c; not = c.n;
				switch(c.type) {
				case 1:
					//return not != (lenW == t.Length && (c.x as string).Equals_(t, ignoreCase));
					return not != (lenW == t.Length && w.EndsWith_(t, ignoreCase));
				case 2:
					return (c.x as Regex).IsMatch(t);
				case 3:
					break;
				}
			}

			if(lenW == 0) return t.Length == 0;
			if(lenW == 1 && w[0] == '*') return true;
			if(t.Length == 0) return false;

			fixed (char* tt = t, ww = w) {
				return not != __WildcardCmp(tt, ww + offsW, t.Length, lenW, ignoreCase ? Util.LibProcessMemory.Ptr->str.GetCaseTable() : null);
			}
		}
#endif

		//public static unsafe bool Match_(this string t, string wildcardExpression)
		//{
		//	var w = wildcardExpression;
		//	if(w == null) return t == null;
		//	if(t == null) return false;
		//	int lenW = w.Length;

		//	bool ignoreCase = true, not = false; int offsW = 0;

		//	if(lenW >= 3 && w[0] == '*' && w[1] == '*') {
		//		int i, o = 0; //1 t, 2 r, 3 m, 8 c, 16 n, 0x100 |
		//		for(i = 2; i < lenW && o < 0x100; i++) {
		//			switch(w[i]) {
		//			case 't': o |= 1; break;
		//			case 'r': o |= 2; break;
		//			case 'm': o |= 3; break;
		//			case 'c': o |= 8; break;
		//			case 'n': o |= 16; break;
		//			case '|': o |= 0x100; break;
		//			}
		//		}
		//		if((o & 0x100) != 0) {
		//			if((o & 8) != 0) ignoreCase = false;
		//			if((o & 16) != 0) not = true;
		//			lenW -= i;
		//			switch(o & 3) {
		//			case 1:
		//				return not != (lenW == t.Length && w.EndsWith_(t, ignoreCase));
		//			case 2:
		//				//return not != t.RegexIs_(w.Substring(i), ignoreCase ? RegexOptions.IgnoreCase : 0);
		//				return not != _regexCache.CreateOrGetCached(w, w.Substring(i), ignoreCase ? RegexOptions.IgnoreCase : 0).IsMatch(t);
		//			case 3:
		//				break;
		//			}
		//			offsW = i;
		//		}
		//	}

		//	if(lenW == 0) return t.Length == 0;
		//	if(lenW == 1 && w[0] == '*') return true;
		//	if(t.Length == 0) return false;

		//	fixed (char* tt = t, ww = w) {
		//		return not != __WildcardCmp(tt, ww + offsW, t.Length, lenW, ignoreCase ? Util.LibProcessMemory.Ptr->str.GetCaseTable() : null);
		//	}
		//}



		/// <summary>
		/// Faster Regex cache.
		/// </summary>
		struct _RegexCache
		{
			struct _CacheItem
			{
				internal object wildex;
				internal Regex r;
			}

			static _CacheItem[] _a;
			static int _i;

			internal Regex CreateOrGetCached(string wildex, string regex, RegexOptions ro)
			{
				//lock("jskdjsiyvtdftfhch") { //slower, and I think that better to use ThreadStatic
				object o = wildex;
				if(_a != null) {
					if(_a[0].wildex == o) return _a[0].r;
					if(_a[1].wildex == o) return _a[1].r;
					if(_a[2].wildex == o) return _a[2].r;
					if(_a[3].wildex == o) return _a[3].r;
				} else _a = new _CacheItem[4];

				var r = _a[_i].r = new Regex(regex, ro);
				_a[_i].wildex = o;
				_i = (_i + 1) & 3;
				return r;
				//}
			}

			internal void Clear()
			{
				_a = null;
			}
		}
		[ThreadStatic]
		static _RegexCache _regexCache;

		internal static void TestClearRegexCache()
		{
			_regexCache.Clear();
		}








	public class WildexC
	{
		/// <summary>
		/// The type of text (wildcard expression) used when creating the Wildex variable.
		/// </summary>
		public enum WildType :byte
		{
			/// <summary>Simple text (option t, or no *? characters and no t r options). Match() calls <see cref="String_.Equals_(string, string, bool)"/>.</summary>
			Text,
			/// <summary>Wildcard (has *? characters and no t r options). Match() calls <see cref="String_.Like_(string, string, bool)"/>.</summary>
			Wildcard,
			/// <summary>Regular expression (option r). Match() calls <see cref="Regex.IsMatch(string)"/>.</summary>
			Regex,
			/// <summary>Multiple parts (option m). Match() calls Match() for each part (see <see cref="MultiArray"/>) and returns true if some non-[n] part returns true and all [n] parts return true.</summary>
			Multi,
		}

		object _obj; //string, Regex or Wildex[]. Tested: getting string etc with '_obj as string' is fast.
		WildType _type;
		bool _ignoreCase;
		bool _not;

		public WildexC(string wildcardExpression)
		{
			var w = wildcardExpression;
			if(w == null) return;
			_type = WildType.Wildcard;
			_ignoreCase = true;

			if(w.Length >= 3 && w[0] == '*' && w[1] == '*') {
				WildType t = _type; bool isC = false, isN = false, hasOptions = false;
				int i;
				for(i = 2; i < w.Length && !hasOptions; i++) {
					switch(w[i]) {
					case 't': t = WildType.Text; break;
					case 'r': t = WildType.Regex; break;
					case 'm': t = WildType.Multi; break;
					case 'c': isC = true; break;
					case 'n': isN = true; break;
					case '|': hasOptions = true; break;
					}
				}
				if(hasOptions) {
					w = w.Substring(i);
					_type = t;
					_ignoreCase = !isC;
					_not = isN;
					if(_type == WildType.Multi) {
						var a = w.Split(new string[] { "[]" }, StringSplitOptions.None);
						var multi = new Wildex[a.Length];
						for(i = 0; i < a.Length; i++) {
							multi[i] = new Wildex(a[i]);
						}
						_obj = multi;
						w = null;
						_type = WildType.Multi;
						return;
					}

					if(_type == WildType.Regex) {
						var ro = _ignoreCase ? (RegexOptions.IgnoreCase | RegexOptions.CultureInvariant) : RegexOptions.CultureInvariant;
						_obj = new Regex(w, ro);
						return;
					}
				}
			}

			if(_type == WildType.Wildcard && !Wildex.HasWildcards(w)) _type = WildType.Text;
			_obj = w;
		}

		public bool Match(string s)
		{
			if(s == null) return _obj == null;
			if(_obj == null) return false;

			bool R = false;
			switch(_type) {
			case WildType.Wildcard: R = s.Like_(_obj as string, _ignoreCase); break;
			case WildType.Text: R = s.Equals_(_obj as string, _ignoreCase); break;
			case WildType.Regex: R = (_obj as Regex).IsMatch(s); break;
			case WildType.Multi:
				var multi = _obj as Wildex[];
				//[n] parts: all must match (with their [n] applied)
				for(int i = 0; i < multi.Length; i++) {
					var v = multi[i];
					if(v.Not && !v.Match(s)) return _not;
				}
				//non-[n] parts: at least one must match
				for(int i = 0; i < multi.Length; i++) {
					var v = multi[i];
					if(!v.Not && v.Match(s)) return !_not;
				}
				break;
			}
			return R ^ _not;
		}
	}

	public struct WildexS
	{
		/// <summary>
		/// The type of text (wildcard expression) used when creating the Wildex variable.
		/// </summary>
		public enum WildType :byte
		{
			/// <summary>Simple text (option t, or no *? characters and no t r options). Match() calls <see cref="String_.Equals_(string, string, bool)"/>.</summary>
			Text,
			/// <summary>Wildcard (has *? characters and no t r options). Match() calls <see cref="String_.Like_(string, string, bool)"/>.</summary>
			Wildcard,
			/// <summary>Regular expression (option r). Match() calls <see cref="Regex.IsMatch(string)"/>.</summary>
			Regex,
			/// <summary>Multiple parts (option m). Match() calls Match() for each part (see <see cref="MultiArray"/>) and returns true if some non-[n] part returns true and all [n] parts return true.</summary>
			Multi,
		}

		object _obj; //string, Regex or Wildex[]. Tested: getting string etc with '_obj as string' is fast.
		WildType _type;
		bool _ignoreCase;
		bool _not;

		public WildexS(string wildcardExpression):this()
		{
			var w = wildcardExpression;
			if(w == null) return;
			_type = WildType.Wildcard;
			_ignoreCase = true;

			if(w.Length >= 3 && w[0] == '*' && w[1] == '*') {
				WildType t = _type; bool isC = false, isN = false, hasOptions = false;
				int i;
				for(i = 2; i < w.Length && !hasOptions; i++) {
					switch(w[i]) {
					case 't': t = WildType.Text; break;
					case 'r': t = WildType.Regex; break;
					case 'm': t = WildType.Multi; break;
					case 'c': isC = true; break;
					case 'n': isN = true; break;
					case '|': hasOptions = true; break;
					}
				}
				if(hasOptions) {
					w = w.Substring(i);
					_type = t;
					_ignoreCase = !isC;
					_not = isN;
					if(_type == WildType.Multi) {
						var a = w.Split(new string[] { "[]" }, StringSplitOptions.None);
						var multi = new Wildex[a.Length];
						for(i = 0; i < a.Length; i++) {
							multi[i] = new Wildex(a[i]);
						}
						_obj = multi;
						w = null;
						_type = WildType.Multi;
						return;
					}

					if(_type == WildType.Regex) {
						var ro = _ignoreCase ? (RegexOptions.IgnoreCase | RegexOptions.CultureInvariant) : RegexOptions.CultureInvariant;
						_obj = new Regex(w, ro);
						return;
					}
				}
			}

			if(_type == WildType.Wildcard && !Wildex.HasWildcards(w)) _type = WildType.Text;
			_obj = w;
		}

		public bool Match(string s)
		{
			if(s == null) return _obj == null;
			if(_obj == null) return false;

			bool R = false;
			switch(_type) {
			case WildType.Wildcard: R = s.Like_(_obj as string, _ignoreCase); break;
			case WildType.Text: R = s.Equals_(_obj as string, _ignoreCase); break;
			case WildType.Regex: R = (_obj as Regex).IsMatch(s); break;
			case WildType.Multi:
				var multi = _obj as Wildex[];
				//[n] parts: all must match (with their [n] applied)
				for(int i = 0; i < multi.Length; i++) {
					var v = multi[i];
					if(v.Not && !v.Match(s)) return _not;
				}
				//non-[n] parts: at least one must match
				for(int i = 0; i < multi.Length; i++) {
					var v = multi[i];
					if(!v.Not && v.Match(s)) return !_not;
				}
				break;
			}
			return R ^ _not;
		}

		public bool IsNull { get { return _obj == null; } }
	}











#elif false
				Api.IShellFolder folder = null; IntPtr pidlItem;
				try {
					int hr = Api.SHBindToParent(pidl, ref Api.IID_IShellFolder, out folder, out pidlItem);
					if(0 != hr) { PrintDebug($"{pidl}, {Marshal.GetExceptionForHR(hr)?.Message}"); return Zero; }

					int ii = SHMapPIDLToSystemImageListIndex(folder, pidlItem, null);
					//Print(ii);
					if(ii < 0) return Zero;

					size = size < 24 ? SHIL_SMALL : SHIL_LARGE;
					IntPtr il;
					if(0 != SHGetImageList(size, ref IID_IImageList, out il)) return Zero;

					return Api.ImageList_GetIcon(il, ii, 0);
				}
				finally {
					Api.ReleaseComObject(folder);
				}
#else
				IntPtr R = Zero;
				Api.IShellFolder folder = null;
				Api.IExtractIcon eic = null;
				try {
					IntPtr pidlItem;
					int hr = Api.SHBindToParent(pidl, ref Api.IID_IShellFolder, out folder, out pidlItem);
					if(0 != hr) { PrintDebug($"{pidl}, {Marshal.GetExceptionForHR(hr)?.Message}"); return Zero; }

					object o;
					hr = folder.GetUIObjectOf(Wnd0, 1, &pidlItem, Api.IID_IExtractIcon, Zero, out o);
					//if(0 != hr) { PrintDebug($"{file}, {Marshal.GetExceptionForHR(hr)?.Message}"); return Zero; }
					if(0 != hr) {
						if(hr != Api.REGDB_E_CLASSNOTREG) PrintDebug($"{pidl}, {Marshal.GetExceptionForHR(hr)?.Message}");
						return Zero;
					}
					eic = o as Api.IExtractIcon;

					var sb = new StringBuilder(300); int ii; uint fl;
					hr = eic.GetIconLocation(0, sb, 300, out ii, out fl);
					if(0 != hr) { PrintDebug($"{pidl}, {Marshal.GetExceptionForHR(hr)?.Message}"); return Zero; }
					string loc = sb.ToString();

					//PrintList(pidl, loc, ii);

					if((fl & (Api.GIL_NOTFILENAME | Api.GIL_SIMULATEDOC)) == 0) {
						R = GetIconHandleRaw(loc, ii, size);
						if(R != Zero) return R;
					}

					//hr = eic.Extract(loc, (uint)ii, &R, null, (uint)size); //no
					//note:
					//	Some shell extensions (eg .sln) ignore size and always return 32x32 in phiconLarge and 16x16 in phiconSmall.
					//	But how then Explorer displays correct icons? Maybe uses SHMapPIDLToSystemImageListIndex/SHGetImageList. Or IExtractImage. Probably it uses other (probably private) functions.

					IntPtr* hiSmall = null, hiBig = null;
					if(size < 24) { hiSmall = &R; size = 32; } else hiBig = &R;
					hr = eic.Extract(loc, (uint)ii, hiBig, hiSmall, Calc.MakeUint(size, 16)); //TODO: may have 20 icon

					if(0 != hr) { PrintDebug($"{pidl}, {Marshal.GetExceptionForHR(hr)?.Message}, location={loc}"); return Zero; }

					//PrintList(pidl, loc, ii);

					//if(size != 16 && size != 32) { //TODO: test with high DPI

					//	//var perf = new Perf.Inst(true);
					//	IntPtr R2 = Api.CopyImage(R, Api.IMAGE_ICON, size, size, Api.LR_COPYDELETEORG | Api.LR_COPYRETURNORG | Api.LR_COPYFROMRESOURCE);
					//	//perf.NW();
					//	//PrintList(R, R2);
					//	R = R2;
					//}
				}
				catch(Exception e) { PrintDebug($"pidl={pidl}, {e.Message}, {e.TargetSite}"); }
				finally {
					Api.ReleaseComObject(eic);
					Api.ReleaseComObject(folder);
				}
				return R;
#endif




					//} else if(isFileType && !isURL) {
					//	uint n = 300; var sb = new StringBuilder((int)n);
					//	if(0 == Api.AssocQueryString(0, Api.ASSOCSTR.ASSOCSTR_DEFAULTICON, file, null, sb, ref n)) {
					//		var icon = sb.ToString();
					//		PrintList(file, icon);
					//		ParseIconLocation(ref icon, out index);
					//		return GetIconHandleRaw(icon, index, size);
					//	}




	#region test icons

	static void TestIcons()
	{
		//Print("start");
		//Sleep(1000);

		var a = new List<string>();
		int n = 0;
#if true
		foreach(var f in Directory.EnumerateFiles(@"q:\app")) {
			//Print(f);
			a.Add(f);
			//if((n & 1) == 0) a.Add(f);
			//if(++n == 30) break;
		}
#endif
#if false
		a.Add("mailto:");
		a.Add(@"shell:AppsFolder\Microsoft.WindowsCalculator_8wekyb3d8bbwe!App");
		a.Add(@"q:\app");
		a.Add(Folders.Favorites);
		a.Add("http://www.quickmacros.com/");
		a.Add("::{21EC2020-3AEA-1069-A2DD-08002B30309D}");
		a.Add(@"C:\Users\G\Desktop\QM in PF.lnk");
#endif
#if false
		a.Add("q:\\app\\Cut.ico");
		a.Add(@"Q:\Programs\ILSpy\ILSpy.exe");
		a.Add(Folders.System + "notepad.exe");
		a.Add("q:\\app\\Copy.ico");
		a.Add("q:\\app\\Paste.ico");
		a.Add("q:\\app\\Run.ico");
		a.Add("q:\\app\\Tip.ico");
		//a.Add("notepad.exe");
		a.Add(Folders.ProgramFilesX86 + @"PicPick\picpick.exe");
		a.Add(@"Q:\Programs\DebugView\Dbgview.exe");
		a.Add(@"Q:\Programs\ProcessExplorer\procexp.exe");
		a.Add(Folders.ProgramFilesX86 + @"Inno Setup 5\Compil32.exe");
		a.Add(Folders.ProgramFilesX86 + @"HTML Help Workshop\hhw.exe");
		a.Add(Folders.ProgramFilesX86 + @"FileZilla FTP Client\filezilla.exe");
		a.Add(Folders.ProgramFilesX86 + @"Internet Explorer\IEXPLORE.EXE");
		a.Add(@"Q:\Programs\ProcessMonitor\Procmon.exe");
		a.Add(Folders.ProgramFilesX86 + @"Resource Hacker\ResourceHacker.exe");
		a.Add(@"Q:\programs\Autoruns\autoruns.exe");
		//a.Add(Folders.ProgramFilesX86 + @"SyncBackFree\SyncBackFree.exe");
		a.Add(@"Q:\Programs\PeView\PEview.exe");
		a.Add(Folders.System + @"shell32.dll,25");
#endif

		//Print(Api.GetCurrentThreadId());
		var F = new Form();
		F.Click += (unu, sed) =>
		{
			_n = a.Count;
			Perf.First();

			//var aph = new _IconPathsAndHandles(a);
			////var work = new Util.TaskSTA(_IconWorkCallback1_W, aph); work.CreateWork();
			//var work = new Util.TaskSTA(_IconWorkCallback2_W, aph, _IconCompletionCallback_W, F); work.CreateWork();

			foreach(var s in a) {
				//_TestIconsSync(s);
				_TestIconsAsync(s);
				//var k = new _StringAndHandle() { s = s }; _TestIconsNewPool(k, F);
				//var k = new _StringAndHandle() { s = s }; work.RunWork();
			}
		};
		F.ShowDialog();
		//Print(2);

		//var m = new CatMenu();
		//m["aaaaaaaaa"] = null;
		//m.Show();
		//ShowRen.ShowEx("", timeoutS: 1);
		//new Form().ShowDialog();
		//Time.SetTimer(1000, true, t => _loop2.Stop()); _loop2.Loop();
		//Time.SetTimer(1000, true, t => Application.ExitThread()); Application.Run();
		//PrintList("end", _n);
	}

	static Util.MessageLoop _loop2 = new Util.MessageLoop();

	static void _TestIconsNewPool(_StringAndHandle s, Control control)
	{
		//new Util.TaskSTA(_IconWorkCallback1, s).Run();
		new Util.TaskSTA(_IconWorkCallback2, s, _IconCompletionCallback, control).Run();

	}

	class _StringAndHandle
	{
		public string s;
		public IntPtr h;
	}

	static object _IconWorkCallback1(object state)
	{
		var k = state as _StringAndHandle;
		var hi = Files.GetIconHandle(k.s, 16, 0);

		int n = Interlocked.Decrement(ref _n);
		//Print(n);
		if(n < 1) Perf.NextWrite();
		//PrintList(tid, Api.GetCurrentThreadId());

		if(hi == Zero) {
			PrintList("failed", k.s);
			return null;
		}
		Api.DestroyIcon(hi);
		return null;
	}

	class _IconPathsAndHandles
	{
		public List<string> _paths;
		public IntPtr[] _handles;
		int _counter;

		public _IconPathsAndHandles(List<string> paths)
		{
			_paths = paths;
			_handles = new IntPtr[paths.Count];
			_counter = -1;
		}

		public int GetNextPath(out string path)
		{
			int r = Interlocked.Increment(ref _counter);
			path = _paths[r];
			return r;
		}
	}

	static object _IconWorkCallback1_W(object state)
	{
		var k = state as _IconPathsAndHandles;
		string path; int counter = k.GetNextPath(out path);
		var hi = Files.GetIconHandle(path, 16, 0);

		int n = Interlocked.Decrement(ref _n);
		//Print(n);
		if(n < 1) Perf.NextWrite();
		//PrintList(tid, Api.GetCurrentThreadId());

		if(hi == Zero) {
			PrintList("failed", path);
			return null;
		}
		Api.DestroyIcon(hi);
		return null;
	}

	static object _IconWorkCallback2_W(object state)
	{
		var k = state as _IconPathsAndHandles;
		string path; int counter = k.GetNextPath(out path);
		k._handles[counter] = Files.GetIconHandle(path, 16, 0);
		return counter;
	}

	static object _IconWorkCallback2(object state)
	{
		var k = state as _StringAndHandle;
		k.h = Files.GetIconHandle(k.s, 16, 0);
		return null;
	}

	static void _IconCompletionCallback(object state, object workResult)
	{
		//PrintList("_CompletionCallback", Api.GetCurrentThreadId(), state);

		_n--;
		if(_n < 1) Perf.NextWrite();
		//PrintList(tid, Api.GetCurrentThreadId());

		var k = state as _StringAndHandle;
		var s = k.s;
		var hi = k.h;

		if(hi == Zero) {
			PrintList("failed", s);
			return;
		}
		Api.DestroyIcon(hi);
	}

	static void _IconCompletionCallback_W(object state, object workResult)
	{
		//PrintList("_CompletionCallback", Api.GetCurrentThreadId(), state);

		_n--;
		if(_n < 1) Perf.NextWrite();
		//PrintList(tid, Api.GetCurrentThreadId());

		var k = state as _IconPathsAndHandles;
		int counter = (int)workResult;
		var s = k._paths[counter];
		var hi = k._handles[counter];
		//PrintList(counter, hi, s);

		if(hi == Zero) {
			PrintList("failed", s);
			return;
		}
		Api.DestroyIcon(hi);
	}


#if true

	static int _n;
	static Random _random = new Random();

	static async void _TestIconsAsync(string s)
	{
		uint tid = Api.GetCurrentThreadId();
#if true
		var task = Task.Run(() =>
		{
			//PrintList(Api.GetCurrentThreadId(), s);
			//var perf = new Perf.Inst(true);
			var R = Files.GetIconHandle(s, 16, 0);
			//var R = Zero; Sleep(s.Length * s.Length / 100);
			//var R = Zero; Sleep(_random.Next(1, 10));
			//perf.Next(); PrintList(perf.Times, s);
			return R;
		});
#else
		var task = Task.Factory.StartNew(() =>
		{
			//PrintList(Api.GetCurrentThreadId(), s);
			//var perf = new Perf.Inst(true);
			var R = Files.GetIconHandle(s, 16, 0);
			//var R = Zero; Sleep(_random.Next(1, 10));
			//perf.Next(); PrintList(perf.Times, s);
			return R;
		}, CancellationToken.None, TaskCreationOptions.None, _staTaskScheduler);
#endif
		await task;
		IntPtr hi = task.Result;

		//Interlocked.Decrement(ref _n);
		_n--;
		if(_n < 1) Perf.NextWrite();
		//PrintList(tid, Api.GetCurrentThreadId());

		if(hi == Zero) {
			PrintList("failed", s);
			return;
		}
		Api.DestroyIcon(hi);
	}

	//static readonly System.Threading.Tasks.Schedulers.StaTaskScheduler _staTaskScheduler = new System.Threading.Tasks.Schedulers.StaTaskScheduler(4); //tested: without StaTaskScheduler would be 4 threads. With 3 the UI thread is slightly faster.

	static void _TestIconsSync(string s)
	{
		//var perf = new Perf.Inst(true);
		var hi = Files.GetIconHandle(s, 16, 0);
		//perf.Next(); PrintList(perf.Times, s);

		if(--_n == 0) Perf.NextWrite();

		if(hi == Zero) {
			PrintList("failed", s);
			return;
		}
		Api.DestroyIcon(hi);
	}

	//	static async void _TestIcons(List<string> a)
	//	{
	//		Print(Api.GetCurrentThreadId());
	//		Perf.First();

	//		foreach(var s in a) {
	//			if(s == "mailto:") Perf.Next();

	//#if true
	//			var task = Task.Run(() =>
	//			{
	//				PrintList(Api.GetCurrentThreadId(), s);
	//				var perf = new Perf.Inst(true);
	//				//var R = Files.GetIconHandle(s, 16, 0);
	//				var R = Zero;
	//				Sleep(s.Length * s.Length / 5);
	//				perf.Next(); PrintList(perf.Times, s);
	//				return R;
	//			});
	//#else
	//			var task = Task.Factory.StartNew(() =>
	//			{
	//				PrintList(Api.GetCurrentThreadId(), s);
	//				var perf = new Perf.Inst(true);
	//				var R= Files.GetIconHandle(s, 16, 0);
	//				perf.Next(); PrintList(perf.Times, s);
	//				return R;
	//			}, CancellationToken.None, TaskCreationOptions.None, _staTaskScheduler);
	//#endif
	//			await task;

	//			IntPtr hi = task.Result;
	//			if(hi == Zero) {
	//				//PrintList("failed", s);
	//				continue;
	//			}
	//			Api.DestroyIcon(hi);
	//		}

	//		Perf.Next();
	//		Perf.Write();
	//	}

#else
	static void _TestIcons(List<string> a)
	{
		Perf.First();

		foreach(var s in a) {
			if(s == "mailto:") Perf.Next();

			var hi= Files.GetIconHandle(s, 16, 0);
			if(hi == Zero) {
				PrintList("failed", s); continue;
			}
			Api.DestroyIcon(hi);
		}

		Perf.Next();
		Perf.Write();
	}
#endif

	static void TestThreadPoolSTA()
	{
		//Print(Api.GetCurrentThreadId());
		//Util.ThreadPoolSTA.AddWork(_WorkCallback, 100);
		new Util.TaskSTA(_WorkCallback, 100).Run();

		//Sleep(1000);
		var f = new Form();

		for(int i = 0; i < 10; i++) {
			//Util.ThreadPoolSTA.AddWork(_WorkCallback, _CompletionCallback, f, i, true);
			new Util.TaskSTA(_WorkCallback, i, _CompletionCallback, f).Run();
		}
		//Sleep(500);

		//f.Load += (unu, sed) =>
		//{
		//	//Print(f.IsHandleCreated);
		//	for(int i = 0; i < 1; i++) {
		//		Util.ThreadPoolSTA.AddWork(_WorkCallback, _CompletionCallback, f, i);
		//		new Util.TaskSTA(_WorkCallback, _CompletionCallback, f, i).Run();
		//	}
		//};

		//Print(1);
		f.ShowDialog();
		//Print(f.IsDisposed);
		f.Dispose();
		//Print(2);
		//ShowRen.Show("after");

		//GC.Collect();
		//ShowRen.Show("after");
	}

	static object _WorkCallback(object state)
	{
		PrintList("_WorkCallback", Api.GetCurrentThreadId(), state);
		//ShowRen.Show("work");
		//MessageBox.Show("work");
		return null;
	}

	static void _CompletionCallback(object state, object workResult)
	{
		PrintList("_CompletionCallback", Api.GetCurrentThreadId(), state);
	}

	#endregion test icons




	public static unsafe class ThreadPoolSTA
	{
		public static void AddWork(WaitCallback workCallback, object state = null)
		{
			AddWork(workCallback, null, null, state);
		}

		public static void AddWork(WaitCallback workCallback, WaitCallback completionCallback, Control completionControl, object state = null, bool startWhenHandleCreated = false)
		{
			if((completionCallback == null) != (completionControl == null)) throw new ArgumentNullException();

			new _Work(workCallback, completionCallback, completionControl, state, startWhenHandleCreated);
		}

		class _Work
		{
			WaitCallback _workCallback, _completionCallback;
			Control _control;
			object _state;
			GCHandle _gch;

			public _Work(WaitCallback workCallback, WaitCallback completionCallback, Control control, object state, bool startWhenHandleCreated)
			{
				_workCallback = workCallback;
				_completionCallback = completionCallback;
				_control = control;
				_state = state;
				_gch = GCHandle.Alloc(this);

				if(startWhenHandleCreated && control != null && !control.IsHandleCreated) {
					control.HandleCreated += _Control_HandleCreated;
				} else {
					_AddWork();
				}
			}

			private void _Control_HandleCreated(object sender, EventArgs e)
			{
				_control.HandleCreated -= _Control_HandleCreated;
				_AddWork();
			}

			void _AddWork()
			{
				bool ok = TrySubmitThreadpoolCallback(_SimpleCallback, Zero, _Env);
				Debug.Assert(ok);
			}

			void _SimpleCallback(IntPtr Instance, IntPtr Context)
			{
				APTTYPE apt; int aptq;
				if(0 == CoGetApartmentType(out apt, out aptq) && apt != APTTYPE.APTTYPE_STA)
					CoInitializeEx(Zero, COINIT.COINIT_APARTMENTTHREADED | COINIT.COINIT_DISABLE_OLE1DDE);

				//PrintFunc();
				_workCallback(_state);
				var c = _control;
				if(c != null && !c.IsDisposed) {
					try {
						for(int i = 1; i < 70; i++) { //~2.5 s
							if(c.IsHandleCreated || c.IsDisposed) break;
							Sleep(i);
						}
						c.Invoke(_completionCallback, _state);
					}
					catch(InvalidOperationException e) {
						if(!c.IsDisposed) {
							PrintDebug(e);
						}
					}
					catch(Exception e) { PrintDebug(e); }
				}

				_gch.Free();
			}

			//~_Work()
			//{
			//	Print("dtor");
			//}
		}

		static ThreadPoolSTA()
		{
			var p = _Env;
			if(p->Pool != Zero) return;
			lock ("{A0142343-BA4D-4B27-B8EA-E5543C139796}") {
				if(p->Pool != Zero) return;

				p->Size = Api.SizeOf(*p);
				p->Version = 3;
				p->CallbackPriority = (int)TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_NORMAL;

				var pool = CreateThreadpool(Zero);
				SetThreadpoolThreadMinimum(pool, 2);
				SetThreadpoolThreadMaximum(pool, 4);

				p->Pool = pool;
			}
		}

		static TP_CALLBACK_ENVIRON_V3* _Env { get { return &_LibProcessMemory.Ptr->threadPool; } }

		internal struct TP_CALLBACK_ENVIRON_V3
		{
			public uint Version;
			public IntPtr Pool;
			public IntPtr CleanupGroup;
			//public PTP_CLEANUP_GROUP_CANCEL_CALLBACK CleanupGroupCancelCallback;
			public IntPtr CleanupGroupCancelCallback;
			public IntPtr RaceDll;
			public IntPtr ActivationContext;
			//public PTP_SIMPLE_CALLBACK FinalizationCallback;
			public IntPtr FinalizationCallback;
			public uint Flags;
			public int CallbackPriority;
			public uint Size;
		}

		enum TP_CALLBACK_PRIORITY
		{
			TP_CALLBACK_PRIORITY_HIGH,
			TP_CALLBACK_PRIORITY_NORMAL,
			TP_CALLBACK_PRIORITY_LOW,
			TP_CALLBACK_PRIORITY_INVALID,
			TP_CALLBACK_PRIORITY_COUNT = 3
		}

		[DllImport("kernel32.dll")]
		static extern IntPtr CreateThreadpool(IntPtr reserved);

		[DllImport("kernel32.dll")]
		static extern void CloseThreadpool(IntPtr ptpp);

		[DllImport("kernel32.dll")]
		static extern void SetThreadpoolThreadMaximum(IntPtr ptpp, uint cthrdMost);

		[DllImport("kernel32.dll")]
		static extern bool SetThreadpoolThreadMinimum(IntPtr ptpp, uint cthrdMic);

		delegate void PTP_WORK_CALLBACK(IntPtr Instance, IntPtr Context, IntPtr Work);

		[DllImport("kernel32.dll")]
		static extern IntPtr CreateThreadpoolWork(PTP_WORK_CALLBACK pfnwk, IntPtr pv, TP_CALLBACK_ENVIRON_V3* pcbe);

		[DllImport("kernel32.dll")]
		static extern void SubmitThreadpoolWork(IntPtr pwk);

		delegate void PTP_SIMPLE_CALLBACK(IntPtr Instance, IntPtr Context);

		[DllImport("kernel32.dll")]
		static extern bool TrySubmitThreadpoolCallback(PTP_SIMPLE_CALLBACK pfns, IntPtr pv, TP_CALLBACK_ENVIRON_V3* pcbe);

		[DllImport("kernel32.dll")]
		static extern void CloseThreadpoolWork(IntPtr pwk);

		[DllImport("kernel32.dll")]
		static extern void WaitForThreadpoolWorkCallbacks(IntPtr pwk, bool fCancelPendingCallbacks);

		public enum APTTYPE
		{
			APTTYPE_CURRENT = -1,
			APTTYPE_STA,
			APTTYPE_MTA,
			APTTYPE_NA,
			APTTYPE_MAINSTA
		}

		[DllImport("ole32.dll", PreserveSig = true)]
		public static extern int CoGetApartmentType(out APTTYPE pAptType, out int pAptQualifier);

		[Flags]
		public enum COINIT :uint
		{
			COINIT_APARTMENTTHREADED = 0x2,
			COINIT_MULTITHREADED = 0x0,
			COINIT_DISABLE_OLE1DDE = 0x4,
			COINIT_SPEED_OVER_MEMORY = 0x8
		}

		[DllImport("ole32.dll", PreserveSig = true)]
		public static extern int CoInitializeEx(IntPtr pvReserved, COINIT dwCoInit);

	}




		[DllImport("kernel32.dll", EntryPoint = "CreateMutexW")]
		public static extern IntPtr CreateMutex(IntPtr lpMutexAttributes, bool bInitialOwner, string lpName);

		[DllImport("kernel32.dll")]
		public static extern bool ReleaseMutex(IntPtr hMutex);

		static InterDomainHandle _mutexLibMem = new InterDomainHandle(CreateMutex(Zero, false, "Catkeys_LibMem"), "Catkeys_LibMem");

		public static unsafe IntPtr GetProcMem()
		{
			//Unfinished. Need to either use unique name (+ process id and start time) or check that the address is valid, because the environment variable may be inherited from an ancestor process.

			Perf.Next();
			string name = "Catkeys_LibMem";
			//Print(name);
			string s;
			s = Environment.GetEnvironmentVariable(name);
			//if(s != null) return (IntPtr)s.ToInt64_();
			if(s != null) return (IntPtr)Convert.ToInt64(s);

			Perf.Next();
			Api.WaitForSingleObject(_mutexLibMem.Handle, Api.INFINITE);

			s = Environment.GetEnvironmentVariable(name);
			//if(s != null) return (IntPtr)s.ToInt64_();
			if(s != null) return (IntPtr)Convert.ToInt64(s);

			Perf.Next();
			const int Size = 0x10000;
			IntPtr r = Api.VirtualAlloc(Zero, Size, 0x3000, 0x40); //much faster when need to zero memory
			Perf.Next();
			Environment.SetEnvironmentVariable(name, r.ToString());
			ReleaseMutex(_mutexLibMem.Handle);
			return r;
		}

		public static unsafe IntPtr GetProcMem2()
		{
			Perf.Next();
			var p = Process.GetCurrentProcess();
			string name = $"Catkeys_{p.Id}_{p.StartTime.ToBinary()}"; //p.StartTime.ToBinary is the slowest part
			Perf.Next();
			//Print(name);
			string s = Environment.GetEnvironmentVariable(name);
			//if(s != null) return (IntPtr)s.ToInt64_();
			if(s != null) return (IntPtr)Convert.ToInt64(s);
			//using(var x=new Mutex(false, "Cat"
			const int Size = 0x10000;
			IntPtr r = Api.VirtualAlloc(Zero, Size, 0x3000, 0x40); //much faster when need to zero memory
			Environment.SetEnvironmentVariable(name, r.ToString());
			return r;
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		public static unsafe IntPtr GetProcMem3()
		{
			return (IntPtr)LibSharedMemoryInterDomain.Ptr;
		}

	/// <summary>
	/// Shared memory that can be used by all appdomains of current process but not by other processes.
	/// </summary>
	internal unsafe struct LibSharedMemoryInterDomain
	{
		//Declare variables used by our library classes.
		//Be careful with types whose sizes are different in 32 and 64 bit process.
		internal _Workarounds.ProcVar workarounds;

		/// <summary>
		/// Shared memory size.
		/// </summary>
		internal const int Size = 0x10000;

		/// <summary>
		/// Creates or opens shared memory on demand in a thread-safe and process-safe way.
		/// </summary>
		static NativeSharedMemory _sm = new NativeSharedMemory("Catkeys_M_" + Api.GetCurrentProcessId(), Size);

		/// <summary>
		/// Gets pointer to the shared memory.
		/// </summary>
		public static LibSharedMemoryInterDomain* Ptr { get { return (LibSharedMemoryInterDomain*)_sm.mem; } }
	}



		/// <summary>
		/// Shared memory that can be used by all appdomains of current process but not by other processes.
		/// </summary>
		internal unsafe struct TestSharedMemoryInterDomain
		{
			//Declare variables used by our library classes.
			//Be careful with types whose sizes are different in 32 and 64 bit process.

			/// <summary>
			/// Shared memory size.
			/// </summary>
			internal const int Size = 0x10000;

			static TestSharedMemoryInterDomain()
			{
				_mm = System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen("Catkeys_M_" + Api.GetCurrentProcessId(), Size);
				_acc = _mm.CreateViewAccessor();
				byte* p = null;
				_acc.SafeMemoryMappedViewHandle.AcquirePointer(ref p);
				_mem = (IntPtr)p;
			}
			/// <summary>
			/// Creates or opens shared memory on demand in a thread-safe and process-safe way.
			/// </summary>
			static System.IO.MemoryMappedFiles.MemoryMappedFile _mm;
			static System.IO.MemoryMappedFiles.MemoryMappedViewAccessor _acc;
			static IntPtr _mem;

			/// <summary>
			/// Gets pointer to the shared memory.
			/// </summary>
			public static TestSharedMemoryInterDomain* Ptr { get { return (TestSharedMemoryInterDomain*)_mem; } }
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		public static unsafe IntPtr GetProcMem4()
		{
			return (IntPtr)TestSharedMemoryInterDomain.Ptr;
		}



		public static AppDomain DefaultAppDomain
		{
			get
			{
				if(_defaultAppDomain == null) {
					var host = CLRUtil.GetCorRuntimeHost();
					object oDom;
					if(0 != host.GetDefaultDomain(out oDom)) return null;
					_defaultAppDomain = oDom as AppDomain;
				}
				return _defaultAppDomain;
			}
		}

		//This works, but not faster than new CorRuntimeHost.
		static class CLRUtil
		{
			internal static ICorRuntimeHost GetCorRuntimeHost()
			{
				// Obtain ICLRMetaHost interface
				object objHost;
				int hr = CLRCreateInstance(ref CLSID_CLRMetaHost, ref IID_CLRMetaHost, out objHost);
				if(hr != 0) throw new COMException("Cannot create meta host", hr);
				var host = (ICLRMetaHost)objHost;

				// Obtain ICLRRuntimeInfo interface
				var vers = Environment.Version;
				var versString = string.Format("v{0}.{1}.{2}", vers.Major, vers.Minor, vers.Build);
				var objRuntime = host.GetRuntime(versString, ref IID_CLRRuntimeInfo);
				var runtime = (ICLRRuntimeInfo)objRuntime;
				bool started;
				uint flags;
				runtime.IsStarted(out started, out flags);
				if(!started) throw new COMException("CLR not started??");

				return (ICorRuntimeHost)runtime.GetInterface(ref CLSID_CorRuntimeHost, ref IID_CorRuntimeHost);
			}

			private static Guid CLSID_CLRMetaHost = new Guid(0x9280188d, 0xe8e, 0x4867, 0xb3, 0xc, 0x7f, 0xa8, 0x38, 0x84, 0xe8, 0xde);
			private static Guid IID_CLRMetaHost = new Guid(0xD332DB9E, 0xB9B3, 0x4125, 0x82, 0x07, 0xA1, 0x48, 0x84, 0xF5, 0x32, 0x16);
			private static Guid IID_CLRRuntimeInfo = new Guid(0xBD39D1D2, 0xBA2F, 0x486a, 0x89, 0xB0, 0xB4, 0xB0, 0xCB, 0x46, 0x68, 0x91);
			private static Guid CLSID_CorRuntimeHost = new Guid(0xcb2f6723, 0xab3a, 0x11d2, 0x9c, 0x40, 0x00, 0xc0, 0x4f, 0xa3, 0x0a, 0x3e);
			private static Guid IID_CorRuntimeHost = new Guid(0xcb2f6722, 0xab3a, 0x11d2, 0x9c, 0x40, 0x00, 0xc0, 0x4f, 0xa3, 0x0a, 0x3e);

			[DllImport("mscoree.dll")]
			private static extern int CLRCreateInstance(ref Guid clsid, ref Guid iid, [MarshalAs(UnmanagedType.Interface)] out object ptr);

			[ComImport, Guid("D332DB9E-B9B3-4125-8207-A14884F53216"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
			private interface ICLRMetaHost
			{
				[return: MarshalAs(UnmanagedType.Interface)]
				object GetRuntime(string version, ref Guid iid);
				// Rest omitted
			}

			[ComImport, Guid("BD39D1D2-BA2F-486a-89B0-B4B0CB466891"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
			private interface ICLRRuntimeInfo
			{
				void GetVersionString(char[] buffer, int bufferLength);
				void GetRuntimeDirectory(char[] buffer, int bufferLength);
				bool IsLoaded(IntPtr hProcess);
				void LoadErrorString(uint id, char[] buffer, int bufferLength, int lcid);
				void LoadLibrary(string path, out IntPtr hMdodule);
				void GetProcAddress(string name, out IntPtr addr);
				[return: MarshalAs(UnmanagedType.Interface)]
				object GetInterface(ref Guid clsid, ref Guid iid);
				bool IsLoadable();
				void SetDefaultStartupFlags(uint flags, string configFile);
				void GetDefaultStartupFlags(out uint flags, char[] configFile, int configFileLength);
				void BindAsLegacyV2Runtime();
				void IsStarted(out bool started, out uint flags);
			}
		}


		//public static AppDomain DefaultAppDomain
		//{
		//	get
		//	{
		//		if(_defaultAppDomain == null) {
		//			var host = new mscoree.CorRuntimeHost();
		//			object defaultAppDomain;
		//			host.GetDefaultDomain(out defaultAppDomain);
		//			_defaultAppDomain = defaultAppDomain as AppDomain;
		//		}
		//		return _defaultAppDomain;
		//          }
		//}

		[DllImport("mscoree.dll", PreserveSig = true)]
		static extern int DllGetClassObject([In] ref Guid rclsid, [In] ref Guid riid, [MarshalAs(UnmanagedType.IUnknown)] out object ppv);

		[ComImport, Guid("00000001-0000-0000-C000-000000000046"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		interface IClassFactory
		{
			[PreserveSig]
			int CreateInstance(IntPtr pUnkOuter, [In] ref Guid riid, [MarshalAs(UnmanagedType.IUnknown)] out object ppvObject);
			[PreserveSig]
			int LockServer([MarshalAs(UnmanagedType.Bool)] bool fLock);
		}

		static Guid IID_IClassFactory = new Guid(0x00000001, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);
		static Guid CLSID_CorRuntimeHost = typeof(CorRuntimeHost).GUID;
		static Guid IID_ICorRuntimeHost = typeof(ICorRuntimeHost).GUID;

		[DllImport("ole32.dll", PreserveSig = true)]
		public static extern int CoCreateInstance([In] ref Guid rclsid, IntPtr pUnkOuter, uint dwClsContext, [In] ref Guid riid, [MarshalAs(UnmanagedType.IUnknown)] out object ppv);

		const uint CLSCTX_SERVER = 0x15;


		//public static AppDomain DefaultAppDomain
		//{
		//	get
		//	{
		//		if(_defaultAppDomain == null) {
		//			object oIcf, oHost, oDom;
		//			if(0 != CoCreateInstance(ref CLSID_CorRuntimeHost, Zero, CLSCTX_SERVER, ref IID_ICorRuntimeHost, out oHost)) return null;
		//			Print(1);
		//			var host=(ICorRuntimeHost)oHost;
		//			PrintHex(host.GetDefaultDomain(out oDom));
		//			if(0 != host.GetDefaultDomain(out oDom)) return null;
		//			Print(3);
		//			_defaultAppDomain = oDom as AppDomain;
		//		}
		//		return _defaultAppDomain;
		//          }
		//}
		//public static AppDomain DefaultAppDomain
		//{
		//	get
		//	{
		//		if(_defaultAppDomain == null) {
		//			object oIcf, oHost, oDom;
		//			if(0 != DllGetClassObject(ref CLSID_CorRuntimeHost, ref IID_IClassFactory, out oIcf)) return null;
		//			Print(1);
		//			if(0!=((IClassFactory)oIcf).CreateInstance(Zero, ref IID_ICorRuntimeHost, out oHost)) return null;
		//			Print(2);
		//			var host=(ICorRuntimeHost)oHost;
		//			PrintHex(host.GetDefaultDomain(out oDom));
		//			if(0 != host.GetDefaultDomain(out oDom)) return null;
		//			Print(3);
		//			_defaultAppDomain = oDom as AppDomain;
		//		}
		//		return _defaultAppDomain;
		//          }
		//}





		//static bool _OnRButtonUpShowContextMenu(ToolStripDropDownMenu dd)
		//{
		//	var cm = dd.ContextMenu;
		//	if(cm == null) return false;

		//	Wnd w = (Wnd)dd.Handle;
		//	bool ac = dd.AutoClose, en = dd.Enabled;
		//	dd.AutoClose = false;
		//	dd.Enabled = false;

		//	cm.Show(dd, dd.PointToClient(Mouse.XY));

		//	//when user clicks disabled menu dd to close cm, don't enable dd until the left mouse button released, or it would select the menu item
		//	Time.SetTimer(10, false, t =>
		//	{
		//		if(Control.MouseButtons.HasFlag(MouseButtons.Left) && w.Visible) return;
		//		t.Stop();
		//		if(!dd.IsDisposed) {
		//			dd.Enabled = en;
		//			dd.AutoClose = ac;
		//		}
		//	});
		//	return true;
		//}



	static void TestCatMenuSpeed(Control c = null)
	{
		var speed = new Perf.Inst();
		speed.First();
		Perf.First();
		var m = c != null ? new CatMenu(new Container()) : new CatMenu();
		Perf.Next();
		m["One"] = o => Print("one");
		Perf.Next();
		//m["Two"] = o => Print("two");
		//m.Items.Add("text");
		for(int i = 0; i < 20; i++) m[$"More {i}"] = o => Print(o);
		Perf.Next();
		//Print(m.LastItem.Height);
		using(var sm = m.Submenu("Submenu")) {
			m["Three"] = o => Print("three");
			m["Four"] = o => Print("four");
			Perf.Next();
			for(int i = 0; i < 20; i++) m[$"More {i}"] = o => Print(o);
			Perf.Next();
		}
		Perf.Next();
		speed.NextWrite();
		Sleep(1000);
		Perf.Next();
		if(c != null) {
			m.Show(c, 100, 100);
		} else {
			//m.Show();
			m.Show(Mouse.X + 10, Mouse.Y + 10);
		}
	}

	static void TestCatMenuArray(Control c = null)
	{
		Perf.First();
		var m = c != null ? new CatMenu(new Container()) : new CatMenu();
		Perf.Next();
		var a = new ToolStripItem[30];
		for(int i = 0; i < a.Length; i++) a[i] = new ToolStripMenuItem("text");
		Perf.Next();
		m.CMS.Items.AddRange(a);
		Perf.Next();
		using(m.Submenu("Submenu")) {
			m["Three"] = o => Print("three");
			m["Four"] = o => Print("four");
		}
		Perf.Next();
		if(c != null) {
			m.Show(c, 100, 100);
		} else {
			//Wait(0.5); Perf.Next();
			//m.Show();
			m.Show(Mouse.X + 10, Mouse.Y + 10);
		}
	}



	public class CatBar :NativeWindow
	{
		static Wnd.Misc.WndClass _WndClass = Wnd.Misc.WndClass.Register("CatBar", _WndProc, 0, Api.CS_GLOBALCLASS);
		//static Wnd.Misc.WndClass _WndClass;
		Wnd _w;

		public static CatBar Create()
		{
			//if(_WndClass == null) { //to test class registration speed
			//	_WndClass = Wnd.Misc.WndClass.Register("CatBar", _WndProc, 0, Api.CS_GLOBALCLASS);
			//	Perf.Next();
			//}

			var c = new CatBar();
			Perf.Next();
			uint exStyle = Native.WS_EX_TOOLWINDOW | Native.WS_EX_NOACTIVATE | Native.WS_EX_TOPMOST;
			uint style = Native.WS_POPUP | Native.WS_CAPTION | Native.WS_SYSMENU;

			//var p = new CreateParams() { ClassName= "CatBar", ExStyle = (int)exStyle, Style = (int)style, X = 400, Y = 200, Width = 1200, Height = 80 };
			//c.CreateHandle(p); //registers class like "WindowsForms10.CatBar.app.0.3ee7db9_r6_ad2". Then would be two classes.

			c._w = Api.CreateWindowEx(exStyle, _WndClass.Name, null, style, 400, 200, 1200, 80, Wnd0, 0, Zero, 0);
			if(c._w.Is0) throw new Win32Exception();
			c.AssignHandle(c._w.Handle);

			return c;
		}

		protected override void WndProc(ref Message m)
		{
			//Print(m);
			base.WndProc(ref m);

			switch((uint)m.Msg) {
			case Api.WM_NCDESTROY:
				_mlTb.Stop();
				break;
			case Api.WM_PAINT:
				//Print("painted");
				//if(_tbStrip2 != null) {
				//	ToolStrip2 t = _tbStrip2; _tbStrip2 = null;
				//	if(!t.Focused) t.Focus(); //solves problem when in native window: the first button-click does not work. This takes several milliseconds therefore is after painting.
				//}
				break;
			}
		}

		static LPARAM _WndProc(Wnd w, uint msg, LPARAM wParam, LPARAM lParam)
		{
			LPARAM R = Api.DefWindowProc(w, msg, wParam, lParam);
			return R;
		}
	}




	#region test old menu

	static void TestOldMenu(Control c = null)
	{
		Perf.First();
		var f = new Form();
		Wnd w = (Wnd)f;
		Api.SetParent(w, Wnd.Misc.SpecHwnd.Message);
		w.SetExStyle(Native.WS_EX_TOOLWINDOW);
		w.SetStyle(Native.WS_POPUP);
		w.Visible = true;
		Perf.Next();

		var m = new ContextMenu();
		Perf.Next();
		m.MenuItems.Add("First", _eho);
		Perf.Next();
		for(int i = 0; i < 16; i++) {
			MenuItem k = m.MenuItems.Add("Text");
			//k.OwnerDraw = true;
			//k.MeasureItem += K_MeasureItem;
			//k.DrawItem += K_DrawItem;
		}
		Perf.Next();

		//add no-activate ex style. On Popup event the menu window is still not created.
		var t = new System.Windows.Forms.Timer();
		t.Interval = 1;
		t.Tick += (o, e) =>
		{
			Perf.Next();
			t.Stop();
			foreach(var tw in Wnd.ThreadWindows()) {
				if(tw.ClassNameIs("#32768")) {
					//Print(tw);
					tw.SetExStyleAdd(Native.WS_EX_NOACTIVATE);
					break;
				}
			}
			Perf.NextWrite();
		};
		t.Start();

		Perf.Next();
		//m.Popup += (o, e) => { Perf.NextWrite(); };

		m.Show(f, new Point(0, 0));
		Application.DoEvents(); //run the click event handler
    }

	private static void K_MeasureItem(object sender, MeasureItemEventArgs e)
	{
		PrintList(e.ItemHeight, e.ItemWidth);
	}

	private static void K_DrawItem(object sender, DrawItemEventArgs e)
	{
		//PrintFunc();
	}

	static EventHandler _eho = _EventHandlerOld;

	static void _EventHandlerOld(object sender, EventArgs args)
	{
		PrintFunc();
	}

	#endregion

		//class HiddenForm :Form
		//{
		//	protected override void SetVisibleCore(bool value)
		//	{
		//		if(!this.IsHandleCreated) {
		//			this.CreateHandle();
		//			value = false;   // Prevent window from becoming visible
		//		}
		//		base.SetVisibleCore(value);
		//	}
		//}




////Perf.SpinCPU(); //does nothing
//long t1 = Stopwatch.GetTimestamp();

////TODO: instead could simply allocate unmanaged memory with Marshal methods and pass to domains with childDomain.SetData
//_sm = new OurSharedMemory();
//_sm.Create("Catkeys_SM_Tasks", 1024 * 1024);

//if(true) //compiler
//{
//	_sm.x->perf.AddTicksFirst(t1);
//	_sm.x->perf.Next();

//	IntPtr ev = Api.CreateEvent(Zero, false, false, null);

//	_sm.x->eventCompilerStartup = ev;

//	//Mes("before");

//	var thr = new Thread(_AppDomainThread);
//	thr.Start();

//	_sm.x->perf.Next();

//	Api.WaitForSingleObject(ev, ~0U);
//	//Thread.Sleep(100);
//	Api.CloseHandle(ev);

//	_sm.x->perf.Next();
//	_sm.x->perf.Write();

//	_hwndCompiler = _sm.x->hwndCompiler;

//	for(int i = 0; i < 1; i++) {
//		_hwndCompiler.Send(Api.WM_USER, Zero, Marshal.StringToBSTR("test"));
//	}

//	//Mes("in");

//	_hwndCompiler.Send(Api.WM_CLOSE);
//	//Environment.Exit(0);

//	//Mes("after");
//	//return;
//}

////Thread.Sleep(100);

////for(int i = 0; i<5; i++) {
////	var thr2 = new Thread(_AppDomainThread2);
////	thr2.Start();
////	Thread.Sleep(100);
////	if(i%10!=9) continue;
////	//Perf.First();
////	thr2=null;
////	GC.Collect(); //releases a lot. Without it, GC runs when Task Manager shows 100 MB.
////				  //GC.Collect(2, GCCollectionMode.Optimized); //collects at 26 MB; without - at 36 MB
////}
////Mes("exit");	//static void _AppDomainThread2()

//{
//	Perf.First();
//	var domain = AppDomain.CreateDomain("Compiler");
//	Perf.Next();
//	domain.ExecuteAssembly(@"C:\Test\test1.exe");
//	Perf.Next();
//	AppDomain.Unload(domain);
//	Perf.NextWrite();
//}

//static void _AppDomainThread()
//{
//	//_DomainCallback();

//	var domain = AppDomain.CreateDomain("Compiler");
//	//var domain=AppDomain.CreateDomain("Compiler", AppDomain.CurrentDomain.Evidence, new AppDomainSetup { LoaderOptimization = LoaderOptimization.MultiDomain }); //by default makes faster, but makes much slower when we use LoaderOptimization attribute on Main(). Assemblies will not be unloaded when appdomain unloaded (will use many MB of memory).
//	//System.IO.Pipes.AnonymousPipeClientStream
//	//childDomain.SetData("hPipe", handle.ToString());
//	unsafe { _sm.x->perf.Next(); }

//	domain.DoCallBack(_DomainCallback);
//	//domain.ExecuteAssembly(Paths.CombineApp("Compiler.exe"));
//	//domain.DoCallBack(Compiler.Compiler.Main); //faster than ExecuteAssembly by 3-4 ms
//	AppDomain.Unload(domain);
//	domain = null;
//	//Print("_AppDomainThread() ended");
//	GC.Collect(); //releases a lot
//				  //Mes("MinimizeMemory");
//				  //Misc.MinimizeMemory(); //does nothing

//	//tested:
//	//Currently speed and memory is similar in both cases - when compiler is in this assembly and when in another.
//	//But will need to test later, when this assembly will be big.
//	//Not using LoaderOptimization.MultiDomain, because then does not unload assemblies of unloaded domains (then uses much memory, and there is no sense to execute compiler in a separate domain).
//}


////[MethodImpl(MethodImplOptions.NoOptimization)]
//static unsafe void _DomainCallback()
//{
//	//if(AppDomain.CurrentDomain.FriendlyName!="Compiler") return;
//	long t1 = Stopwatch.GetTimestamp();

//	_sm = new OurSharedMemory();
//	_sm.Open("Catkeys_SM_Tasks");

//	_sm.x->perf.AddTicksNext(t1);
//	_sm.x->perf.Next();

//	//=AppDomain.CurrentDomain.GetData("hPipe")

//	_wndClassCompiler = Wnd.Misc.WndClass.Register("Catkeys_Compiler", _WndProcCompiler);

//	_sm.x->perf.Next();

//	Wnd w = Api.CreateWindowEx(0, _wndClassCompiler.Name, null, Native.WS_POPUP, 0, 0, 0, 0, Wnd.Misc.SpecHwnd.Message, Zero, Zero, Zero);

//	_sm.x->perf.Next();

//	_SHMEM* x = _sm.x;
//	x->hwndCompiler = w;
//	Api.SetEvent(x->eventCompilerStartup);

//	//message loop
//	//Application.Run(); //By default would add several ms to the startup time. Same speed if Main() has the LoaderOptimization attribute. Also may be not completely compatible with native wndproc. Also in some cases adds several MB to the working set.
//	Native.MSG m;
//	while(Api.GetMessage(out m, Wnd0, 0, 0) > 0) { Api.DispatchMessage(ref m); }
//}

//struct _SHMEM
//{
//	public IntPtr eventCompilerStartup;
//	public Wnd hwndCompiler;
//	public Perf.PerfInstance perf;
//}

////We don't use MemoryMappedFile because it is very slow. Creating/writing is 1500, opening/reading is 5000.
////With this class - 1300 and 600 (because of JIT). With ngen - 60 and 20 (same as in C++).
//unsafe class OurSharedMemory :Util.SharedMemoryFast
//{
//	public _SHMEM* x { get { return (_SHMEM*)_mem; } }
//}

//static OurSharedMemory _sm;
//static Wnd _hwndCompiler;



////class DialogVariables { public string lb3, c4; public string[] au; }
////class DialogVariables { public object lb3, c4, au; }
////here class is better than struct, because:
////Don't need ref;
////Can be used with modeless dialogs.

////const string S1="one"+NL+"two"; //ok
////const string S2=$"one{NL}two"; //error


//static void ShowDialog(object v)
//{
//	FieldInfo[] a = v.GetType().GetFields();
//	foreach(FieldInfo f in a) {
//		Print(f.Name);
//		//Print(f.FieldType.Equals(typeof(string)));
//		switch(Type.GetTypeCode(f.FieldType)) {
//		case TypeCode.String: Print("string"); break;
//		case TypeCode.Object: Print("object"); break;
//		}
//	}
//}

////delegate void Dee(GCHandle x);

////static void Mee(GCHandle x)
////{
////Print("here"); return;
//////Print(x.IsAllocated);
////Print(GCHandle.ToIntPtr(x));
////if(GCHandle.ToIntPtr(x)==Zero) Print("null");
////else {
////string s=(x.Target as string);
////Print(s);
////}
////}
//delegate void Dee(object x);


//delegate void Del(int t);
////delegate void Del0();

//class TestIndexers
//{
//	//public int this[int i]
//	//{
//	//get { return i*i; }
//	//set { Print($"{i} {value}"); }
//	//}
//	//public int this[int i, int j=1]
//	//{
//	//	get { return i*j; }
//	//	set { Print($"{i} {j} {value}"); }
//	//}
//	public string this[string s]
//	{
//		get { return s + " ?"; }
//		set { Print($"{s} {value}"); }
//	}

//	//static TestIndexers ti_=new TestIndexers();
//	//public static TestIndexers Hotkey => ti_;
//	//or
//	public static readonly TestIndexers Hotkey = new TestIndexers();
//}

////[MethodImpl(MethodImplOptions.NoInlining)]
////static void TestCallersVariables()
////{
////	Perf.First();
////	StackFrame frame = new StackFrame(1);
////	var method = frame.GetMethod();
////	MethodBody mb=method.GetMethodBody();
////	int n=0;
////	foreach(LocalVariableInfo v in mb.LocalVariables) {
////		//Print(v.LocalType.ToString());
////		if(v.LocalType.Name=="Wnd") {
////			n++;
////			//v.
////		}
////	}
////	Print(n);
////}


//[Trigger.Hotkey("Ctrl+K")]
//public static void Function1(HotkeyTriggers.Message m) { Print("script"); }



//TestUnmanaged();

//StackTrace stackTrace = new StackTrace();
//Print(stackTrace.GetFrame(1).GetMethod().Name);
////Print(stackTrace.GetFrame(1).GetFileLineNumber()); //always 0, even in Debug build
//Print(stackTrace.GetFrame(1).GetFileName()); //null
////Print(stackTrace.GetFrame(1).GetMethod(). //nothing useful




//Dee f=Mee;
////f(GCHandle.Alloc("test"));
////f(GCHandle.FromIntPtr(Zero));
//f("test");
//f(5);


//return;

//UIntPtr ki=1;

//switch(2)
//{
//	case 1:
//	int hdh=8;
//	break;
//	case 2:
//	int koop=8;
//Print(hdh);
//	break;
//}

//Print(hdh);

//Print($"one{_}two");
//Print("three"+_+"four");
//Print("one" RN "two"); //error
//Print($"one{}two"); //error


////str controls="3"
////var d=new DialogVariables("3") { lb3="oooo" };
////var d=new DialogVariables("3");
//var d=new DialogVariables();
//d.lb3="oooo";
//d.c4=7;
//d.au=new string[] { "one", "two" };
////d.au={ "one", "two" }; //error
//ShowDialog(d);
//return;


//static void AnotherThread()
//{
//	//ShowRen.Show("another thread", "", "", x:1);
//	MessageBox.Show("another thread");
//	Print("after msgbox in another thread");
//}

//[DllImport("comctl32.dll", EntryPoint = "TaskDialog")]
//static extern int _TaskDialog(Wnd hWndParent, IntPtr hInstance, string pszWindowTitle, string pszMainInstruction, string pszContent, TDButtons dwCommonButtons, LPARAM pszIcon, out int pnButton);

//static int TD(string s, bool asy)
//{
//	int r = 0;
//	for(int i = 0; i < 100; i++) {
//		int hr = _TaskDialog(Wnd0, Zero, "Test", s, null, TDButtons.Cancel, 0, out r);
//		//PrintList(hr, r, asy);
//		if(hr == 0 || hr == Api.E_INVALIDARG) break;
//		Thread.Sleep(20);
//	}
//	return r;
//}



////string ss = "gggggg.txt";
////Print(ss.Like_(false, "*.exe", "*.txt"));

////string ss = "5ggggg.txt";
////Print(ss.LikeEx_(false, "#*.exe", "#*.txt"));

////string ss = "5ggggg.txt";
////Print(ss.Equals_(false, "moo.exe", "5ggggg.txt"));

////string ss = "5ggggg.txt";
////Print(ss.EndsWith_(false, ".exe", ".txt"));

////string ss = "file.txt";
////Print(ss.StartsWith_(false, "kkk", "file."));

//string ss = "file.txt";
////Print(ss.RegexIs_(".*.TXT"));
////Print(ss.RegexIs_(".*.txt", RegexOptions.IgnoreCase));
////Print(ss.RegexIs_(0, ".*.TXT", ".*.txt"));
////Print(ss.RegexIs_(RegexOptions.IgnoreCase, ".*.TXT", ".*.txt"));
//ss = "gggg.exe\naaa.txt\nbbb.txt";
////Print(ss.RegexMatch_(".*.TXT"));
////Print(ss.RegexMatch_(".*.TXT", RegexOptions.IgnoreCase));
////Output.Write(ss.RegexMatches_(".*.TXT"));
////Output.Write(ss.RegexMatches_(".*.TXT", RegexOptions.IgnoreCase));

//Print(ss.RegexReplace_(@"\.txt\b", ".moo"));
//Print(ss.RegexReplace_(@"\.txt\b", m=> { return ".boo"; }));

////var au = new int[] {1, 2, 3 };
////var au = new List<int> {1, 2, 3 };
////var au = new Dictionary<string, string>() { { "A", "B" }, { "C", "D" } };
////Output.Write(au, ", ");

//return;




//Print(AppDomain.CurrentDomain.FriendlyName);

//new Thread(AnotherThread).Start();

//ShowRen.Show("appdomain primary thread", "", "e");

////Thread.CurrentThread.Abort();
////AppDomain.Unload(AppDomain.CurrentDomain);
//Print("after TaskDialog");

//return;

//ShowRen.Show("", "<a href=\"test\">test</a>", onLinkClick: ed =>
//{
//	Wnd z = ed.hwnd;
//	string s = null;
//	Perf.First(100);
//	for(int j = 0; j<8; j++) {
//		for(int i=0; i<1000; i++) s= z.ClassName;
//		//for(int i=0; i<1000; i++) s= z.Name;
//		//for(int i = 0; i<1000; i++) s= z.ControlText;
//		//for(int i = 0; i<1000; i++) s= z.ControlTextLength;
//		Perf.Next();
//	}
//	Perf.Write();
//	Print(s);
//}
//);

//return;

////Time.Wait(1);
//Wnd z = Wnd.Find("Untitled - Notepad");
////z=(Wnd)2098486; //Inno
////z=(Wnd)395896; //Static
////z=(Wnd)1510052; //Edit

////z.Name = "MMMMMMMMGGGG"; return;

////string m = z.Name;
////string m = z.GetControlText();
////PrintList(m==null, m=="", m);
////return;

//Print(z);

//string cn = null;
////cn= z.ControlText; PrintList(cn.Length, cn); return;
//int nt = 0;

//Perf.First(100);
//for(int j = 0; j<8; j++) {
//	//for(int i=0; i<1000; i++) cn= z.ClassName;
//	//for(int i=0; i<1000; i++) cn= z.Name;
//	for(int i = 0; i<1000; i++) cn= z.GetControlText();
//	Perf.Next();
//}
//Perf.Write();
//Print(cn);
//Print(nt);

//Wnd ww = Wnd.Find("Untitled - Notepad");
//ww.MoveInScreen(100, 100);
//return;

//PrintFunc();
//Print(FunctionName());
//Output.WriteHex((sbyte)(-10));
//PrintList(1, "mmm", true, null, 5.6);
//Print("ff");
//Print(5);
//PrintList(1, 2, 3);
//return;

//Output.Clear();
//Screen s = null;
////Output.Write(s);
////Console.WriteLine(s);
//Info("stri");
//Info(5);
//Info(true);
//Info(new char[] { 'a', 'b' });
//Info(new string[] { "aaa", "bbb" });
//Info(new int[] { 'a', 'b' });
//Info(new Dictionary<string, string>() { { "A", "B" }, { "C", "D" } });
//Print("----------");
//Print("stri");
//Print(5);
//Print(true);
//Print(new char[] { 'a', 'b' });
//Print(new string[] { "aaa", "bbb" });
//Print(new int[] { 'a', 'b' });
//Print(new Dictionary<string, string>() { { "A", "B" }, { "C", "D" } });

////Perf.First(100);
////for(int j=0; j<5; j++) {
////	for(int i = 0; i<1000; i++) Info2("ff");
////	Perf.Next();
////}
////Perf.Write();

//return;




//Wait(2);
//Info("bla");
//Print("bla");
//Say("bla");
//Print("bla");
//OW("bla");

//Info("bla"); Warning("bla"); Error("bla");



//Wnd w = Wnd.Find("Untitled - Notepad");
////Wnd w2 = Wnd.Find("Registry Editor");

////w.MoveInScreen(0, 0, null, limitSize:true, rawXY:false);
////w.EnsureInScreen(null, limitSize:true, workArea:true);

//RECT k=new RECT(0, 1700, 5000, 400, true);
////RECT k=new RECT(-1, -1, 500, 400, true);

////Wnd.RectMoveInScreen(ref k, limitSize:true);
//Wnd.RectEnsureInScreen(ref k, limitSize:true);
//Print(k);

////w=Wnd.Misc.SpecHwnd.NoTopmost;
//Print(Screen_.FromObject(w));

////Screen s1 = Screen_.FromObject(w);
////Screen s2 = Screen_.FromObject(w);
//Screen s1 = Screen.PrimaryScreen;
//Screen s2 = Screen.PrimaryScreen;
//Print(s1==s2);
//Print(s1.Equals(s2));


//IntPtr hm = DisplayMonitor.GetHandle(w);
////hm=DisplayMonitor.GetHandle(2);
////hm=DisplayMonitor.GetHandle(DisplayMonitor.OfMouse);
////hm=DisplayMonitor.GetHandle(new POINT(2000, 2000));
////hm=DisplayMonitor.GetHandle(new RECT(2000, 2000, 100, 100, true));
//Print(hm);

//for(int z=0; z<2; z++) {
//	Screen[] ad = Screen.AllScreens;
//	foreach(Screen k in ad) {
//		RECT rr = k.Bounds;
//		Print(rr);
//	}
//	ShowRen.MessageDialog("aaa");
//}

//Perf.First(100);
//for(int rep1=0; rep1<5; rep1++) {
//	//for(int rep2=0; rep2<100; rep2++) { RECT u1 = DisplayMonitor.GetRectangle(2); }
//	for(int rep2=0; rep2<100; rep2++) { RECT u2 = ScreenFromIndex(2).Bounds; }
//	Perf.Next();
//}
//Perf.Write();

//Screen k = ScreenFromIndex(1);
//Print(k.Bounds);


//return;

//RECT r1; System.Drawing.Rectangle r2;

//Api.GetWindowRect(w, out r1);
//GetWindowRect(w, out r2);

//PrintList(r1, r2);

//return;


//var r1 = new RECT();
//var r2 = r1;
//var r3 = RECT.LTRB(1, 8, 10, 50);
//var r4 = RECT.LTWH(1, 8, 10, 50);
//var r5 = new RECT() { left=2, top=20, Width=2, Height=10 };

//Print(r2==r1);

//Print(r3);
//Print(r4);
//Print(r5);

//return;

//Wnd w = Wnd.Misc.SpecHwnd.Bottom;
//Print(w.Equals(Wnd.Misc.SpecHwnd.Bottom));
//Wnd w2 = w;
//Print(w.Equals(w2));
////Wnd w = Wnd0;
////Print(w.Equals(Wnd0));

//Wnd wg = Wnd.Get.FirstToplevel();

//return;

//int eon, x = "ab 99 hjk".ToInt_(2, out eon);
//PrintList(x, eon);
//int x = "ab 99 hjk".ToInt_(2);
//int x = " 99 hjk".ToInt_();
//PrintList(x);
//int eon, x = " 99 hjk".ToInt_(out eon);
//PrintList(x, eon);

//return;

//#if NEWRESULT
//try {
//Thread.Sleep(5000);

//Api.MessageBox(Wnd0, "dd", "ggg", 0x40000);
//return;

//Script.Option.dialogRtlLayout=true;
//Script.Option.dialogTopmostIfNoOwner=true;

//var asm = Assembly.GetEntryAssembly(); //fails if DoCallBack or CreateInstance, OK if ExecuteAssembly
//var asm = Assembly.GetExecutingAssembly(); //OK
//Print(asm!=null);
//Print(asm.Location);
////var rm = new System.Resources.ResourceManager("", asm);
////Print(rm);
//return;

//ScriptOptions.DisplayName="Script display name";
//Print(Assembly.GetEntryAssembly().FullName); //exception

//Wnd ko = Wnd0;
////ko = Wnd.Misc.SpecHwnd.Topmost;
//Print(ko == null);
//Print(null==ko);
//Wnd? mo = null, mo2=null;
//Print(ko == mo);
//Print(mo == mo2);
//POINT po = new POINT();
//Print(po == null);
////int io = 0;
////Print(io == null);
//IntPtr pi = Zero;
//Print(pi == null);
//return;

//Print(sizeof(WPARAM));

////void* b = (void*)1000000;
////IntPtr b = (IntPtr)(-1);
////UIntPtr b = (UIntPtr)(0xffffffff);
//int b = -1;
////uint b = 0xffffffff;
////byte b = 5;
////sbyte b = -5;
////ushort b = 5;
////short b = -5;
////char b = 'A';
////WPARAM b = -1;

////IntPtr b=(IntPtr)(-1);
////UIntPtr b=(UIntPtr)(0xffffffff);
////uint b = 5;
////char b = 'A';

//LPARAM x;
//x=b;
////x=1000;
//b=x;

////uint u =0xffffffff;
////int x = (int)u;
////WPARAM y = u;

//Print("OK");
//Print($"{x} {b}");
////Print($"{x} {((int)b).ToString()}");
////Print(x==-1);
////Print(x+4);


////string s = " 10 more";
//string s = "-10 more";
////string s = "0x10 more";
////string s = "-0x10";
//s=" 15 text";

////Print(Convert.ToInt32(s));
////Print(int.Parse(s));
////Print(SplitNumberString(ref s));
////Print($"'{s}'");

//int len, r = s.ToInt_(out len);
//Print($"{r} 0x{r:X} {len}");

//string tail;
//r=s.ToInt_(out tail);
//Print($"{r} 0x{r:X} '{tail}' {tail==null}");

//Perf.SpinCPU();
//int i, j, n1=0, n2=0;
//for(j=0; j<4; j++) {
//	Perf.First();
//	for(i=0; i<1000; i++) n1+=int.Parse(s);
//	Perf.Next();
//	for(i=0; i<1000; i++) n2+=ToInt_(s, out len);
//	Perf.NextWrite();
//}
//Print($"{n1} {n2} {len}");

//string[] a = { "one", "two" };
//Print(a);

//var d = new Dictionary<int, int>() { { 1, 1 }, { 2, 2 } };
//Print(d);

//var k = new Dictionary<string, string>() { { "A", "B" }, { "C", "D" } };
////Print(k);
//Output.Write(k);

//Redirect();
//Thread.Sleep(100);

//Output.Writer=new MooWriter();

//Perf.SpinCPU();
//int i, n=10;
//for(int j=0; j<3; j++) {

//	Perf.First();
//	for(i=0; i<n; i++) Print("out");
//	Perf.Next();
//	for(i=0; i<n; i++) Console.WriteLine("con");
//	//Perf.Next();
//	//for(i=0; i<n; i++) Trace.WriteLine("tra");
//	Perf.NextWrite();
//}
//speed: Write unbuffered 35, Console.WriteLine 30, Trace.WriteLine (debug mode) 900

////Perf.First(100);
////Output.AlwaysOutput=true;
//Output.RedirectConsoleOutput();
//Output.RedirectDebugOutput();
////Perf.NextWrite();

////Console.Write("{0} {1}", 1, true);
////return;
//Print("out");
//Console.WriteLine("con");
//Trace.WriteLine("tra");
////Thread.Sleep(1000); try { Console.Clear(); } catch { Print("exc"); }
//Debug.WriteLine("deb");

////Output.Clear();


//var e = new Exception("failed");
//var e = new ArgumentException(null, "paramName");
//var e = new FormatException();
//var e = new InvalidOperationException();
//var e = new NotImplementedException();
//var e = new NotSupportedException();
//var e = new OperationCanceledException();
//var e = new TimeoutException();
//var e = new WaitTimeoutException();
//var e = new WaitTimeoutException(null, new Exception("inner"));
//var e = new WaitTimeoutException();
//Print(e.Message);


//Print(1);
//Input.Key("Ctrl+K");
//Cat.Key("Ctrl+K");

//ShowRen.MessageDialog("dddd");
//Meow.MessageDialog("dddd");

//Test_str();

//Print($"{(int)Control.ModifierKeys:X}");
//Print($"{(int)Keys.Control:X}");
//Print($"{(int)K.Control:X}");
//Keys("");
//Key("");
//SendKeys


//Print((IntPtr)WndSpec.NoTopmost);
//Print(Wnd.Find("Untitled - Notepad"));

//TestUtil.Test_str();

//string s = "file.txt";
//Print(s.likeS("*.txt"));

////Print(s.Reverse());

//switch(s) {
//case "*.txt":
//	Print("txt");
//	break;
//case "*.moo":
//	Print("moo");
//	break;
//default:
//	Print("none");
//	break;
//}

//if(s.likeI("*.txt")) {
//	Print("txt");
//} else if(s.likeI("*.moo")) {
//	Print("moo");
//} else {
//	Print("none");
//}

//if(s.endsWithI(".txt")) {
//	Print("txt");
//} else if(s.endsWithI(".moo")) {
//	Print("moo");
//} else {
//	Print("none");
//}

//if(Regex.IsMatch(s, "one")) {
//	Print("txt");
//} else if(Regex.IsMatch(s, "two")) {
//	Print("moo");
//} else {
//	Print("none");
//}


//Print(K.A);
//Keys("dd");
//Text("uu");

//Trigger.Hotkey["Ctrl+K"] =O=> { Print("lambda"); };
//Trigger.Hotkey["Ctrl+K"] = delegate(HotkeyTriggers.Message m) { Print("delegate"); };

//HotkeyTriggers.TestFireTrigger();

//var k=new TestIndexers();
//Print(k[3]); k[7]=5;
//Print(k[3, 4]); k[7, 2]=5;
//Print(k[3]); k[7]=5;
//Print(k["AAA"]); k["BBB"]="C";
//TestIndexers.Hotkey["test"]="moo";



////var thr=new Thread(AppDomainThread);
////thr.Start();
//AppDomainThread();
////Uuoo(1);
////Uuoo(2);
////Uuoo(3);
//MessageBox.Show("main domain, tid="+Thread.CurrentThread.ManagedThreadId.ToString());


//System.AppDomain.CreateDomain(
//System.Collections.ArrayList k=new System.Collections.ArrayList();
//k.Add(object
//System.Collections.Hashtable t=new System.Collections.Hashtable();
//t.Add(
//System.Collections.Generic.HashSet<

//		return;
//			//Print(OptParam(b:5));

//			//try { Print(1); }catch {}

//			//for(int j=0; j<5; j++)
//			//{
//			//	TestLocal();
//			//	//Print("returned");
//			//	//GC.Collect(0, GCCollectionMode.Forced, true);
//			//	Perf.First();
//			//	GC.Collect();
//			//	Perf.Next();
//			//	//Print("collected");
//			//	GC.WaitForFullGCComplete();
//			//	//Print("waited");
//			//}

//			//long g1, g2;
//			//g1=Stopwatch.GetTimestamp();
//			//Perf.First();
//			////Thread.Sleep(1000);
//			//g2=Stopwatch.GetTimestamp();

//			//Print(g2-g1);
//			//return;

//			string script = @"
//import System
////import System.Runtime.InteropServices
//import Moo
//import Catkeys.Winapi

////[DllImport(""user32.dll"")]
////def MessageBox(hWnd as int, text as string, caption as string, type as int) as int:
////	pass

//static def Main():
//	i =8
//	print ""Hello, World!""
//	api.MessageBox(0, ""text $(i)"", ""cap"", 0);

//	print Class1.Add(1, 2);

//	//print ""Press a key . . . mm""; Console.ReadKey(true)
//";
////static def stringManip(item as string):
////	return ""'${item}' ? What the hell are you talking about ? ""
////";

//			for (int i = 0; i < 1; i++)
//			{
//				Stopwatch sw = new Stopwatch();
//				long t1, t2 = 0, t3 = 0, t4 = 0, t5 = 0;

//				sw.Start();
//				BooCompiler compiler = new BooCompiler();
//				//compiler.Parameters.Input.Add(new StringInput("_script_", "print('Hello!')"));
//				compiler.Parameters.Input.Add(new StringInput("Script", script + "//" + i.ToString()));
//				compiler.Parameters.Pipeline = new CompileToMemory();
//				//compiler.Parameters.Pipeline = new CompileToFile();
//				//compiler.Parameters.Ducky = true;
//				//Print(compiler.Parameters.BooAssembly.FullName);
//				//Print(compiler.Parameters.Debug);
//				compiler.Parameters.Debug = false; //default true; 20% faster when Release
//				//compiler.Parameters.Environment.Provide.
//				//compiler.Parameters.GenerateInMemory=false; //default is true even if new CompileToFile()
//				//Print(compiler.Parameters.GenerateInMemory);
//				//Print(compiler.Parameters.OutputAssembly);
//				//compiler.Parameters.OutputAssembly=@"q:\test\boo.dll";

//				compiler.Parameters.AddAssembly(Assembly.LoadFile(@"Q:\test\Moo.dll")); //ok
//				//compiler.Parameters.LoadAssembly(@"Q:\test\Moo.dll", true); //no effect
//				//compiler.Parameters.LoadReferencesFromPackage(@"Q:\test\Moo.dll"); //error
//				//compiler.Parameters.References.Add(Assembly.LoadFile(@"Q:\test\Moo.dll")); //ok
//				compiler.Parameters.AddAssembly(Assembly.LoadFile(@"C:\Users\G\Documents\SharpDevelop Projects\Test\Winapi\bin\Release\Winapi.dll"));

//				CompilerContext context = compiler.Run();
//				t1 = sw.ElapsedTicks;
//				//Note that the following code might throw an error if the Boo script had bugs.
//				//Poke context.Errors to make sure.
//				if (context.GeneratedAssembly != null)
//				{
//					//SaveAssembly(context.GeneratedAssembly, @"q:\test\boo.exe");
//					//Print(context.GeneratedAssembly.FullName);
//					//Print(context.GeneratedAssembly.EntryPoint.ToString()); //void Main()
//					//Print(context.GeneratedAssembly.);

//					Type scriptModule = context.GeneratedAssembly.GetType("ScriptModule");
//					//Print(scriptModule == null);
//					MethodInfo met = scriptModule.GetMethod("Main");

//					//MethodInfo[] a = scriptModule.GetMethods();
//					//foreach(MethodInfo m in a)
//					//{
//					//Print(m.Name);
//					//}

//					met.Invoke(null, null);

//					//string output = (string)stringManip.Invoke(null, new object[] { "Tag" });
//					//Print(output);
//				}
//				else
//				{
//					foreach (CompilerError error in context.Errors)
//						Print(error);
//				}

//				double f = Stopwatch.Frequency / 1000000.0;
//				Print("speed: {0} {1} {2} {3} {4}", (long)(t1 / f), (long)((t2 - t1) / f), (long)((t3 - t2) / f), (long)((t4 - t3) / f), (long)((t5 - t4) / f));
//			}
//			Print("Press a key . . . ");
//			Console.ReadKey(true);
//}

//static void SaveAssembly(Assembly a, string file)
//{
//	using (FileStream stream = new FileStream(file, FileMode.Create))
//	{
//		BinaryFormatter formatter = new BinaryFormatter();

//		formatter.Serialize(stream, a); //error, assembly not marked as serializable
//	}
//}
