	//struct, 1 int field, fraction as int*10000
	//Slightly bigger and slower than 1 long field. Need noinline.
	/// <summary>
	/// Contains x or y coordinate that can be specified as normal (from left or top), reverse (from right or bottom), fractional (fraction of width or height) or null.
	/// Used for parameters of functions like Mouse.Move, Wnd.Move.
	/// Also has functions to convert to normal coodinates.
	/// </summary>
	//[DebuggerStepThrough]
	public struct Coord
	{
		/// <summary>
		/// Coord variable value type.
		/// </summary>
		public enum CoordType
		{
			/// <summary>
			/// No value. Assigned null or default(Coord).
			/// </summary>
			None,

			/// <summary>
			/// <see cref="Value"/> is pixel offset from left or top of a rectangle.
			/// </summary>
			Normal,

			/// <summary>
			/// <see cref="Value"/> is pixel offset from right or bottom of a rectangle -1.
			/// </summary>
			Reverse,

			/// <summary>
			/// <see cref="Value"/> is fraction of a rectangle multiplied by 10000.
			/// </summary>
			Fraction,
		}

		//Pack 30 bits of int and 2 bits of CoordType in single int field.
		//Using multiple fields is not necessary, then compiler generates bigger/slower native code.
		int _v;

		/// <summary>
		/// Value type.
		/// </summary>
		public CoordType Type { get => (CoordType)(_v & 3); }

		/// <summary>
		/// Value.
		/// When Type is Fraction, this is the floating-point value multiplied by 10000.
		/// </summary>
		public int Value { get => _v >> 2; }

		/// <summary>
		/// Returns true if type is None. This is when assigned null or default(Coord).
		/// </summary>
		public bool IsNone { get => Type == CoordType.None; }

		Coord(CoordType type, int v)
		{
			if(v > 500000000) v = 500000000;
			if(v < -500000000) v = -500000000;
			_v = (v << 2) | (int)type;
		}

		Coord(double v)
		{
			if(v > 50000) v = 50000;
			if(v < -50000) v = -50000;
			_v = (int)(v * 40000) | (int)CoordType.Fraction;
		}

		/// <summary>
		/// Creates Coord of Normal type.
		/// </summary>
		[MethodImpl(MethodImplOptions.NoInlining)] //no
		public static implicit operator Coord(int v) => new Coord(CoordType.Normal, v);

		//rejected. Would be used when assigning uint, long, ulong. Or need functions for these too.
		///// <summary>
		///// Creates Coord of Fraction type.
		///// </summary>
		//public static implicit operator Coord(float v) => new Coord(v);

		/// <summary>
		/// Infrastructure. Allows to assign null.
		/// </summary>
		/// <param name="v">null.</param>
		public static implicit operator Coord(CatkeysPrivate.TypesNull1 v) => new Coord();

		/// <summary>
		/// Creates Coord of Reverse type.
		/// Value 0 is at the right or bottom, and belongs to the rectangle. Positive values are towards left or top.
		/// </summary>
		public static Coord Reverse(int v)
		{
			return new Coord(CoordType.Reverse, v);
		}

		/// <summary>
		/// Creates Coord of Fraction type.
		/// Value 0.0 is the left or top of the rectangle. Value 1.0 is the right or bottom of the rectangle. Values &lt;0.0 and &gt;=1.0 are outside of the rectangle.
		/// </summary>
		public static Coord Fraction(double v)
		{
			return new Coord(v);
		}

		static bool _NeedRect(Coord x, Coord y)
		{
			return x.Type > CoordType.Normal || y.Type > CoordType.Normal;
		}

		static int _Normalize(Coord c, int min, int max)
		{
			var v = c.Value;
			switch(c.Type) {
			case CoordType.Normal: return min + v;
			case CoordType.Reverse: return max - 1 - v;
			case CoordType.Fraction: return min + (int)((long)(max - min) * v / 10000);
			default: return 0;
			}
		}

		/// <summary>
		/// Returns normal coordinates relative to the primary screen. Converts fractional/reverse coordinates etc.
		/// </summary>
		/// <param name="x">X coordinate. If null, returns 0 x.</param>
		/// <param name="y">Y coordinate. If null, returns 0 y.</param>
		/// <param name="workArea">x y are coordinates in work area.</param>
		/// <param name="widthHeight">x y are width and height.</param>
		public static POINT GetNormalizedInScreen(Coord x, Coord y, bool workArea = false, bool widthHeight = false)
		{
			var p = new POINT();
			if(x.Type != CoordType.None || y.Type != CoordType.None) {
				RECT r;
				if(workArea) {
					r = Screen_.WorkArea;
					if(widthHeight) r.Offset(-r.left, -r.top);
				} else if(_NeedRect(x, y)) {
					r = Screen_.Rect;
				} else r = new RECT();
				p.x = _Normalize(x, r.left, r.right);
				p.y = _Normalize(y, r.top, r.bottom);
			}
			return p;
		}

		/// <summary>
		/// Returns normal coordinates relative to the window w client area. Converts fractional/reverse coordinates etc.
		/// </summary>
		/// <param name="x">X coordinate. If null, returns 0 x.</param>
		/// <param name="y">Y coordinate. If null, returns 0 y.</param>
		/// <param name="w"></param>
		/// <param name="nonClient">x y are coordinates in full w rectangle, not in client area.</param>
		public static POINT GetNormalizedInWindowClientArea(Coord x, Coord y, Wnd w, bool nonClient = false)
		{
			var p = new POINT();
			if(x.Type != CoordType.None || y.Type != CoordType.None) {
				RECT r;
				if(nonClient) {
					w.GetRectInClientOf(w, out r);
				} else if(_NeedRect(x, y)) {
					r = w.ClientRect; //TODO: throw if fails
				} else r = new RECT();
				p.x = _Normalize(x, r.left, r.right);
				p.y = _Normalize(y, r.top, r.bottom);
			}
			return p;
		}
	}





#if false
	/// <summary>
	/// Contains x or y coordinate that can be specified as normal (from left or top), reverse (from right or bottom) or fractional (fraction of width or height).
	/// Used for parameters of functions like Mouse.Move, Wnd.Move.
	/// Also has functions to convert to normal coodinates.
	/// </summary>
	//[DebuggerStepThrough]
	public class Coord
	{
		/// <summary>
		/// Coord variable value type.
		/// </summary>
		public enum CoordType
		{
			/// <summary>
			/// <see cref="IntValue"/> is pixel offset from left or top of a rectangle.
			/// </summary>
			Normal,

			/// <summary>
			/// <see cref="IntValue"/> is pixel offset from right or bottom of a rectangle.
			/// </summary>
			Reverse,

			/// <summary>
			/// <see cref="FloatValue"/> is fraction of a rectangle.
			/// </summary>
			Fraction,
		}

		/// <summary>
		/// Value type.
		/// </summary>
		public CoordType Type { get; set; }

		/// <summary>
		/// int value. Used when Type is Normal or Reverse.
		/// </summary>
		public int IntValue { get; set; }

		/// <summary>
		/// float value. Used when Type is Fraction.
		/// </summary>
		public float FloatValue { get; set; }

		///
		public Coord() { }

		/// <summary>
		/// Creates Coord of Normal type.
		/// </summary>
		/// <seealso cref="Reverse"/>
		[MethodImpl(MethodImplOptions.NoInlining)]
		public static implicit operator Coord(int i) => new Coord() { IntValue = i };

		/// <summary>
		/// Creates Coord of Fraction type.
		/// </summary>
		[MethodImpl(MethodImplOptions.NoInlining)]
		public static implicit operator Coord(float f) => new Coord() { Type = CoordType.Fraction, FloatValue = f };

		/// <summary>
		/// Creates Coord of Reverse type.
		/// Value 0 is at the right or bottom, and belongs to the rectangle. Positive values are towards left or top.
		/// </summary>
		[MethodImpl(MethodImplOptions.NoInlining)]
		public static Coord Reverse(int i)
		{
			return new Coord() { Type = CoordType.Reverse, IntValue = i };
		}

		/// <summary>
		/// Creates Coord of Fraction type.
		/// The same as the implicit assignment Coord=float. Can be used to make code easier to read.
		/// Values 0.0f to less than 1.0f belong to the rectangle. Negative values are to the left or top from the rectangle. Values 1.0f and larger are to the right or bottom from the rectangle.
		/// </summary>
		public static Coord Fraction(double f)
		{
			return (float)f;
		}

		static bool _NeedRect(Coord x, Coord y)
		{
			if(x != null && x.Type != CoordType.Normal) return true;
			if(y != null && y.Type != CoordType.Normal) return true;
			return false;
		}

		static int _Normalize(Coord c, int min, int max)
		{
			if(c == null) return 0;
			switch(c.Type) {
			case CoordType.Fraction: return min + (int)((max - min) * c.FloatValue);
			case CoordType.Reverse: return max - 1 - c.IntValue;
			default: return min + c.IntValue;
			}
		}

		/// <summary>
		/// Returns normal coordinates relative to the primary screen. Converts fractional/reverse coordinates etc.
		/// </summary>
		/// <param name="x">X coordinate. If null, returns 0 x.</param>
		/// <param name="y">Y coordinate. If null, returns 0 y.</param>
		/// <param name="workArea">x y are coordinates in work area.</param>
		/// <param name="widthHeight">x y are width and height.</param>
		public static POINT GetNormalizedInScreen(Coord x, Coord y, bool workArea = false, bool widthHeight = false)
		{
			var p = new POINT();
			if(x != null || y != null) {
				RECT r;
				if(workArea) {
					r = Screen_.WorkArea;
					if(widthHeight) r.Offset(-r.left, -r.top);
				} else if(_NeedRect(x, y)) {
					r = Screen_.Rect;
				} else r = new RECT();
				p.x = _Normalize(x, r.left, r.right);
				p.y = _Normalize(y, r.top, r.bottom);
			}
			return p;
		}

		/// <summary>
		/// Returns normal coordinates relative to the window w client area. Converts fractional/reverse coordinates etc.
		/// </summary>
		/// <param name="x">X coordinate. If null, returns 0 x.</param>
		/// <param name="y">Y coordinate. If null, returns 0 y.</param>
		/// <param name="w"></param>
		/// <param name="nonClient">x y are coordinates in full w rectangle, not in client area.</param>
		public static POINT GetNormalizedInWindowClientArea(Coord x, Coord y, Wnd w, bool nonClient = false)
		{
			var p = new POINT();
			if(x != null || y != null) {
				RECT r;
				if(nonClient) {
					w.GetRectInClientOf(w, out r);
				} else if(_NeedRect(x, y)) {
					r = w.ClientRect; //TODO: throw if fails
				} else r = new RECT();
				p.x = _Normalize(x, r.left, r.right);
				p.y = _Normalize(y, r.top, r.bottom);
			}
			return p;
		}
	}

#elif false
	//struct, 2 fields, fraction as int*10000
	/// <summary>
	/// Contains x or y coordinate that can be specified as normal (from left or top), reverse (from right or bottom) or fractional (fraction of width or height).
	/// Used for parameters of functions like Mouse.Move, Wnd.Move.
	/// Also has functions to convert to normal coodinates.
	/// </summary>
	//[DebuggerStepThrough]
	public struct Coord
	{
		/// <summary>
		/// Coord variable value type.
		/// </summary>
		public enum CoordType
		{
			/// <summary>
			/// No value. Assigned null or default(Coord).
			/// </summary>
			None,

			/// <summary>
			/// <see cref="Value"/> is pixel offset from left or top of a rectangle.
			/// </summary>
			Normal,

			/// <summary>
			/// <see cref="Value"/> is pixel offset from right or bottom of a rectangle.
			/// </summary>
			Reverse,

			/// <summary>
			/// <see cref="Value"/> is fraction of a rectangle multiplied by 10000.
			/// </summary>
			Fraction,
		}

		/// <summary>
		/// Value type.
		/// </summary>
		public CoordType Type { get; }

		/// <summary>
		/// Value.
		/// When Type is Fraction, this is the passed floating-point value multiplied by 10000.
		/// </summary>
		public int Value { get; }

		/// <summary>
		/// Returns true if type is None. This is when assigned null or default(Coord).
		/// </summary>
		public bool IsNone { get => Type == CoordType.None; }

		Coord(CoordType type, int value) { Type = type; Value = value; }

		/// <summary>
		/// Creates Coord of Normal type.
		/// </summary>
		/// <seealso cref="Reverse"/>
		/// <seealso cref="Fraction"/>
		//[MethodImpl(MethodImplOptions.NoInlining)] //no, bigger/slower
		public static implicit operator Coord(int v) => new Coord(CoordType.Normal, v);

		//rejected. Would be used when assigning uint, long, ulong. Or need functions for these too.
		///// <summary>
		///// Creates Coord of Fraction type.
		///// </summary>
		//public static implicit operator Coord(float v) => new Coord(CoordType.Fraction, (int)(v*10000));

		/// <summary>
		/// Infrastructure. Allows to assign null.
		/// </summary>
		/// <param name="v">null.</param>
		public static implicit operator Coord(CatkeysPrivate.TypesNull1 v) => new Coord();

		/// <summary>
		/// Creates Coord of Reverse type.
		/// Value 0 is at the right or bottom, and belongs to the rectangle. Positive values are towards left or top.
		/// </summary>
		public static Coord Reverse(int v)
		{
			return new Coord(CoordType.Reverse, v);
		}

		/// <summary>
		/// Creates Coord of Fraction type.
		/// Value 0.0 is the left or top of the rectangle. Value 1.0 is the right or bottom of the rectangle. Values &lt;0.0 and &gt;=1.0 are outside of the rectangle.
		/// </summary>
		public static unsafe Coord Fraction(double v)
		{
			return new Coord(CoordType.Fraction, (int)(v*10000));
		}

		static bool _NeedRect(Coord x, Coord y)
		{
			return (x.Type > CoordType.Normal) || (y.Type > CoordType.Normal);
		}

		static int _Normalize(Coord c, int min, int max)
		{
			switch(c.Type) {
			case CoordType.Normal: return min + c.Value;
			case CoordType.Reverse: return max - 1 - c.Value;
			case CoordType.Fraction: return min + (int)((long)(max - min) * c.Value / 10000);
			default: return 0;
			}
		}

		/// <summary>
		/// Returns normal coordinates relative to the primary screen. Converts fractional/reverse coordinates etc.
		/// </summary>
		/// <param name="x">X coordinate. If null, returns 0 x.</param>
		/// <param name="y">Y coordinate. If null, returns 0 y.</param>
		/// <param name="workArea">x y are coordinates in work area.</param>
		/// <param name="widthHeight">x y are width and height.</param>
		public static POINT GetNormalizedInScreen(Coord x, Coord y, bool workArea = false, bool widthHeight = false)
		{
			var p = new POINT();
			if(x.Type != CoordType.None || y.Type != CoordType.None) {
				RECT r;
				if(workArea) {
					r = Screen_.WorkArea;
					if(widthHeight) r.Offset(-r.left, -r.top);
				} else if(_NeedRect(x, y)) {
					r = Screen_.Rect;
				} else r = new RECT();
				p.x = _Normalize(x, r.left, r.right);
				p.y = _Normalize(y, r.top, r.bottom);
			}
			return p;
		}

		/// <summary>
		/// Returns normal coordinates relative to the window w client area. Converts fractional/reverse coordinates etc.
		/// </summary>
		/// <param name="x">X coordinate. If null, returns 0 x.</param>
		/// <param name="y">Y coordinate. If null, returns 0 y.</param>
		/// <param name="w"></param>
		/// <param name="nonClient">x y are coordinates in full w rectangle, not in client area.</param>
		public static POINT GetNormalizedInWindowClientArea(Coord x, Coord y, Wnd w, bool nonClient = false)
		{
			var p = new POINT();
			if(x.Type != CoordType.None || y.Type != CoordType.None) {
				RECT r;
				if(nonClient) {
					w.GetRectInClientOf(w, out r);
				} else if(_NeedRect(x, y)) {
					r = w.ClientRect; //TODO: throw if fails
				} else r = new RECT();
				p.x = _Normalize(x, r.left, r.right);
				p.y = _Normalize(y, r.top, r.bottom);
			}
			return p;
		}
	}
#elif false
	//struct, 2 fields, fraction as float.
	//Good in 32-bit, but huge code in 64-bit.
	/// <summary>
	/// Contains x or y coordinate that can be specified as normal (from left or top), reverse (from right or bottom) or fractional (fraction of width or height).
	/// Used for parameters of functions like Mouse.Move, Wnd.Move.
	/// Also has functions to convert to normal coodinates.
	/// </summary>
	//[DebuggerStepThrough]
	[StructLayout(LayoutKind.Sequential, Pack =8, Size =8)]
	public struct Coord
	{
		/// <summary>
		/// Coord variable value type.
		/// </summary>
		public enum CoordType
		{
			/// <summary>
			/// No value. Assigned null or default(Coord).
			/// </summary>
			None,

			/// <summary>
			/// <see cref="Value"/> is pixel offset from left or top of a rectangle.
			/// </summary>
			Normal,

			/// <summary>
			/// <see cref="Value"/> is pixel offset from right or bottom of a rectangle.
			/// </summary>
			Reverse,

			/// <summary>
			/// <see cref="Value"/> is fraction of a rectangle.
			/// </summary>
			Fraction,
		}

		/// <summary>
		/// Value type.
		/// </summary>
		public CoordType Type { get; }

		/// <summary>
		/// Non-fraction value.
		/// </summary>
		public int Value { get; }

		/// <summary>
		/// Fraction value.
		/// </summary>
		public unsafe float FractionValue { get { int i = Value; return *(float*)&i; } }
		//note: don't use struct or union with both int and float fields. It creates slow and huge calling code.

		/// <summary>
		/// Returns true if type is None. This is when assigned null or default(Coord).
		/// </summary>
		public bool IsNone { get => Type == CoordType.None; }

		Coord(CoordType type, int value) { Type = type; Value = value; }

		/// <summary>
		/// Creates Coord of Normal type.
		/// </summary>
		/// <seealso cref="Reverse"/>
		/// <seealso cref="Fraction"/>
		//[MethodImpl(MethodImplOptions.NoInlining)] //no, bigger/slower
		public static implicit operator Coord(int v) => new Coord(CoordType.Normal, v);

		//rejected. Would be used when assigning uint, long, ulong. Or need functions for these too.
		///// <summary>
		///// Creates Coord of Fraction type.
		///// </summary>
		//public static implicit operator Coord(float v) => new Coord(CoordType.Fraction, (int)(v*10000));

		/// <summary>
		/// Infrastructure. Allows to assign null.
		/// </summary>
		/// <param name="v">null.</param>
		public static implicit operator Coord(CatkeysPrivate.TypesNull1 v) => new Coord();

		/// <summary>
		/// Creates Coord of Reverse type.
		/// Value 0 is at the right or bottom, and belongs to the rectangle. Positive values are towards left or top.
		/// </summary>
		public static Coord Reverse(int v)
		{
			return new Coord(CoordType.Reverse, v);
		}

		/// <summary>
		/// Creates Coord of Fraction type.
		/// Value 0.0 is the left or top of the rectangle. Value 1.0 is the right or bottom of the rectangle. Values &lt;0.0 and &gt;=1.0 are outside of the rectangle.
		/// </summary>
		public static unsafe Coord Fraction(double v)
		{
			float f = (float)v;
			return new Coord(CoordType.Fraction, *(int*)&f);
		}

		static bool _NeedRect(Coord x, Coord y)
		{
			return (x.Type > CoordType.Normal) || (y.Type > CoordType.Normal);
		}

		static int _Normalize(Coord c, int min, int max)
		{
			switch(c.Type) {
			case CoordType.Normal: return min + c.Value;
			case CoordType.Reverse: return max - 1 - c.Value;
			case CoordType.Fraction: return min + (int)((max - min) * c.FractionValue);
			default: return 0;
			}
		}

		/// <summary>
		/// Returns normal coordinates relative to the primary screen. Converts fractional/reverse coordinates etc.
		/// </summary>
		/// <param name="x">X coordinate. If null, returns 0 x.</param>
		/// <param name="y">Y coordinate. If null, returns 0 y.</param>
		/// <param name="workArea">x y are coordinates in work area.</param>
		/// <param name="widthHeight">x y are width and height.</param>
		public static POINT GetNormalizedInScreen(Coord x, Coord y, bool workArea = false, bool widthHeight = false)
		{
			var p = new POINT();
			if(x.Type != CoordType.None || y.Type != CoordType.None) {
				RECT r;
				if(workArea) {
					r = Screen_.WorkArea;
					if(widthHeight) r.Offset(-r.left, -r.top);
				} else if(_NeedRect(x, y)) {
					r = Screen_.Rect;
				} else r = new RECT();
				p.x = _Normalize(x, r.left, r.right);
				p.y = _Normalize(y, r.top, r.bottom);
			}
			return p;
		}

		/// <summary>
		/// Returns normal coordinates relative to the window w client area. Converts fractional/reverse coordinates etc.
		/// </summary>
		/// <param name="x">X coordinate. If null, returns 0 x.</param>
		/// <param name="y">Y coordinate. If null, returns 0 y.</param>
		/// <param name="w"></param>
		/// <param name="nonClient">x y are coordinates in full w rectangle, not in client area.</param>
		public static POINT GetNormalizedInWindowClientArea(Coord x, Coord y, Wnd w, bool nonClient = false)
		{
			var p = new POINT();
			if(x.Type != CoordType.None || y.Type != CoordType.None) {
				RECT r;
				if(nonClient) {
					w.GetRectInClientOf(w, out r);
				} else if(_NeedRect(x, y)) {
					r = w.ClientRect; //TODO: throw if fails
				} else r = new RECT();
				p.x = _Normalize(x, r.left, r.right);
				p.y = _Normalize(y, r.top, r.bottom);
			}
			return p;
		}
	}










	static void TestInterDomainLock()
	{
		new Thread(() => { var d = AppDomain.CreateDomain("one"); d.DoCallBack(_Domain); }).Start();
		new Thread(() => { var d = AppDomain.CreateDomain("two"); d.DoCallBack(_Domain); }).Start();
	}

	static Type _lockObj = typeof(string); //locks interdomain
	static void _Domain()
	{
		//lock("sssssssssssssss") { //locks interdomain
		lock(_lockObj) {
			MessageBox.Show("domain");
		}
	}

#region old_test_functions

	//This class used to test serialization.
	//Now probably does not work, must be not a nested class, but I want to collapse the code.
	public class Ooo
	{
		[XmlAttribute]
		public uint style, styleMask, exStyle, exStyleMask;
		//[XmlAttribute(DataType ="string")] //cannot be applied to object
		public object x, y; //int or double, not used if null
							//[XmlAttribute] //cannot be applied to nullable
							//public int? x, y;
		[XmlAttribute]
		public string control, propName, wfName;
		//[XmlAttribute] //cannot be applied to LPARAM
		//public LPARAM propValue_;
		[XmlAttribute]
		public long propValue;

		public Ooo() { }

		//speed: TextFieldParser is 8 times slower than XML serialization
		public Ooo(string csv)
		{
			using(var tr = new StringReader(csv)) { //the usings make 30% faster, but still very slow, much slower than XML serialization
				using(var p = new TextFieldParser(tr)) {
					p.SetDelimiters(new string[] { "=" });

					while(!p.EndOfData) {
						string[] a = p.ReadFields();
						if(a.Length != 2) break;
						//Print(a, "|");
						string s = a[1];
						switch(a[0]) {
						case "style": style = (uint)s.ToInt32_(); break;
						case "control": control = s; break;
						case "x": x = s.ToInt32_(); break;
						case "propValue": propValue = s.ToInt32_(); break;
						}
					}
				}
			}
		}
	}

	static void TestCsvSerialization()
	{
		string s;
		s = "<style>0x10</style><control>CCCCCCCCCCCCCC</control><x>5</x><propValue>100</propValue>";
		s = "style=0x10\ncontrol=CCCCCCCCCCCCCC\nx=5\npropValue=100";
		s = "style=0x10 \n control=CCCCCCCCCCCCCC \n x=5 \n propValue=100";
		s = "style=0x10[]control=CCCCCCCCCCCCCC[]x=5[]propValue=100";
		s = "style=0x10|control=CCCCCCCCCCCCCC|x=5|propValue=100";
		//the winners
		s = "<style>0x10</style>  <control>CCCCCCCCCCCCCC</control>  <x>5</x>  <propValue>100</propValue>";
		s = "style='0x10' control='CCCCCCCCCCCCCC' x='5' propValue='100'";
		s = "style=0x10 |control=CCCCCCCCCCCCCC |x=5 |propValue=100";


		s = "style=0x10 \n control=CCCCCCCCCCCCCC \n x=5 \n propValue=100";
		Ooo v = null;

		var a1 = new Action(() => { v = new Ooo(s); });

		for(int i = 0; i < 5; i++) {
			Perf.First();
			Perf.Execute(1000, a1);
			Perf.Write();
		}

		PrintList(v.style, v.x, v.control, v.propValue);
	}

	static void TestSerialization()
	{
		//var m = new Wnd._FindProperties();
		//m.style = "0x12 0x12";
		//var x3 = new XmlSerializer(typeof(Wnd._FindProperties));
		//var t3 = new StringWriter();
		//x3.Serialize(t3, m);
		//Print(t3.ToString());
		//return;

		//var v = new Ooo() { style = 0x123, x = 5, control = "Ccccc", propValue = 10 };
		var v = new Ooo() { style = 0x12, control = "Ccccc", x = 5 };

		var x = new XmlSerializer(typeof(Ooo));
		var t = new StringWriter();
		x.Serialize(t, v);
		string s = t.ToString();
		Print(s);

		//s = "<Ooo><control>hhhhh</control></Ooo>";
		s = "<Ooo control='CCCCCCCCCCCCC' style='12'/>";

		//Deserialization ok if no <?xml...>, ok if no xmlns, ok if some members missing, ok if there are unknown members.
		//Fails if type name does not match (my func can add the root tag automatically; also there are attributes to set XML element name).

		var x2 = new XmlSerializer(typeof(Ooo));
		Ooo v2 = null;
		var a1 = new Action(() => v2 = (Ooo)x2.Deserialize(new StringReader(s)));
		a1();

		for(int i = 0; i < 5; i++) {
			Perf.First();
			Perf.Execute(1000, a1);
			Perf.Write();
		}
		//PrintList(v2.style, v2.x, v2.control, v2.propValue);
		PrintList(v2.style, v2.x, v2.control);

	}

	static void TestSerializeLPARAM()
	{
		//LPARAM p = 8;

		var v = new Serializ();
		var x = new XmlSerializer(typeof(Serializ));
		//var v = new LPARAM2();
		//var x = new XmlSerializer(typeof(LPARAM2));

		var t = new StringWriter();
		x.Serialize(t, v);
		string s = t.ToString();
		Print(s);

	}

	public class Serializ
	{
		public string s = "ssss";
		public int i = 7;
		//public IntPtr ip = (IntPtr)9;
		public LPARAM lp = 10;
	}

	static void TestCsv()
	{
		string s = @"a1,b1, c1
a2, ""b2 """" aaa
bbb"", b3
";
		var tr = new StringReader(s);
		var p = new TextFieldParser(tr);
		//Print(p.HasFieldsEnclosedInQuotes);
		//Print(p.TrimWhiteSpace);
		p.SetDelimiters(new string[] { "," });

		while(!p.EndOfData) {
			string[] a = p.ReadFields();
			Print(a.Length);
			Print(a, "|");
		}
	}

	static void TestTaskDialog()
	{
		//TaskDialog.Show(Wnd0, "text", icon:TDIcon.Warning);
		//TaskDialog.Show("text", "", "!");
		//TaskDialog.Show("text", "", new System.Drawing.Icon(@"q:\app\find.ico"));

		//TaskDialog.Show(Wnd0, "text", flags: TDFlags.RawXY);
		//TaskDialog.ShowEx(Wnd0, "text", flags: TDFlags.RawXY, x:-100);
		//TaskDialog.Show("text", null, "r");
		//TaskDialog.ShowEx("text", null, "r", x:-100);

		//Task.Run(() =>
		//{
		//	Wait(5);
		//	//Script.Option.RtlLayout = true;
		//	//Script.Option.ScreenIfNoOwner = 2;
		//	TestDialogScreen("thread");
		//      });

		////Script.Option.ScreenIfNoOwner = 1;
		////TestDialogScreen("main");

		////var f = new Form();
		////f.ShowDialog();

		//Wait(10);


		//TaskDialog.ShowNoWait(null, "Text."); //simplest example
		//var td=TaskDialog.ShowNoWait(ed => { Print(ed); }, "Text.", style: "OCi");
		//var td=TaskDialog.ShowNoWaitEx(ed => { Print(ed); }, "Text.", "text", "OCi", Wnd0, "1 Cust", "1 ra", "Check", "exp", "foo", "Tii", 100, -100, 30);
		//Wait(3); //do something while the dialog is open in other thread
		//td.ThreadWaitClosed(); //wait until dialog closed (optional, but if the main thread will exit before closing the dialog, dialog's thread then will be aborted)


		//TaskDialog.Show("aaa");

		//bool marquee = false;
		//var pd = TaskDialog.ShowProgress(marquee, "Working", customButtons: "1 Stop", y: -1);
		////var pd = TaskDialog.ShowProgressEx(marquee, "Working", "ttt", "a", Wnd0, "1 Stop", "1 r1|2 r2", "Check", "exp", "foo", "Tii", 100, -1, 30);
		//for(int i = 1; i <= 100; i++) {
		//	if(!pd.IsOpen) { Print(pd.Result); break; } //if the user closed the dialog
		//	if(!marquee) pd.Send.Progress(i);
		//	Thread.Sleep(50); //do something in the loop
		//}
		//pd.Send.Close();

		//Print(TaskDialog.ShowList("1 one|2 two|3 three\r\n").ToString());
		//Print(TaskDialog.ShowList("1 One|2 Two|3 Three|Cancel", "Main instruction.", "More info.", "Cxb").ToString());
		//Print(TaskDialog.ShowList("1 One|2 Two|3 Three|Cancel", "Main instruction.", "More info.", TDIcon.App).ToString());
		//Print(TaskDialog.ShowListEx("1 One|2 Two|3 Three|Cancel", "Main instruction.", "More info.", TDIcon.App, Wnd0, "", "exp\r\n<a href=\"mmm\">link</a>", "foo: <a href=\"mmm\">link</a>", "Moo", -1, 100, 30, (ed)=>Print(ed.linkHref)).ToString());

		//TaskDialog.ShowList("1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30");
		//TaskDialog.ShowList("WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBBBBBBBBBBB");
		//Print(TaskDialog.ShowListEx("1 one|2 two|3 three\r\n", footerText: "!|foo").ToString());
		//return;

		//var f = new Form();
		//f.Show();

		//Script.Option.RtlLayout=true;
		//string s; //int i;
		//if(!TaskDialog.ShowInput(out s)) return;
		//if(!TaskDialog.ShowInput(out s, "Text.", ownerWindow: Wnd.Find("Untitled - Notepad"))) return;
		//if(!TaskDialog.ShowInput(out s, "Text gggggggggggg.")) return;
		//if(!TaskDialog.ShowInput(out s, "Text.", "Default")) return;
		//if(!TaskDialog.ShowInputEx(out s, "Text.", "0", editType: TDEdit.Number, expandedText:"exp")) return;
		//if(!TaskDialog.ShowInput(out i, "Text.", 5)) return; Print(i); return;
		//if(!TaskDialog.ShowInputEx(out s, "Text.", "pas", editType: TDEdit.Password)) return;
		//if(!TaskDialog.ShowInput(out s, "Text.", "one\r\ntwo\r\nthree", editType: TDEdit.Multiline)) return;
		//if(!TaskDialog.ShowInput(out s, "Text.", "def\none\r\ntwo\nthree", editType: TDEdit.Combo)) return;
		//if(!TaskDialog.ShowInputEx(out s, "Text.", "def\none\r\ntwo\nthree", Wnd0, TDEdit.Combo, "i", "exp", "foo", "Tii", 200, -100, 30, "1 Browse...", ed => { if(ed.wParam == 1) { string _s; if(TaskDialog.ShowInput(out _s, ownerWindow:ed.hwnd)) ed.dialog.EditControl.SetControlText(_s); ed.returnValue = 1; } })) return;
		//if(!TaskDialog.ShowInputEx(out s, "Text.", "def\none\r\ntwo\nthree", Wnd0, TDEdit.Combo, "i", "exp", "foo", "Tii", 200, -100, 30, "", ed => { if(ed.wParam == TDResult.OK) { string _s=ed.dialog.EditControl.Name; if(Empty(_s)) { TaskDialog.Show("Text cannot be empty.", ownerWindow: ed.hwnd); ed.returnValue = 1; } } })) return;
		//if(!TaskDialog.ShowInputEx(out s, "Text.", "def\none\r\ntwo\nthree", Wnd0, TDEdit.Combo, "i", "exp", "foo", "Tii", 200, -100, 30, "1 Browse...", ed=>
		//{
		//	if(ed.wParam != 1) return;
		//	string _s; if(TaskDialog.ShowInput(out _s, ownerWindow:ed.hwnd)) ed.dialog.EditControl.SetControlText(_s);
		//	ed.returnValue = 1;
		//})) return;
		//if(!TaskDialog.ShowInputEx(out s, "Text.")) return;
		//if(!TaskDialog.ShowInputEx(out s, "Text.", footerText:"a|Foooooo.")) return;
		//if(!TaskDialog.ShowInputEx(out s, "Text.", footerText:"a|Foooooo.", timeoutS:30)) return;
		//bool ch;
		//if(!TaskDialog.ShowInputEx(out s, out ch, "Check", "Text.", "one\r\ntwo\r\nthree", editType:TDEdit.Multiline, expandedText:"More\ntext.", timeoutS: 60)) return;
		//if(!TaskDialog.ShowInput(out s, out ch, "Check", "Text.", "txt", editType:TDEdit.Multiline)) return;
		//Print(s);
		//Print(ch);

		//if(false) {
		//	d.SetCustomButtons("1 Browse...", true, true);
		//	d.ButtonClicked += e => { if(e.wParam == 1) { Print("Browse"); e.returnValue = 1; } };
		//}

		//MessageBox.Show("ddddddddddddddddddd");
		//TaskDialog.MessageDialog("fffffffffff");

		//return;


		//TaskDialogAsync("async"); //warning "consider applying await"
		//TDResult rr=await TaskDialogAsync("async"); //error, the caller must be marked with async. But then fails to run altogether.

		//Task<TDResult> t=TaskDialogAsync("async");
		//TaskDialog.Show("continue");
		//t.Wait();
		//Print(t.Result);

		//var pd = ShowNoWait("async", y=>Print(y));
		//var pd = ShowNoWait("async");
		//Wait(2);
		//if(pd.IsOpen) pd.Send.Close();
		//Print(pd.Result);

		//var td = new TaskDialog("dddd");
		//Task.Run(() => td.ShowDialog());
		////Perf.First();
		////td.ThreadWaitOpen();
		////Perf.NW();
		//td.ThreadWaitClosed();
		////Task.Run(() => td.ShowDialog());
		////td.ThreadWaitOpen();
		////td.ThreadWaitClosed();
		//Print(td.Result);

		//TaskDialog.Show("continue", y:300);


		//Print("finished");

		//Task t = Task.Run(() =>
		//{
		//	//Thread.Sleep(100);

		//	//Print("run");
		//	Print(TaskDialog.Show("async", style: "OC", x: 1));
		//	//MessageBox.Show("another thread");
		//	//TaskDialog.MessageDialog("async",style:"OC");
		//	//TD("async", true);
		//}
		//);

		////Thread.Sleep(7);

		//Print(TaskDialog.Show("continue", style: "OC"));
		////TD("continue", false);
		////TaskDialog.MessageDialog("continue",style:"OC");
		////Thread.Sleep(1000);
		//t.Wait();
		//Print("after all");

		//for(int i=0; i<5; i++) TD("continue", false);

		//Print(GetThemeAppProperties());
		//MessageBox.Show("sss");
		//Print(TaskDialog.MessageDialog("test", MDButtons.OKCancel, MDIcon.App, MDFlag.DefaultButton2));
		//Print(TaskDialog.MessageDialog("One\ntwooooooooooooo."));
		//Print(TaskDialog.MessageDialog("One\ntwooooooooooooo.", "YNC!t2"));
		//TaskDialog.MessageDialog("One\ntwooooooooooooo.");
		//Print(Wnd.ActiveWindow);

		//Print(TaskDialog.Show(Wnd0, "Head1\nHead2.", "Text1\nText2.", TDButtons.OKCancel, TDIcon.App, TDFlags.CommandLinks, TDResult.Cancel, "1 one|2 two", new string[] { "101 r1|||", "102 r2" }, "Chick|check", "expanded", "", "TTT", 0, 0, 20).ToString());
		//Print(TaskDialog.Show("Head1\nHead2.", "Text1\nText2.", "OCd2!t", Wnd0, "1 one|2 two", null, null, "expanded", "foo", 60, "TTT").ToString());
		//Print(TaskDialog.Show(Wnd0, "Head1\nHead2.", "Text1\nText2.", TDButtons.OKCancel|TDButtons.YesNo|TDButtons.Retry|TDButtons.Close, TDIcon.Info).ToString());
		//Print(TaskDialog.Show(Wnd0, "Head1\nHead2.", "Text1\nText2.", TDButtons.OKCancel|TDButtons.YesNo|TDButtons.Retry|TDButtons.Close, (TDIcon)0xfff0).ToString());
		//Print(TaskDialog.Show("head", "content", "OCYNLRio", ownerWindow: Wnd.Find("Untitled - Notepad")).ToString());
		//Print(TaskDialog.Show("head", "content", "OCYNLRi", x:100, y:-11, timeoutS:15).ToString());
		//Print(TaskDialog.Show("", "<a href=\"example\">link</a>.", onLinkClick: ed => { Print(ed.linkHref); }).ToString());
		//Print(TaskDialog.Show("head", "content", "i", customButtons: "-1 Mo OK|-2 My Cancel").ToString());

		//Print(TaskDialog.ShowList("1 one| 2 two| 3three|4 four\nnnn|5 five|6 six|7 seven|8 eight|9 nine|10Ten|0Cancel|1 one|2 two|3three|4 four\nnnn|5 five|6 six|7 seven|8 eight|9 nine|10Ten", "Main", "More."));
		//Print(TaskDialog.ShowList(new string[] { "1 one", "2 two", "Cancel" }, "Main", "More").ToString());
		//Print(TaskDialog.ShowList(new List<string> { "1 one", "2 two", "Cancel" }, "Main", "More").ToString());
		////		Print(TaskDialog.ShowList(@"
		////|1 one
		////|2 two
		////comments
		////|3 three
		////" , "Main", "More\r\nmore"));

		////		Print(TaskDialog.ShowList("1 one|2 two\nN|3 three\r\nRN|4 four"));
		//return;

		//var d = new TaskDialog("Head", "Text <A HREF=\"xxx\">link</A>.", TDButtons.OKCancel|TDButtons.Retry, TDIcon.Shield, "Title");
		//var d = new TaskDialog("Head", "Text <A HREF=\"xxx\">link</A>.", TDButtons.OKCancel|TDButtons.Retry, (TDIcon)0xfff0, "Title");
		//var d = new TaskDialog("Head", "Text <A HREF=\"xxx\">link</A>.", (TDButtons)111);
		//var d = new TaskDialog("Head Text.", null, 0, TDIcon.Shield);
		//var d = new TaskDialog("", "More text.", 0, TDIcon.Shield);
		//var d = new TaskDialog();
		var d = new TaskDialog();

		d.SetTitleBarText("MOO");

		d.SetText("Main text.", "More text.\nSupports <A HREF=\"link data\">links</A> if you subscribe to HyperlinkClick event.");

		//d.SetButtons(TDButtons.OKCancel | TDButtons.Retry);

		//d.SetIcon(TDIcon.Warning);
		//d.SetIcon(new System.Drawing.Icon(@"Q:\app\copy.ico", 32, 32)); //OK
		//d.SetIcon(Catkeys.Tasks.Properties.Resources.output); //OK
		//d.SetIcon(new System.Drawing.Icon(Catkeys.Tasks.Properties.Resources.output, 16, 16)); //OK
		//d.SetIcon(new System.Drawing.Icon("Resources/output.ico")); //OK
		//d.SetIcon(new System.Drawing.Icon("Resources/output.ico", 16, 16)); //OK
		//d.SetIcon(new System.Drawing.Icon(typeof(Test), "output.ico")); //exception
		//Print(Catkeys.Tasks.Properties.Resources.output.Width);
		//d.SetIcon(new System.Drawing.Icon(TaskDialog.Resources.AppIconHandle32));
		//d.SetIcon(TDIcon.App);

		Wnd w = Wnd.Find("Untitled - Notepad");
		//d.SetOwnerWindow(w);

		//Script.Option.ScreenIfNoOwner=2;

		d.SetXY(100, 100);

		d.SetCheckbox("Checkbox", false);

		TaskDialog.Options.TopmostIfNoOwnerWindow = true;
		//d.FlagTopmost=true;
		d.FlagXCancel = true;
		d.FlagCanBeMinimized = true;
		//d.FlagRtlLayout=true;
		//d.FlagPositionRelativeToWindow=true;
		//d.FlagNoTaskbarButton = true;
		//d.FlagNeverActivate = true;

		//Script.Option.ScreenIfNoOwner=2;
		//d.Screen=2;

		d.SetExpandedText("Expanded info\nand more info.", true);

		d.SetExpandControl(true, "Show more info", "Hide more info");

		//d.SetFooterText("Footer text.", TDIcon.Warning);
		//d.SetFooterText("Footer.");
		//d.SetFooterText("Footer.", Catkeys.Tasks.Properties.Resources.output); //icon 32x32, srinked
		//d.SetFooterText("Footer.", new System.Drawing.Icon(Catkeys.Tasks.Properties.Resources.output, 16, 16)); //icon OK
		//d.SetFooterText("Footer text.", new System.Drawing.Icon(@"q:\app\wait.ico", 16, 16));

		//d.Width=700;

		//d.SetButtons(new string[] { "101 one", "102 two" });
		d.SetButtons("1 one|2 two\nzzz", true);
		//d.SetCustomButtons(new string[] { "5", "102 two" }, true);
		//d.SetCustomButtons("101|102 two\nzzz", true);
		d.DefaultButton = 2;
		//d.SetDefaultButton(2);
		//d.SetDefaultButton(TDResult.Cancel);
		//d.SetDefaultButton(TDResult.Retry);

		//d.SetRadioButtons(new string[] { "1001 r1", "1002 r2" }, 1002);
		d.SetRadioButtons("1001 r1|1002 r2");

		//d.SetTimeout(10, "Cancel");
		//d.SetTimeout(10, null, true);

		//d.Created += ed => { Print($"{ed.message} {ed.wParam} {ed.linkHref}"); };
		d.Created += ed => { ed.dialog.Send.EnableButton(1, false); };
		//d.Created += ed => { ed.OwnerWindow.Enabled=true; };
		//d.Created += ed => { ed.hwnd.Owner.Enabled=true; };
		//d.Created += ed => { Wnd.Get.Owner(ed.hwnd).Enabled=true; };
		//d.Created += ed => { w.Enabled=true; };
		//d.Destroyed += ed => { Print($"{ed.message} {ed.wParam} {ed.linkHref}"); };
		d.ButtonClicked += ed => { Print($"{ed.message} {ed.wParam} {ed.LinkHref}"); if(ed.wParam == 2) ed.returnValue = 1; };
		d.HyperlinkClicked += ed => { Print($"{ed.message} {ed.wParam} {ed.LinkHref}"); };
		//d.OtherEvents += ed => { Print($"{ed.message} {ed.wParam} {ed.linkHref}"); };
		//d.Timer += ed => { Print($"{ed.message} {ed.wParam} {ed.linkHref}"); };
		//d.HelpF1 += ed => { Print($"{ed.message} {ed.wParam} {ed.linkHref}"); };

		//d.FlagShowProgressBar = true; d.Timer += ed => ed.dialog.Send.Progress(ed.wParam / 100);

		//Perf.First();
		TDResult r = d.ShowDialog();
		//Perf.NW();

		Print(r.ToString());

		//} catch(ArgumentException e) { Print($"ArgumentException: {e.ParamName}, '{e.Message}'"); } catch(Exception e) { Print($"Exception: '{e.Message}'"); }
		//#endif
	}

	static void TestFolders()
	{

		//Print(Path_.IsFullPath(@""));
		//Print(Path_.IsFullPath(@"\"));
		//Print(Path_.IsFullPath(@"\\"));
		//Print(Path_.IsFullPath(@"c:"));
		//Print(Path_.IsFullPath(@"c:\"));
		//Print(Path_.IsFullPath(@"c:aa"));
		//Print(Path_.IsFullPath(@"c\dd"));
		//Print(Path_.IsFullPath(@"%aa"));
		//Print(Path_.IsFullPath(@"<ff"));
		//Print(Path_.IsFullPath(@"%temp%"));
		//Print(Path_.IsFullPath(@"<ff>"));

		//Print(Path_.Combine(@"%temp%\..", null));
		//Print(Path_.Combine(@"%emp%\..", null));
		//Print(Path_.Combine(@"%temp", null));
		//Print(Path_.Combine(@"<ccc>", null));
		//Print(Path_.Combine(@"<ccc", null));

		//Print(Path_.Combine(@"c:\one", "two"));
		//Print(Path_.Combine(@"c:one", "two"));
		//Print(Path_.Combine(@"c:", "two"));
		//Print(Path_.Combine(@"\\one", "two"));

		//Print(Path_.Combine(null, @"c:\one"));
		//Print(Path_.Combine(null, @"c:one"));
		//Print(Path_.Combine(null, @"c:"));
		//Print(Path_.Combine(null, @"\\one"));
		//Print(1);
		//Print(Path_.Combine("one", "two"));
		//Print(Path_.Combine("one", null));
		//Print(Path_.Combine(null, "two"));
		//Print(Path_.Combine(@"one\", null));
		//Print(Path_.Combine(null, @"\two"));
		//Print(Path_.Combine(@"c:\one\", null));
		//Print(2);
		//Print(Path_.Combine("one", @"\two"));
		//Print(Path_.Combine(@"one\", "two"));
		//Print(Path_.Combine(@"one\", @"\two"));
		//Print(Path_.Combine("one", @"a:\two"));
		//Print(Path_.Combine("one", @"a:two"));
		//Print(3);
		//Print(Path_.Combine(null, @"C:\PROGRA~2\Acer\LIVEUP~1\updater.exe"));
		//Print(Path_.Combine(null, @"C:PROGRA~2\Acer\LIVEUP~1\updater.exe"));
		//Print(Path_.Combine(null, @"..\aaa.bbb"));
		//Print(Path_.Combine(@"C:\PROGRA~2\Acer\LIVEUP~1\..\updater.exe", null));
		//Print(Path_.Combine("C:\\PROGRA~2\\Acer\\LIVEUP~1\nupdater.exe", null));
		//Print(Path_.Combine(@"c:\one~", @" space "));

		//Output.Write(Folders.GetKnownFolders());

		//Print(Folders.Desktop);
		//Print(Folders.Desktop + "app.end");
		//Print(Folders.Desktop + "..\\file.txt");
		//Print(Folders.Desktop.ToString());
		//Print(Folders.Virtual.ComputerFolder + "mmm");
		//Print(Folders.Desktop + "app" + ".end");
		//Print(Folders.Profile);
		//Print(Folders.Virtual.ControlPanelFolder);
		//Print(Folders.CommonPrograms + "append.this");
		//Print(Folders.ApplicationShortcuts_Win8);
		//Print(Folders.Temp + "file.c");
		//Print(Folders.ThisApp + "file.c");
		//Print(Folders.ThisAppTemp + "file.c");
		//Print(Folders.ThisAppDocuments + "file.c");
		//Print(1);
		//Print(Folders.GetFolder("Start menu") + "append.nnn");
		//Print(Folders.GetFolder("APp") + "append.nnn");
		//Print(Folders.EnvVar("Temp") + "append.txt");
		//Print(Folders.GetFolder("UnknownFolder") + "append.nnn"); //throws
		//Print(Folders.EnvVar("unknown") + "append.txt"); //throws
		//Print(2);
		//Print(Folders.CDDrive());
		//Print(Folders.CDDrive() + "in CDDrive.txt");
		//Print(Folders.RemovableDrive(0));
		//Print(Folders.RemovableDrive(0) + "in Removable.txt");
		//Print(Folders.RemovableDrive(1) + "in Removable.txt");
		//Print(Folders.RemovableDrive("PortableApp") + "in Removable.txt");
		//Print(Folders.RemovableDrive("PortableApps.com") + "in Removable.txt");
		//Print(3);
		//Print(Folders.Desktop + @"\file.txt");
		//Print($@"{Folders.Desktop}\file.txt");
		//Print(Folders.Desktop + @"\file.txt");
		//Print(Folders.Desktop + @"C:\file.txt");
		//Print(Folders.Desktop);
		//Print(Folders.Desktop + "file.txt");
		//Print(Folders.Desktop + "..\\file.txt");

		//Print(Path.GetFullPath(@"c:\a\b\c."));


		//Process.Start("notepad.exe");
		//Process.Start(@"::{26EE0668-A00A-44D7-9371-BEB064C98683}\0\::{A3DD4F92-658A-410F-84FD-6FBBBEF2FFFE}");

		//var pi = new ProcessStartInfo("notepad.exe");
		//pi.


		//Guid g=default(Guid); string s=null/*, s2=null*/;
		//var a1 = new Action(() => { g = new Guid("{82A5EA35-D9CD-47C5-9629-E15D2F714E6E}"); });
		//var a2 = new Action(() => { g = new Guid(0xB4BFCC3A, 0xDB2C, 0x424C, 0xB0, 0x29, 0x7F, 0xE9, 0x9A, 0x87, 0xC6, 0x41); });
		//var a3 = new Action(() => { s = _Get(ref g); });
		////var a4 = new Action(() => { s2 = _Get(man, ref g); });
		////var a4 = new Action(() => { s = $"{_Get(ref g)}\\etc\\etc.etc"; });
		//var a4 = new Action(() => { s = Folders.Desktop; });
		//var a5 = new Action(() => { s = $"{Folders.Desktop}\\file.txt"; });
		//var a6 = new Action(() => { s = Folders.DesktopAnd("file.txt"); });
		//var a7 = new Action(() => { s = Path.Combine(Folders.Desktop, "file.txt"); });

		//a1();
		//a2();
		//a3();
		//a4();
		//a5();
		//a6();

		//Print(s);
		////Print(s2);

		//for(int i=0; i<5; i++) {
		//	Perf.First();
		//	Perf.Execute(1000, a1);
		//	Perf.Execute(1000, a2);
		//	Perf.Execute(1000, a3);
		//	Perf.Execute(1000, a4);
		//	Perf.Execute(1000, a5);
		//	Perf.Execute(1000, a6);
		//	Perf.Execute(1000, a7);
		//	Perf.Write();
		//}

		//Task.Run(()=> Directory.SetCurrentDirectory("c:\\windows\\system32"));
		//Wait(1);
		//Print(Path.GetFullPath("..\\nnn.ttt"));

		//Print(File.Exists(@"%windir%\System32\notepad.exe"));
		//Print(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles));
	}

	static void TestWndAll()
	{
		foreach(Wnd w in Wnd.Misc.AllWindows()) {
			Print(w);
		}
		Print("ok");

		//Wnd wq = Wnd.Find(null, "QM_Editor");
		//Print(wq.GetClassLong(Api.GCW_ATOM));

		//Print(Wnd.GetClassAtom("Edit"));
		//Print(Wnd.GetClassAtom("QM_Editor"));
		//Print(Wnd.GetClassAtom("QM_Editor", Util.Misc.GetModuleHandleOfProcessExe()));

		//var ac = new string[] { "IME", "MSCTFIME UI", "tooltips_class32", "ComboLBox", "WorkerW", "VBFloatingPalette" };
		//foreach(string s in ac) Print(Wnd.GetClassAtom(s));

		//return;

		//List<Wnd> a = null;

		////var a1 = new Action(() => { a = Wnd.AllWindows(); });
		////var a1 = new Action(() => { a = Wnd.AllWindows(null, true); });
		////var a1 = new Action(() => { a = wy.AllChildren(); });
		////var a2 = new Action(() => { wy.AllChildren((c, e) => { }); });
		//var a1 = new Action(() => { a = Wnd.AllWindows(); });
		//var a2 = new Action(() => { Wnd.AllWindows((w3, e) => { }); });

		////wy.AllChildren((c, e)=> { Print(c); }, null, true); return;
		////Wnd.AllWindows((c, e)=> { Print(c); }, "QM_*"); return;
		////Wnd.AllWindows((c, e)=> { Print(c); }, null, true); return;
		////foreach(Wnd w3 in Wnd.AllWindows(onlyVisible:true)) { Print(w3); }; return;
		////a1();

		////var a2 = new Action(() =>
		////{
		////	foreach(Wnd t in a) {
		////		string s = t.ClassName;
		////	}
		////});

		//int n = 10;

		//for(int k = 0; k < 5; k++) {
		//	Perf.First();
		//	Perf.Execute(n, a1);
		//	Perf.Execute(n, a2);
		//	Perf.Write();
		//}
		//Print(a.Count);

		//Wnd wq = Wnd.Find(null, "QM_Editor");

		//var f = new Form();
		//for(int i=0; i<20; i++) {
		//	var b = new Button();
		//	b.Location = new POINT(0, i * 20);
		//	b.Size = new SIZE(50, 18);
		//	f.Controls.Add(b);
		//}

		//f.Click += (o, e) =>
		//{
		//	Wnd hform = (Wnd)((Form)o).Handle;

		//	List<Wnd> a = null;

		//	var a1 = new Action(() => { a=hform.AllChildren(); });
		//	//var a1 = new Action(() => { a=wq.AllChildren(); });
		//	//a1();

		//	for(int k=0; k<5; k++) {
		//		Perf.First();
		//		Perf.Execute(1000, a1);
		//		Perf.Write();
		//	}
		//	Print(a);
		//      };

		//f.ShowDialog();


		////Output.Write(Wnd.All.ThreadWindows(wq.ThreadId));
		////Output.Write(Wnd.All.ThreadWindows(wq.ThreadId, "QM_toolbar"));
		//Output.Write(Wnd.All.ThreadWindows(wq.ThreadId, "", true));

		//TaskDialog.ShowEx("", "<a href=\"test\">test</a>", onLinkClick: ed =>
		//{
		//	var a = Wnd.All.ThreadWindows();
		//	Output.Write(a);
		//});

		//return;



		//var gu= new Guid("{82A5EA35-D9CD-47C5-9629-E15D2F714E6E}");
		//Print(gu);

		//Print(SpecFolder.CommonStartup);
		//Print(SpecFolder.Desktop);



		////string g;
		//////g = "ąčęėįšųūž абв αβγ";
		////g = "ĄČĘĖĮŠŲŪŽ АБВ ΑΒΓ";

		//////Print(g.ToUpper());
		//////Print(g.ToUpper_());
		////Print(g.ToLower());
		////Print(g.ToLower_());



		////return;

		////Wnd w=(Wnd)1245464;
		////List<Wnd> e1 = w.AllChildren();
		////Print(e1.Count);
		//////IEnumerable<Wnd> e= w.DirectChildControlsEnum();
		////List<Wnd> e2 = w.DirectChildControlsFastUnsafe();
		////Print(e2.Count);

		////Perf.First(100);
		////for(int uu=0; uu<5; uu++) {
		////	Perf.First();
		////	Perf.Execute(1000, () => { e2 =w.DirectChildControlsFastUnsafe(); });
		////	Perf.Execute(1000, () => { e1 =w.AllChildren(); });
		////	Perf.Execute(1000, () => { e1 = w.AllChildren("Button", true); });
		////	Perf.Execute(1000, () => { w.AllChildren(c=> { /*Print(c);*/ return false; }; });
		////	Perf.Write();
		////}

	}

	static void TestProcesses()
	{
		Wnd w = Wnd0;
		WFFlags hiddenToo = WFFlags.HiddenToo;

		//Process_.EnumProcesses(p =>
		//{
		//	Print(p.ProcessName);
		//	return false;
		//});
		//return;

		//w =Wnd.Find("", program: "YouTubeDownloader");
		//w =Wnd.Find("", program: @"C:\Program Files (x86)\Free YouTube Downloader\YouTubeDownloader.exe");
		//Print(w);
		//Print(w.ProcessName);
		//Print(w.ProcessPath);
		//return;

		//Print(Process_.GetProcessName(7140));
		//Print(Process_.GetProcessName(1988));
		//Print(Process_.GetProcessName(1988, true));

		//string pn1=null, pn2 = null;
		//var a11 = new Action(() => { pn1=Process_.GetProcessName(1988); }); //qmserv
		//var a12 = new Action(() => { pn2=Process_.GetProcessName(7140); }); //firefox
		//Perf.ExecuteMulti(5, 1000, a11, a12);
		//Print(pn1); Print(pn2);
		//return;

		var a1 = new Action(() => { w = Wnd.Find("*Notepad", flags: hiddenToo); });
		var a2 = new Action(() => { w = Wnd.Find("*Notepad", "Notepad", flags: hiddenToo); });
		var a3 = new Action(() => { w = Wnd.Find("*Notepad", "Notepad", "Notepad", flags: hiddenToo); });
		var a4 = new Action(() => { w = Wnd.Find("*Notepad", "Notepad", "NotepaD.exE", flags: hiddenToo); });
		var a5 = new Action(() => { w = Wnd.Find("*Notepad", "Notepad", @"c:\windows\syswow64\Notepad.exe", flags: hiddenToo); });
		//var a6 = new Action(() => { w = Wnd.Find("", "", "NotepaD.exE", flags: hiddenToo); });
		//var a7 = new Action(() => { w = Wnd.Find("", "", @"c:\windows\syswow64\Notepad.exe", flags: hiddenToo); });
		var a6 = new Action(() => { w = Wnd.Find("", "", "no NotepaD.exE", flags: hiddenToo); });
		var a7 = new Action(() => { w = Wnd.Find("", "", @"c:\no windows\syswow64\Notepad.exe", flags: hiddenToo); });
		var a8 = new Action(() => { w = Wnd.Find("", "", "youtubedownloader", flags: hiddenToo); });

		//a6(); Print(w); return;

		a1(); Print(w);
		a2(); Print(w);
		a3(); Print(w);
		a4(); Print(w);
		a5(); Print(w);
		a6(); Print(w);
		a7(); Print(w);
		a8(); Print(w);

		Perf.ExecuteMulti(5, 1, a1, a2, a3, a4, a5, a6, a7, a8);

		//Wnd w = (Wnd)12582978; //Notepad

		//string s = null;

		//s = w.ProcessName;
		//Print(s);
		//s = w.ProcessPath;
		//Print(s);

		//var a1 = new Action(() => { s = w.ProcessName; });
		//var a2 = new Action(() => { s = w.ProcessPath; });

		//Perf.ExecuteMulti(5, 1, a1, a2);

		//Process[] a=null;

		//Perf.First(100);
		//a = Process.GetProcesses();
		//Perf.Next();
		//a = Process.GetProcesses();
		//Perf.Next();
		//a = Process.GetProcesses();
		//Perf.Next();
		//a = Process.GetProcessesByName("NoTepad");
		//Perf.Next();
		//a = Process.GetProcessesByName("NoTepad");
		//Perf.Next();
		//a = Process.GetProcessesByName("NoTepad");
		//Perf.Next();
		//Perf.Write();

		//int pid = a[0].Id;

		//Process u = null;
		//string name = null;

		//Perf.First();
		//u=Process.GetProcessById(pid);
		//Perf.Next();
		//name = u.ProcessName;
		//Perf.Next();
		//u=Process.GetProcessById(pid);
		//Perf.Next();
		//name = u.ProcessName;
		//Perf.Next();
		//u=Process.GetProcessById(pid);
		//Perf.Next();
		//name = u.ProcessName;
		//Perf.Next();
		//Perf.Write();

		//Print(name);

		//a = Process.GetProcesses();
		//Print(a.Length);
		//a = Process.GetProcessesByName("NoTepad");
		//Print(a.Length);
		//a = Process.GetProcessesByName("regedit");
		//Print(a.Length);
		//foreach(Process p in a) {
		//	Print(p.Id);
		//	//Print(p.Handle);
		//}
	}

	static void TestProcessUacInfo()
	{
		////Print(Process_.UacInfo.ThisProcess.IntegrityLevel);
		////Print(Api.GetModuleHandle("shell32"));
		////Print(Api.GetModuleHandle("advapi32"));
		//bool is1 = false, is2 = false, is3=false;
		//Perf.SpinCPU(200);
		//Perf.ExecuteMulti(5, 1, () => { is1 = Process_.UacInfo.IsThisProcessAdmin; }, () => { is2 = Api.IsUserAnAdmin(); }, () => { is3 = IsUserAdmin; });
		//PrintList(is1, is2, is3);
		////Print(Api.GetModuleHandle("shell32"));
		////Print(Api.GetModuleHandle("advapi32"));

		//Print(Process_.UacInfo.IsUacDisabled);
		Print(Process_.UacInfo.IsAdmin);
		return;

		Print(Process_.UacInfo.IsAdmin);

		Process[] a = Process.GetProcesses();
		for(int i = -5; i < a.Length; i++) {
			Process x = null;
			Process_.UacInfo p = null;

			Perf.First();
			if(i < 0) p = Process_.UacInfo.ThisProcess;
			else {
				x = a[i];
				Print($"<><Z 0x80c080>{x.ProcessName}</Z>");
				p = Process_.UacInfo.GetOfProcess(x.Id);
			}
			if(p == null) { Print("failed"); continue; }
			Perf.Next();
			var elev = p.Elevation; if(p.Failed) Print("<><c 0xff>Elevation failed</c>");
			Perf.Next();
			var IL = p.IntegrityLevel; if(p.Failed) Print("<><c 0xff>IntegrityLevel failed</c>");
			Perf.Next();
			var IL2 = p.IntegrityLevelAndUIAccess;
			Perf.Next();
			bool uiaccess = p.IsUIAccess; if(p.Failed) Print("<><c 0xff>IsUIAccess failed</c>");
			Perf.Next();
			bool appcontainer = p.IsAppContainer; if(p.Failed) Print("<><c 0xff>IsAppContainer failed</c>");
			Perf.Next();
			Print($"elev={elev}, uiAccess={uiaccess}, AppContainer={appcontainer}, IL={IL}, IL+uiaccess={IL2}");
			//Print($"uiAccess={uiaccess}, IL={IL}");
			//Perf.Write();
		}
	}

	static void TestRegexSpeed()
	{
		Regex r = null;
		string p = @"^\w:\\.+\\\w+\.\w\w\w$";
		string s = @"c:\jshgdjhasdhjahjdashjdjhas\ksjhdkjshdkj\file.txt";
		bool yes = false;

		var a1 = new Action(() => { r = new Regex(p); });
		var a2 = new Action(() => { yes = r.IsMatch(s); });
		var a1i = new Action(() => { r = new Regex(p, RegexOptions.IgnoreCase); });
		var a2i = new Action(() => { yes = r.IsMatch(s); });
		var a1o = new Action(() => { r = new Regex(p, RegexOptions.CultureInvariant); });
		var a2o = new Action(() => { yes = r.IsMatch(s); });
		var a1oi = new Action(() => { r = new Regex(p, RegexOptions.CultureInvariant | RegexOptions.IgnoreCase); });
		var a2oi = new Action(() => { yes = r.IsMatch(s); });

		a1(); a2(); Print(yes);
		a1i(); a2i(); Print(yes);
		a1o(); a2o(); Print(yes);
		a1oi(); a2oi(); Print(yes);

		Perf.ExecuteMulti(5, 1000, a1, a2, a1i, a2i, a1o, a2o, a1oi, a2oi);

		//compiling: Regex 4500, PCRE 450.
		//match (invariant, match case): Regex 1200, PCRE 300.
		//match (invariant, ignore case): Regex 1700, PCRE 300.
	}

	static void TestProcessMemory()
	{
		//var w = Wnd.FindFast("QM_Editor");
		var w = Wnd.FindFast(null, "Notepad");
		Print(w);
		Process_.Memory x = null;
		try {
			x = new Process_.Memory(w, 1000);
			//x = new Process_.Memory(w, 0);

		}
		catch(CatException e) { Print(e); return; }

		//Print(1);
		//Print(x.WriteUnicodeString("Unicode"));
		//Print(2);
		//Print(x.WriteAnsiString("ANSI", 100));
		//Print(3);
		//Print(x.ReadUnicodeString(7));
		//Print(4);
		//Print(x.ReadAnsiString(4, 100));
		//Print(5);

		unsafe
		{
			int i1 = 5, i2 = 0;
			//Print(x.Write(&i1, 4));
			//Print(x.Read(&i2, 4));
			//Print(x.Write(&i1, 4, 50));
			//Print(x.Read(&i2, 4, 50));
			Print(x.WriteOther(x.Mem, &i1, 4));
			Print(x.ReadOther(x.Mem, &i2, 4));
			Print(i2);
		}
	}

	static void TestDotNetControls()
	{
		var w = Wnd.Find("Free YouTube Downloader", "*.Window.*");
		//var w = Wnd.Find("Keyboard Layout*", "*.Window.*");
		//var c = w.Child("", "*.SysListView32.*");
		Print(w);
		if(w.Is0) return;
		//Print(c);
		var x = new Wnd.Misc.WinFormsControlNames(w);

		////Print(x.GetControlNameOrText(c));
		//Print(x.GetControlNameOrText(w));

		var a = w.AllChildren();
		foreach(Wnd k in a) {
			Print("---");
			Print(k);
			Print(Wnd.Misc.WinFormsControlNames.IsWinFormsControl(k));
			Print(x.GetControlName(k));
		}
	}

	static void TestDotNetControls2()
	{
		//Wnd w = Wnd.Find("Keyboard*").Child("Caps");
		//Wnd w = Wnd.Find("Keyboard*");
		//Wnd w = Wnd.Find("Quick*");
		Wnd w = Wnd.Find("Free YouTube*").Child("My*");
		Print(w);
		//Print(WinFormsControlNames.GetSingleControlName(w));

		string s1 = null, s2 = null;
		var a1 = new Action(() =>
		{
			try {
				using(var x = new Wnd.Misc.WinFormsControlNames(w)) { s1 = x.GetControlName(w); }
			}
			catch { s1 = null; }
		});
		var a2 = new Action(() => { s2 = Wnd.Misc.WinFormsControlNames.GetSingleControlName(w); });

		Perf.ExecuteMulti(5, 10, a1, a2);
		PrintList(s1, s2);
	}

	static void TestWndFind()
	{
		Wnd w = Wnd0, c = Wnd0;
		//w = Wnd.Find("", "", "dwm", true);
		w = Wnd.Find(null, "QM_Editor");
		//w = Wnd.Find("Quick Macros*");
		//w = Wnd.Find("*[*]");
		//w = Wnd.Find("Quick Macros - ok - [Macro2773]");
		//w = Wnd.Find("[f]Quick Macros - ok - [Macro2773]");
		//w = Wnd.Find("[f]Quick Macros - ");
		//w = Wnd.Find("[f]Quick Macros - *");
		//w = Wnd.Find("[p]Quick Macros - ");
		//w = Wnd.Find("[r]^Quick Macros - ");
		//w = Wnd.Find("[r]^quick macros - ");
		//w = Wnd.Find("[ri]^quick macros - ");
		//w = Wnd.Find("[ric]^quick macros - ");
		//w = Wnd.Find(null, "qm_Editor");
		//w = Wnd.Find("", "qm_Editor");
		//w = Wnd.Find("", "[-i]qm_Editor");
		//w = Wnd.Find(null, "QM_Editor"); //test when hidden
		//w = Wnd.Find(null, "QM_Editor", "", true); //test when hidden
		//w = Wnd.Find(WFFlags.HiddenToo, null, "QM_Editor"); //test when hidden
		//w = Wnd.Find(null, "QM_*");
		//w = Wnd.Find(null, null, "*env");
		//w = Wnd.Find(null, null, "Q:\\*");
		//w = Wnd.Find(WFFlags.ProgramPath, null, null, "Q:\\*");
		//w = Wnd.Find(WFFlags.ProgramPath, null, null, "c:\\*");
		//w = Wnd.Find(null, "QM_*", matchIndex:2);
		//w = Wnd.Find(null, "QM_*", prop:new Wnd.WinProp() {childClass="QM_Code" } );
		//w = Wnd.Find(null, "QM_*", prop:new Wnd.WinProp() {owner=Wnd.Find("Quick Macros*") } );
		//w = Wnd.Find(null, null, prop:new Wnd.WinProp() {processId= Wnd.Find("Quick Macros*").ProcessId } );
		//w = Wnd.Find(null, null, prop:new Wnd.WinProp() {threadId=Wnd.Find("*Notepad").ThreadId } );
		//w = Wnd.Find(null, null, prop:new Wnd.WinProp() {propName= "qmshex" } );
		//w = Wnd.Find(null, null, prop:new Wnd.WinProp() {propName= "qmshex", propValue=1 } );
		//w = Wnd.Find(null, null, prop:new Wnd.WinProp() {style=Native.WS_CAPTION, styleMask=Native.WS_CAPTION } );
		//w = Wnd.Find(null, null, prop: new Wnd.WinProp() { styleHas = Native.WS_CAPTION });
		//w = Wnd.Find(null, null, prop: new Wnd.WinProp() { styleNot = Native.WS_CAPTION });
		//w = Wnd.Find("* Notepad", null, prop: new Wnd.WinProp() { styleNot = Native.WS_DISABLED, styleHas = Native.WS_CAPTION });
		//w = Wnd.Find(null, null, prop: new Wnd.WinProp() { exStyleHas = Native.WS_EX_NOREDIRECTIONBITMAP });
		//w = Wnd.Find(null, null, prop: new Wnd.WinProp() { exStyleNot = Native.WS_EX_TOPMOST });
		//w = Wnd.Find(null, null, prop: new Wnd.WinProp() {  });
		//w = Wnd.Find(null, "QM_*", also:e=> { Print(e.w); if(e.w.Name == "TB MSDEV") e.Stop(); });
		//w = Wnd.Find(null, "QM_*", also:e=> { Print(e.w); e.w = Wnd0; e.Stop(); });
		//w = Wnd.Find(null, "QM_*", prop: new Wnd.WinProp() { childClass="QM_Code" });
		//w = Wnd.Find(null, "QM_*", prop: new Wnd.WinProp() { childName="Te&xt" });
		//w = Wnd.Find(null, "QM_*", prop: new Wnd.WinProp() { childId = 2202 });
		//w = Wnd.Find(null, "QM_*", prop: new Wnd.WinProp() { childClass = "Button", childName = "Te&xt" });
		//w = Wnd.Find(null, "QM_*", prop: new Wnd.WinProp() { childClass = "*Edit", childName = "sea" });
		//w = Wnd.Find("Free YouTube Downloader", "*.Window.*");
		//w = Wnd.Find("Keyboard Layout*", "*.Window.*");
		//w = Wnd.Find("Catkeys -*");
		//w = Wnd.Find("", prop: new Wnd.WinProp() { x=Screen_.Width-1, y=Screen_.Height-10 });
		//w = Wnd.Find("", prop: new Wnd.WinProp() { x=0.5, y=1.1 });
		//w = Wnd.FromXY(1532, 1224, null);
		//w = Wnd.FromXY(0.1, 0.1, null, true, true);

		//Perf.ExecuteMulti(5, 100, () => { Wnd.FindFast("QM_Editor"); }, () => { Wnd.Find(null, "QM_Editor"); });

		//w = Wnd.FindFast("QM_Editor");
		Print(w);
		//return;

		//c = w.Child(2202);
		//c = w.Child("Open*");
		//c = w.Child(null, "SysListView32", 2212);
		//c = w.Child(null, "SysListView32");
		//c = w.Child(null, "", 2212);
		//c = w.Child(null, "SysListView32", 0, true);
		//c = w.Child(null, "SysListView32", 0, true, matchIndex:2);
		//c = w.Child(null, "SysListView32", matchIndex:2);
		//c = w.Child(WCFlags.HiddenToo, null, "SysListView32", 0);
		//c = w.Child("sea");
		//c = w.Child("Regex*");
		//c = w.Child(WCFlags.ControlText, "sea");
		//c = w.Child(WCFlags.DirectChild, "", matchIndex:4);
		//c = w.Child(null, "Button", also: e => { Print(e.w); });
		//c = w.Child(null, "Button", also: e => { Print(e.w); if(e.w.Name == "Te&xt") e.Stop(); });
		//c = w.Child(null, "", prop:new Wnd.ChildEtc() { exStyleHas=Native.WS_EX_CLIENTEDGE});
		//c = w.Child(null, "", prop:new Wnd.ChildEtc() { styleHas=Native.WS_BORDER});
		//c = w.Child(null, "Button", prop:new Wnd.ChildEtc() { x=344, y=448});
		//c = w.Child(null, "", prop:new Wnd.ChildEtc() { x=0.5, y=0.03});
		//c = w.Child(null, "", prop:new Wnd.ChildEtc() { childId=1028 });
		//c = w.Child(null, "", prop: new Wnd.ChildEtc() { child = new Wnd.ChildFinder(WCFlags.DirectChild, "Reg*") });
		//c = w.Child("Regex*", "Button");
		//c = w.Child(null, "", prop: new Wnd.ChildEtc() { wfName = "textBoxUrl" });
		//try {
		//	Wnd w = Wnd.Find("Keyboard*");
		//	Wnd c = w.Child("", prop: new Wnd.ChildEtc() { wfName = "ckControl" });
		//	Print(c);
		//} catch(CatException e) {
		//	Print(e);
		//}
		//c = w.Child(null, "SysTreeView32", prop:new Wnd.ChildEtc() { x=1 });
		//c = w.Child(null, "SysTreeView32", prop:new Wnd.ChildEtc() { x=1276});
		//c = w.Child(null, "SysTreeView32", prop:new Wnd.ChildEtc() { x=w.ClientWidth-1 });
		//c = w.Child(null, "QM_*", prop:new Wnd.ChildEtc() { y=0.99 });
		//c = w.Child("Find &Previous");
		//c = w.Child("Find Previous");

		Print(c);
		return;

		//Wnd c1 = Wnd0, c2 = Wnd0, c3 = Wnd0, c4 = Wnd0, c5 = Wnd0, c6 = Wnd0, c7 = Wnd0;
		//var a1 = new Action(() => { c1 = w.Child("sea"); });
		//var a2 = new Action(() => { c2 = w.Child("sea", flags: WCFlags.NameIsValue); });
		//var a3 = new Action(() => { c3 = w.Child("sea", "*Edit"); });
		//var a4 = new Action(() => { c4 = w.Child("sea", "*Edit", WCFlags.NameIsValue); });
		//var a5 = new Action(() => { c5 = w.Child("Regex*"); });
		//var a6 = new Action(() => { c6 = w.Child("Regex*", "Button"); });
		////var a7 = new Action(() => { c7 = w.Child("1028", flags: WCFlags.NameIsId); });
		//var a7 = new Action(() => { c7 = w.Child(1028); });
		//Perf.ExecuteMulti(5, 100, a1, a2, a3, a4, a5, a6, a7);
		//Output.WriteListSep("\n", c1, c2, c3, c4, c5, c6, c7);

		Wnd c1 = Wnd0, c2 = Wnd0, c3 = Wnd0, c4 = Wnd0, c5 = Wnd0, c6 = Wnd0, c7 = Wnd0;
		var a1 = new Action(() => { c1 = w.Child("sea"); });
		var a2 = new Action(() => { c2 = w.Child("**text:sea"); });
		var a3 = new Action(() => { c3 = w.Child("sea", "*Edit"); });
		var a4 = new Action(() => { c4 = w.Child("**text:sea", "*Edit"); });
		var a5 = new Action(() => { c5 = w.Child("Regex*"); });
		var a6 = new Action(() => { c6 = w.Child("Regex*", "Button"); });
		//var a7 = new Action(() => { c7 = w.Child("1028", flags: WCFlags.NameIsId); });
		var a7 = new Action(() => { c7 = w.Child("**id:1028"); });
		Perf.ExecuteMulti(5, 100, a1, a2, a3, a4, a5, a6, a7);
		Output.WriteListSep("\n", c1, c2, c3, c4, c5, c6, c7);

		//Print(Process.GetProcessesByName("qm")[0].MainWindowTitle); //TB INTERNET

		//var w = Wnd.Find(null, "QM_Editor");
		//Print(Wnd.Get.NextMainWindow());
		//Print(Wnd.Get.NextMainWindow(w));
		//Print(Wnd.Get.NextMainWindow(w));

		//var a=Wnd.All.MainWindows();
		//foreach(Wnd w in a) {
		//	Print(w);
		//}

		//var x = new Wnd.WinProp() { owner = Wnd0, exStyle = 8 };
		//var y = new Wnd.WinProp(owner: Wnd0, style: 8);
		//TestProp(new Wnd.WinProp() { owner = Wnd0, exStyle = 8 });
		//TestProp(new Wnd.WinProp(owner: Wnd0, style: 8));

		//var a1 = new Action(() => { Wnd.AllWindows(e => { }); });
		//var a2 = new Action(() => { var a = Wnd.All.ThreadWindows(7192); /*Print(a == null); Print(a.Count);*/ });
		////a2();

		//Print("---");
		//Perf.ExecuteMulti(5, 1000, a1, a2);

		//Wnd w = (Wnd)1705264;

		//var a1 = new Action(() => { RECT r = w.Rect; });
		//var a2 = new Action(() => { uint st = w.Style; });
		//var a3 = new Action(() => { uint est = w.ExStyle; });
		//var a4 = new Action(() => { string name = w.Name; });
		//var a5 = new Action(() => { string cn = w.ClassName; });
		//var a6 = new Action(() => { uint tid = w.ThreadId; });
		//var a7 = new Action(() => { Wnd own = w.Owner; });
		//var a8 = new Action(() => { bool clo=w.IsCloaked; });

		//Perf.ExecuteMulti(5, 1000, a1, a2, a3, a4, a5, a6, a7, a8);
	}

	static void TestWndFromXY()
	{
		Wnd w1 = Wnd0, w2 = Wnd0, w3 = Wnd0, w4 = Wnd0, w5 = Wnd0, w6 = Wnd0;

		var a1 = new Action(() => { var p = Mouse.XY; w1 = Api.WindowFromPoint(p); });
		var a2 = new Action(() => { w2 = Wnd.FromMouse(); });
		//var a3 = new Action(() => { w3 = Wnd.FromXY2(Mouse.XY); });
		//var a4 = new Action(() => { w4 = Wnd.FromXY3(Mouse.XY); });

		for(;;) {
			Wait(1);
			if(Mouse.X == 0 && Mouse.Y == 0) break;
			//a4(); Print(w4); continue;
			Print("---------------------------");
			a1(); a2(); //a3(); a4();
			Perf.ExecuteMulti(3, 1, a1, a2);
			Print(w1);
			Print(w2);
			//Print(w3);
			//Print(w4);
		}

	}

	static void TestChildFromXY()
	{
		Wnd w1 = Wnd.Find("Options");
		Print(w1);
		Print(w1.ChildFromXY(43, 132));
		Print(w1.ChildFromXY(43, 132, true));
		Print(w1.ChildFromXY(1265, 1243, false, true));
		Print(w1.ChildFromXY(1, 1)); //coord not in a child
		Print(w1.ChildFromXY(43, 932)); //coord outside
	}

	[DllImport("user32.dll", EntryPoint = "InternalGetWindowText", SetLastError = true)]
	public static extern int InternalGetWindowTextSB(Wnd hWnd, [Out] StringBuilder pString, int cchMaxCount);

	static void TestMemory2(Wnd w)
	{
		var sb = new StringBuilder(1000);
		InternalGetWindowTextSB(w, sb, 1000);
		sb.Clear();
		//sb.Length = 0;
		//sb.Capacity = 0;

	}

	static void TestMemory3(Wnd w)
	{
		var sb = new StringBuilder();
		for(int i = 16; i < 1000000; i *= 2) {
			sb.Capacity = i;
			InternalGetWindowTextSB(w, sb, i);

		}
		string R = sb.ToString();
		Perf.First();
		sb.Clear();
		sb.Length = 0;
		sb.Capacity = 0;
		Perf.NW();
		Print(R);
	}

	static void TestMemory()
	{
		//Wnd w = Wnd.Find("", "QM_Editor");
		//Print(w);
		////Print(w.Name);
		////Print(w.ControlText);
		////return;

		//while(TaskDialog.Show("test", "", TDButtons.OKCancel) == TDResult.OK) {
		//	for(int i = 0; i < 1; i++) {
		//		TestMemory3(w);
		//	}
		//	TaskDialog.Show("allocated 2 MB");
		//}
	}

	static void TestStringPlusConcatInterpolation()
	{
		string s;
		if(Time.Milliseconds > 1000) s = "sjhdkjshdjkshjkdhsjkhdjkshdjkhsjkdhjskhdjksh"; else s = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaa";
		string s1 = null, s2 = null, s3 = null, s4 = null, s5 = null, s6 = null;

		var a1 = new Action(() => { s1 = "<IDLIST:" + s + ">"; });                          //40
		var a2 = new Action(() => { s2 = string.Concat("<IDLIST:", s, ">"); });             //40
		var a3 = new Action(() => { s3 = "<IDLIST:" + s + ">" + s + " tail"; });            //125
		var a4 = new Action(() => { s4 = string.Concat("<IDLIST:", s, ">", s, " tail"); }); //125
		var a5 = new Action(() => { s5 = $"<IDLIST:{s}>"; });                               //160
		var a6 = new Action(() => { s6 = $"<IDLIST:{s}>{s} tail"; });                       //220

		Perf.ExecuteMulti(5, 1000, a1, a2, a3, a4, a5, a6);
		Print(s1);
		Print(s2);
		Print(s3);
		Print(s4);
		Print(s5);
		Print(s6);

		//Print(Folders.Virtual.ControlPanelFolder);
	}

	static void TestArrayAndList(IList<string> a)
	{
		Print(a.Count);
		//for(int)
	}

	static void TestWndFindAll()
	{
		//Print(Wnd.FindAll(0, "*I*"));
		Wnd w = Wnd.Find("Quick*");
		Print(w.ChildAll("", "QM*"));
	}

	static bool _Activate(Wnd w)
	{
		if(!Wnd.Misc.EnableActivate()) return false;
		Api.SetForegroundWindow(Wnd.WndActive);
		Api.SetForegroundWindow(Wnd.WndActive);
		Api.SetForegroundWindow(Wnd.WndActive);
		Perf.First();
		if(!Api.SetForegroundWindow(w)) return false;
		Perf.Next();
		for(int i = 0; i < 10; i++) { Print(Wnd.WndActive); Thread.Sleep(1); }
		//Thread.Sleep(100);
		Perf.Write();
		if(w.IsActive) return true;

		int tid = w.ThreadId;
		if(tid != 0 && tid == Wnd.WndActive.ThreadId && Api.SetForegroundWindow(Wnd.Misc.WndRoot)) {
			Api.SetForegroundWindow(w);
			Wnd t = Wnd.WndActive;
			Print(t);
			if(t.ThreadId == tid) return true;
		}

		return false;
	}

	static void TestWndActivateFocus()
	{
		//Wnd.ActiveWindow.ShowMinimized();
		//Print(Wnd.ActiveWindow);
		//Print(Wnd.SwitchActiveWindow(true));
		//return;

		//Wait(2);
		//var a = new Api.INPUTKEY[] { new Api.INPUTKEY(65, 0), new Api.INPUTKEY(65, 0, Api.IKFlag.Up), new Api.INPUTKEY(66, 0), new Api.INPUTKEY(66, 0, Api.IKFlag.Up)};
		//Api.SendInputKey(a);
		//Print("ok");
		//return;

		//Thread.CurrentThread.Priority = ThreadPriority.Highest;
		Wait(2);

		//Print(Wnd.LockActiveWindow(true));
		//return;

		//Wnd w=Wnd.Find("Quick*");
		//Wnd w=Wnd.Find("*Notepad");
		//Wnd w=Wnd.Find("[p]Paint");
		Wnd w = Wnd.Find("Options");
		//Wnd w=Wnd.Find(Wnd.Find("Microsoft Excel*").Name.EndsWith_("dictionary.xls") ? "Book1.xls" : "dictionary.xls");
		Print(w);
		//Print(w.ActivateLL());
		w.Activate();
		//Print(Api.SetForegroundWindow(Wnd.Get.WndRoot));
		//Thread.Sleep(100);
		//Print(Api.SetForegroundWindow(w));
		//Print(_Activate(w));
		//Thread.Sleep(100);
		Print(Wnd.WndActive);

		Wnd c = w.Child("Show*");
		c.Focus();
		Print(Wnd.WndFocused);
		Print(Wnd.WndFocusedLL);

		//TaskDialog.Show("a");
		return;
		Wait(2);
		w = Wnd.Find("[p]Notepad");
		Print(w.ActivateLL());
		Print(Wnd.WndActive);
	}

	static void TestWndMinMaxRes()
	{
		//Wnd w = Wnd.Find("", "XLMAIN");
		//Wnd w = Wnd.Find("Book1.xls");
		//Wnd w = Wnd.Find("[p]Dreamweaver");
		//Wnd w = Wnd.Find("app -*", "wndclass_desked_gsk");
		//Wnd w = Wnd.Find("* Notepad");
		Wnd w = Wnd.Find("Registry*");
		//Print(w);

		//w.Show(false);
		//Thread.Sleep(1000);

		//w.ActivateLL(); return;

		//w.Activate(); Wait(1); //return;

		//Wnd w = Wnd.Find("Dialog MM");
		//w.ShowMinimized();
		//w.ShowMinimized(true);
		//w.ShowMaximized(); //Registry does not work. Access denied.
		//w.ShowNotMinMax();
		w.ShowNotMinimized();
		//Wnd.Misc.Arrange.MinimizeWindows();

		Print(Wnd.WndActive);
		return;


		//if(false) {
		//	w.ShowNotMinMax();
		//	Wait(1);
		//	w.ShowMaximized();
		//	return;

		//	w.ShowMinimized();
		//	//Print(w.IsMinimized);
		//	Print(Wnd.ActiveWindow);
		//	Wait(1);
		//	w.ShowNotMinimized();
		//	//Print(w.IsMinimized);
		//	Print(Wnd.ActiveWindow);

		//	//w.ShowMaximized();
		//	//w.ShowNotMinMax();
		//} else {
		//	var m = true;

		//	//Print(w.ShowNotMinMax(m));
		//	//Wait(1);
		//	//Print(w.ShowMaximized(m));
		//	//return;

		//	w.ShowMinimized(m);
		//	//Print(w.IsMinimized);
		//	Print(Wnd.ActiveWindow);
		//	Wait(1);
		//	w.ShowNotMinimized(m);
		//	//Print(w.IsMinimized);
		//	Print(Wnd.ActiveWindow);

		//	//Print(w.ShowMaximized(m));
		//	//Print(w.ShowNotMinMax(m));
		//}

		//Print("ok");
	}

	static void TestWindowDimensions()
	{
		//Wnd w=Wnd.Find("Quick*", "QM_*");
		Wnd w = Wnd.Find("* Notepad");
		//Wnd w=Wnd.Find("Registry*");
		//Wnd w=Wnd.Find(null, "Dwm", flags:WFFlags.HiddenToo);
		Print(w);

		//Print(w.MoveInScreen(0, 0));
		//Print(w.MoveToScreenCenter(2));

		//Print(w.Child("", "*Tree*", prop: new Wnd.ChildEtc() { y=0.5 }));
		//Print(Wnd.Find("", "QM_*", prop: new Wnd.WinProp() { x=0.5 }));

		w.Activate();
		//w.MoveLL(300, 100, 600, 200);
		//w.Width = 500;
		//w.MoveLL(100, 30, 500, 300);
		//w.MoveLL(100, 30, null, null);
		//w.MoveLL(null, null, 500, 300);
		//w.MoveLL(null, null, 500, null);
		//w.MoveLL(null, null, null, 500);
		//w.MoveLL(100, null, null, null);
		//w.MoveLL(null, 100, null, null);
		//w.MoveLL(null, 100, null, 300);
		//w.MoveLL(300, 100);
		//w.MoveLL(null, 100);
		//w.ResizeLL(300, 100);
		//w.ResizeLL(null, 100);
		//w.ResizeLL(300, null);

		//w.Move(300, 100, 600, 200);
		//w.Move(100, 30, 500, 300);
		//w.Move(100, 30, null, null);
		//w.Move(null, null, 500, 300);
		//w.Move(null, null, 500, null);
		//w.Move(null, null, null, 500);
		//w.Move(100, null, null, null);
		//w.Move(null, 100, null, null);
		//w.Move(null, 100, null, 300);
		//w.Move(500, 100);
		//w.Move(null, 100);
		//w.Resize(300, 100);
		//w.Resize(null, 100);
		//w.Resize(300, null);

		//w = Wnd0;
		//Print(w.Height);
		//Print(w.IsNotMinMax);
		//Print(ThreadError.ErrorText);


		PrintList(w.X, w.Y, w.Width, w.Height);
		PrintList(w.ClientWidth, w.ClientHeight);

		//w.X = 500;
		//w.Y = 500;
		//w.Width = 500;
		//w.Height = 500;

		//RECT r = w.Rect;
		//r.Inflate(20, 20);
		//w.Rect = r;

		//RECT r = w.ClientRect;
		//Print(r);
		//r.Inflate(20, 20);
		//w.ClientRect = r;

		//w.ClientWidth = 300;
		//Print(w.ClientWidth);
		//w.ClientHeight = 300;
		//Print(w.ClientHeight);

		//RECT rw, rc;
		//if(w.GetWindowAndClientRectInScreen(out rw, out rc)) PrintList(rw, rc);
	}

	static void TestWndtaskbarButton()
	{
		//Wnd w=Wnd.Find("Quick*", "QM_*");
		Wnd w = Wnd.Find("* Notepad");
		//Wnd w=Wnd.Find("Registry*");
		//Wnd w=Wnd.Find(null, "Dwm", flags:WFFlags.HiddenToo);
		Print(w);

		//Wnd.Misc.TaskbarButton.Flash(w, 0);
		//Wait(3);
		//Wnd.Misc.TaskbarButton.Flash(w, 1);

		//Wnd.Misc.TaskbarButton.SetProgressState(w, Wnd.Misc.TaskbarButton.ProgressState.Error);
		//for(int i = 0; i < 100; i++) {
		//	Wnd.Misc.TaskbarButton.SetProgressValue(w, i + 1);
		//	Thread.Sleep(100);
		//}
		//Wnd.Misc.TaskbarButton.SetProgressState(w, Wnd.Misc.TaskbarButton.ProgressState.NoProgress);

		Wnd.Misc.TaskbarButton.Delete(w);
		Wait(2);
		Wnd.Misc.TaskbarButton.Add(w);
	}

	static void TestWndClose()
	{
		//Wnd w = Wnd.Find("*Notepad*");
		//Wnd w = Wnd.Find("* Internet Explorer*");
		//Wnd w = Wnd.Find("*Dreamweaver*");
		Wnd w = Wnd.Find("Registry*");
		Print(w);
		//Script.Speed = 200;
		Print(w.Close());
		//Wnd.CloseAll("*Notepad*");
	}

	static void TestWndArrange()
	{
		Wnd w = Wnd.Find("*Notepad");
		//Print(w);
		Wnd.Misc.Desktop.ToggleShowDesktop();
		Print("ok");
		Wait(1);
		Wnd.Misc.Desktop.ToggleShowDesktop();
		//Wait(1);
		//Wnd.Misc.Arrange.MinimizeWindows(true);
		//Wait(1);
		//Wnd.Misc.Arrange.MinimizeWindows(false);
		//Wnd.Misc.Arrange.CascadeWindows();
		//Wait(1);
		//Wnd.Misc.Arrange.TileWindows(true);
		//Wait(1);
		//Wnd.Misc.Arrange.TileWindows(false);
	}

	static void TestWndShowHide()
	{
		bool vis = false;
		Wnd w = Wnd.Find("*Notepad", flags: WFFlags.HiddenToo);

		var a1 = new Action(() => { vis = w.IsVisible; });
		var a2 = new Action(() => { Api.ShowWindow(w, vis ? 0 : Api.SW_SHOWNA); });
		//var a2 = new Action(() => { Api.ShowWindow(w, vis?0:Api.SW_SHOW); });
		var a3 = new Action(() => { Api.SetWindowPos(w, Wnd0, 0, 0, 0, 0, (vis ? Native.SWP_HIDEWINDOW : Native.SWP_SHOWWINDOW) | Native.SWP_NOMOVE | Native.SWP_NOSIZE | Native.SWP_NOZORDER | Native.SWP_NOOWNERZORDER | Native.SWP_NOACTIVATE); });
		//var a3 = new Action(() => { Api.SetWindowPos(w, Wnd0, 0, 0, 0, 0, (vis ? Native.SWP_HIDEWINDOW: Native.SWP_SHOWWINDOW)|Native.SWP_NOMOVE|Native.SWP_NOSIZE|Native.SWP_NOZORDER|Native.SWP_NOOWNERZORDER|Native.SWP_NOACTIVATE|Native.SWP_NOSENDCHANGING); });

		//Perf.ExecuteMulti(5, 1000, a1, a2);

		Wnd[] a = new Wnd[10];
		var f = new Form();
		for(int i = 0; i < 10; i++) {
			var b = new Button();
			b.Location = new POINT(0, i * 20);
			b.Size = new SIZE(50, 18);
			f.Controls.Add(b);
			a[i] = (Wnd)b.Handle; Print(a[i]);
		}

		var a10 = new Action(() => { for(int j = 0; j < 10; j++) { w = a[j]; a3(); } });

		f.Click += (o, e) =>
		{
			Perf.ExecuteMulti(5, 10, a1, a10);
			//Perf.ExecuteMulti(5, 1000, a10);
		};

		f.ShowDialog();

	}

	static unsafe void TestRegistry()
	{
		bool ok;

		//Print(Registry_.CatkeysKey);

		//Print(Registry_.CanOpen(@"SOFTWARE\Microsoft"));
		//Print(Registry_.CanOpen(@"HKEY_CURRENT_USER\SOFTWARE\Microsoft"));
		//Print(Registry_.CanOpen(@"SOFTWARE\GinDi", Registry.CurrentUser));
		//Print(Registry_.CanOpen(@"GinDi", Registry.CurrentUser.OpenSubKey("SOFTWARE")));
		//Print(Registry_.CanOpen(null, Registry.CurrentUser.OpenSubKey("SOFTWARE")));
		//return;

		Print("---- int ----");

		Registry_.SetInt(5, "ii", "Test");

		ok = Registry_.GetInt(out int i, "ii", "Test");
		if(!ok) { Print("no"); return; }
		Print(i);

		Print("---- long ----");

		Registry_.SetLong(5, "LLL", "Test");

		ok = Registry_.GetLong(out long L, "LLL", "Test");
		if(!ok) { Print("no"); return; }
		Print(L);

		Print("---- string ----");

		Registry_.SetString("stttttttttttrrrrrr", "SSS", "Test");

		ok = Registry_.GetString(out string s, "SSS", "Test");
		if(!ok) { Print("no"); return; }
		Print(s);

		Print("---- multi string ----");

		Registry_.SetStringArray(new string[] { "one", "two", "three" }, "AAA", "Test");

		ok = Registry_.GetStringArray(out string[] a, "AAA", "Test");
		if(!ok) { Print("no"); return; }
		Print(a);

		Print("---- binary ----");

		var r = new RECT(1, 2, 3, 4, false);
		int n = Marshal.SizeOf(r);
		Registry_.SetBinary(&r, n, "BB", "Test");
		//Registry_.SetBinary(&r, n, "rect2", @"HKEY_CURRENT_USER\Test");
		//Registry_.SetBinary(&r, n, "rect2", @"HKEY_LOCAL_MACHINE\Software\Test");

		RECT r2;
		n = Registry_.GetBinary(&r2, n, "BB", "Test");
		Print(n);
		if(n == 0) { Print("no"); return; }
		Print(r2);
	}

	static void TestWndTransparency()
	{
		Wnd w = Wnd.Find("FileZilla");
		Wnd c = w.ChildById(-31781);
		Print(c);
		c.SetTransparency(true, 0.5);


		//Wnd.Find("Dialog").SetTransparency(true, 0.5, 0xFF);

		//Wnd w = Wnd.Find("*Notepad", "Notepad");
		////w = w.Child(15);
		//Print(w);
		////w.SetTransparency(true, null, 0);
		////w.SetTransparency(true, 0.3);
		////w.SetTransparency(true, 0.3, 0);
		////w.SetTransparency(true);
		//w.SetTransparency(false);
	}

	[ComImport, Guid("ea1afb91-9e28-4b86-90e9-9e9f8a5eefaf"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface ITaskbarList3
	{
		// ITaskbarList
		[PreserveSig]
		int HrInit();
	}

	static char[] TextFileToCharArray(string file)
	{
		try {
			using(var reader = new StreamReader(file)) {
				long n = reader.BaseStream.Length;
				if(n <= int.MaxValue / 4) {
					var s = new char[n];
					reader.Read(s, 0, (int)n);
					return s;
				}
			}
		}
		catch { }
		return null;
	}

	class Parser
	{
		char[] s, d; //source, destination
		int i, j, n; //index in source, in destination, length

		/// <summary>
		/// i must be at the starting ". Moves i to the ending ".
		/// </summary>
		void SkipString()
		{
			Debug.Assert(s[i] == '\"');
			for(++i; i < n; i++) {
				if(s[i] == '\"') {
					int k = i; while(s[k - 1] == '\\') k--;
					if((k & 1) == 0) break;
				} else d[j++] = s[i];
			}
		}
	}

	//static _StringFold(char s, int i, int )

	static void TestStringFold()
	{
		var s = TextFileToCharArray(@"c:\test\a.txt");
		if(s == null) return;

		int i = 0, j = 0, n = s.Length;
		var d = new char[n];

		for(; i < n; i++) {
			char c = s[i];
			switch(c) {
			case '\"':
				d[j++] = c;
				for(++i; i < n; i++) {
					if(s[i] == '\"') {
						int k = i; while(s[k - 1] == '\\') k--;
						if((k & 1) == 0) break;
					} else d[j++] = s[i];
				}
				break;
			}
		}

		Print(d, "");
	}

	static void TestStrToI()
	{
		var s = "1234567";
		//var s = "0xffffffff";
		var c = s.ToCharArray();

		unsafe
		{
			fixed (char* p = c) {
				Print(s.ToInt32_());
				char* t = p, e;
				Print(Api.strtoi(t, out e));
				Print(Api.strtoui(t, out e));
				Print(Api.strtoi64(t, out e));
				int n;
				Print(Api.strtoi(s, 0, out n)); Print(n);
				Print(Api.strtoui(s, 0, out n)); Print(n);
				Print(Api.strtoi64(s, 0, out n)); Print(n);

				var a1 = new Action(() => { s.ToInt32_(); });
				var a2 = new Action(() => { Api.strtoi(t, out e); });
				var a3 = new Action(() => { Api.strtoui(t, out e); });
				var a4 = new Action(() => { Api.strtoi64(t, out e); });
				var a5 = new Action(() => { Api.strtoi64(s, 0, out n); });

				Perf.ExecuteMulti(5, 1000, a1, a2, a3, a4, a5);
			}
		}
	}

	static void TestStrToI2()
	{
		//var s = "12 ";
		//int len;
		//Print(Api.strtoi(s, 0, out len));
		//Print(len);
		//Print(Api.strtoi(s));

		//Print(Api.strtoi("0x7ffffffe"));
		//Print(Api.strtoi("0x8ffffffe"));
		//Print(Api.strtoi("-0x8ffffffe"));
		//PrintHex(Api.strtoui("0xfffffffe"));
		//PrintHex(Api.strtoui("0xffffffff1"));
		//PrintHex(Api.strtoui("-2"));
		//PrintHex(Api.strtoui("-0x7fffffff"));
		//PrintHex(Api.strtoui("-0x80000000"));

		Print(Api.strtoi64("0x7ffffffffffffffe"));
		Print(Api.strtoi64("0x8000000000000000"));
	}

	static void TestRegexAgain()
	{
		//string p = @"(\d)\d+", r = "$1R";
		//string s = "aaa 45 fff 877 mmaaa 45 fff 877 mmaaa 45 fff 877 mmaaa 45 fff 877 mmaaa 45 fff 877 mmaaa 45 fff 877 mmaaa 45 fff 877 mmaaa 45 fff 877 mmaaa 45 fff 877 mmaaa 45 fff 877 mm";

		////Print(s.RegexReplace_(out s, p, r));
		////Print(s);

		//string s2 = null; int n = 0;
		//var a1 = new Action(() => { s2 = s.RegexReplace_(p, r); });
		//var a2 = new Action(() => { n = s.RegexReplace_(out s2, p, r); });

		//Perf.ExecuteMulti(5, 1000, a1, a2);

		//PrintList(n, s2);

		//var k = new UNS.TDARRAY();
		////k.a = new int[5];
		//k[0] = 5;
		//Print(k[0]);
	}

	public unsafe class UNS
	{
		public struct HASARRAY
		{
			//[MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)]
			public fixed int a[5];
			public fixed char s[5];
			//fixed public char s[5]; //error

			//public fixed POINT p[6]; //error
		}

		public struct USEHASARRAY
		{
			public HASARRAY* p;
		}


		[DllImport("user32.dll", SetLastError = true)]
		public static extern Wnd SetFocus2(Wnd hWnd);

		public struct TDARRAY
		{
			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 5)]
			public int[] a;

			public int this[int i] { get { return a[i]; } set { _Init(); a[i] = value; } }
			void _Init() { if(a == null) a = new int[5]; }
		}
	}

	static unsafe void TestFixedArrayMember()
	{
		//	PrintList(sizeof(UNS.HASARRAY), Marshal.SizeOf(typeof(UNS.HASARRAY)));

		//	var k = new UNS.HASARRAY();

		//	Print(k.a[0]);
		//	k.a[0]=5;
		//	Print(k.a[0]);

		//	//Print(k.a); //error
		//	//Print(k.s); //error

		//	//char[] s = k.s; //error
		//	k.s[0] = 'A';
		//	string s = new string(k.s, 0, 5);
		//	Print(s);
	}

	[DllImport(@"Q:\app\Catkeys\Test Projects\UnmanagedDll.dll", CallingConvention = CallingConvention.Cdecl)]
	static extern void TestSimple();

	[System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptions]
	[MethodImpl(MethodImplOptions.NoInlining)]
	public static void TestExceptions()
	{
		Print(1);
		try {
			TestSimple();
		}
		catch { Print("exc"); }
		Print(2);

	}

	[ComImport, Guid("3AB5235E-2768-47A2-909A-B5852A9D1868"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ITest
	{
		[PreserveSig]
		int Test1(int i);
		[PreserveSig]
		int TestOL(ref int i);
		[PreserveSig]
		int TestOL(string s);
		[PreserveSig]
		int TestNext(ref sbyte p);
	};

	[DllImport(@"Q:\app\Catkeys\Test Projects\UnmanagedDll.dll", CallingConvention = CallingConvention.Cdecl)]
	static extern ITest CreateTestInterface();

	static void TestInterfaceMethodOverload()
	{
		var x = CreateTestInterface();
		int k = 0; sbyte b = 0;
		x.TestOL(ref k);
		x.TestOL("ddd"); //calls TestNext

		//x.TestNext(ref b);
		Print("fin");
	}

	[DllImport(@"Q:\app\Catkeys\Test Projects\UnmanagedDll.dll", CallingConvention = CallingConvention.Cdecl)]
	//static extern void CreateTestInterface2(out ITest t);
	//static extern void CreateTestInterface2(out IntPtr t); //with Marshal.GetTypedObjectForIUnknown is missing 1 Release
	static extern void CreateTestInterface2([MarshalAs(UnmanagedType.IUnknown)] out object t); //the same number of QI etc as with 'out ITest t'
																							   //static extern void CreateTestInterface2(out IUnknown t); //more QI etc

	[ComImport, Guid("00000000-0000-0000-C000-000000000046")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	private interface IUnknown
	{
		//[PreserveSig]
		//IntPtr QueryInterface(ref Guid riid, out IntPtr pVoid);

		//[PreserveSig]
		//IntPtr AddRef();

		//[PreserveSig]
		//IntPtr Release();
	}

	static void TestOutAnyInterface()
	{
		ITest t; IntPtr p; object o; IUnknown u;

		//CreateTestInterface2(out t);

		//CreateTestInterface2(out p);
		//t=(ITest)Marshal.GetTypedObjectForIUnknown(p, typeof(ITest));

		//void* v = null;
		//t = (ITest)v;

		CreateTestInterface2(out o);
		//t = (ITest)o;
		t = o as ITest;

		//CreateTestInterface2(out u);
		//t = (ITest)u;

		t.Test1(4);

		Marshal.FinalReleaseComObject(t);
		t = null;
		Print("fin");
	}

	static void TestWndGetIcon()
	{
		//Wnd w = Wnd.Find("*Notepad");
		Wnd w = Wnd.Find("Calculator");
		if(w.Is0) { //on Win8 cannot find window, probably must be uiAccess. Find in QM and copy-paste.
			string s;
			if(!TaskDialog.ShowInput(out s, "hwnd")) return;
			w = (Wnd)(LPARAM)s.ToInt32_();
		}
		Print(w);
		IntPtr hi16 = Wnd.Misc.GetIconHandle(w);
		IntPtr hi32 = Wnd.Misc.GetIconHandle(w, true);
		PrintList(hi16, hi32);
		if(hi32 == Zero) return;
		var d = new TaskDialog("big icon");
		d.SetIcon(hi32);
		d.SetFooterText("small icon", hi16);
		d.ShowDialog();
		Api.DestroyIcon(hi16);
		Api.DestroyIcon(hi32);

		var a2 = new Action(() => { hi32 = Wnd.Misc.GetIconHandle(w, true); Api.DestroyIcon(hi32); });
		Perf.ExecuteMulti(5, 10, a2);
	}

	static void TestFileIcon()
	{
		//IntPtr hi = Files._IconCreateEmpty(16, 16);

		string s;

		//s = @"q:\app\qm.exe,-133";
		//int i = Files._IconGetIndex(ref s);
		//PrintList(i, s);
		//return;

		s = @"q:\app\paste.ico";
		s = @"q:\app\qm.exe";
		s = @"q:\app\qm.exe,1";
		s = @"q:\app\qm.exe,-133";
		s = @"q:\app\app.cpp";
		s = @".dll";
		s = "CatkeysTasks.exe";
		s = @"Properties\app.config";
		s = "http://ddd.com";
		s = @"shell:AppsFolder\Microsoft.WindowsCalculator_8wekyb3d8bbwe!App";
		//s = "Control Panel"; //no
		s = "::{20d04fe0-3aea-1069-a2d8-08002b30309d}";
		//s = "%TEMP%";
		//s = @"C:\Program Files\WindowsApps\Microsoft.WindowsCalculator_10.1605.1582.0_x64__8wekyb3d8bbwe\Calculator.exe";

		IntPtr hi = Icons.GetFileIconHandle(s, 32);
		//IntPtr hi = Files.GetIconHandle(Folders.VirtualITEMIDLIST.ControlPanelFolder, 32);
		Print(hi);
		if(hi == Zero) return;
		var d = new TaskDialog("text"); d.SetIcon(hi);
		Api.DestroyIcon(hi);
	}

	//static void TestCoord(int x, int y)
	//{
	//	Print("int");
	//}

	static void TestCoord(float x, float y)
	{
		PrintList("float", x > 0.0 && x < 1.1);
	}

	//static void TestCoord(double x, double y)
	//{
	//	Print("double");
	//}

	static void TestCoord()
	{
		//var w = Wnd.Find("*Notepad");
		//w.Activate();
		////w.Move(0.5f, 1f);
		////w.Resize(500, 200);
		//w.Resize(0.5f, 1f, true);

		//var w = Wnd.Find("Quick Macros *");
		//w.Activate();
		//w.Move(0.02f, 0.02f, 0.96f, 0.96f, true);
		////Print(w.ChildFromXY(0.97f, 100));
		////Print(w.ChildFromXY(0.3f, 1.05f, screenXY:true));
		//var c = w.ChildById(2212);
		//c.ZorderTop();
		//c.Move(0.1f, 0.1f, 0.8f, 0.8f);

		//var w = Wnd.Find(prop:new Wnd.WinProp() { x=100, y=0.5f});
		//Print(w);

		Print(Wnd.FromXY(0.5f, 0.99f, workArea: true));
	}

	//static IEnumerable<int> TestYield()
	//{
	//	for(int i=0; i<5; i++) {
	//		int k = ToInt("5");
	//		yield return i+k;
	//	}
	//}

	static unsafe void TestStringZeroTerm(string s)
	{
		fixed (char* p = s) {
			if((int)p[s.Length] != 0 || (int)p[s.Length + 1] != 0 || (int)p[s.Length + 2] != 0 || (int)p[s.Length + 3] != 0)
				PrintList((long)p, (int)p[s.Length], (int)p[s.Length + 1], (int)p[s.Length + 2], (int)p[s.Length + 3]);
		}
	}

	static void TestStringMisc()
	{
		//Print(int.Parse("+16"));

		//TestStringZeroTerm("aaaaaaaa");
		//TestStringZeroTerm("aabaaaaa");
		//TestStringZeroTerm("aacaaaaa");
		//TestStringZeroTerm("aadaaaaa");
		//TestStringZeroTerm($"aa{1}aaaaa");
		//TestStringZeroTerm($"aa{2}aaaaa");

		//for(int i=1; i<100000000; i++) {
		//	TestStringZeroTerm(new string('a', i&0xff));
		//      }
		//Print("fin");

		//foreach(int i in TestYield()) {
		//	Print(i);
		//}
		//Print("fin");

		//string s = "abc";
		//fixed(char* p= s)
		//{
		//	p[0] = 'A';
		//}
		//Print(s);

		//string s = "abc";
		//CharUpperBuff(s, 2);
		//Print(s);

		PrintList(int.MaxValue, uint.MaxValue, long.MaxValue, ulong.MaxValue);

		string s;
		s = "mm  18446744073709551615 kk";
		//s = "mm  9999999999999999999 kk";
		//s = "mm  0xFfffffffffffffff kk";

		s = "mm  4294967295 kk";
		//s = "mm  999999999 kk";
		//s = "mm  0xFfffffff kk";

		int iEnd;
		int R = s.ToInt32_(2, out iEnd);
		uint u = (uint)R;
		//long R = s.ToInt64_(2, out iEnd);
		//ulong u = (ulong)R;
		PrintList(s, R, u, iEnd);


		//int i1 = 0, i2 = 0, i3 = 0, i4=0;

		////i3 = ToInt(s);

		//Perf.SpinCPU(200);
		//Action a1 = new Action(() => { i1 = int.Parse(s); });
		//Action a2 = new Action(() => { i2 = s.ToInt_(); });
		//Action a3 = new Action(() => { i3 = ToInt(s); });
		//Action a4 = new Action(() => { i4 = ToInt2(s); });

		//Perf.ExecuteMulti(5, 1000, a1, a2, a3, a4);
		//PrintList(i1, i2, i3, i4);

	}

	static void TestWndMisc()
	{
		Wnd w;
		Wnd w2 = Wnd.Find("Quick*");
		//w = Wnd.Get.WndRoot;
		//Print(w);
		//w = Wnd.Get.Desktop;
		//Print(w);
		//w = Wnd.Get.DesktopListview;
		//Print(w);
		Print(w2.IsTopmost);

		Action a1 = new Action(() => { w = Wnd.Misc.WndRoot; });
		Action a2 = new Action(() => { w = Wnd.Misc.WndDesktop; });
		Action a3 = new Action(() => { w = Wnd.Misc.WndDesktopControl; });
		Action a4 = new Action(() => { bool fs = w2.IsFullScreen; });
		Perf.ExecuteMulti(5, 1000, a1, a2, a3, a4);

		//w = Wnd.Find("Quick*");
		//w = Wnd.Find("My QM");
		//w = Wnd.Get.Desktop;
		//w = Wnd.Get.DesktopListview;
		//w = Wnd.Find("* Firefox");
		//w = Wnd.Get.WndRoot;
		////w = Wnd.Get.WndShell;
		//w = Wnd.Find("*- Google Chrome");
		//Print(w);
		////PrintList(w.IsOfShellThread, w.IsOfShellProcess);
		//Print(w.IsFullScreen);

		//while(true) {
		//	Wait(1);
		//	w = Wnd.FromMouse(false);
		//	if(w.ClassNameIs("WorkerW")) break;
		//	Print(w);
		//	PrintList(w.IsFullScreen, w.Rect);
		//}
	}

#region TestWndRegisterClass
	static Wnd.Misc.WindowClass _wndRC, _wndRCSuper;
	static void TestWndRegisterClass()
	{
		_wndRC = Wnd.Misc.WindowClass.Register("Cat_Test", Cat_Test_WndProc, IntPtr.Size/*, Api.CS_GLOBALCLASS*/);
		Wnd w = Api.CreateWindowEx(0, _wndRC.Name, _wndRC.Name, Native.WS_OVERLAPPEDWINDOW | Native.WS_VISIBLE, 300, 100, 300, 200, Wnd0, 0, Zero, 0);
		if(w.Is0) return;

		_wndRCSuper = Wnd.Misc.WindowClass.Superclass("Edit", "Edit_Super", Cat_Test_WndProcSuper, IntPtr.Size);
		Wnd w2 = Api.CreateWindowEx(0, _wndRCSuper.Name, _wndRCSuper.Name, Native.WS_CHILD | Native.WS_VISIBLE, 0, 0, 200, 30, w, 3, Zero, 0);
		if(w2.Is0) return;

		//Print(Wnd.WindowClass.GetClassAtom("Cat_Test", Api.GetModuleHandle(null)));

		//Api.SetTimer(w, 1, 1000, null);

		Native.MSG m;
		while(Api.GetMessage(out m, Wnd0, 0, 0) > 0) {

			//if(m.message == Api.WM_TIMER && m.hwnd==w) {
			//	Print("timer");
			//	GC.Collect();
			//}

			Api.TranslateMessage(ref m);
			Api.DispatchMessage(ref m);
		}
	}
	static LPARAM Cat_Test_WndProc(Wnd w, uint msg, LPARAM wParam, LPARAM lParam)
	{
		switch(msg) {
		case Api.WM_DESTROY:
			Api.PostQuitMessage(0);
			break;
		case Api.WM_CREATE:
			_wndRC.SetMyLong(w, 1);
			break;
		case Api.WM_LBUTTONDOWN:
			Print(_wndRC.GetMyLong(w));
			break;
		}

		return Api.DefWindowProc(w, msg, wParam, lParam);
	}
	static LPARAM Cat_Test_WndProcSuper(Wnd w, uint msg, LPARAM wParam, LPARAM lParam)
	{
		switch(msg) {
		case Api.WM_DESTROY:
			return Api.DefWindowProc(w, msg, wParam, lParam);
		case Api.WM_CREATE:
			_wndRCSuper.SetMyLong(w, 2);
			break;
		case Api.WM_LBUTTONDOWN:
			Print(_wndRCSuper.GetMyLong(w));
			break;
		}

		return Api.CallWindowProc(_wndRCSuper.BaseClassWndProc, w, msg, wParam, lParam);
	}
#endregion

	static void TestIsGhost()
	{
		Wnd w = Wnd.Find("Hung");
		Print(w);
		Print(w.IsHung);
		w = Wnd.Find("Hung*", "Ghost");
		Print(w);
		PrintList(w.IsHung, w.IsHungGhost);

		//bool y;
		//var a1 = new Action(() => { y = w.ClassNameIs("Ghost"); });
		//var a2 = new Action(() => { y = w.ProcessName.Equals_("DWM", true); });
		//var a3 = new Action(() => { y = w.IsHung; });
		//Perf.ExecuteMulti(5, 100, a1, a2, a3);

		//Perf.SpinCPU(100);
		//var a = Wnd.AllWindows(null, true);
		//foreach(Wnd t in a) {
		//	Print(t);
		//	Perf.First();
		//	y = t.IsHung;
		//	Perf.Next();
		//	y=t.ClassNameIs("Ghost");
		//	Perf.NW();
		//}
	}

	static void TestWndGetPropList()
	{
		foreach(Wnd w in Wnd.Misc.AllWindows(true)) {
			Print(w);
			foreach(var k in w.PropList()) {
				Print(k);
			}
			Print("---------");
		}
	}

	static void TestWndMapPoints()
	{
		Wnd w = Wnd.Find("", "QM_Editor");
		Print(w);
		RECT r = new RECT(1, 2, 3, 4, false);
		RECT rr;
		rr = r; w.MapClientToScreen(ref rr);
		Print(rr);
		rr = r; w.MapScreenToClient(ref rr);
		Print(rr);

		Wnd c = w.Child("", "QM_Code");
		Print(c);
		//rr = c.Rect;
		rr = r; c.MapClientToClientOf(w, ref rr);
		Print(rr);

		c.GetRectInClientOf(w, out rr);
		Print(rr);

		Print(Wnd.FromXY(1460, 1400));

		//rr = r; c.MapClientToClientOf(w, ref rr);
		//Print(rr);
		//rr = r; c.MapClientToClientOf(w, ref rr);
		//Print(rr);
		POINT p = new POINT(1, 2), pp;
		pp = p; w.MapClientToWindow(ref pp);
		Print(pp);
		pp = p; w.MapWindowToClient(ref pp);
		Print(pp);

		rr = r; w.MapClientToWindow(ref rr);
		Print(rr);
		rr = r; w.MapWindowToClient(ref rr);
		Print(rr);

		Print(Wnd.FromMouse().MouseClientXY);
	}

	static void TestWndIsAbove()
	{
		Wnd w1 = Wnd.Find("", "QM_Editor");
		Wnd w2 = Wnd.Find("", "CabinetWClass");
		PrintList(w1.ZorderIsBefore(w2), w2.ZorderIsBefore(w1));
	}

	static void TestWndSetParent()
	{
		//note: SetParent removed, it did not work well, anyway probably will need to change parent only of form controls, then Form.Parent should be used and works well, even with topmost windows.

		//Wnd w1 = Wnd.Find("", "QM_Editor");
		//Wnd w2 = w1.Child("Running items");
		//Wnd w3 = w2.WndDirectParentOrOwner;
		//Print(w3);

		//PrintList("SetParent", w2.SetParent(Wnd0));
		//TaskDialog.Show("");
		//PrintList("SetParent", w2.SetParent(w3));

		var f = new Form();
		var b = new Button();
		f.Controls.Add(b);

		f.Click += (o, e) =>
		{
			Form f2 = null;
			f2 = new Form();
			f2.Show();
			f2.Left = 500;
			((Wnd)f).ZorderTopmost();
			//Print(b.Handle);

			b.Parent = f2;
			//Print(b.Handle);
			//Wnd w = (Wnd)b;
			//w.SetParent(Wnd0, true);
			TaskDialog.Show("");
			b.Parent = f;
			//w.SetParent((Wnd)f, true);

			f2.Close();
		};

		f.ShowDialog();
	}

	static void TestWndBorder()
	{
		Wnd w = Wnd.Find("", "QM_Editor");
		//w = Wnd.Find("", "QM_Toolbar");
		Print(w);
		Print(Wnd.Misc.BorderWidth(w));
		Print(Wnd.Misc.BorderWidth(w.Style, w.ExStyle));

		RECT r = w.ClientRect;
		Print(r);
		Wnd.Misc.WindowRectFromClientRect(ref r, w.Style, w.ExStyle, false);
		Print(r);
	}

	static void TestWndStoreApp()
	{
		foreach(Wnd w in Wnd.Misc.AllWindows()) {
			bool isWin8Metro = w.IsWindows8MetroStyle;
			int isWin10StoreApp = w.IsWindows10StoreApp;
			string prefix = null, suffix = null;
			if(isWin8Metro || isWin10StoreApp != 0) { prefix = isWin8Metro ? "<><c 0xff>" : "<><c 0xff0000>"; suffix = "</c>"; }
			Print($"{prefix}metro={isWin8Metro}, win10={isWin10StoreApp}, cloaked={w.IsCloaked},    {w.ProcessName}  {w}  {w.Rect}{suffix}");
		}
	}

	static void TestWndControlCast()
	{
		var f = new Form();

		f.Click += (o, e) =>
		{
			if(true) {
				var b = new Button();
				f.Controls.Add(b);
				Wnd t = (Wnd)b;
				var c = (Control)t;
				Print(c == null); //False
			} else {
				Wnd t = Api.CreateWindowEx(0, "Edit", "Edit", Native.WS_CHILD | Native.WS_VISIBLE, 0, 0, 200, 30, (Wnd)f, 3, Zero, 0);
				if(t.Is0) return;
				var c = (Control)t;
				Print(c == null); //True
								  //Print(c.Bounds);
				f.Controls.Add(c);
			}
		};

		f.ShowDialog();

	}

	static void TestWndRect()
	{
		//var w=Wnd.Find("*Notepad");
		var w = Wnd.Find("Options");
		w = w.Child("OK");
		Print(w);
		RECT r;

		r = w.Rect;
		Print(r);
		//w.Rect = new RECT(100, 1300, 300, 500, true);
		//w.Rect = new RECT(100, 320, 80, 50, true);

		r = w.ClientRect;
		Print(r);
		//r.Inflate(2, 2); w.ClientRect=r;

		//r =w.ClientRectInScreen;
		//Print(r);
		//w.ClientRectInScreen = new RECT(100, 320, 80, 50, true);

		//r.Inflate(2, 2);
		//w.ClientRectInScreen = r;

		r = w.RectInParent;
		Print(r);
	}

	static void TestWndMoveMisc()
	{
		var w = Wnd.Find("*Notepad");
		//w.Move(200, 1500, 400, 200);

		//w.MoveToScreenCenter(2);
		w.MoveInScreen(-100, -20, 2);
		w.ActivateLL();
	}

	static void _TestWndZorder(Wnd w, Wnd w2)
	{
		//Print(w.ZorderTop());
		//Print(w.ZorderBottom());

		//Print(w.ZorderTopmost());
		////TaskDialog.Show("");
		//Wait(1);
		//Print(w.ZorderNotopmost(true));
		////Print(w.ZorderBottom());

		Print(w.ZorderBelow(w2));
		w2.ActivateLL(); Thread.Sleep(500);
		Print(w.ZorderAbove(w2));

	}

	static void TestWndZorder()
	{
		var w = Wnd.Find("*Notepad");
		//var w = Wnd.Find("*WordPad");
		//var w = Wnd.Find("Options");
		//var w = Wnd.Find("Font");
		//var w = Wnd.Find("", "QM_Editor");
		var w2 = Wnd.Find("* - Paint");
		//PrintList(w, w2);

		_TestWndZorder(w, w2);

		//var f = new Form();
		//f.Click += (o, e) =>
		//{
		//	_TestWndZorder((Wnd)f.Handle);
		//      };
		//f.ShowDialog();
	}

	static void TestWndIsUacDenied()
	{
		//var w = Wnd.Find("*Notepad");
		var w = Wnd.Find("", "QM_Editor");
		//var w = Wnd.Find("Calculator");
		//w = w.Child("", "Windows.UI.Core.*");
		if(w.Is0) {
			int i;
			if(!TaskDialog.ShowInput(out i, "Handle")) return;
			w = (Wnd)(LPARAM)i;
		}

		Print(w);
		Print(w.IsUacAccessDenied);
		//PrintList(w.IsUacAccessDenied, w.IsUacAccessDenied2);
		//Print(w.SetProp("abc", 1)); //fails
		//Print(w.RemoveProp("abcde"));
		//Print(w.SetWindowLong());
		//Print(w.)


		//var a1 = new Action(() => { bool b = w.IsUacAccessDenied; });
		//var a2 = new Action(() => { bool b = w.IsUacAccessDenied2; });
		//Perf.ExecuteMulti(5, 1000, a1, a2);
	}

	static void TestTaskDialogActivationEtc()
	{
		Wait(3);
		//Script.Option.TopmostIfNoOwnerWindow = true;
		//Script.Option.dialogAlwaysActivate = true;
		//Print(Wnd.AllowActivate());
		//Print(Wnd.Find("*Notepad").ActivateLL());
		//Wait(1);
		//Print(Wnd.ActiveWindow);
		TaskDialog.Show("test");
		//Wait(3);
	}

	static void TestWndFindFast()
	{
		Wnd w = Wnd0;
		for(;;) {
			w = Wnd.FindFast(null, "QM_Toolbar", w);
			if(w.Is0) break;
			Print(w);
		}
		Print(Wnd.FindFast(null, "QM_Editor").ChildFast(null, "QM_Scc"));
	}

	static void TestWndGetGUIThreadInfo()
	{
		Wait(3);
		Print(Wnd.WndFocused);
		RECT r;
		Print(Input.GetTextCursorRect(out r));
		Print(r);
	}

	static class TestStaticInitClass
	{
		static int _x = _InitX();
		static int _InitX() { DebugPrintFunc(); return 1; }
		public static int GetX()
		{
			DebugPrintFunc();
			return _x;
		}
		public static int Other()
		{
			DebugPrintFunc();
			return -1;
		}
	}

	static void TestStaticInit1()
	{
		DebugPrintFunc();
		Print(TestStaticInitClass.GetX());
	}

	static void TestStaticInit2()
	{
		DebugPrintFunc();
		Print(TestStaticInitClass.Other());
	}

	static string BytesToHexString_BitConverter(byte[] a)
	{
		return BitConverter.ToString(a).Replace("-", "");
	}

	static void TestHash()
	{
		Perf.SpinCPU(100);

		//var b = new byte[] { 0, 1, 0xA, 0xF, 0xBE, 0x59 };
		//string s;
		//s = Calc.BytesToHexString(b);
		//Print(s);
		////s = Calc.BytesToHexString2(b);
		////Print(s);
		//s = BytesToHexString_BitConverter(b);
		//Print(s);

		//var a1 = new Action(() => { s = BytesToHexString_BitConverter(b); });
		//var a2 = new Action(() => { s = Calc.BytesToHexString(b); });
		////var a3 = new Action(() => { s = Calc.BytesToHexString2(b); });
		//Perf.ExecuteMulti(5, 1000, a1, a2);


		//var b = new byte[] { 0, 1, 0xA, 0xF, 0xBE, 0x59, 0, 0xff, 0x58, 0xD7, 0, 1, 0xA, 0xF, 0xBE, 0x59, 0, 0xff, 0x58, 0xD7 };
		//var s = Calc.BytesToHexString(b);
		//Print(s);
		//Print(Calc.BytesToHexString(Calc.BytesFromHexString(s)));
		//string sB64 = Convert.ToBase64String(b);
		//Print(sB64);
		//Print(Convert.ToBase64String(Convert.FromBase64String(sB64)));

		//var a1 = new Action(() => { Calc.BytesToHexString(b); });
		//var a2 = new Action(() => { Calc.BytesFromHexString(s); });
		//var a3 = new Action(() => { Convert.ToBase64String(b); });
		//var a4 = new Action(() => { Convert.FromBase64String(sB64); });
		//Perf.ExecuteMulti(5, 1000, a1, a2, a3, a4);


		string s = @"Q:\app\catkeys\tasks\CatkeysTasks.exe";
		string hash;
		Perf.First();
		hash = Convert_.HashMD5Hex(s);
		Perf.NW(); //1700 (.NET 3700)
		Print(hash);
		hash = Convert_.HashHex(s, "MD5");
		Print(hash);
		hash = Convert_.HashHex(s, "SHA256");
		Print(hash);
		int hashInt = Convert_.HashFnv1(s);
		Print(hashInt);
		unsafe { fixed (char* p = s) { hashInt = Convert_.HashFnv1(p, s.Length); } }
		Print(hashInt);
		unsafe { fixed (char* p = s) { hashInt = Convert_.HashFnv1((byte*)p, s.Length * 2); } }
		Print(hashInt);

		byte[] a = Encoding.UTF8.GetBytes(s);

		var a1 = new Action(() => { hash = Convert_.HashMD5Hex(s); }); //440 (QM2 350, .NET 2000 with static var, 4000 with local var)
		var a2 = new Action(() => { hash = Convert_.HashHex(s, "MD5"); }); //4200
		var a3 = new Action(() => { hash = Convert_.HashHex(s, "SHA256"); }); //2500
		var a4 = new Action(() => { hash = Convert_.HashMD5Hex(a); }); //320
		var a5 = new Action(() => { hashInt = Convert_.HashFnv1(s); }); //40
		var a6 = new Action(() => { unsafe { fixed (char* p = s) { hashInt = Convert_.HashFnv1((byte*)p, s.Length * 2); } } }); //84 (40 if no *2)
		Perf.ExecuteMulti(5, 1000, a1, a2, a3, a4, a5, a6);
	}

	static void TestNewPerf()
	{
		Perf.SpinCPU(100);

		//Perf.First();
		//Thread.Sleep(1);
		//Perf.Next();
		//Thread.Sleep(10);
		//Perf.NW();

		var t = new Perf.Inst();
		var t2 = new Perf.Inst();
		for(int j = 0; j < 5; j++) {
			t.First();
			for(int i = 0; i < 1000; i++) { t2.First(); }
			t.Next();
			for(int i = 0; i < 1000; i++) { t2.First(); t2.Next(); }
			t.Next();
			for(int i = 0; i < 1000; i++) { Perf.First(); }
			t.Next();
			for(int i = 0; i < 1000; i++) { Perf.First(); Perf.Next(); }
			t.Next();
			t.Write();
		}
	}

#region test timer

	static void TestTimer()
	{
		//Time.SetTimer(1000, (t, p) => { Print(1); });
		Perf.First();
		//Timer_.Every(1000, t => { Print(t.Tag); Application.ExitThread(); }, "test 1");
		//Timer_.After(1000, t => { Print(t.Tag); }, "test 1");
		//Perf.Next();
		//Timer_.After(1100, t => { Print(t.Tag); Application.ExitThread(); }, "test 2");

		//Api.SetTimer(Wnd0, 1, 1000, (w, m, i, t)=>{ Api.KillTimer(w, i); Print(1); Application.ExitThread(); });
		//Perf.Next();
		//Api.SetTimer(Wnd0, 1, 900, (w, m, i, t)=>{ Api.KillTimer(w, i); Print(2); });

		//var t=new System.Threading.Timer()

		//var comp = new Container();
		//Perf.Next();
		//var t = new System.Windows.Forms.Timer(comp);
		//t.Tick += (s, d) => { Print(1); Application.ExitThread(); };
		//t.Interval = 1000; t.Start();
		//Perf.Next();
		//var tt = new System.Windows.Forms.Timer(comp);
		//tt.Tick += (s, d) => { Print(2); };
		//tt.Interval = 900; tt.Start();

		//var t1=Timer_.After(1000, t => { Print(t.Tag); }, "test 1");
		//Perf.Next();
		//var t2=Timer_.After(1100, t => { Print(t.Tag); Application.ExitThread(); }, "test 2");

		Timer_.Every(1100, t => { Print(t.Tag); Application.ExitThread(); }, "test 2");
		//GC.Collect();

		//t1.Stop();
		//t2.Tag = "new tag";
		//t2.Start(5000, true);

		Perf.NW();
		//PrintList(t1, t2);
		//Application.Run();
		TaskDialog.Show("message loop");

	}

	static void _StartFormsTimer()
	{
		var t = new System.Windows.Forms.Timer();
		t.Interval = 1000;
		t.Tick += (a, b) => Print("tick");
		t.Start();
	}

	static void TestTimerThread()
	{
		//Time.Timer_ u = null;

		var T = new Thread(() =>
		{
			Timer_.After(1000, t => { Print(t.Tag); }, "test 2");
			//Timer_.After(1000, t => { Print(t.Tag); t.Start(1000, true); }, "test 2");
			//u=Timer_.Every(1000, t => { Print(t.Tag); }, "test 2");
			//_StartFormsTimer();

			//u.Start(3000, false);
			//u.Stop();

			GC.Collect();
			TaskDialog.Show("timer thread");
			GC.Collect();
			//TaskDialog.Show("timer thread");
		});
		T.Start();
		T.Join(1500);
		//u.Stop(); //test assert
		T.Join();
		Print("thread ended");
		Thread.Sleep(1000);
		//u = null;
		GC.Collect();
		TaskDialog.Show("main thread");

	}

#endregion

#region test async

	static Task<int> SomeOperationAsync2()
	{
		return Task.Run(() => { Thread.Sleep(800); return 5; });
	}

	static async Task<int> SomeOperationAsync()
	{
		return await SomeOperationAsync2();
	}

	static async void TestAsyncAsync()
	{
		int timeout = 1000;
		var task = SomeOperationAsync2();
#if true
		await task;
		Print(task.Result);
#else //test with timeout
		if(await Task.WhenAny(task, Task.Delay(timeout)) == task) {
			Print(task.Result);
		} else {
			Print("timeout");
		}
#endif
	}

	static void TestAsync()
	{
		Perf.First();
		TestAsyncAsync();
		Perf.NW();
		Print("END");
		TaskDialog.Show("waiting");
	}

#endregion

#region test native thread

	public delegate uint PTHREAD_START_ROUTINE(IntPtr lpThreadParameter);
	[DllImport("kernel32.dll")]
	public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, LPARAM dwStackSize, PTHREAD_START_ROUTINE lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out uint lpThreadId);

	[Flags]
	public enum COINIT :uint
	{
		COINIT_APARTMENTTHREADED = 0x2,
		COINIT_MULTITHREADED = 0x0,
		COINIT_DISABLE_OLE1DDE = 0x4,
		COINIT_SPEED_OVER_MEMORY = 0x8
	}

	[DllImport("ole32.dll", PreserveSig = true)]
	public static extern int CoInitializeEx(IntPtr pvReserved, COINIT dwCoInit);
	[DllImport("ole32.dll")]
	public static extern void CoUninitialize();

	static Thread _iconThread;

	static uint _ThreadProc(IntPtr param)
	{
		CoInitializeEx(Zero, COINIT.COINIT_APARTMENTTHREADED | COINIT.COINIT_DISABLE_OLE1DDE); //if before Thread.CurrentThread etc, then Thread.GetApartmentState will get STA. Without this .NET would make MTA.
		_iconThread = Thread.CurrentThread; //tested: it seems this auto-creates and correctly initializes .NET Thread object etc. Sets IsBackground true.

		//Print(_iconThread.IsBackground);
		//_iconThread.IsBackground = false;
		//Print(_iconThread.GetApartmentState());
		//Print(_iconThread.ThreadState);

		TaskDialog.Show("thread");
		//Wait(30);

		return 0;
	}

	static PTHREAD_START_ROUTINE _threadProc = _ThreadProc;

	static void TestNativeThread()
	{
		//This works, but probably not useful.
		//It would be useful only if we want to share the thread between appdomains.
		//But it is probably impossible because .NET ends threads when the appdomain exits. Also deletes the delegate.
		//To share a thread, create it in default appdomain.

		uint tid;
		var ht = CreateThread(Zero, 0, _threadProc, Zero, 0, out tid);
		PrintList(ht, tid);
		if(ht == Zero) return;
		Api.CloseHandle(ht);
		TaskDialog.ShowEx("main", y: -300);
	}

#endregion

	static void TestExpandPath()
	{
		string s1 = @"Q:\app\Catkeys\Tasks\System.Collections.Immutable.dll";
		string s2 = @"%ProgramFiles%\Quick Macros 2\qm.exe";

		string r1 = null, r2 = null, r3 = null, r4 = null;

		//Print(ExpandPath(s2)); return;

		var a1 = new Action(() => { r1 = Environment.ExpandEnvironmentVariables(s1); });
		var a2 = new Action(() => { r2 = Environment.ExpandEnvironmentVariables(s2); });
		var a3 = new Action(() => { r3 = Path_.ExpandEnvVar(s1); });
		var a4 = new Action(() => { r4 = Path_.ExpandEnvVar(s2); });
		Perf.ExecuteMulti(5, 1000, a1, a2, a3, a4);

		Print(r1);
		Print(r2);
		Print(r3);
		Print(r4);
	}

	static void TestAssoc()
	{
		//var s = Files.Misc.GetFileTypeOrProtocolRegistryKey(".txt");
		//var s = Files.Misc.GetFileTypeOrProtocolRegistryKey(".cs");
		//var s = Files.Misc.GetFileTypeOrProtocolRegistryKey("http:");
		//var s = Files.Misc.GetFileTypeOrProtocolRegistryKey("http://hdhdhdh");
		//var s = Files.Misc.GetFileTypeOrProtocolRegistryKey("shell:hdhdhdh");
		//var s = Files.Misc.GetFileTypeOrProtocolRegistryKey("c:\\file.bmp");
		//var s = Files.Misc.GetFileTypeOrProtocolRegistryKey("invalid");
		//if(s != null) Print(s); else Print("null");
	}

	static void TestSearchPath()
	{
		string s = null;
		//s = "pythonwin.exe";
		//s = "blend.exe";
		//s = "cmmgr32.exe";
		//s = "excel.exe";
		//s = "mip.exe";
		//s = "tests.exe";
		//s = "notepad.exe";
		//s = "calc.exe";
		//s = "typescript.js"; //in PATH
		//Environment.CurrentDirectory = @"q:\app";
		//s = "qmdd.exe";
		//s = "csc.exe";
		//s = @"C:\windows";
		//s = @"C:\windows\system32\notepad.exe";
		//s = @"%SystemRoot%\system32\notepad.exe";
		//s = @"%SystemRoot%";
		s = @"\\q7c\q\downloads";
		s = @"\\q7c\q";
		s = @"q:\";
		s = @"q:";
		s = ":: {jfjfjfjf}";
		s = @"http://www.quickmacros.com";
		s = "notepad"; //not found, its OK

		var r = Files.SearchPath(s);
		//var r =Files.SearchPath(s, @"q:\app");
		if(r != null) Print(r); else Print("not found");
	}

	static void TestSynchronizationContext1()
	{
		//WindowsFormsSynchronizationContext.AutoInstall = false;
		//Print(WindowsFormsSynchronizationContext.AutoInstall);

		Print(SynchronizationContext.Current);
		//Timer_.After(100, t =>
		//{
		//	Print(SynchronizationContext.Current);
		//	Application.ExitThread();
		//});
		//Application.Run();
		//var f = new Form();
		//Print(SynchronizationContext.Current);
		//SynchronizationContext.Current.Post(state => { PrintList("posted", SynchronizationContext.Current); }, null);
		Timer_.After(1, t => { PrintList("posted", SynchronizationContext.Current); });
		Thread.Sleep(100);
		//WindowsFormsSynchronizationContext.AutoInstall = false;
		Print(1);
		Application.DoEvents();
		Print(2);
		Print(SynchronizationContext.Current);
	}

	static void TestSynchronizationContext2()
	{
		PrintList("main 1", SynchronizationContext.Current);
		var f = new Form();
		PrintList("main 2", SynchronizationContext.Current);
		WindowsFormsSynchronizationContext.AutoInstall = false;

		var thread = new Thread(() =>
		{
			PrintList("thread 1", SynchronizationContext.Current);
			var ff = new Form();
			PrintList("thread 2", SynchronizationContext.Current);
		});
		thread.SetApartmentState(ApartmentState.STA);
		thread.Start();
		thread.Join();
	}

	//static void TestSynchronizationContext3()
	//{
	//	//Application.DoEvents();
	//	//var f = new Form();
	//	PrintList(SynchronizationContext.Current, WindowsFormsSynchronizationContext.AutoInstall);
	//	using(new Util.LibEnsureWindowsFormsSynchronizationContext()) {
	//		PrintList(SynchronizationContext.Current, WindowsFormsSynchronizationContext.AutoInstall);
	//		Application.DoEvents();
	//		PrintList(SynchronizationContext.Current, WindowsFormsSynchronizationContext.AutoInstall);
	//	}
	//	PrintList(SynchronizationContext.Current, WindowsFormsSynchronizationContext.AutoInstall);
	//}

	static void TestInterDomain()
	{
		//var d=Util.AppDomain_.GetDefaultDomain();
		////var s = d.GetData("testData") as string;
		////if(s == null) d.SetData("testData", $"dddata {8}");
		//var s = d.GetData("testData") as List<int>;
		//if(s == null) d.SetData("testData", new List<int> { 1, 2, 3 });
		//Print(s);

		//string s = InterDomain.GetVariable("str") as string;
		//if(s==null) InterDomain.SetVariable("str", "VALUE");
		//Print(s);

		//int? i = InterDomain.GetVariable("str") as int?;
		//if(i==null) InterDomain.SetVariable("str", 55);
		//Print(i);
		//i = 8;

		//var a = InterDomain.GetVariable("list") as List<int>;
		//if(a == null) InterDomain.SetVariable("list", new List<int> { 1, 2, 3 });
		//Print(a);
		//a.Add(100);

		//var a = InterDomain.GetVariable("list") as string[];
		//if(a == null) InterDomain.SetVariable("list", new string[] { "one","two","three" });
		//Print(a);

		//var a = InterDomain.GetVariable("list") as Dictionary<int, string>;
		//if(a == null) {
		//	var b = new Dictionary<int, string>();
		//	b.Add(5, "gg"); b.Add(6, "hh");
		//	InterDomain.SetVariable("list", b);
		//}
		//Print(a);

		//InterDomain.SetVariable("{D6349CB1-0E29-4AFC-B172-2A1D3CCB8A32}", "vvvvv");
		//Print(InterDomain.GetVariable("{D6349CB1-0E29-4AFC-B172-2A1D3CCB8A32}"));

		//var a1 = new Action(() => { Environment.SetEnvironmentVariable("EnvironmentVariable", "valuevaluevalue"); string s = Environment.GetEnvironmentVariable("EnvironmentVariable"); });
		//var a2 = new Action(() => { InterDomain.SetVariable("InterDomainVariable", "valuevaluevalue"); string s = InterDomain.GetVariable("InterDomainVariable") as string; });
		//Perf.ExecuteMulti(5, 1000, a1, a2);

		//var k = new InterDomainData(10, "test");
		//PrintList(k._i, k._s);
		//InterDomain.SetVariable("k", k);
		//var b = InterDomain.GetVariable("k") as InterDomainData;
		//PrintList(b._i, b._s);

		//var b = InterDomain.GetVariable("k") as InterDomainData;
		//if(b == null) {
		//	Print("null");
		//	var k = new InterDomainData(10, "test");
		//	InterDomain.SetVariable("k", k);
		//	k._i = 11;
		//} else PrintList(b._i, b._s);

		//var k = new InterDomainData(10, "test");
		//InterDomain.SetVariable("k", k);

		//var o = InterDomain.Get2("test");
		//if(o == null) { Print("null"); InterDomain.Set2("test", "kkk"); }
		//Print(o);

		//string x;
		//if(InterDomain.Get3("nm", out x)) Print(x);
		//else { Print("no"); InterDomain.Set3("nm", "DATA"); }
		////else { Print("no"); InterDomain.Set3("nm", (string)null); }

		//int x;
		//if(InterDomain.GetVariable("nm", out x)) Print(x);
		//else { Print("no"); InterDomain.SetVariable("nm", 8); }
		//else { Print("no"); InterDomain.SetVariable("nm", "DATA"); }
		//else { Print("no"); InterDomain.SetVariable("nm", null); }

		//var a1 = new Action(() => { Environment.SetEnvironmentVariable("EnvironmentVariable", "valuevaluevalue"); string s = Environment.GetEnvironmentVariable("EnvironmentVariable"); });
		//var a2 = new Action(() => { InterDomain.SetVariable("InterDomainVariable", "valuevaluevalue"); string s = InterDomain.GetVariable("InterDomainVariable") as string; });
		//var a3 = new Action(() => { InterDomain.Set2("InterDomainVariable2", "valuevaluevalue"); string s = InterDomain.Get2("InterDomainVariable2") as string; });
		//var k = new Dictionary<string, object>();
		//var a4 = new Action(() => { k["InterDomainVariable"]="valuevaluevalue"; string s = k["InterDomainVariable"] as string; });
		//var a5 = new Action(() => { InterDomain.Set3("InterDomain_int1", 5); int s; InterDomain.Get3("InterDomain_int1", out s); });
		//var a6 = new Action(() => { InterDomain.Set2("InterDomain_int2", 5); int s = (int)InterDomain.Get2("InterDomain_int2"); });
		//var a7 = new Action(() => { InterDomain.SetVariable("InterDomain_int3", 5); int s = (int)InterDomain.GetVariable("InterDomain_int3"); });
		////var a8 = new Action(() => { InterDomain.Set2("InterDomain_int4", 5); object s; InterDomain.TryGet("InterDomain_int4", out s); });
		////var a9 = new Action(() => { InterDomain.Set2("InterDomain_int5", 5); int s; InterDomain.Get4("InterDomain_int5", out s); });
		//Perf.ExecuteMulti(5, 1000, a1, a2, a3, a4, a5, a6, a7/*, a8, a9*/);


		//POINT x;
		//if(InterDomain.GetVariable("nm", out x)) Print(x);
		//else { Print("no"); InterDomain.SetVariable("nm", new POINT(5,6)); }

		//IntPtr x;
		//if(InterDomain.GetVariable("nm", out x)) Print(x);
		//else { Print("no"); InterDomain.SetVariable("nm", new IntPtr(6)); }

		//LPARAM x;
		//if(InterDomain.GetVariable("nm", out x)) Print(x);
		//else { Print("no"); InterDomain.SetVariable("nm", (LPARAM)9); }

		//Wnd x;
		//if(InterDomain.GetVariable("nm", out x)) Print(x);
		//else { Print("no"); InterDomain.SetVariable("nm", Wnd.FindFast("QM_Editor")); }

		//InterDomainData x;
		//if(InterDomain.GetVariable("nm", out x)) Print(x._s);
		//else { Print("no"); InterDomain.SetVariable("nm", new InterDomainData(5, "five")); }

		//TODO: move TDx to TaskDialog. Or not.

		//PrintList("before", AppDomain.CurrentDomain.IsDefaultAppDomain());
		//var x = InterDomain.DefaultDomainVariable("goo", () => { PrintList("delegate", AppDomain.CurrentDomain.IsDefaultAppDomain()); return new InterDomainData(5, "fff"); });
		InterDomainData x, y, z;
		Perf.First();
		InterDomain.DefaultDomainVariable("goox", out x);
		Perf.Next();
		InterDomain.DefaultDomainVariable("gooy", out y);
		Perf.Next();
		InterDomain.DefaultDomainVariable("gooz", out z);
		Perf.NW();
		x.Method();
		Print(x._s);
		//TaskDialog.Show("");
	}

	//[Serializable]
	class InterDomainData :MarshalByRefObject
	{
		public int _i;
		public string _s;

		public InterDomainData() { _i = 3; _s = "def"; }
		public InterDomainData(int i, string s) { _i = i; _s = s; PrintList("ctor", AppDomain.CurrentDomain.IsDefaultAppDomain()); }

		public void Method()
		{
			//PrintList("method", AppDomain.CurrentDomain.IsDefaultAppDomain());
		}
	}

	public static void TestPidlToString()
	{
		var a = Directory.GetFiles(@"q:\app");
		//var a = new string[] { "http://www.quickmacros.com" };

		var ai = new IntPtr[a.Length];
		var af = new string[a.Length];

		Perf.First();
		for(int i = 0; i < a.Length; i++) {
			ai[i] = Shell.Pidl.LibFromString(a[i]);
			if(ai[i] == Zero) PrintList("PidlFromString", a[i]);
		}
		Perf.Next();
		for(int i = 0; i < a.Length; i++) {
			af[i] = Shell.Pidl.LibToShellString(ai[i], Native.SIGDN.SIGDN_DESKTOPABSOLUTEPARSING);
			if(af[i] == null) PrintList("PidlToString", a[i]);
		}
		Perf.NW();
		for(int i = 0; i < a.Length; i++) Marshal.FreeCoTaskMem(ai[i]);
		Print(af);
	}

	static void TestGetIconsOfAllFileTypes()
	{
		var d = new Dictionary<string, string>();
		string s;
		using(var k1 = Registry_.Open(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\FileExts")) {
			string[] sub1 = k1.GetSubKeyNames();
			//Print(sub1);
			foreach(var s1 in sub1) {
				if(!Registry_.GetString(out s, "ProgId", s1 + @"\UserChoice", k1)) { /*PrintList(s1, "-");*/ continue; }
				//PrintList(s1, s);
				d.Add(s1, s);
			}
		}

		{
			string[] sub1 = Registry.ClassesRoot.GetSubKeyNames();
			//Print(sub1);
			foreach(var s1 in sub1) {
				if(s1[0] != '.') continue;
				if(d.ContainsKey(s1)) continue;
				if(!Registry_.GetString(out s, "", s1, Registry.ClassesRoot)) { /*PrintList(s1, "-");*/ continue; }
				//PrintList(s1, s);
				d.Add(s1, s);
			}
		}

		//Print(d);

		foreach(var v in d) {
			Print($"<><Z 0x80E080>{v.Key}</Z>");
			//var hi = Icons.GetIconHandle(v.Value + ":", 16, 0);
			var hi = Icons.GetFileIconHandle(v.Key, 16, 0);

			if(hi == Zero) {
				PrintList("<><c 0xff>", v.Key, v.Value, "</c>");
				continue;
			}

			Api.DestroyIcon(hi);
		}
	}

	static void TestPerfIncremental()
	{
		//var perf = new Perf.Inst();
		//perf.First();
		//Thread.Sleep(1);
		//perf.Next();
		//Thread.Sleep(5);
		//perf.Next();
		//perf.Write();

		var perf = new Perf.Inst();
		perf.Incremental = true;
		for(int i = 0; i < 5; i++) {
			perf.First();
			perf.Next();
			perf.Next();
			Api.GetFileAttributes("c:\nofile.tct");
			perf.Next();
			perf.Next();
			//Api.PathIsURL("jdjdjdj:jdjdj");
			//Api.CloseHandle(Zero);
			//Api.GetFileAttributes("c:\nofile.tct");
			perf.Next();
			perf.Next();
			Api.GetFileAttributes("c:\nofile.tct");
			perf.Next();
			perf.Next();
			//perf.Write();

			Thread.Sleep(50);
		}
		perf.Write();
		perf.Incremental = false;

		//var perf = new Perf.Inst();
		//perf.Incremental = true;
		//for(int i = 0; i < 5; i++) {
		//	Thread.Sleep(100); //not included in the measurement
		//	perf.First();
		//	Thread.Sleep(30); //will make sum ~150000
		//	perf.Next();
		//	Thread.Sleep(10); //will make sum ~50000
		//	perf.Next();
		//	Thread.Sleep(100); //not included in the measurement
		//}
		//perf.Write(); //speed:  154317  51060  (205377)
		//perf.Incremental = false;

		//Perf.Incremental = true;
		//for(int i = 0; i < 5; i++) {
		//	Thread.Sleep(100); //not included in the measurement
		//	Perf.First();
		//	Thread.Sleep(30); //will make sum ~150000
		//	Perf.Next();
		//	Thread.Sleep(10); //will make sum ~50000
		//	Perf.Next();
		//	Thread.Sleep(100); //not included in the measurement
		//}
		//Perf.Write(); //speed:  154317  51060  (205377)
		//Perf.Incremental = false;
	}

#region test thread pool

	static int _nTasks = 30;

	//static void TestTasksDefault()
	//{
	//	Perf.Next();
	//	using(new Util.LibEnsureWindowsFormsSynchronizationContext()) {
	//		_n = _nTasks;
	//		for(int i = 0; i < _nTasks; i++) _TestTasksDefault();
	//	}
	//	Timer_.After(500, t => _loop.Stop());
	//	_loop.Loop();
	//}

	//static async void _TestTasksDefault()
	//{
	//	var task = Task.Run(() =>
	//	{
	//		Thread.Sleep(_random.Next(1, 10));
	//		return 0;
	//	});
	//	await task;
	//	int hi = task.Result;
	//	if(--_n < 1) Perf.NW();
	//}

	//static void TestTasksSta()
	//{
	//	_staTaskScheduler = new System.Threading.Tasks.Schedulers.StaTaskScheduler(4);
	//	Perf.Next();
	//	using(new Util.LibEnsureWindowsFormsSynchronizationContext()) {
	//		_n = _nTasks;
	//		for(int i = 0; i < _nTasks; i++) _TestTasksSta();
	//	}
	//	Timer_.After(500, t => _loop.Stop());
	//	_loop.Loop();
	//}

	//static System.Threading.Tasks.Schedulers.StaTaskScheduler _staTaskScheduler;

	//static async void _TestTasksSta()
	//{
	//	var task = Task.Factory.StartNew(() =>
	//	{
	//		Thread.Sleep(_random.Next(1, 10));
	//		return 0;
	//	}, CancellationToken.None, TaskCreationOptions.None, _staTaskScheduler);
	//	await task;
	//	int hi = task.Result;
	//	if(--_n < 1) Perf.NW();
	//}

	static void TestThreadPoolSTA()
	{
		Print("BEGIN");
		//Print(Api.GetCurrentThreadId());
		Task.Run(() => { for(;;) { Thread.Sleep(100); GC.Collect(); } });
		Perf.Next();
		//using(new Util.LibEnsureWindowsFormsSynchronizationContext()) {
		_nTasks = 30;
		_n = _nTasks;
		for(int i = 0; i < _nTasks; i++) _TestThreadPoolSTA2();
		//}
		Timer_.After(1000, t => _loop.Stop());
		_loop.Loop();
		Print("END");
	}

	static void _TestThreadPoolSTA()
	{
		Catkeys.Util.ThreadPoolSTA.SubmitCallback(null, o =>
		{
			PrintList("worker", Api.GetCurrentThreadId());
			//Thread.Sleep(_random.Next(1, 10));
			Thread.Sleep(_random.Next(10, 100));
			//Thread.Sleep(2000);
			//Thread.Sleep(16000);
			//if(0==Interlocked.Decrement(ref _n)) Perf.NW();
		}, o =>
		{
			//PrintList("completion", Api.GetCurrentThreadId());
			if(--_n < 1) Perf.NW();
		});
	}

	static void _TestThreadPoolSTA2()
	{
		var work = Catkeys.Util.ThreadPoolSTA.CreateWork(null, o =>
		{
			PrintList("worker", Api.GetCurrentThreadId());
			//Thread.Sleep(_random.Next(1, 10));
			Thread.Sleep(_random.Next(10, 100));
			//Thread.Sleep(2000);
			//Thread.Sleep(16000);
			//if(0==Interlocked.Decrement(ref _n)) Perf.NW();
		}, o =>
		{
			//PrintList("completion", Api.GetCurrentThreadId());
			if(--_n < 1) Perf.NW();
		});

		work.Submit();
		//for(int i=0; i<10; i++) work.Submit();
		//Thread.Sleep(10); work.Cancel();
		//work.Submit();
		//work.Wait();
		//work.Submit();
		work.Wait();
		work.Dispose();
		//work.Submit();
	}

#endregion

	//public static string[] Receive(string user, string password, string filter = "ALL", bool markSeen = false)
	//{
	//	using(var client = new ImapClient("imap.googlemail.com", true)) {
	//		//client.Port=993; client.UseSsl=true; //default
	//		if(!client.Connect()) { Print("failed to connect"); return null; }
	//		if(!client.Login(user, password)) { Print("failed to login"); return null; }
	//		var folder = client.Folders.Inbox;
	//		List<string> a = new List<string>();
	//		foreach(var m in folder.Search(filter, ImapX.Enums.MessageFetchMode.Tiny)) {
	//			Print(m.From);
	//			if(markSeen) m.Seen = true;
	//			//a.Add(m.ToEml());
	//			a.Add(m.DownloadRawMessage());
	//		}
	//		return a.ToArray();
	//	}
	//}

	//static void TestImapX()
	//{
	//	var a = Receive("qmgindi@gmail.com", "jucakgoogle", "UNSEEN", false);
	//	Print(a);
	//}

	static unsafe LPARAM _WndProc(Wnd w, uint msg, LPARAM wParam, LPARAM lParam)
	{
		//Wnd.Misc.PrintMsg(w, msg, wParam, lParam);

		var R = Api.DefWindowProc(w, msg, wParam, lParam);

		switch(msg) {
		case Api.WM_DESTROY:
			//case Api.WM_LBUTTONUP:
			Application.ExitThread();
			break;
		}

		return R;
	}
	static Native.WNDPROC _wndProcDelegate = _WndProc;

	static void TestWindowClassInterDomain()
	{
		var atom = Wnd.Misc.WindowClass.InterDomainRegister("InterDomain", _WndProc);
		Print(atom);
		Wnd w = Wnd.Misc.WindowClass.InterDomainCreateWindow(0, "InterDomain", "InterDomain", Native.WS_OVERLAPPEDWINDOW, 100, 100, 300, 100);
		Print(w);
		w.Show(true);
		Application.Run();
		Print("exit");
	}

	static void TestCorrectFileName()
	{
		string s = null;
		s = "valid";
		s = "a ?*<>\"/\\| \x01 \x1f \x00 b";
		//s = ".txt"; //valid
		//s = "a.";
		//s = " ab ";
		//s = "CON";
		s = "con";
		//s = "LPT5.txt";
		//s = "qwertyuiopasdfghjklzxcvbnm";
		Print(Path_.CorrectFileName(s));

		//var a1 = new Action(() => { s = Path_.CorrectFileName(s); });
		//Perf.ExecuteMulti(5, 1000, a1);

	}

	static void TestLnkShortcut()
	{
		string s;
		s = Folders.Programs + @"QTranslate\QTranslate.lnk"; //target is in the 32-bit PF
		s = Folders.CommonPrograms + @"Microsoft Office\Microsoft Office Access 2003.lnk"; //test MSI
		s = Folders.Desktop + @"ClassicStartMenu.exe - Shortcut.lnk"; //test the PF (x86) problem
		s = Folders.Programs + @"Test\test.lnk";
		//s = Folders.Programs + @"Test\virtual.lnk";
		//s = Folders.Programs + @"Test\URL.lnk";
		s = Folders.CommonPrograms + @"Accessories\Math Input Panel.lnk"; //test the PF (x86) problem in icon path (env var)

		try {
			//Print(Files.Shortcut.GetTarget(s));

			//Files.Shortcut.Delete(s);
			//return;

			Shell.Shortcut x;

#if true
			x = Shell.Shortcut.Open(s);
			Print("TargetPath: " + x.TargetPath);
			Print("TargetPathMSI: " + x.TargetPathRawMSI);
			Print("URL: " + x.TargetURL);
			Print("Shell name: " + x.TargetAnyType);
			var pidl = x.TargetPidl; Print("Name from IDList: " + pidl.ToShellString(Native.SIGDN.SIGDN_NORMALDISPLAY)); Marshal.FreeCoTaskMem(pidl);
			Print("Hotkey: " + x.Hotkey);
			int ii; var iloc = x.GetIconLocation(out ii); Print($"Icon: {iloc}          ii={ii}");
			Print("Arguments: " + x.Arguments);
			Print("Description: " + x.Description);
			Print("WorkingDirectory: " + x.WorkingDirectory);
			Print("ShowState: " + x.ShowState);
#else
			x = Files.Shortcut.Create(s);
			x.Target = Folders.System + "notepad.exe";
			//x.SetIconLocation(@"q:\app\paste.ico");
			//Print(x.Hotkey);
			x.Hotkey = Keys.O | Keys.Control | Keys.Alt;
			//x.Hotkey = 0;
			x.Arguments = @"""q:\test\a.txt""";
			x.Description = "comments mmm";
			x.WorkingDirectory = @"c:\Test";
			x.Save();

			//x = Files.Shortcut.OpenOrCreate(s);
			////x.Target = Folders.System + "notepad.exe";
			//x.SetIconLocation(@"q:\app\paste.ico");
			//Print(x.Hotkey);
			//x.Hotkey = Keys.E | Keys.Control | Keys.Alt;
			////x.Hotkey = 0;
			//x.Save();

			//x = Files.Shortcut.Create(s);
			//x.TargetIDList = Folders.VirtualITEMIDLIST.ControlPanelFolder;
			////x.SetIconLocation(@"q:\app\paste.ico");
			//x.Save();

			//x = Files.Shortcut.OpenOrCreate(s);
			//x.SetIconLocation(@"q:\app\run.ico");
			//x.Save();

			//x = Files.Shortcut.Create(s);
			//x.TargetURL = "http://www.quickmacros.com";
			//x.SetIconLocation(Folders.System+"shell32.dll", 10);
			//x.Save();
#endif
			Print("fin");
		}
		catch(Exception e) { Print(e.Message); }

	}

	static void TestLnkShortcut2()
	{
		string folder = Folders.CommonPrograms;
		foreach(var f in Directory.EnumerateFiles(folder, "*.lnk", System.IO.SearchOption.AllDirectories)) {
			var x = Shell.Shortcut.Open(f);
			string s = x.TargetAnyType;
			//s = x.TargetPath;
			//s = x.TargetPathRawMSI;
			//s = x.TargetURL;
			//var pidl = x.TargetPidl; s=Files.Misc.PidlToString(pidl, Native.SIGDN.SIGDN_NORMALDISPLAY); Marshal.FreeCoTaskMem(pidl);
			//s = x.Arguments;
			//s = x.Description;
			//s = x.WorkingDirectory;
			Print($"{Path.GetFileNameWithoutExtension(f),-50} {s}");

			//int ii; s = x.GetIconLocation(out ii); Print($"{Path.GetFileNameWithoutExtension(f),-50} {s}____{ii}");
			//Print($"{Path.GetFileNameWithoutExtension(f),-50} {x.Hotkey} {x.ShowState}");
		}
	}

	static void TestCsvCatkeys()
	{
		//		string s = @"A1,B1,C1
		//A2,B2,C2
		//A3,B3,C3
		//A4,B4,C4
		//A5,B5,C5
		//A6,B6,C6
		//A7,B7,C7
		//A8,B8,C8
		//A9,""a,b
		//c"",C9
		//A,""B """"Q"""" Z"",C
		//";

		string s = @"  A1  ,  B1  ,  Ŧͷת  
A2,
A9,  ""a,b""  ,
""new
line""	,	m	,		"" n ""	
A,""B """"Q"""" Z"",C
";
		var file = Folders.Temp + "csv.csv";
		File.WriteAllText(file, s);

		//s = @"  A1  ;  B1  ;  C1  
		//A2
		//A9;  ""a;b""  ;
		//""new
		//line"";m;"" n ""
		//A;""B """"Q"""" Z"";C
		//";

		//		s = @"  A1  ,  B1  ,  Ŧͷת  
		//A2,
		//A9,  'a,b'  ,
		//'new
		//line',m,' n '
		//A,'B ''Q'' Z',C
		//";

		try {
			//var x = new CsvTable(s);
			var x = new CsvTable();
			//x.TrimSpaces = false;
			//x.Separator = ';';
			//x.Quote = '\'';
			x.FromString(s);
			//x.FromString(File.ReadAllText(file));
			//x[-1, 0] = "A1";
			//x[-1, 2] = "B3";
			//x.ColumnCount = 6;
			//x.ColumnCount = 2;
			//x.RowCount = 2;
			////x.ColumnCount = 6;
			//x[0,3]="r";
			//x[0] = new string[] { "a", "b" };
			//x[-1] = new string[] { null, "", "c", "d" };
			//Print(x[0]);
			//x.InsertRow(2);
			//x.InsertRow(2, new string[] { "a", "b" });
			//x.InsertRow(2, new string[] { null, "", "c", "d" });
			//x.RemoveRow(1, 3);
			//x.Data.Sort((a,b) => string.CompareOrdinal(a[0], b[0]));
			//x.Data.RemoveRange(0, 4);
			//x[0, 0] = 20.ToString();
			//int y = x[0, 0].ToInt_(); Print(y);
			//x.SetInt(0, 0, 20, true);
			//int y = x.GetInt(0, 0)); Print(y);
			//x.SetDouble(0, 0, 0.00055);
			//Print(x.GetDouble(0, 0));
			//x.InsertRow(0, new string[] { "g", "h" });
			//x.InsertRow(0, "n", "m");
			//x.InsertRow(-1);
			//x.Data[0] = new string[] { "x", "y", "z" };
			//x.ColumnCount = 3;

			PrintList(x.RowCount, x.ColumnCount);
			Print("----------");
			for(int r = 0; r < x.RowCount; r++) {
				Print(r);
				for(int c = 0; c < x.ColumnCount; c++) {
					string f = x[r, c];
					Print(f == null ? "<NULL>" : f);
				}
			}
			Print("----------");
			Print(x);
		}
		catch(Exception e) { Print(e.Message); }



		//p.Dispose();
	}

#endregion


#region test end back thread

	class MyAppContext :ApplicationContext
	{
		protected override void ExitThreadCore()
		{
			DebugPrintFunc();
			base.ExitThreadCore();
		}
	}

	static void _BackThread()
	{
		//Print(Api.GetCurrentThreadId());
		//Application.ThreadExit += Application_ThreadExit;
		Print(1);
		try {
			//Application.Run(_appContext);
			Application.Run();
			//Application.Run(new Form());
			//_loop.Loop();
			//Wait(1000);
			//Native.MSG m; while(Api.GetMessage(out m, Wnd0, 0, 0) > 0) Api.DispatchMessage(ref m);
		}
		catch(ThreadAbortException) { Print("abort exception"); }
		Print(2);
	}

	static Catkeys.Util.MessageLoop _loop = new Catkeys.Util.MessageLoop();
	//static MyAppContext _appContext=new MyAppContext();

	private static void Application_ThreadExit1(object sender, EventArgs e)
	{
		DebugPrintFunc();
	}

	private static void Application_ThreadExit2(object sender, EventArgs e)
	{
		DebugPrintFunc();
	}

	private static void Application_ApplicationExit(object sender, EventArgs e)
	{
		DebugPrintFunc();
		//Application.ApplicationExit -= Application_ApplicationExit;
		//Print(Api.GetCurrentThreadId());
	}

	static Thread _thread;

	static void TestBackThreadEnd()
	{
		_thread = new Thread(_BackThread);
		_thread.IsBackground = true;
		_thread.SetApartmentState(ApartmentState.STA);
		_thread.Start();

		//GC.Collect();
		//TaskDialog.Show("main");
		//MessageBox.Show("");
		//MessageBoxX(Wnd0, "", "", 0);

		//Timer_.After(1000, t => { Application.ExitThread(); });
		//Application.Run();
		//Print("after main loop");

		//Print(Api.GetCurrentThreadId());
		//_thread.Abort();
		//Application.Exit();
	}

	[DllImport("user32.dll", EntryPoint = "MessageBoxW")]
	public static extern int MessageBoxX(Wnd hWnd, string lpText, string lpCaption, uint uType);

	//class ExitClass
	//{
	//	public ExitClass()
	//	{
	//		Print("ctor");
	//	}

	//	~ExitClass()
	//	{
	//		//Print(AppDomain.CurrentDomain.IsFinalizingForUnload());
	//		Print("dtor");
	//	}
	//}

	//static ExitClass _exit=new ExitClass();

#endregion

#region test icons

	static void TestIcons2()
	{
		//Print("start");
		//Thread.Sleep(1000);

		var a = new List<string>();
		int n = 0;
#if true
		foreach(var f in Directory.EnumerateFiles(@"q:\app")) {
			//Print(f);
			a.Add(f);
			//if((n & 1) == 0) a.Add(f);
			//if(++n == 30) break;
		}
#endif
#if false
		a.Add("mailto:");
		a.Add(@"shell:AppsFolder\Microsoft.WindowsCalculator_8wekyb3d8bbwe!App");
		a.Add(@"q:\app");
		a.Add(Folders.Favorites);
		a.Add("http://www.quickmacros.com/");
		a.Add("::{21EC2020-3AEA-1069-A2DD-08002B30309D}");
		a.Add(@"C:\Users\G\Desktop\QM in PF.lnk");
#endif
#if false
		a.Add("q:\\app\\Cut.ico");
		a.Add(@"Q:\Programs\ILSpy\ILSpy.exe");
		a.Add(Folders.System + "notepad.exe");
		a.Add("q:\\app\\Copy.ico");
		a.Add("q:\\app\\Paste.ico");
		a.Add("q:\\app\\Run.ico");
		a.Add("q:\\app\\Tip.ico");
		//a.Add("notepad.exe");
		a.Add(Folders.ProgramFilesX86 + @"PicPick\picpick.exe");
		a.Add(@"Q:\Programs\DebugView\Dbgview.exe");
		a.Add(@"Q:\Programs\ProcessExplorer\procexp.exe");
		a.Add(Folders.ProgramFilesX86 + @"Inno Setup 5\Compil32.exe");
		a.Add(Folders.ProgramFilesX86 + @"HTML Help Workshop\hhw.exe");
		a.Add(Folders.ProgramFilesX86 + @"FileZilla FTP Client\filezilla.exe");
		a.Add(Folders.ProgramFilesX86 + @"Internet Explorer\IEXPLORE.EXE");
		a.Add(@"Q:\Programs\ProcessMonitor\Procmon.exe");
		a.Add(Folders.ProgramFilesX86 + @"Resource Hacker\ResourceHacker.exe");
		a.Add(@"Q:\programs\Autoruns\autoruns.exe");
		//a.Add(Folders.ProgramFilesX86 + @"SyncBackFree\SyncBackFree.exe");
		a.Add(@"Q:\Programs\PeView\PEview.exe");
		a.Add(Folders.System + @"shell32.dll,25");
#endif

		//Print(Api.GetCurrentThreadId());
		var F = new Form();
		F.Click += (unu, sed) =>
		{
			_n = a.Count;
			Perf.First();
			foreach(var s in a) {
				//_TestIconsSync(s);
				_TestIconsAsync(s);
			}
		};
		F.ShowDialog();
		//Print(2);

		//var m = new CatMenu();
		//m["aaaaaaaaa"] = null;
		//m.Show();
		//TaskDialog.ShowEx("", timeoutS: 1);
		//new Form().ShowDialog();
		//Timer_.After(1000, t => _loop2.Stop()); _loop2.Loop();
		//Timer_.After(1000, t => Application.ExitThread()); Application.Run();
		//PrintList("end", _n);
	}

	static Catkeys.Util.MessageLoop _loop2 = new Catkeys.Util.MessageLoop();

	static int _n;
	static Random _random = new Random();

	static async void _TestIconsAsync(string s)
	{
		int tid = Api.GetCurrentThreadId();
#if true
		var task = Task.Run(() =>
		{
			//PrintList(Api.GetCurrentThreadId(), s);
			//var perf = new Perf.Inst(true);
			var R = Icons.GetFileIconHandle(s, 16, 0);
			//var R = Zero; Thread.Sleep(s.Length * s.Length / 100);
			//var R = Zero; Thread.Sleep(_random.Next(1, 10));
			//perf.Next(); PrintList(perf.Times, s);
			return R;
		});
#else
		var task = Task.Factory.StartNew(() =>
		{
			//PrintList(Api.GetCurrentThreadId(), s);
			//var perf = new Perf.Inst(true);
			var R = Icons.GetIconHandle(s, 16, 0);
			//var R = Zero; Thread.Sleep(_random.Next(1, 10));
			//perf.Next(); PrintList(perf.Times, s);
			return R;
		}, CancellationToken.None, TaskCreationOptions.None, _staTaskScheduler);
#endif
		await task;
		IntPtr hi = task.Result;

		//Interlocked.Decrement(ref _n);
		_n--;
		if(_n < 1) Perf.NW();
		//PrintList(tid, Api.GetCurrentThreadId());

		if(hi == Zero) {
			PrintList("failed", s);
			return;
		}
		Api.DestroyIcon(hi);
	}

	//static readonly System.Threading.Tasks.Schedulers.StaTaskScheduler _staTaskScheduler = new System.Threading.Tasks.Schedulers.StaTaskScheduler(4); //tested: without StaTaskScheduler would be 4 threads. With 3 the UI thread is slightly faster.

	static void _TestIconsSync(string s)
	{
		//var perf = new Perf.Inst(true);
		var hi = Icons.GetFileIconHandle(s, 16, 0);
		//perf.Next(); PrintList(perf.Times, s);

		if(--_n == 0) Perf.NW();

		if(hi == Zero) {
			PrintList("failed", s);
			return;
		}
		Api.DestroyIcon(hi);
	}

	[DllImport("kernel32.dll")]
	public static extern bool SetProcessAffinityMask(IntPtr hProcess, LPARAM dwProcessAffinityMask);

	static void TestIcons()
	{
		//SetProcessAffinityMask(Api.GetCurrentProcess(), 9); //like without hyperthreading

		var a = new List<string>();
		int i, n = 0;

#if true
		bool lnk = true;
		string folder, pattern = "*"; bool recurse = true;

		if(lnk) {
			folder = Folders.CommonPrograms;
			foreach(var f in Directory.EnumerateFiles(folder, "*.lnk", System.IO.SearchOption.AllDirectories)) {
				//Print(f);
				a.Add(f);
				n++;
				//if(n == 44) break;
			}
		} else {
			folder = @"q:\app"; recurse = false;
			//folder = @"q:\app"; pattern = "*.ico";
			//folder = @"q:\app"; pattern = "*.cur";
			//folder = @"c:\windows\cursors"; pattern = "*.ani";
			//folder =@"q:\app\catkeys\tasks";
			//folder = @"c:\program files (x86)";
			//folder = @"c:\program files";
			//folder = @"c:\programdata";
			//folder = @"c:\users";
			//folder = @"c:\windows";
			//folder = @"c:\windows\system32"; pattern = "*.exe"; recurse = false;
			//folder = @"c:\windows\system32"; pattern = "*.msc";
			//folder = @"c:\windows"; pattern = "*.scr";
			//folder = @"c:\windows"; pattern = "*.lnk";
			//folder = @"c:\windows"; pattern = "*.cpl";
			//folder = @"q:\";
			//folder = @"q:\downloads"; pattern = "*.exe"; recurse = false;

			var oneExt = new HashSet<string>();
			//foreach(var f in Directory.EnumerateFiles(folder)) {
			//foreach(var f in Directory.EnumerateFileSystemEntries(folder, pattern, System.IO.SearchOption.AllDirectories)) {
			foreach(var f in Files.EnumDirectory(folder, Files.EDFlags.AndSubdirectories | Files.EDFlags.IgnoreAccessDeniedErrors)) {
				var s = f.Name;
				if(!s.Like_(pattern, true)) continue;
				//Print(f);
				//if(pattern == "*") {
				//	var ext = Path.GetExtension(s).ToLower();
				//	if(oneExt.Contains(ext)) continue; else oneExt.Add(ext);
				//}
				//if(0 != s.Like_(true, "*.aps", "*.tss", "*.bin", "*.wal", "*.???_?*", "*.????_?*")) continue;
				if(0 != s.RegexIs_(RegexOptions.IgnoreCase, @"\.\w+?[_\-][^\.]+$", @", PublicKeyToken", @"^(LanguageService|TextEditor|WindowManagement)", @"\bVisualStudio\b")) continue;
				//if(n>=3000)
				a.Add(f.FullPath);
				//var k = f.RegexReplace_(@"(?i)^C:\\windows\\system32", @"C:\Users\G\Desktop\system64");
				//Print($"{s} : * {k}");
				n++;
				if(n == 15) break;
				//break;
			}
		}
#elif false
		//a.Add(@"c:\windows\Boot\DVD\PCAT\etfsboot.com");
		//a.Add(@"c:\windows\System32\Bubbles.scr");

		//a.Add(@"c:\test\Z.appcontent-ms");
		//a.Add(@"c:\test\Z.appref-ms");
		//a.Add(@"c:\test\Z.as");
		//a.Add(@"c:\test\Z.asa");
		//a.Add(@"c:\test\Z.asp");
		//a.Add(@"c:\test\Z.axd");
		//a.Add(@"c:\test\Z.cdx");
		//a.Add(@"c:\test\Z.cdxml");
		//a.Add(@"c:\test\Z.cfm");
		//a.Add(@"c:\test\Z.chk");

		//a.Add(@".appcontent-ms");
		//a.Add(@".appref-ms");
		//a.Add(@".as");
		//a.Add(@".asa");
		//a.Add(@".asp");
		//a.Add(@".axd");
		//a.Add(@".cdx");
		//a.Add(@".cdxml");
		//a.Add(@".cfm");
		//a.Add(@".chk");
		////a.Add(@".txt");

		a.Add(@".com");
		a.Add(@".p7s");
		a.Add(@".pano");
		a.Add(@".sst");
#else //all registered file types
		var d = new SortedDictionary<string, string>();
		string s;
		using(var k1 = Registry_.Open(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\FileExts")) {
			string[] sub1 = k1.GetSubKeyNames();
			//Print(sub1);
			foreach(var s1 in sub1) {
				if(!Registry_.GetString(out s, "ProgId", s1 + @"\UserChoice", k1)) { /*PrintList(s1, "-");*/ continue; }
				//PrintList(s1, s);
				d.Add(s1, s);
			}
		}

		{
			string[] sub1 = Registry.ClassesRoot.GetSubKeyNames();
			//Print(sub1);
			foreach(var s1 in sub1) {
				if(s1[0] != '.') continue;
				if(d.ContainsKey(s1)) continue;
				if(!Registry_.GetString(out s, "", s1, Registry.ClassesRoot)) { /*PrintList(s1, "-");*/ continue; }
				//PrintList(s1, s);
				d.Add(s1, s);
			}
		}

		//Print(d);

		foreach(var v in d) {
			//Print($"<><Z 0x80E080>{v.Key}</Z>");
			//Print($"{v.Key} : * {v.Key}");
			a.Add(v.Key);
			//a.Add(v.Value+":");
		}
		//return;
#endif

		Print(n);
		//FileIconInit(false);

		int size = 0;
		//size = Icons.GetShellIconSize(Icons.ShellSize.Small);
		//size = Icons.GetShellIconSize(Icons.ShellSize.Large);
		//size = Icons.GetShellIconSize(Icons.ShellSize.ExtraLarge);
		//size = Icons.GetShellIconSize(Icons.ShellSize.Jumbo);

#if true
		var m = new CatBar();
		if(size > 0) m.Ex.ImageScalingSize = new Size(size, size);
		//m.IconFlags = Icons.IconFlags.Shell;

		//m.Ex.AutoSize = false;
		m.Ex.LayoutStyle = ToolStripLayoutStyle.Flow;

		m.ItemAdded += g => { g.Margin = new Padding(4, 0, 0, 0); };

		//m["cut", @"q:\app\cut.ico"] = null;
		//m["copy", @"q:\app\copy.ico"] = null;
		//m["paste", @"q:\app\paste.ico"] = null;

		//m["Calculator", @"shell:AppsFolder\Microsoft.WindowsCalculator_8wekyb3d8bbwe!App"] = null;
		//m["Virt folder", @"::{20d04fe0-3aea-1069-a2d8-08002b30309d}"] = null;
		//m[".cs", @".cs"] = null;

		for(i = 0; i < a.Count; i++) {
			if(size == 256 && i < 12) continue;
			var u = a[i];
			m[Path.GetFileName(u), u] = null;
			//m[Path.GetFileName(u), @"q:\app\paste.ico"] = null;
		}

		//m.Ex.Click += (unu, sed) => _mlTb.Stop();
		m.Ex.MouseUp += (unu, sed) => _mlTb.Stop();
		Perf.First();
		m.Visible = true;
		//m.Visible = false; m["cut", @"q:\app\cut.ico"] = null; m.Visible = true;
		_mlTb.Loop();
		m.Close();
		//Print("exit");
#elif true
		for(int c = 0; c < 1; c++) {
			var m = new CatMenu();
			//if(size > 0) m.CMS.ImageScalingSize = new Size(size, size);
			if(size > 0) m.IconSize = size;
			//m.ActivateMenuWindow = true;

			for(i = 0; i < a.Count; i++) {
				var s = a[i];
				m[Path.GetFileName(s), s] = null;

				//if(i == 0) m.LastItem.DisplayStyle = ToolStripItemDisplayStyle.Text;
			}

			using(m.Submenu("sub")) {
				m.LastMenuItem.DropDown.ImageScalingSize = new Size(24, 24);
				m["two", a[0]] = null;
			}

			Perf.First();
			m.Show();
		}
#elif false
		var m = new CatMenu();
		m.CMS.ImageScalingSize = new Size(size, size);

		Perf.First();
		for(i = 0; i < a.Count; i++) {
			var hi = Icons.GetIconHandle(a[i], size);
			if(hi != Zero) {
				//var ic = Icon.FromHandle(hi);
				//var im = ic.ToBitmap();
				//m[Path.GetFileName(a[i]), im] = null;

				m[Path.GetFileName(a[i]), hi] = null;

				Api.DestroyIcon(hi);
			}
		}
		Perf.NW();

		m.Show();
#else
		var ai = new IntPtr[a.Count];
		Print(a.Count);

		var m = new CatMenu();
		m.CMS.ImageScalingSize = new Size(size, size);

		try {
			Perf.First();
			for(i = 0; i < a.Count; i++) {
				ai[i] = Icons.GetIconHandle(a[i], size);
				//Print(ai[i]);
				//Api.DestroyIcon(ai[i]); ai[i] = Zero;
            }
			Perf.NW();

			for(i = 0; i < a.Count; i++) {
				var s = a[i];
				//Print(i);
				//m[Path.GetFileName(s), ai[i]] = null;
				m[Path.GetFileName(s)] = null;
			}
		}
		finally {
			for(i = 0; i < ai.Length; i++) Api.DestroyIcon(ai[i]);
		}

		m.Show();
#endif
	}

	//[DllImport("shell32.dll", EntryPoint ="#660")]
	//static extern bool FileIconInit(bool restorFromDisk);

#endregion test icons

	static void TestCatkeysListFileCSV()
	{
		int size = 0, nRows = 0;
		List<string> k = null;
		for(int i = 0; i < 5; i++) {
			Perf.First();
			var s = File.ReadAllText(@"q:\test\ok\LIST.csv");
			size = s.Length;
			Perf.Next();
			var x = new CsvTable(); x.Separator = '|';
			x.FromString(s);
			nRows = x.RowCount;
			//Perf.Next();
			//k = new List<string>(nRows);
			//for(int j = 0; j < nRows; j++) {
			//	k.Add(x[j, 0]);
			//}
			Perf.NW();
		}
		Print(k);
		Print($"{size / 1024.0:F3} KB, {nRows} rows");
	}

	static void TestCatkeysListFileXML()
	{
		int size = 0, nRows = 0;
		List<string> k = null;
		for(int i = 0; i < 5; i++) {
			Perf.First();
#if true
			var s = "";
			var x = new XmlDocument();
			x.Load(@"q:\test\ok\LIST.xml");
#else
			var s = File.ReadAllText(@"q:\test\ok\LIST.xml");
			Perf.Next();
			var x = new XmlDocument();
			x.LoadXml(s);
#endif
			Perf.Next();
			//nRows = x.FirstChild.ChildNodes.Count;
			var f = x.FirstChild.ChildNodes;
			nRows = f.Count;
			k = new List<string>(nRows);

			//for(int j = 0; j<nRows; j++) {
			//	//k.Add(f[j].Attributes["n"].Value);
			//	//size += f[j].Attributes["n"].Value.Length;
			//	var p =f[j]; //very slow
			//	k.Add(p.InnerText);
			//	//size += f[j].Value.Length;
			//}

			foreach(XmlNode p in f) {
				k.Add(p.InnerText); //quite fast but 3-4 times slower than CSV
			}

			Perf.NW();
			size = s.Length;
		}
		Print(k);
		Print($"{size / 1024.0:F3} KB, {nRows} rows");
	}































#if true
	public class Types<T1, T2>
	{
		public object obj;

		public Types(object obj) { this.obj = obj; }

		public static implicit operator Types<T1, T2>(T1 x) { return new Types<T1, T2>(x); }
		public static implicit operator Types<T1, T2>(T2 x) { return new Types<T1, T2>(x); }
	}

	public class Types<T1, T2, T3>
	{
		public object obj;

		public Types(object obj) { this.obj = obj; }

		public static implicit operator Types<T1, T2, T3>(T1 x) { return new Types<T1, T2, T3>(x); }
		public static implicit operator Types<T1, T2, T3>(T2 x) { return new Types<T1, T2, T3>(x); }
		public static implicit operator Types<T1, T2, T3>(T3 x) { return new Types<T1, T2, T3>(x); }
	}

	static void TestTypes(Types<string, IEnumerable<string>> x = null)
	{
		switch(x?.obj) {
		case string s: PrintList("string", s); break;
		case IEnumerable<string> a: PrintList("IEnumerable<string>", a); break;
		default: Print("null"); break;
		}
	}

	static void TestTypes2(Types<int, double> x = null)
	{
		switch(x?.obj) {
		case int i: PrintList("int", i); break;
		case double d: PrintList("double", d); break;
		default: Print("null"); break;
		}
	}

	static void TestTypes3(Types<int, double, string> x)
	{
		switch(x?.obj) {
		case int i: PrintList("int", i); break;
		case double d: PrintList("double", d); break;
		case string s: PrintList("string", s); break;
		default: Print("null"); break;
		}
	}

	static void TestTypes4(Types<int, int?> x)
	{
		switch(x?.obj) {
		case int i: PrintList("int", i); break;
		default: Print("null"); break;
		}
	}
#else
	public struct Types<T1, T2>
	{
		public object obj;

		public Types(object obj) { this.obj = obj; }

		public static implicit operator Types<T1, T2>(T1 x) { return new Types<T1, T2>(x); }
		public static implicit operator Types<T1, T2>(T2 x) { return new Types<T1, T2>(x); }
	}

	public struct Types<T1, T2, T3>
	{
		public object obj;

		public Types(object obj) { this.obj = obj; }

		public static implicit operator Types<T1, T2, T3>(T1 x) { return new Types<T1, T2, T3>(x); }
		public static implicit operator Types<T1, T2, T3>(T2 x) { return new Types<T1, T2, T3>(x); }
		public static implicit operator Types<T1, T2, T3>(T3 x) { return new Types<T1, T2, T3>(x); }
	}

	static void TestTypes(Types<string, IEnumerable<string>> x = default(Types<string, IEnumerable<string>>))
	{
		switch(x.obj) {
		case string s: PrintList("string", s); break;
		case IEnumerable<string> a: PrintList("IEnumerable<string>", a); break;
		default: Print("null"); break;
		}
	}

	static void TestTypes2(Types<int, double> x = default(Types<int, double>))
	{
		switch(x.obj) {
		case int i: PrintList("int", i); break;
		case double d: PrintList("double", d); break;
		default: Print("null"); break;
		}
	}

	static void TestTypes3(Types<int, double, string> x)
	{
		switch(x.obj) {
		case int i: PrintList("int", i); break;
		case double d: PrintList("double", d); break;
		case string s: PrintList("string", s); break;
		default: Print("null"); break;
		}
	}

	static void TestTypes4(Types<int, int?> x)
	{
		switch(x.obj) {
		case int i: PrintList("int", i); break;
		default: Print("null"); break;
		}
	}
#endif

	static void TestMultiTypeParam()
	{
		TestTypes("S");
		TestTypes(new string[] { "S0", "S1" });
		TestTypes(new List<string>() { "L0", "L1" });
		//TestTypes(null);
		//TestMultiTypeParam(5);
		TestTypes(default(Types<string, IEnumerable<string>>));
		Print("----");

		TestTypes2(3);
		TestTypes2(3.5);
		//TestTypes2(null);
		//int? n = 7;
		//TestTypes2(n);
		Print("----");

		TestTypes3(3);
		TestTypes3(3.5);
		TestTypes3("S");
		//TestTypes3(null);
		//TestTypes3(n);
		Print("----");

		TestTypes4(3);
		int? n = 7;
		TestTypes4(n);
		TestTypes4(null);
		Print("----");

		TestTypes();
		TestTypes2();
		Print("----");

		//TestTypes(10.5);
		TestTypes2(10.5);
	}


	//static void Fu<T>(T x)
	//{
	//	Print(x);
	//}

	//static void FuWhere<T>(T x) where T: String
	//{
	//	Print(x);
	//}

	//static void TestGenericParam()
	//{
	//	Fu("S");
	//	Fu(1);
	//}



	public struct TypesS<T1, T2>
	{
		public object obj;

		public TypesS(object obj) { this.obj = obj; }

		public static implicit operator TypesS<T1, T2>(T1 x) { return new TypesS<T1, T2>(x); }
		public static implicit operator TypesS<T1, T2>(T2 x) { return new TypesS<T1, T2>(x); }

		//public static implicit operator Types<T1, T2>(float? x) { return new Types<T1, T2>(null); }
		//public static implicit operator Types<T1, T2>(double? x) { return new Types<T1, T2>(null); }
	}


	[MethodImpl(MethodImplOptions.NoInlining)]
	static bool SpeedObj(object x)
	{
		switch(x) {
		case string s: return s is null;
		case IEnumerable<string> a: return a is null;
		default: return false;
		}
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	static bool SpeedS(TypesS<string, IEnumerable<string>> x)
	{
		switch(x.obj) {
		case string s: return s is null;
		case IEnumerable<string> a: return a is null;
		default: return false;
		}
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	static bool SpeedC(Types<string, IEnumerable<string>> x)
	{
		switch(x?.obj) {
		case string s: return s is null;
		case IEnumerable<string> a: return a is null;
		default: return false;
		}
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	static bool SpeedObj2(object x)
	{
		switch(x) {
		case int s: return s==0;
		case double a: return a==0.0;
		default: return false;
		}
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	static bool SpeedS2(TypesS<int, double> x)
	{
		switch(x.obj) {
		case int s: return s==0;
		case double a: return a==0.0;
		default: return false;
		}
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	static bool SpeedC2(Types<int, double> x)
	{
		switch(x?.obj) {
		case int s: return s==0;
		case double a: return a==0.0;
		default: return false;
		}
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	static bool SpeedS3(TypesS<string, IEnumerable<string>>? x=null)
	{
		switch(x?.obj) {
		case string s: return s is null;
		case IEnumerable<string> a: return a is null;
		default: return false;
		}
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	static bool SpeedS4(TypesS<int, double>? x)
	{
		switch(x?.obj) {
		case int s: return s==0;
		case double a: return a==0.0;
		default: return false;
		}
	}

	static void TestMultiTypeParamSpeed()
	{
		int r = 0;
		string s = "kkkk";
		var a = new string[] { "A", "B" };
		int m = 7;
		double d = 3.4;

		for(int i = 0; i < 5; i++) {
			Perf.First();
			for(int j = 0; j < 1000; j++) {
				if(SpeedObj(s)) r++;
				if(SpeedObj(a)) r++;
				//if(SpeedObj(null)) r++;
			}
			Perf.Next();
			for(int j = 0; j < 1000; j++) {
				if(SpeedS(s)) r++;
				if(SpeedS(a)) r++;
				//if(Speed1(null)) r++;
				//if(SpeedS((string)null)) r++;
			}
			Perf.Next();
			for(int j = 0; j < 1000; j++) {
				if(SpeedC(s)) r++;
				if(SpeedC(a)) r++;
				//if(SpeedC(null)) r++;
			}
			Perf.Next();
			for(int j = 0; j < 1000; j++) {
				if(SpeedObj2(m)) r++;
				if(SpeedObj2(d)) r++;
				//if(SpeedObj(null)) r++;
			}
			Perf.Next();
			for(int j = 0; j < 1000; j++) {
				if(SpeedS2(m)) r++;
				if(SpeedS2(d)) r++;
			}
			Perf.Next();
			for(int j = 0; j < 1000; j++) {
				if(SpeedC2(m)) r++;
				if(SpeedC2(d)) r++;
			}
			Perf.Next();
			for(int j = 0; j < 1000; j++) {
				if(SpeedS3(s)) r++;
				if(SpeedS3(a)) r++;
			}
			Perf.Next();
			for(int j = 0; j < 1000; j++) {
				if(SpeedS4(m)) r++;
				if(SpeedS4(d)) r++;
			}
			Perf.NW();
		}

		Print(r);
	}



	[MethodImpl(MethodImplOptions.NoInlining)]
	static void TypesNullable(TypesS<string, IEnumerable<string>>? x = null)
	{
		switch(x?.obj) {
		case string s: Print(s); break;
		case IEnumerable<string> a: Print(a); break;
		default: Print("null"); break;
		}
	}

	static void TestTypesNullable()
	{
		TypesNullable("S");
		TypesNullable(new string[] { "a", "b" });
		string s = null;
		TypesNullable(s);
		TypesNullable();
	}







#if false //struct much slower
		/// <summary>
		/// Used with <see cref="Match_"/>. 
		/// </summary>
		public struct MatchContext
		{
			//internal Regex rx;
			//internal _MatchContext[] multi;
			internal object x; //Regex or _MatchContext[]
			internal int offset;
			internal byte type; //0 wild, 1 text, 2 regex, 3 multi
			internal bool c;
			internal bool n;
		}

		public static unsafe bool Match_(this string t, string wildcardExpression, ref MatchContext context)
		{
			var w = wildcardExpression;
			if(w == null) return t == null;
			if(t == null) return false;

			int lenW = w.Length;
			bool ignoreCase = true, not = false;

			if(context.offset == 0 && lenW >= 3 && w[0] == '*' && w[1] == '*') {
				var c = new MatchContext();
				for(int i = 2; i < lenW; i++) {
					switch(w[i]) {
					case 't': c.type = 1; break;
					case 'r': c.type = 2; break;
					case 'm': c.type = 3; break;
					case 'c': c.c = true; break;
					case 'n': c.n = true; break;
					case '|': c.offset = ++i; goto g1;
					}
				}
				g1:
				if(c.offset > 0) {
					//var s = (c.type>=2) ? w.Substring(c.offset) : null;
					switch(c.type) {
					//case 1:
					//	c.x = s;
					//	break;
					case 2:
						c.x = new Regex(w.Substring(c.offset), c.c ? RegexOptions.CultureInvariant : (RegexOptions.CultureInvariant | RegexOptions.IgnoreCase));
						break;
					case 3:

						break;
					}
					context = c;
				}
			}

			if(context.offset > 0) {
				lenW -= context.offset;
				ignoreCase = !context.c; not = context.n;
				switch(context.type) {
				case 1:
					//return not != (lenW == t.Length && (context.x as string).Equals_(t, ignoreCase));
					return not != (lenW == t.Length && w.EndsWith_(t, ignoreCase));
				case 2:
					return (context.x as Regex).IsMatch(t);
				case 3:
					break;
				}
			}

			if(lenW == 0) return t.Length == 0;
			if(lenW == 1 && w[0] == '*') return true;
			if(t.Length == 0) return false;

			fixed (char* tt = t, ww = w) {
				return not != __WildcardCmp(tt, ww + context.offset, t.Length, lenW, ignoreCase ? Util.LibProcessMemory.Ptr->str.GetCaseTable() : null);
			}
		}
#else
		class _MatchContext
		{
			//internal Regex rx;
			//internal _MatchContext[] multi;
			internal object x; //Regex or _MatchContext[]
			internal int offset;
			internal byte type; //0 wild, 1 text, 2 regex, 3 multi
			internal bool c;
			internal bool n;
		}

		public static unsafe bool Match_(this string t, string wildcardExpression, ref object context)
		{
			var w = wildcardExpression;
			if(w == null) return t == null;
			if(t == null) return false;

			int lenW = w.Length, offsW = 0;
			bool ignoreCase = true, not = false;

			_MatchContext c = null;
			if(context != null) c = context as _MatchContext;
			else if(lenW >= 3 && w[0] == '*' && w[1] == '*') {
				context = c = new _MatchContext();
				for(int i = 2; i < lenW; i++) {
					switch(w[i]) {
					case 't': c.type = 1; break;
					case 'r': c.type = 2; break;
					case 'm': c.type = 3; break;
					case 'c': c.c = true; break;
					case 'n': c.n = true; break;
					case '|': c.offset = ++i; goto g1;
					}
				}
				g1:
				if(c.offset > 0) {
					var s = (c.type >= 2) ? w.Substring(c.offset) : null;
					switch(c.type) {
					//case 1:
					//	c.x = s;
					//	break;
					case 2:
						c.x = new Regex(s, c.c ? RegexOptions.CultureInvariant : (RegexOptions.CultureInvariant | RegexOptions.IgnoreCase));
						break;
					case 3:
						//var a = s.Split(new string[] { "[]" }, StringSplitOptions.None);
						//var multi = new _MatchContext[a.Length];
						//for(int i = 0; i < a.Length; i++) {
						//	multi[i] = new _MatchContext(a[i]);
						//}
						//c.x = multi;
						break;
					}
				}
			}

			if(c != null && c.offset > 0) {
				offsW = c.offset; lenW -= c.offset;
				ignoreCase = !c.c; not = c.n;
				switch(c.type) {
				case 1:
					//return not != (lenW == t.Length && (c.x as string).Equals_(t, ignoreCase));
					return not != (lenW == t.Length && w.EndsWith_(t, ignoreCase));
				case 2:
					return (c.x as Regex).IsMatch(t);
				case 3:
					break;
				}
			}

			if(lenW == 0) return t.Length == 0;
			if(lenW == 1 && w[0] == '*') return true;
			if(t.Length == 0) return false;

			fixed (char* tt = t, ww = w) {
				return not != __WildcardCmp(tt, ww + offsW, t.Length, lenW, ignoreCase ? Util.LibProcessMemory.Ptr->str.GetCaseTable() : null);
			}
		}
#endif

		//public static unsafe bool Match_(this string t, string wildcardExpression)
		//{
		//	var w = wildcardExpression;
		//	if(w == null) return t == null;
		//	if(t == null) return false;
		//	int lenW = w.Length;

		//	bool ignoreCase = true, not = false; int offsW = 0;

		//	if(lenW >= 3 && w[0] == '*' && w[1] == '*') {
		//		int i, o = 0; //1 t, 2 r, 3 m, 8 c, 16 n, 0x100 |
		//		for(i = 2; i < lenW && o < 0x100; i++) {
		//			switch(w[i]) {
		//			case 't': o |= 1; break;
		//			case 'r': o |= 2; break;
		//			case 'm': o |= 3; break;
		//			case 'c': o |= 8; break;
		//			case 'n': o |= 16; break;
		//			case '|': o |= 0x100; break;
		//			}
		//		}
		//		if((o & 0x100) != 0) {
		//			if((o & 8) != 0) ignoreCase = false;
		//			if((o & 16) != 0) not = true;
		//			lenW -= i;
		//			switch(o & 3) {
		//			case 1:
		//				return not != (lenW == t.Length && w.EndsWith_(t, ignoreCase));
		//			case 2:
		//				//return not != t.RegexIs_(w.Substring(i), ignoreCase ? RegexOptions.IgnoreCase : 0);
		//				return not != _regexCache.CreateOrGetCached(w, w.Substring(i), ignoreCase ? RegexOptions.IgnoreCase : 0).IsMatch(t);
		//			case 3:
		//				break;
		//			}
		//			offsW = i;
		//		}
		//	}

		//	if(lenW == 0) return t.Length == 0;
		//	if(lenW == 1 && w[0] == '*') return true;
		//	if(t.Length == 0) return false;

		//	fixed (char* tt = t, ww = w) {
		//		return not != __WildcardCmp(tt, ww + offsW, t.Length, lenW, ignoreCase ? Util.LibProcessMemory.Ptr->str.GetCaseTable() : null);
		//	}
		//}



		/// <summary>
		/// Faster Regex cache.
		/// </summary>
		struct _RegexCache
		{
			struct _CacheItem
			{
				internal object wildex;
				internal Regex r;
			}

			static _CacheItem[] _a;
			static int _i;

			internal Regex CreateOrGetCached(string wildex, string regex, RegexOptions ro)
			{
				//lock("jskdjsiyvtdftfhch") { //slower, and I think that better to use ThreadStatic
				object o = wildex;
				if(_a != null) {
					if(_a[0].wildex == o) return _a[0].r;
					if(_a[1].wildex == o) return _a[1].r;
					if(_a[2].wildex == o) return _a[2].r;
					if(_a[3].wildex == o) return _a[3].r;
				} else _a = new _CacheItem[4];

				var r = _a[_i].r = new Regex(regex, ro);
				_a[_i].wildex = o;
				_i = (_i + 1) & 3;
				return r;
				//}
			}

			internal void Clear()
			{
				_a = null;
			}
		}
		[ThreadStatic]
		static _RegexCache _regexCache;

		internal static void TestClearRegexCache()
		{
			_regexCache.Clear();
		}








	public class WildexC
	{
		/// <summary>
		/// The type of text (wildcard expression) used when creating the Wildex variable.
		/// </summary>
		public enum WildType :byte
		{
			/// <summary>Simple text (option t, or no *? characters and no t r options). Match() calls <see cref="String_.Equals_(string, string, bool)"/>.</summary>
			Text,
			/// <summary>Wildcard (has *? characters and no t r options). Match() calls <see cref="String_.Like_(string, string, bool)"/>.</summary>
			Wildcard,
			/// <summary>Regular expression (option r). Match() calls <see cref="Regex.IsMatch(string)"/>.</summary>
			Regex,
			/// <summary>Multiple parts (option m). Match() calls Match() for each part (see <see cref="MultiArray"/>) and returns true if some non-[n] part returns true and all [n] parts return true.</summary>
			Multi,
		}

		object _obj; //string, Regex or Wildex[]. Tested: getting string etc with '_obj as string' is fast.
		WildType _type;
		bool _ignoreCase;
		bool _not;

		public WildexC(string wildcardExpression)
		{
			var w = wildcardExpression;
			if(w == null) return;
			_type = WildType.Wildcard;
			_ignoreCase = true;

			if(w.Length >= 3 && w[0] == '*' && w[1] == '*') {
				WildType t = _type; bool isC = false, isN = false, hasOptions = false;
				int i;
				for(i = 2; i < w.Length && !hasOptions; i++) {
					switch(w[i]) {
					case 't': t = WildType.Text; break;
					case 'r': t = WildType.Regex; break;
					case 'm': t = WildType.Multi; break;
					case 'c': isC = true; break;
					case 'n': isN = true; break;
					case '|': hasOptions = true; break;
					}
				}
				if(hasOptions) {
					w = w.Substring(i);
					_type = t;
					_ignoreCase = !isC;
					_not = isN;
					if(_type == WildType.Multi) {
						var a = w.Split(new string[] { "[]" }, StringSplitOptions.None);
						var multi = new Wildex[a.Length];
						for(i = 0; i < a.Length; i++) {
							multi[i] = new Wildex(a[i]);
						}
						_obj = multi;
						w = null;
						_type = WildType.Multi;
						return;
					}

					if(_type == WildType.Regex) {
						var ro = _ignoreCase ? (RegexOptions.IgnoreCase | RegexOptions.CultureInvariant) : RegexOptions.CultureInvariant;
						_obj = new Regex(w, ro);
						return;
					}
				}
			}

			if(_type == WildType.Wildcard && !Wildex.HasWildcards(w)) _type = WildType.Text;
			_obj = w;
		}

		public bool Match(string s)
		{
			if(s == null) return _obj == null;
			if(_obj == null) return false;

			bool R = false;
			switch(_type) {
			case WildType.Wildcard: R = s.Like_(_obj as string, _ignoreCase); break;
			case WildType.Text: R = s.Equals_(_obj as string, _ignoreCase); break;
			case WildType.Regex: R = (_obj as Regex).IsMatch(s); break;
			case WildType.Multi:
				var multi = _obj as Wildex[];
				//[n] parts: all must match (with their [n] applied)
				for(int i = 0; i < multi.Length; i++) {
					var v = multi[i];
					if(v.Not && !v.Match(s)) return _not;
				}
				//non-[n] parts: at least one must match
				for(int i = 0; i < multi.Length; i++) {
					var v = multi[i];
					if(!v.Not && v.Match(s)) return !_not;
				}
				break;
			}
			return R ^ _not;
		}
	}

	public struct WildexS
	{
		/// <summary>
		/// The type of text (wildcard expression) used when creating the Wildex variable.
		/// </summary>
		public enum WildType :byte
		{
			/// <summary>Simple text (option t, or no *? characters and no t r options). Match() calls <see cref="String_.Equals_(string, string, bool)"/>.</summary>
			Text,
			/// <summary>Wildcard (has *? characters and no t r options). Match() calls <see cref="String_.Like_(string, string, bool)"/>.</summary>
			Wildcard,
			/// <summary>Regular expression (option r). Match() calls <see cref="Regex.IsMatch(string)"/>.</summary>
			Regex,
			/// <summary>Multiple parts (option m). Match() calls Match() for each part (see <see cref="MultiArray"/>) and returns true if some non-[n] part returns true and all [n] parts return true.</summary>
			Multi,
		}

		object _obj; //string, Regex or Wildex[]. Tested: getting string etc with '_obj as string' is fast.
		WildType _type;
		bool _ignoreCase;
		bool _not;

		public WildexS(string wildcardExpression):this()
		{
			var w = wildcardExpression;
			if(w == null) return;
			_type = WildType.Wildcard;
			_ignoreCase = true;

			if(w.Length >= 3 && w[0] == '*' && w[1] == '*') {
				WildType t = _type; bool isC = false, isN = false, hasOptions = false;
				int i;
				for(i = 2; i < w.Length && !hasOptions; i++) {
					switch(w[i]) {
					case 't': t = WildType.Text; break;
					case 'r': t = WildType.Regex; break;
					case 'm': t = WildType.Multi; break;
					case 'c': isC = true; break;
					case 'n': isN = true; break;
					case '|': hasOptions = true; break;
					}
				}
				if(hasOptions) {
					w = w.Substring(i);
					_type = t;
					_ignoreCase = !isC;
					_not = isN;
					if(_type == WildType.Multi) {
						var a = w.Split(new string[] { "[]" }, StringSplitOptions.None);
						var multi = new Wildex[a.Length];
						for(i = 0; i < a.Length; i++) {
							multi[i] = new Wildex(a[i]);
						}
						_obj = multi;
						w = null;
						_type = WildType.Multi;
						return;
					}

					if(_type == WildType.Regex) {
						var ro = _ignoreCase ? (RegexOptions.IgnoreCase | RegexOptions.CultureInvariant) : RegexOptions.CultureInvariant;
						_obj = new Regex(w, ro);
						return;
					}
				}
			}

			if(_type == WildType.Wildcard && !Wildex.HasWildcards(w)) _type = WildType.Text;
			_obj = w;
		}

		public bool Match(string s)
		{
			if(s == null) return _obj == null;
			if(_obj == null) return false;

			bool R = false;
			switch(_type) {
			case WildType.Wildcard: R = s.Like_(_obj as string, _ignoreCase); break;
			case WildType.Text: R = s.Equals_(_obj as string, _ignoreCase); break;
			case WildType.Regex: R = (_obj as Regex).IsMatch(s); break;
			case WildType.Multi:
				var multi = _obj as Wildex[];
				//[n] parts: all must match (with their [n] applied)
				for(int i = 0; i < multi.Length; i++) {
					var v = multi[i];
					if(v.Not && !v.Match(s)) return _not;
				}
				//non-[n] parts: at least one must match
				for(int i = 0; i < multi.Length; i++) {
					var v = multi[i];
					if(!v.Not && v.Match(s)) return !_not;
				}
				break;
			}
			return R ^ _not;
		}

		public bool IsNull { get { return _obj == null; } }
	}











#elif false
				Api.IShellFolder folder = null; IntPtr pidlItem;
				try {
					int hr = Api.SHBindToParent(pidl, ref Api.IID_IShellFolder, out folder, out pidlItem);
					if(0 != hr) { PrintDebug($"{pidl}, {Marshal.GetExceptionForHR(hr)?.Message}"); return Zero; }

					int ii = SHMapPIDLToSystemImageListIndex(folder, pidlItem, null);
					//Print(ii);
					if(ii < 0) return Zero;

					size = size < 24 ? SHIL_SMALL : SHIL_LARGE;
					IntPtr il;
					if(0 != SHGetImageList(size, ref IID_IImageList, out il)) return Zero;

					return Api.ImageList_GetIcon(il, ii, 0);
				}
				finally {
					Api.ReleaseComObject(folder);
				}
#else
				IntPtr R = Zero;
				Api.IShellFolder folder = null;
				Api.IExtractIcon eic = null;
				try {
					IntPtr pidlItem;
					int hr = Api.SHBindToParent(pidl, ref Api.IID_IShellFolder, out folder, out pidlItem);
					if(0 != hr) { PrintDebug($"{pidl}, {Marshal.GetExceptionForHR(hr)?.Message}"); return Zero; }

					object o;
					hr = folder.GetUIObjectOf(Wnd0, 1, &pidlItem, Api.IID_IExtractIcon, Zero, out o);
					//if(0 != hr) { PrintDebug($"{file}, {Marshal.GetExceptionForHR(hr)?.Message}"); return Zero; }
					if(0 != hr) {
						if(hr != Api.REGDB_E_CLASSNOTREG) PrintDebug($"{pidl}, {Marshal.GetExceptionForHR(hr)?.Message}");
						return Zero;
					}
					eic = o as Api.IExtractIcon;

					var sb = new StringBuilder(300); int ii; uint fl;
					hr = eic.GetIconLocation(0, sb, 300, out ii, out fl);
					if(0 != hr) { PrintDebug($"{pidl}, {Marshal.GetExceptionForHR(hr)?.Message}"); return Zero; }
					string loc = sb.ToString();

					//PrintList(pidl, loc, ii);

					if((fl & (Api.GIL_NOTFILENAME | Api.GIL_SIMULATEDOC)) == 0) {
						R = GetIconHandleRaw(loc, ii, size);
						if(R != Zero) return R;
					}

					//hr = eic.Extract(loc, (uint)ii, &R, null, (uint)size); //no
					//note:
					//	Some shell extensions (eg .sln) ignore size and always return 32x32 in phiconLarge and 16x16 in phiconSmall.
					//	But how then Explorer displays correct icons? Maybe uses SHMapPIDLToSystemImageListIndex/SHGetImageList. Or IExtractImage. Probably it uses other (probably private) functions.

					IntPtr* hiSmall = null, hiBig = null;
					if(size < 24) { hiSmall = &R; size = 32; } else hiBig = &R;
					hr = eic.Extract(loc, (uint)ii, hiBig, hiSmall, Calc.MakeUint(size, 16)); //TODO: may have 20 icon

					if(0 != hr) { PrintDebug($"{pidl}, {Marshal.GetExceptionForHR(hr)?.Message}, location={loc}"); return Zero; }

					//PrintList(pidl, loc, ii);

					//if(size != 16 && size != 32) { //TODO: test with high DPI

					//	//var perf = new Perf.Inst(true);
					//	IntPtr R2 = Api.CopyImage(R, Api.IMAGE_ICON, size, size, Api.LR_COPYDELETEORG | Api.LR_COPYRETURNORG | Api.LR_COPYFROMRESOURCE);
					//	//perf.NW();
					//	//PrintList(R, R2);
					//	R = R2;
					//}
				}
				catch(Exception e) { PrintDebug($"pidl={pidl}, {e.Message}, {e.TargetSite}"); }
				finally {
					Api.ReleaseComObject(eic);
					Api.ReleaseComObject(folder);
				}
				return R;
#endif




					//} else if(isFileType && !isURL) {
					//	uint n = 300; var sb = new StringBuilder((int)n);
					//	if(0 == Api.AssocQueryString(0, Api.ASSOCSTR.ASSOCSTR_DEFAULTICON, file, null, sb, ref n)) {
					//		var icon = sb.ToString();
					//		PrintList(file, icon);
					//		ParseIconLocation(ref icon, out index);
					//		return GetIconHandleRaw(icon, index, size);
					//	}




	#region test icons

	static void TestIcons()
	{
		//Print("start");
		//Sleep(1000);

		var a = new List<string>();
		int n = 0;
#if true
		foreach(var f in Directory.EnumerateFiles(@"q:\app")) {
			//Print(f);
			a.Add(f);
			//if((n & 1) == 0) a.Add(f);
			//if(++n == 30) break;
		}
#endif
#if false
		a.Add("mailto:");
		a.Add(@"shell:AppsFolder\Microsoft.WindowsCalculator_8wekyb3d8bbwe!App");
		a.Add(@"q:\app");
		a.Add(Folders.Favorites);
		a.Add("http://www.quickmacros.com/");
		a.Add("::{21EC2020-3AEA-1069-A2DD-08002B30309D}");
		a.Add(@"C:\Users\G\Desktop\QM in PF.lnk");
#endif
#if false
		a.Add("q:\\app\\Cut.ico");
		a.Add(@"Q:\Programs\ILSpy\ILSpy.exe");
		a.Add(Folders.System + "notepad.exe");
		a.Add("q:\\app\\Copy.ico");
		a.Add("q:\\app\\Paste.ico");
		a.Add("q:\\app\\Run.ico");
		a.Add("q:\\app\\Tip.ico");
		//a.Add("notepad.exe");
		a.Add(Folders.ProgramFilesX86 + @"PicPick\picpick.exe");
		a.Add(@"Q:\Programs\DebugView\Dbgview.exe");
		a.Add(@"Q:\Programs\ProcessExplorer\procexp.exe");
		a.Add(Folders.ProgramFilesX86 + @"Inno Setup 5\Compil32.exe");
		a.Add(Folders.ProgramFilesX86 + @"HTML Help Workshop\hhw.exe");
		a.Add(Folders.ProgramFilesX86 + @"FileZilla FTP Client\filezilla.exe");
		a.Add(Folders.ProgramFilesX86 + @"Internet Explorer\IEXPLORE.EXE");
		a.Add(@"Q:\Programs\ProcessMonitor\Procmon.exe");
		a.Add(Folders.ProgramFilesX86 + @"Resource Hacker\ResourceHacker.exe");
		a.Add(@"Q:\programs\Autoruns\autoruns.exe");
		//a.Add(Folders.ProgramFilesX86 + @"SyncBackFree\SyncBackFree.exe");
		a.Add(@"Q:\Programs\PeView\PEview.exe");
		a.Add(Folders.System + @"shell32.dll,25");
#endif

		//Print(Api.GetCurrentThreadId());
		var F = new Form();
		F.Click += (unu, sed) =>
		{
			_n = a.Count;
			Perf.First();

			//var aph = new _IconPathsAndHandles(a);
			////var work = new Util.TaskSTA(_IconWorkCallback1_W, aph); work.CreateWork();
			//var work = new Util.TaskSTA(_IconWorkCallback2_W, aph, _IconCompletionCallback_W, F); work.CreateWork();

			foreach(var s in a) {
				//_TestIconsSync(s);
				_TestIconsAsync(s);
				//var k = new _StringAndHandle() { s = s }; _TestIconsNewPool(k, F);
				//var k = new _StringAndHandle() { s = s }; work.RunWork();
			}
		};
		F.ShowDialog();
		//Print(2);

		//var m = new CatMenu();
		//m["aaaaaaaaa"] = null;
		//m.Show();
		//ShowRen.ShowEx("", timeoutS: 1);
		//new Form().ShowDialog();
		//Timer_.After(1000, t => _loop2.Stop()); _loop2.Loop();
		//Timer_.After(1000, t => Application.ExitThread()); Application.Run();
		//PrintList("end", _n);
	}

	static Util.MessageLoop _loop2 = new Util.MessageLoop();

	static void _TestIconsNewPool(_StringAndHandle s, Control control)
	{
		//new Util.TaskSTA(_IconWorkCallback1, s).Run();
		new Util.TaskSTA(_IconWorkCallback2, s, _IconCompletionCallback, control).Run();

	}

	class _StringAndHandle
	{
		public string s;
		public IntPtr h;
	}

	static object _IconWorkCallback1(object state)
	{
		var k = state as _StringAndHandle;
		var hi = Files.GetIconHandle(k.s, 16, 0);

		int n = Interlocked.Decrement(ref _n);
		//Print(n);
		if(n < 1) Perf.NextWrite();
		//PrintList(tid, Api.GetCurrentThreadId());

		if(hi == Zero) {
			PrintList("failed", k.s);
			return null;
		}
		Api.DestroyIcon(hi);
		return null;
	}

	class _IconPathsAndHandles
	{
		public List<string> _paths;
		public IntPtr[] _handles;
		int _counter;

		public _IconPathsAndHandles(List<string> paths)
		{
			_paths = paths;
			_handles = new IntPtr[paths.Count];
			_counter = -1;
		}

		public int GetNextPath(out string path)
		{
			int r = Interlocked.Increment(ref _counter);
			path = _paths[r];
			return r;
		}
	}

	static object _IconWorkCallback1_W(object state)
	{
		var k = state as _IconPathsAndHandles;
		string path; int counter = k.GetNextPath(out path);
		var hi = Files.GetIconHandle(path, 16, 0);

		int n = Interlocked.Decrement(ref _n);
		//Print(n);
		if(n < 1) Perf.NextWrite();
		//PrintList(tid, Api.GetCurrentThreadId());

		if(hi == Zero) {
			PrintList("failed", path);
			return null;
		}
		Api.DestroyIcon(hi);
		return null;
	}

	static object _IconWorkCallback2_W(object state)
	{
		var k = state as _IconPathsAndHandles;
		string path; int counter = k.GetNextPath(out path);
		k._handles[counter] = Files.GetIconHandle(path, 16, 0);
		return counter;
	}

	static object _IconWorkCallback2(object state)
	{
		var k = state as _StringAndHandle;
		k.h = Files.GetIconHandle(k.s, 16, 0);
		return null;
	}

	static void _IconCompletionCallback(object state, object workResult)
	{
		//PrintList("_CompletionCallback", Api.GetCurrentThreadId(), state);

		_n--;
		if(_n < 1) Perf.NextWrite();
		//PrintList(tid, Api.GetCurrentThreadId());

		var k = state as _StringAndHandle;
		var s = k.s;
		var hi = k.h;

		if(hi == Zero) {
			PrintList("failed", s);
			return;
		}
		Api.DestroyIcon(hi);
	}

	static void _IconCompletionCallback_W(object state, object workResult)
	{
		//PrintList("_CompletionCallback", Api.GetCurrentThreadId(), state);

		_n--;
		if(_n < 1) Perf.NextWrite();
		//PrintList(tid, Api.GetCurrentThreadId());

		var k = state as _IconPathsAndHandles;
		int counter = (int)workResult;
		var s = k._paths[counter];
		var hi = k._handles[counter];
		//PrintList(counter, hi, s);

		if(hi == Zero) {
			PrintList("failed", s);
			return;
		}
		Api.DestroyIcon(hi);
	}


#if true

	static int _n;
	static Random _random = new Random();

	static async void _TestIconsAsync(string s)
	{
		uint tid = Api.GetCurrentThreadId();
#if true
		var task = Task.Run(() =>
		{
			//PrintList(Api.GetCurrentThreadId(), s);
			//var perf = new Perf.Inst(true);
			var R = Files.GetIconHandle(s, 16, 0);
			//var R = Zero; Sleep(s.Length * s.Length / 100);
			//var R = Zero; Sleep(_random.Next(1, 10));
			//perf.Next(); PrintList(perf.Times, s);
			return R;
		});
#else
		var task = Task.Factory.StartNew(() =>
		{
			//PrintList(Api.GetCurrentThreadId(), s);
			//var perf = new Perf.Inst(true);
			var R = Files.GetIconHandle(s, 16, 0);
			//var R = Zero; Sleep(_random.Next(1, 10));
			//perf.Next(); PrintList(perf.Times, s);
			return R;
		}, CancellationToken.None, TaskCreationOptions.None, _staTaskScheduler);
#endif
		await task;
		IntPtr hi = task.Result;

		//Interlocked.Decrement(ref _n);
		_n--;
		if(_n < 1) Perf.NextWrite();
		//PrintList(tid, Api.GetCurrentThreadId());

		if(hi == Zero) {
			PrintList("failed", s);
			return;
		}
		Api.DestroyIcon(hi);
	}

	//static readonly System.Threading.Tasks.Schedulers.StaTaskScheduler _staTaskScheduler = new System.Threading.Tasks.Schedulers.StaTaskScheduler(4); //tested: without StaTaskScheduler would be 4 threads. With 3 the UI thread is slightly faster.

	static void _TestIconsSync(string s)
	{
		//var perf = new Perf.Inst(true);
		var hi = Files.GetIconHandle(s, 16, 0);
		//perf.Next(); PrintList(perf.Times, s);

		if(--_n == 0) Perf.NextWrite();

		if(hi == Zero) {
			PrintList("failed", s);
			return;
		}
		Api.DestroyIcon(hi);
	}

	//	static async void _TestIcons(List<string> a)
	//	{
	//		Print(Api.GetCurrentThreadId());
	//		Perf.First();

	//		foreach(var s in a) {
	//			if(s == "mailto:") Perf.Next();

	//#if true
	//			var task = Task.Run(() =>
	//			{
	//				PrintList(Api.GetCurrentThreadId(), s);
	//				var perf = new Perf.Inst(true);
	//				//var R = Files.GetIconHandle(s, 16, 0);
	//				var R = Zero;
	//				Sleep(s.Length * s.Length / 5);
	//				perf.Next(); PrintList(perf.Times, s);
	//				return R;
	//			});
	//#else
	//			var task = Task.Factory.StartNew(() =>
	//			{
	//				PrintList(Api.GetCurrentThreadId(), s);
	//				var perf = new Perf.Inst(true);
	//				var R= Files.GetIconHandle(s, 16, 0);
	//				perf.Next(); PrintList(perf.Times, s);
	//				return R;
	//			}, CancellationToken.None, TaskCreationOptions.None, _staTaskScheduler);
	//#endif
	//			await task;

	//			IntPtr hi = task.Result;
	//			if(hi == Zero) {
	//				//PrintList("failed", s);
	//				continue;
	//			}
	//			Api.DestroyIcon(hi);
	//		}

	//		Perf.Next();
	//		Perf.Write();
	//	}

#else
	static void _TestIcons(List<string> a)
	{
		Perf.First();

		foreach(var s in a) {
			if(s == "mailto:") Perf.Next();

			var hi= Files.GetIconHandle(s, 16, 0);
			if(hi == Zero) {
				PrintList("failed", s); continue;
			}
			Api.DestroyIcon(hi);
		}

		Perf.Next();
		Perf.Write();
	}
#endif

	static void TestThreadPoolSTA()
	{
		//Print(Api.GetCurrentThreadId());
		//Util.ThreadPoolSTA.AddWork(_WorkCallback, 100);
		new Util.TaskSTA(_WorkCallback, 100).Run();

		//Sleep(1000);
		var f = new Form();

		for(int i = 0; i < 10; i++) {
			//Util.ThreadPoolSTA.AddWork(_WorkCallback, _CompletionCallback, f, i, true);
			new Util.TaskSTA(_WorkCallback, i, _CompletionCallback, f).Run();
		}
		//Sleep(500);

		//f.Load += (unu, sed) =>
		//{
		//	//Print(f.IsHandleCreated);
		//	for(int i = 0; i < 1; i++) {
		//		Util.ThreadPoolSTA.AddWork(_WorkCallback, _CompletionCallback, f, i);
		//		new Util.TaskSTA(_WorkCallback, _CompletionCallback, f, i).Run();
		//	}
		//};

		//Print(1);
		f.ShowDialog();
		//Print(f.IsDisposed);
		f.Dispose();
		//Print(2);
		//ShowRen.Show("after");

		//GC.Collect();
		//ShowRen.Show("after");
	}

	static object _WorkCallback(object state)
	{
		PrintList("_WorkCallback", Api.GetCurrentThreadId(), state);
		//ShowRen.Show("work");
		//MessageBox.Show("work");
		return null;
	}

	static void _CompletionCallback(object state, object workResult)
	{
		PrintList("_CompletionCallback", Api.GetCurrentThreadId(), state);
	}

	#endregion test icons




	public static unsafe class ThreadPoolSTA
	{
		public static void AddWork(WaitCallback workCallback, object state = null)
		{
			AddWork(workCallback, null, null, state);
		}

		public static void AddWork(WaitCallback workCallback, WaitCallback completionCallback, Control completionControl, object state = null, bool startWhenHandleCreated = false)
		{
			if((completionCallback == null) != (completionControl == null)) throw new ArgumentNullException();

			new _Work(workCallback, completionCallback, completionControl, state, startWhenHandleCreated);
		}

		class _Work
		{
			WaitCallback _workCallback, _completionCallback;
			Control _control;
			object _state;
			GCHandle _gch;

			public _Work(WaitCallback workCallback, WaitCallback completionCallback, Control control, object state, bool startWhenHandleCreated)
			{
				_workCallback = workCallback;
				_completionCallback = completionCallback;
				_control = control;
				_state = state;
				_gch = GCHandle.Alloc(this);

				if(startWhenHandleCreated && control != null && !control.IsHandleCreated) {
					control.HandleCreated += _Control_HandleCreated;
				} else {
					_AddWork();
				}
			}

			private void _Control_HandleCreated(object sender, EventArgs e)
			{
				_control.HandleCreated -= _Control_HandleCreated;
				_AddWork();
			}

			void _AddWork()
			{
				bool ok = TrySubmitThreadpoolCallback(_SimpleCallback, Zero, _Env);
				Debug.Assert(ok);
			}

			void _SimpleCallback(IntPtr Instance, IntPtr Context)
			{
				APTTYPE apt; int aptq;
				if(0 == CoGetApartmentType(out apt, out aptq) && apt != APTTYPE.APTTYPE_STA)
					CoInitializeEx(Zero, COINIT.COINIT_APARTMENTTHREADED | COINIT.COINIT_DISABLE_OLE1DDE);

				//DebugPrintFunc();
				_workCallback(_state);
				var c = _control;
				if(c != null && !c.IsDisposed) {
					try {
						for(int i = 1; i < 70; i++) { //~2.5 s
							if(c.IsHandleCreated || c.IsDisposed) break;
							Sleep(i);
						}
						c.Invoke(_completionCallback, _state);
					}
					catch(InvalidOperationException e) {
						if(!c.IsDisposed) {
							PrintDebug(e);
						}
					}
					catch(Exception e) { PrintDebug(e); }
				}

				_gch.Free();
			}

			//~_Work()
			//{
			//	Print("dtor");
			//}
		}

		static ThreadPoolSTA()
		{
			var p = _Env;
			if(p->Pool != Zero) return;
			lock ("{A0142343-BA4D-4B27-B8EA-E5543C139796}") {
				if(p->Pool != Zero) return;

				p->Size = Api.SizeOf(*p);
				p->Version = 3;
				p->CallbackPriority = (int)TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_NORMAL;

				var pool = CreateThreadpool(Zero);
				SetThreadpoolThreadMinimum(pool, 2);
				SetThreadpoolThreadMaximum(pool, 4);

				p->Pool = pool;
			}
		}

		static TP_CALLBACK_ENVIRON_V3* _Env { get { return &_LibProcessMemory.Ptr->threadPool; } }

		internal struct TP_CALLBACK_ENVIRON_V3
		{
			public uint Version;
			public IntPtr Pool;
			public IntPtr CleanupGroup;
			//public PTP_CLEANUP_GROUP_CANCEL_CALLBACK CleanupGroupCancelCallback;
			public IntPtr CleanupGroupCancelCallback;
			public IntPtr RaceDll;
			public IntPtr ActivationContext;
			//public PTP_SIMPLE_CALLBACK FinalizationCallback;
			public IntPtr FinalizationCallback;
			public uint Flags;
			public int CallbackPriority;
			public uint Size;
		}

		enum TP_CALLBACK_PRIORITY
		{
			TP_CALLBACK_PRIORITY_HIGH,
			TP_CALLBACK_PRIORITY_NORMAL,
			TP_CALLBACK_PRIORITY_LOW,
			TP_CALLBACK_PRIORITY_INVALID,
			TP_CALLBACK_PRIORITY_COUNT = 3
		}

		[DllImport("kernel32.dll")]
		static extern IntPtr CreateThreadpool(IntPtr reserved);

		[DllImport("kernel32.dll")]
		static extern void CloseThreadpool(IntPtr ptpp);

		[DllImport("kernel32.dll")]
		static extern void SetThreadpoolThreadMaximum(IntPtr ptpp, uint cthrdMost);

		[DllImport("kernel32.dll")]
		static extern bool SetThreadpoolThreadMinimum(IntPtr ptpp, uint cthrdMic);

		delegate void PTP_WORK_CALLBACK(IntPtr Instance, IntPtr Context, IntPtr Work);

		[DllImport("kernel32.dll")]
		static extern IntPtr CreateThreadpoolWork(PTP_WORK_CALLBACK pfnwk, IntPtr pv, TP_CALLBACK_ENVIRON_V3* pcbe);

		[DllImport("kernel32.dll")]
		static extern void SubmitThreadpoolWork(IntPtr pwk);

		delegate void PTP_SIMPLE_CALLBACK(IntPtr Instance, IntPtr Context);

		[DllImport("kernel32.dll")]
		static extern bool TrySubmitThreadpoolCallback(PTP_SIMPLE_CALLBACK pfns, IntPtr pv, TP_CALLBACK_ENVIRON_V3* pcbe);

		[DllImport("kernel32.dll")]
		static extern void CloseThreadpoolWork(IntPtr pwk);

		[DllImport("kernel32.dll")]
		static extern void WaitForThreadpoolWorkCallbacks(IntPtr pwk, bool fCancelPendingCallbacks);

		public enum APTTYPE
		{
			APTTYPE_CURRENT = -1,
			APTTYPE_STA,
			APTTYPE_MTA,
			APTTYPE_NA,
			APTTYPE_MAINSTA
		}

		[DllImport("ole32.dll", PreserveSig = true)]
		public static extern int CoGetApartmentType(out APTTYPE pAptType, out int pAptQualifier);

		[Flags]
		public enum COINIT :uint
		{
			COINIT_APARTMENTTHREADED = 0x2,
			COINIT_MULTITHREADED = 0x0,
			COINIT_DISABLE_OLE1DDE = 0x4,
			COINIT_SPEED_OVER_MEMORY = 0x8
		}

		[DllImport("ole32.dll", PreserveSig = true)]
		public static extern int CoInitializeEx(IntPtr pvReserved, COINIT dwCoInit);

	}




		[DllImport("kernel32.dll", EntryPoint = "CreateMutexW")]
		public static extern IntPtr CreateMutex(IntPtr lpMutexAttributes, bool bInitialOwner, string lpName);

		[DllImport("kernel32.dll")]
		public static extern bool ReleaseMutex(IntPtr hMutex);

		static InterDomainHandle _mutexLibMem = new InterDomainHandle(CreateMutex(Zero, false, "Catkeys_LibMem"), "Catkeys_LibMem");

		public static unsafe IntPtr GetProcMem()
		{
			//Unfinished. Need to either use unique name (+ process id and start time) or check that the address is valid, because the environment variable may be inherited from an ancestor process.

			Perf.Next();
			string name = "Catkeys_LibMem";
			//Print(name);
			string s;
			s = Environment.GetEnvironmentVariable(name);
			//if(s != null) return (IntPtr)s.ToInt64_();
			if(s != null) return (IntPtr)Convert.ToInt64(s);

			Perf.Next();
			Api.WaitForSingleObject(_mutexLibMem.Handle, Api.INFINITE);

			s = Environment.GetEnvironmentVariable(name);
			//if(s != null) return (IntPtr)s.ToInt64_();
			if(s != null) return (IntPtr)Convert.ToInt64(s);

			Perf.Next();
			const int Size = 0x10000;
			IntPtr r = Api.VirtualAlloc(Zero, Size, 0x3000, 0x40); //much faster when need to zero memory
			Perf.Next();
			Environment.SetEnvironmentVariable(name, r.ToString());
			ReleaseMutex(_mutexLibMem.Handle);
			return r;
		}

		public static unsafe IntPtr GetProcMem2()
		{
			Perf.Next();
			var p = Process.GetCurrentProcess();
			string name = $"Catkeys_{p.Id}_{p.StartTime.ToBinary()}"; //p.StartTime.ToBinary is the slowest part
			Perf.Next();
			//Print(name);
			string s = Environment.GetEnvironmentVariable(name);
			//if(s != null) return (IntPtr)s.ToInt64_();
			if(s != null) return (IntPtr)Convert.ToInt64(s);
			//using(var x=new Mutex(false, "Cat"
			const int Size = 0x10000;
			IntPtr r = Api.VirtualAlloc(Zero, Size, 0x3000, 0x40); //much faster when need to zero memory
			Environment.SetEnvironmentVariable(name, r.ToString());
			return r;
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		public static unsafe IntPtr GetProcMem3()
		{
			return (IntPtr)LibSharedMemoryInterDomain.Ptr;
		}

	/// <summary>
	/// Shared memory that can be used by all appdomains of current process but not by other processes.
	/// </summary>
	internal unsafe struct LibSharedMemoryInterDomain
	{
		//Declare variables used by our library classes.
		//Be careful with types whose sizes are different in 32 and 64 bit process.
		internal _Workarounds.ProcVar workarounds;

		/// <summary>
		/// Shared memory size.
		/// </summary>
		internal const int Size = 0x10000;

		/// <summary>
		/// Creates or opens shared memory on demand in a thread-safe and process-safe way.
		/// </summary>
		static NativeSharedMemory _sm = new NativeSharedMemory("Catkeys_M_" + Api.GetCurrentProcessId(), Size);

		/// <summary>
		/// Gets pointer to the shared memory.
		/// </summary>
		public static LibSharedMemoryInterDomain* Ptr { get { return (LibSharedMemoryInterDomain*)_sm.mem; } }
	}



		/// <summary>
		/// Shared memory that can be used by all appdomains of current process but not by other processes.
		/// </summary>
		internal unsafe struct TestSharedMemoryInterDomain
		{
			//Declare variables used by our library classes.
			//Be careful with types whose sizes are different in 32 and 64 bit process.

			/// <summary>
			/// Shared memory size.
			/// </summary>
			internal const int Size = 0x10000;

			static TestSharedMemoryInterDomain()
			{
				_mm = System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen("Catkeys_M_" + Api.GetCurrentProcessId(), Size);
				_acc = _mm.CreateViewAccessor();
				byte* p = null;
				_acc.SafeMemoryMappedViewHandle.AcquirePointer(ref p);
				_mem = (IntPtr)p;
			}
			/// <summary>
			/// Creates or opens shared memory on demand in a thread-safe and process-safe way.
			/// </summary>
			static System.IO.MemoryMappedFiles.MemoryMappedFile _mm;
			static System.IO.MemoryMappedFiles.MemoryMappedViewAccessor _acc;
			static IntPtr _mem;

			/// <summary>
			/// Gets pointer to the shared memory.
			/// </summary>
			public static TestSharedMemoryInterDomain* Ptr { get { return (TestSharedMemoryInterDomain*)_mem; } }
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		public static unsafe IntPtr GetProcMem4()
		{
			return (IntPtr)TestSharedMemoryInterDomain.Ptr;
		}



		public static AppDomain DefaultAppDomain
		{
			get
			{
				if(_defaultAppDomain == null) {
					var host = CLRUtil.GetCorRuntimeHost();
					object oDom;
					if(0 != host.GetDefaultDomain(out oDom)) return null;
					_defaultAppDomain = oDom as AppDomain;
				}
				return _defaultAppDomain;
			}
		}

		//This works, but not faster than new CorRuntimeHost.
		static class CLRUtil
		{
			internal static ICorRuntimeHost GetCorRuntimeHost()
			{
				// Obtain ICLRMetaHost interface
				object objHost;
				int hr = CLRCreateInstance(ref CLSID_CLRMetaHost, ref IID_CLRMetaHost, out objHost);
				if(hr != 0) throw new COMException("Cannot create meta host", hr);
				var host = (ICLRMetaHost)objHost;

				// Obtain ICLRRuntimeInfo interface
				var vers = Environment.Version;
				var versString = string.Format("v{0}.{1}.{2}", vers.Major, vers.Minor, vers.Build);
				var objRuntime = host.GetRuntime(versString, ref IID_CLRRuntimeInfo);
				var runtime = (ICLRRuntimeInfo)objRuntime;
				bool started;
				uint flags;
				runtime.IsStarted(out started, out flags);
				if(!started) throw new COMException("CLR not started??");

				return (ICorRuntimeHost)runtime.GetInterface(ref CLSID_CorRuntimeHost, ref IID_CorRuntimeHost);
			}

			private static Guid CLSID_CLRMetaHost = new Guid(0x9280188d, 0xe8e, 0x4867, 0xb3, 0xc, 0x7f, 0xa8, 0x38, 0x84, 0xe8, 0xde);
			private static Guid IID_CLRMetaHost = new Guid(0xD332DB9E, 0xB9B3, 0x4125, 0x82, 0x07, 0xA1, 0x48, 0x84, 0xF5, 0x32, 0x16);
			private static Guid IID_CLRRuntimeInfo = new Guid(0xBD39D1D2, 0xBA2F, 0x486a, 0x89, 0xB0, 0xB4, 0xB0, 0xCB, 0x46, 0x68, 0x91);
			private static Guid CLSID_CorRuntimeHost = new Guid(0xcb2f6723, 0xab3a, 0x11d2, 0x9c, 0x40, 0x00, 0xc0, 0x4f, 0xa3, 0x0a, 0x3e);
			private static Guid IID_CorRuntimeHost = new Guid(0xcb2f6722, 0xab3a, 0x11d2, 0x9c, 0x40, 0x00, 0xc0, 0x4f, 0xa3, 0x0a, 0x3e);

			[DllImport("mscoree.dll")]
			private static extern int CLRCreateInstance(ref Guid clsid, ref Guid iid, [MarshalAs(UnmanagedType.Interface)] out object ptr);

			[ComImport, Guid("D332DB9E-B9B3-4125-8207-A14884F53216"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
			private interface ICLRMetaHost
			{
				[return: MarshalAs(UnmanagedType.Interface)]
				object GetRuntime(string version, ref Guid iid);
				// Rest omitted
			}

			[ComImport, Guid("BD39D1D2-BA2F-486a-89B0-B4B0CB466891"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
			private interface ICLRRuntimeInfo
			{
				void GetVersionString(char[] buffer, int bufferLength);
				void GetRuntimeDirectory(char[] buffer, int bufferLength);
				bool IsLoaded(IntPtr hProcess);
				void LoadErrorString(uint id, char[] buffer, int bufferLength, int lcid);
				void LoadLibrary(string path, out IntPtr hMdodule);
				void GetProcAddress(string name, out IntPtr addr);
				[return: MarshalAs(UnmanagedType.Interface)]
				object GetInterface(ref Guid clsid, ref Guid iid);
				bool IsLoadable();
				void SetDefaultStartupFlags(uint flags, string configFile);
				void GetDefaultStartupFlags(out uint flags, char[] configFile, int configFileLength);
				void BindAsLegacyV2Runtime();
				void IsStarted(out bool started, out uint flags);
			}
		}


		//public static AppDomain DefaultAppDomain
		//{
		//	get
		//	{
		//		if(_defaultAppDomain == null) {
		//			var host = new mscoree.CorRuntimeHost();
		//			object defaultAppDomain;
		//			host.GetDefaultDomain(out defaultAppDomain);
		//			_defaultAppDomain = defaultAppDomain as AppDomain;
		//		}
		//		return _defaultAppDomain;
		//          }
		//}

		[DllImport("mscoree.dll", PreserveSig = true)]
		static extern int DllGetClassObject([In] ref Guid rclsid, [In] ref Guid riid, [MarshalAs(UnmanagedType.IUnknown)] out object ppv);

		[ComImport, Guid("00000001-0000-0000-C000-000000000046"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		interface IClassFactory
		{
			[PreserveSig]
			int CreateInstance(IntPtr pUnkOuter, [In] ref Guid riid, [MarshalAs(UnmanagedType.IUnknown)] out object ppvObject);
			[PreserveSig]
			int LockServer([MarshalAs(UnmanagedType.Bool)] bool fLock);
		}

		static Guid IID_IClassFactory = new Guid(0x00000001, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);
		static Guid CLSID_CorRuntimeHost = typeof(CorRuntimeHost).GUID;
		static Guid IID_ICorRuntimeHost = typeof(ICorRuntimeHost).GUID;

		[DllImport("ole32.dll", PreserveSig = true)]
		public static extern int CoCreateInstance([In] ref Guid rclsid, IntPtr pUnkOuter, uint dwClsContext, [In] ref Guid riid, [MarshalAs(UnmanagedType.IUnknown)] out object ppv);

		const uint CLSCTX_SERVER = 0x15;


		//public static AppDomain DefaultAppDomain
		//{
		//	get
		//	{
		//		if(_defaultAppDomain == null) {
		//			object oIcf, oHost, oDom;
		//			if(0 != CoCreateInstance(ref CLSID_CorRuntimeHost, Zero, CLSCTX_SERVER, ref IID_ICorRuntimeHost, out oHost)) return null;
		//			Print(1);
		//			var host=(ICorRuntimeHost)oHost;
		//			PrintHex(host.GetDefaultDomain(out oDom));
		//			if(0 != host.GetDefaultDomain(out oDom)) return null;
		//			Print(3);
		//			_defaultAppDomain = oDom as AppDomain;
		//		}
		//		return _defaultAppDomain;
		//          }
		//}
		//public static AppDomain DefaultAppDomain
		//{
		//	get
		//	{
		//		if(_defaultAppDomain == null) {
		//			object oIcf, oHost, oDom;
		//			if(0 != DllGetClassObject(ref CLSID_CorRuntimeHost, ref IID_IClassFactory, out oIcf)) return null;
		//			Print(1);
		//			if(0!=((IClassFactory)oIcf).CreateInstance(Zero, ref IID_ICorRuntimeHost, out oHost)) return null;
		//			Print(2);
		//			var host=(ICorRuntimeHost)oHost;
		//			PrintHex(host.GetDefaultDomain(out oDom));
		//			if(0 != host.GetDefaultDomain(out oDom)) return null;
		//			Print(3);
		//			_defaultAppDomain = oDom as AppDomain;
		//		}
		//		return _defaultAppDomain;
		//          }
		//}





		//static bool _OnRButtonUpShowContextMenu(ToolStripDropDownMenu dd)
		//{
		//	var cm = dd.ContextMenu;
		//	if(cm == null) return false;

		//	Wnd w = (Wnd)dd.Handle;
		//	bool ac = dd.AutoClose, en = dd.Enabled;
		//	dd.AutoClose = false;
		//	dd.Enabled = false;

		//	cm.Show(dd, dd.PointToClient(Mouse.XY));

		//	//when user clicks disabled menu dd to close cm, don't enable dd until the left mouse button released, or it would select the menu item
		//	Timer_.Every(10, t =>
		//	{
		//		if(Control.MouseButtons.HasFlag(MouseButtons.Left) && w.Visible) return;
		//		t.Stop();
		//		if(!dd.IsDisposed) {
		//			dd.Enabled = en;
		//			dd.AutoClose = ac;
		//		}
		//	});
		//	return true;
		//}



	static void TestCatMenuSpeed(Control c = null)
	{
		var speed = new Perf.Inst();
		speed.First();
		Perf.First();
		var m = c != null ? new CatMenu(new Container()) : new CatMenu();
		Perf.Next();
		m["One"] = o => Print("one");
		Perf.Next();
		//m["Two"] = o => Print("two");
		//m.Items.Add("text");
		for(int i = 0; i < 20; i++) m[$"More {i}"] = o => Print(o);
		Perf.Next();
		//Print(m.LastItem.Height);
		using(var sm = m.Submenu("Submenu")) {
			m["Three"] = o => Print("three");
			m["Four"] = o => Print("four");
			Perf.Next();
			for(int i = 0; i < 20; i++) m[$"More {i}"] = o => Print(o);
			Perf.Next();
		}
		Perf.Next();
		speed.NextWrite();
		Sleep(1000);
		Perf.Next();
		if(c != null) {
			m.Show(c, 100, 100);
		} else {
			//m.Show();
			m.Show(Mouse.X + 10, Mouse.Y + 10);
		}
	}

	static void TestCatMenuArray(Control c = null)
	{
		Perf.First();
		var m = c != null ? new CatMenu(new Container()) : new CatMenu();
		Perf.Next();
		var a = new ToolStripItem[30];
		for(int i = 0; i < a.Length; i++) a[i] = new ToolStripMenuItem("text");
		Perf.Next();
		m.CMS.Items.AddRange(a);
		Perf.Next();
		using(m.Submenu("Submenu")) {
			m["Three"] = o => Print("three");
			m["Four"] = o => Print("four");
		}
		Perf.Next();
		if(c != null) {
			m.Show(c, 100, 100);
		} else {
			//Wait(0.5); Perf.Next();
			//m.Show();
			m.Show(Mouse.X + 10, Mouse.Y + 10);
		}
	}



	public class CatBar :NativeWindow
	{
		static Wnd.Misc.WndClass _WndClass = Wnd.Misc.WndClass.Register("CatBar", _WndProc, 0, Api.CS_GLOBALCLASS);
		//static Wnd.Misc.WndClass _WndClass;
		Wnd _w;

		public static CatBar Create()
		{
			//if(_WndClass == null) { //to test class registration speed
			//	_WndClass = Wnd.Misc.WndClass.Register("CatBar", _WndProc, 0, Api.CS_GLOBALCLASS);
			//	Perf.Next();
			//}

			var c = new CatBar();
			Perf.Next();
			uint exStyle = Native.WS_EX_TOOLWINDOW | Native.WS_EX_NOACTIVATE | Native.WS_EX_TOPMOST;
			uint style = Native.WS_POPUP | Native.WS_CAPTION | Native.WS_SYSMENU;

			//var p = new CreateParams() { ClassName= "CatBar", ExStyle = (int)exStyle, Style = (int)style, X = 400, Y = 200, Width = 1200, Height = 80 };
			//c.CreateHandle(p); //registers class like "WindowsForms10.CatBar.app.0.3ee7db9_r6_ad2". Then would be two classes.

			c._w = Api.CreateWindowEx(exStyle, _WndClass.Name, null, style, 400, 200, 1200, 80, Wnd0, 0, Zero, 0);
			if(c._w.Is0) throw new Win32Exception();
			c.AssignHandle(c._w.Handle);

			return c;
		}

		protected override void WndProc(ref Message m)
		{
			//Print(m);
			base.WndProc(ref m);

			switch((uint)m.Msg) {
			case Api.WM_NCDESTROY:
				_mlTb.Stop();
				break;
			case Api.WM_PAINT:
				//Print("painted");
				//if(_tbStrip2 != null) {
				//	ToolStrip2 t = _tbStrip2; _tbStrip2 = null;
				//	if(!t.Focused) t.Focus(); //solves problem when in native window: the first button-click does not work. This takes several milliseconds therefore is after painting.
				//}
				break;
			}
		}

		static LPARAM _WndProc(Wnd w, uint msg, LPARAM wParam, LPARAM lParam)
		{
			LPARAM R = Api.DefWindowProc(w, msg, wParam, lParam);
			return R;
		}
	}




	#region test old menu

	static void TestOldMenu(Control c = null)
	{
		Perf.First();
		var f = new Form();
		Wnd w = (Wnd)f;
		Api.SetParent(w, Wnd.Misc.SpecHwnd.Message);
		w.SetExStyle(Native.WS_EX_TOOLWINDOW);
		w.SetStyle(Native.WS_POPUP);
		w.Visible = true;
		Perf.Next();

		var m = new ContextMenu();
		Perf.Next();
		m.MenuItems.Add("First", _eho);
		Perf.Next();
		for(int i = 0; i < 16; i++) {
			MenuItem k = m.MenuItems.Add("Text");
			//k.OwnerDraw = true;
			//k.MeasureItem += K_MeasureItem;
			//k.DrawItem += K_DrawItem;
		}
		Perf.Next();

		//add no-activate ex style. On Popup event the menu window is still not created.
		var t = new System.Windows.Forms.Timer();
		t.Interval = 1;
		t.Tick += (o, e) =>
		{
			Perf.Next();
			t.Stop();
			foreach(var tw in Wnd.ThreadWindows()) {
				if(tw.ClassNameIs("#32768")) {
					//Print(tw);
					tw.SetExStyleAdd(Native.WS_EX_NOACTIVATE);
					break;
				}
			}
			Perf.NextWrite();
		};
		t.Start();

		Perf.Next();
		//m.Popup += (o, e) => { Perf.NextWrite(); };

		m.Show(f, new Point(0, 0));
		Application.DoEvents(); //run the click event handler
    }

	private static void K_MeasureItem(object sender, MeasureItemEventArgs e)
	{
		PrintList(e.ItemHeight, e.ItemWidth);
	}

	private static void K_DrawItem(object sender, DrawItemEventArgs e)
	{
		//DebugPrintFunc();
	}

	static EventHandler _eho = _EventHandlerOld;

	static void _EventHandlerOld(object sender, EventArgs args)
	{
		DebugPrintFunc();
	}

	#endregion

		//class HiddenForm :Form
		//{
		//	protected override void SetVisibleCore(bool value)
		//	{
		//		if(!this.IsHandleCreated) {
		//			this.CreateHandle();
		//			value = false;   // Prevent window from becoming visible
		//		}
		//		base.SetVisibleCore(value);
		//	}
		//}




////Perf.SpinCPU(); //does nothing
//long t1 = Stopwatch.GetTimestamp();

////TODO: instead could simply allocate unmanaged memory with Marshal methods and pass to domains with childDomain.SetData
//_sm = new OurSharedMemory();
//_sm.Create("Catkeys_SM_Tasks", 1024 * 1024);

//if(true) //compiler
//{
//	_sm.x->perf.AddTicksFirst(t1);
//	_sm.x->perf.Next();

//	IntPtr ev = Api.CreateEvent(Zero, false, false, null);

//	_sm.x->eventCompilerStartup = ev;

//	//Mes("before");

//	var thr = new Thread(_AppDomainThread);
//	thr.Start();

//	_sm.x->perf.Next();

//	Api.WaitForSingleObject(ev, ~0U);
//	//Thread.Sleep(100);
//	Api.CloseHandle(ev);

//	_sm.x->perf.Next();
//	_sm.x->perf.Write();

//	_hwndCompiler = _sm.x->hwndCompiler;

//	for(int i = 0; i < 1; i++) {
//		_hwndCompiler.Send(Api.WM_USER, Zero, Marshal.StringToBSTR("test"));
//	}

//	//Mes("in");

//	_hwndCompiler.Send(Api.WM_CLOSE);
//	//Environment.Exit(0);

//	//Mes("after");
//	//return;
//}

////Thread.Sleep(100);

////for(int i = 0; i<5; i++) {
////	var thr2 = new Thread(_AppDomainThread2);
////	thr2.Start();
////	Thread.Sleep(100);
////	if(i%10!=9) continue;
////	//Perf.First();
////	thr2=null;
////	GC.Collect(); //releases a lot. Without it, GC runs when Task Manager shows 100 MB.
////				  //GC.Collect(2, GCCollectionMode.Optimized); //collects at 26 MB; without - at 36 MB
////}
////Mes("exit");	//static void _AppDomainThread2()

//{
//	Perf.First();
//	var domain = AppDomain.CreateDomain("Compiler");
//	Perf.Next();
//	domain.ExecuteAssembly(@"C:\Test\test1.exe");
//	Perf.Next();
//	AppDomain.Unload(domain);
//	Perf.NextWrite();
//}

//static void _AppDomainThread()
//{
//	//_DomainCallback();

//	var domain = AppDomain.CreateDomain("Compiler");
//	//var domain=AppDomain.CreateDomain("Compiler", AppDomain.CurrentDomain.Evidence, new AppDomainSetup { LoaderOptimization = LoaderOptimization.MultiDomain }); //by default makes faster, but makes much slower when we use LoaderOptimization attribute on Main(). Assemblies will not be unloaded when appdomain unloaded (will use many MB of memory).
//	//System.IO.Pipes.AnonymousPipeClientStream
//	//childDomain.SetData("hPipe", handle.ToString());
//	unsafe { _sm.x->perf.Next(); }

//	domain.DoCallBack(_DomainCallback);
//	//domain.ExecuteAssembly(Paths.CombineApp("Compiler.exe"));
//	//domain.DoCallBack(Compiler.Compiler.Main); //faster than ExecuteAssembly by 3-4 ms
//	AppDomain.Unload(domain);
//	domain = null;
//	//Print("_AppDomainThread() ended");
//	GC.Collect(); //releases a lot
//				  //Mes("MinimizeMemory");
//				  //Misc.MinimizeMemory(); //does nothing

//	//tested:
//	//Currently speed and memory is similar in both cases - when compiler is in this assembly and when in another.
//	//But will need to test later, when this assembly will be big.
//	//Not using LoaderOptimization.MultiDomain, because then does not unload assemblies of unloaded domains (then uses much memory, and there is no sense to execute compiler in a separate domain).
//}


////[MethodImpl(MethodImplOptions.NoOptimization)]
//static unsafe void _DomainCallback()
//{
//	//if(AppDomain.CurrentDomain.FriendlyName!="Compiler") return;
//	long t1 = Stopwatch.GetTimestamp();

//	_sm = new OurSharedMemory();
//	_sm.Open("Catkeys_SM_Tasks");

//	_sm.x->perf.AddTicksNext(t1);
//	_sm.x->perf.Next();

//	//=AppDomain.CurrentDomain.GetData("hPipe")

//	_wndClassCompiler = Wnd.Misc.WndClass.Register("Catkeys_Compiler", _WndProcCompiler);

//	_sm.x->perf.Next();

//	Wnd w = Api.CreateWindowEx(0, _wndClassCompiler.Name, null, Native.WS_POPUP, 0, 0, 0, 0, Wnd.Misc.SpecHwnd.Message, Zero, Zero, Zero);

//	_sm.x->perf.Next();

//	_SHMEM* x = _sm.x;
//	x->hwndCompiler = w;
//	Api.SetEvent(x->eventCompilerStartup);

//	//message loop
//	//Application.Run(); //By default would add several ms to the startup time. Same speed if Main() has the LoaderOptimization attribute. Also may be not completely compatible with native wndproc. Also in some cases adds several MB to the working set.
//	Native.MSG m;
//	while(Api.GetMessage(out m, Wnd0, 0, 0) > 0) { Api.DispatchMessage(ref m); }
//}

//struct _SHMEM
//{
//	public IntPtr eventCompilerStartup;
//	public Wnd hwndCompiler;
//	public Perf.PerfInstance perf;
//}

////We don't use MemoryMappedFile because it is very slow. Creating/writing is 1500, opening/reading is 5000.
////With this class - 1300 and 600 (because of JIT). With ngen - 60 and 20 (same as in C++).
//unsafe class OurSharedMemory :Util.SharedMemoryFast
//{
//	public _SHMEM* x { get { return (_SHMEM*)_mem; } }
//}

//static OurSharedMemory _sm;
//static Wnd _hwndCompiler;



////class DialogVariables { public string lb3, c4; public string[] au; }
////class DialogVariables { public object lb3, c4, au; }
////here class is better than struct, because:
////Don't need ref;
////Can be used with modeless dialogs.

////const string S1="one"+NL+"two"; //ok
////const string S2=$"one{NL}two"; //error


//static void ShowDialog(object v)
//{
//	FieldInfo[] a = v.GetType().GetFields();
//	foreach(FieldInfo f in a) {
//		Print(f.Name);
//		//Print(f.FieldType.Equals(typeof(string)));
//		switch(Type.GetTypeCode(f.FieldType)) {
//		case TypeCode.String: Print("string"); break;
//		case TypeCode.Object: Print("object"); break;
//		}
//	}
//}

////delegate void Dee(GCHandle x);

////static void Mee(GCHandle x)
////{
////Print("here"); return;
//////Print(x.IsAllocated);
////Print(GCHandle.ToIntPtr(x));
////if(GCHandle.ToIntPtr(x)==Zero) Print("null");
////else {
////string s=(x.Target as string);
////Print(s);
////}
////}
//delegate void Dee(object x);


//delegate void Del(int t);
////delegate void Del0();

//class TestIndexers
//{
//	//public int this[int i]
//	//{
//	//get { return i*i; }
//	//set { Print($"{i} {value}"); }
//	//}
//	//public int this[int i, int j=1]
//	//{
//	//	get { return i*j; }
//	//	set { Print($"{i} {j} {value}"); }
//	//}
//	public string this[string s]
//	{
//		get { return s + " ?"; }
//		set { Print($"{s} {value}"); }
//	}

//	//static TestIndexers ti_=new TestIndexers();
//	//public static TestIndexers Hotkey => ti_;
//	//or
//	public static readonly TestIndexers Hotkey = new TestIndexers();
//}

////[MethodImpl(MethodImplOptions.NoInlining)]
////static void TestCallersVariables()
////{
////	Perf.First();
////	StackFrame frame = new StackFrame(1);
////	var method = frame.GetMethod();
////	MethodBody mb=method.GetMethodBody();
////	int n=0;
////	foreach(LocalVariableInfo v in mb.LocalVariables) {
////		//Print(v.LocalType.ToString());
////		if(v.LocalType.Name=="Wnd") {
////			n++;
////			//v.
////		}
////	}
////	Print(n);
////}


//[Trigger.Hotkey("Ctrl+K")]
//public static void Function1(HotkeyTriggers.Message m) { Print("script"); }



//TestUnmanaged();

//StackTrace stackTrace = new StackTrace();
//Print(stackTrace.GetFrame(1).GetMethod().Name);
////Print(stackTrace.GetFrame(1).GetFileLineNumber()); //always 0, even in Debug build
//Print(stackTrace.GetFrame(1).GetFileName()); //null
////Print(stackTrace.GetFrame(1).GetMethod(). //nothing useful




//Dee f=Mee;
////f(GCHandle.Alloc("test"));
////f(GCHandle.FromIntPtr(Zero));
//f("test");
//f(5);


//return;

//UIntPtr ki=1;

//switch(2)
//{
//	case 1:
//	int hdh=8;
//	break;
//	case 2:
//	int koop=8;
//Print(hdh);
//	break;
//}

//Print(hdh);

//Print($"one{_}two");
//Print("three"+_+"four");
//Print("one" RN "two"); //error
//Print($"one{}two"); //error


////str controls="3"
////var d=new DialogVariables("3") { lb3="oooo" };
////var d=new DialogVariables("3");
//var d=new DialogVariables();
//d.lb3="oooo";
//d.c4=7;
//d.au=new string[] { "one", "two" };
////d.au={ "one", "two" }; //error
//ShowDialog(d);
//return;


//static void AnotherThread()
//{
//	//ShowRen.Show("another thread", "", "", x:1);
//	MessageBox.Show("another thread");
//	Print("after msgbox in another thread");
//}

//[DllImport("comctl32.dll", EntryPoint = "TaskDialog")]
//static extern int _TaskDialog(Wnd hWndParent, IntPtr hInstance, string pszWindowTitle, string pszMainInstruction, string pszContent, TDButtons dwCommonButtons, LPARAM pszIcon, out int pnButton);

//static int TD(string s, bool asy)
//{
//	int r = 0;
//	for(int i = 0; i < 100; i++) {
//		int hr = _TaskDialog(Wnd0, Zero, "Test", s, null, TDButtons.Cancel, 0, out r);
//		//PrintList(hr, r, asy);
//		if(hr == 0 || hr == Api.E_INVALIDARG) break;
//		Thread.Sleep(20);
//	}
//	return r;
//}



////string ss = "gggggg.txt";
////Print(ss.Like_(false, "*.exe", "*.txt"));

////string ss = "5ggggg.txt";
////Print(ss.LikeEx_(false, "#*.exe", "#*.txt"));

////string ss = "5ggggg.txt";
////Print(ss.Equals_(false, "moo.exe", "5ggggg.txt"));

////string ss = "5ggggg.txt";
////Print(ss.EndsWith_(false, ".exe", ".txt"));

////string ss = "file.txt";
////Print(ss.StartsWith_(false, "kkk", "file."));

//string ss = "file.txt";
////Print(ss.RegexIs_(".*.TXT"));
////Print(ss.RegexIs_(".*.txt", RegexOptions.IgnoreCase));
////Print(ss.RegexIs_(0, ".*.TXT", ".*.txt"));
////Print(ss.RegexIs_(RegexOptions.IgnoreCase, ".*.TXT", ".*.txt"));
//ss = "gggg.exe\naaa.txt\nbbb.txt";
////Print(ss.RegexMatch_(".*.TXT"));
////Print(ss.RegexMatch_(".*.TXT", RegexOptions.IgnoreCase));
////Output.Write(ss.RegexMatches_(".*.TXT"));
////Output.Write(ss.RegexMatches_(".*.TXT", RegexOptions.IgnoreCase));

//Print(ss.RegexReplace_(@"\.txt\b", ".moo"));
//Print(ss.RegexReplace_(@"\.txt\b", m=> { return ".boo"; }));

////var au = new int[] {1, 2, 3 };
////var au = new List<int> {1, 2, 3 };
////var au = new Dictionary<string, string>() { { "A", "B" }, { "C", "D" } };
////Output.Write(au, ", ");

//return;




//Print(AppDomain.CurrentDomain.FriendlyName);

//new Thread(AnotherThread).Start();

//ShowRen.Show("appdomain primary thread", "", "e");

////Thread.CurrentThread.Abort();
////AppDomain.Unload(AppDomain.CurrentDomain);
//Print("after TaskDialog");

//return;

//ShowRen.Show("", "<a href=\"test\">test</a>", onLinkClick: ed =>
//{
//	Wnd z = ed.hwnd;
//	string s = null;
//	Perf.First(100);
//	for(int j = 0; j<8; j++) {
//		for(int i=0; i<1000; i++) s= z.ClassName;
//		//for(int i=0; i<1000; i++) s= z.Name;
//		//for(int i = 0; i<1000; i++) s= z.ControlText;
//		//for(int i = 0; i<1000; i++) s= z.ControlTextLength;
//		Perf.Next();
//	}
//	Perf.Write();
//	Print(s);
//}
//);

//return;

////Time.Wait(1);
//Wnd z = Wnd.Find("Untitled - Notepad");
////z=(Wnd)2098486; //Inno
////z=(Wnd)395896; //Static
////z=(Wnd)1510052; //Edit

////z.Name = "MMMMMMMMGGGG"; return;

////string m = z.Name;
////string m = z.GetControlText();
////PrintList(m==null, m=="", m);
////return;

//Print(z);

//string cn = null;
////cn= z.ControlText; PrintList(cn.Length, cn); return;
//int nt = 0;

//Perf.First(100);
//for(int j = 0; j<8; j++) {
//	//for(int i=0; i<1000; i++) cn= z.ClassName;
//	//for(int i=0; i<1000; i++) cn= z.Name;
//	for(int i = 0; i<1000; i++) cn= z.GetControlText();
//	Perf.Next();
//}
//Perf.Write();
//Print(cn);
//Print(nt);

//Wnd ww = Wnd.Find("Untitled - Notepad");
//ww.MoveInScreen(100, 100);
//return;

//DebugPrintFunc();
//Print(FunctionName());
//Output.WriteHex((sbyte)(-10));
//PrintList(1, "mmm", true, null, 5.6);
//Print("ff");
//Print(5);
//PrintList(1, 2, 3);
//return;

//Output.Clear();
//Screen s = null;
////Output.Write(s);
////Console.WriteLine(s);
//Info("stri");
//Info(5);
//Info(true);
//Info(new char[] { 'a', 'b' });
//Info(new string[] { "aaa", "bbb" });
//Info(new int[] { 'a', 'b' });
//Info(new Dictionary<string, string>() { { "A", "B" }, { "C", "D" } });
//Print("----------");
//Print("stri");
//Print(5);
//Print(true);
//Print(new char[] { 'a', 'b' });
//Print(new string[] { "aaa", "bbb" });
//Print(new int[] { 'a', 'b' });
//Print(new Dictionary<string, string>() { { "A", "B" }, { "C", "D" } });

////Perf.First(100);
////for(int j=0; j<5; j++) {
////	for(int i = 0; i<1000; i++) Info2("ff");
////	Perf.Next();
////}
////Perf.Write();

//return;




//Wait(2);
//Info("bla");
//Print("bla");
//Say("bla");
//Print("bla");
//OW("bla");

//Info("bla"); Warning("bla"); Error("bla");



//Wnd w = Wnd.Find("Untitled - Notepad");
////Wnd w2 = Wnd.Find("Registry Editor");

////w.MoveInScreen(0, 0, null, limitSize:true, rawXY:false);
////w.EnsureInScreen(null, limitSize:true, workArea:true);

//RECT k=new RECT(0, 1700, 5000, 400, true);
////RECT k=new RECT(-1, -1, 500, 400, true);

////Wnd.RectMoveInScreen(ref k, limitSize:true);
//Wnd.RectEnsureInScreen(ref k, limitSize:true);
//Print(k);

////w=Wnd.Misc.SpecHwnd.NoTopmost;
//Print(Screen_.FromObject(w));

////Screen s1 = Screen_.FromObject(w);
////Screen s2 = Screen_.FromObject(w);
//Screen s1 = Screen.PrimaryScreen;
//Screen s2 = Screen.PrimaryScreen;
//Print(s1==s2);
//Print(s1.Equals(s2));


//IntPtr hm = DisplayMonitor.GetHandle(w);
////hm=DisplayMonitor.GetHandle(2);
////hm=DisplayMonitor.GetHandle(DisplayMonitor.OfMouse);
////hm=DisplayMonitor.GetHandle(new POINT(2000, 2000));
////hm=DisplayMonitor.GetHandle(new RECT(2000, 2000, 100, 100, true));
//Print(hm);

//for(int z=0; z<2; z++) {
//	Screen[] ad = Screen.AllScreens;
//	foreach(Screen k in ad) {
//		RECT rr = k.Bounds;
//		Print(rr);
//	}
//	ShowRen.MessageDialog("aaa");
//}

//Perf.First(100);
//for(int rep1=0; rep1<5; rep1++) {
//	//for(int rep2=0; rep2<100; rep2++) { RECT u1 = DisplayMonitor.GetRectangle(2); }
//	for(int rep2=0; rep2<100; rep2++) { RECT u2 = ScreenFromIndex(2).Bounds; }
//	Perf.Next();
//}
//Perf.Write();

//Screen k = ScreenFromIndex(1);
//Print(k.Bounds);


//return;

//RECT r1; System.Drawing.Rectangle r2;

//Api.GetWindowRect(w, out r1);
//GetWindowRect(w, out r2);

//PrintList(r1, r2);

//return;


//var r1 = new RECT();
//var r2 = r1;
//var r3 = RECT.LTRB(1, 8, 10, 50);
//var r4 = RECT.LTWH(1, 8, 10, 50);
//var r5 = new RECT() { left=2, top=20, Width=2, Height=10 };

//Print(r2==r1);

//Print(r3);
//Print(r4);
//Print(r5);

//return;

//Wnd w = Wnd.Misc.SpecHwnd.Bottom;
//Print(w.Equals(Wnd.Misc.SpecHwnd.Bottom));
//Wnd w2 = w;
//Print(w.Equals(w2));
////Wnd w = Wnd0;
////Print(w.Equals(Wnd0));

//Wnd wg = Wnd.Get.FirstToplevel();

//return;

//int eon, x = "ab 99 hjk".ToInt_(2, out eon);
//PrintList(x, eon);
//int x = "ab 99 hjk".ToInt_(2);
//int x = " 99 hjk".ToInt_();
//PrintList(x);
//int eon, x = " 99 hjk".ToInt_(out eon);
//PrintList(x, eon);

//return;

//#if NEWRESULT
//try {
//Thread.Sleep(5000);

//Api.MessageBox(Wnd0, "dd", "ggg", 0x40000);
//return;

//Script.Option.dialogRtlLayout=true;
//Script.Option.dialogTopmostIfNoOwner=true;

//var asm = Assembly.GetEntryAssembly(); //fails if DoCallBack or CreateInstance, OK if ExecuteAssembly
//var asm = Assembly.GetExecutingAssembly(); //OK
//Print(asm!=null);
//Print(asm.Location);
////var rm = new System.Resources.ResourceManager("", asm);
////Print(rm);
//return;

//ScriptOptions.DisplayName="Script display name";
//Print(Assembly.GetEntryAssembly().FullName); //exception

//Wnd ko = Wnd0;
////ko = Wnd.Misc.SpecHwnd.Topmost;
//Print(ko == null);
//Print(null==ko);
//Wnd? mo = null, mo2=null;
//Print(ko == mo);
//Print(mo == mo2);
//POINT po = new POINT();
//Print(po == null);
////int io = 0;
////Print(io == null);
//IntPtr pi = Zero;
//Print(pi == null);
//return;

//Print(sizeof(WPARAM));

////void* b = (void*)1000000;
////IntPtr b = (IntPtr)(-1);
////UIntPtr b = (UIntPtr)(0xffffffff);
//int b = -1;
////uint b = 0xffffffff;
////byte b = 5;
////sbyte b = -5;
////ushort b = 5;
////short b = -5;
////char b = 'A';
////WPARAM b = -1;

////IntPtr b=(IntPtr)(-1);
////UIntPtr b=(UIntPtr)(0xffffffff);
////uint b = 5;
////char b = 'A';

//LPARAM x;
//x=b;
////x=1000;
//b=x;

////uint u =0xffffffff;
////int x = (int)u;
////WPARAM y = u;

//Print("OK");
//Print($"{x} {b}");
////Print($"{x} {((int)b).ToString()}");
////Print(x==-1);
////Print(x+4);


////string s = " 10 more";
//string s = "-10 more";
////string s = "0x10 more";
////string s = "-0x10";
//s=" 15 text";

////Print(Convert.ToInt32(s));
////Print(int.Parse(s));
////Print(SplitNumberString(ref s));
////Print($"'{s}'");

//int len, r = s.ToInt_(out len);
//Print($"{r} 0x{r:X} {len}");

//string tail;
//r=s.ToInt_(out tail);
//Print($"{r} 0x{r:X} '{tail}' {tail==null}");

//Perf.SpinCPU();
//int i, j, n1=0, n2=0;
//for(j=0; j<4; j++) {
//	Perf.First();
//	for(i=0; i<1000; i++) n1+=int.Parse(s);
//	Perf.Next();
//	for(i=0; i<1000; i++) n2+=ToInt_(s, out len);
//	Perf.NextWrite();
//}
//Print($"{n1} {n2} {len}");

//string[] a = { "one", "two" };
//Print(a);

//var d = new Dictionary<int, int>() { { 1, 1 }, { 2, 2 } };
//Print(d);

//var k = new Dictionary<string, string>() { { "A", "B" }, { "C", "D" } };
////Print(k);
//Output.Write(k);

//Redirect();
//Thread.Sleep(100);

//Output.Writer=new MooWriter();

//Perf.SpinCPU();
//int i, n=10;
//for(int j=0; j<3; j++) {

//	Perf.First();
//	for(i=0; i<n; i++) Print("out");
//	Perf.Next();
//	for(i=0; i<n; i++) Console.WriteLine("con");
//	//Perf.Next();
//	//for(i=0; i<n; i++) Trace.WriteLine("tra");
//	Perf.NextWrite();
//}
//speed: Write unbuffered 35, Console.WriteLine 30, Trace.WriteLine (debug mode) 900

////Perf.First(100);
////Output.AlwaysOutput=true;
//Output.RedirectConsoleOutput();
//Output.RedirectDebugOutput();
////Perf.NextWrite();

////Console.Write("{0} {1}", 1, true);
////return;
//Print("out");
//Console.WriteLine("con");
//Trace.WriteLine("tra");
////Thread.Sleep(1000); try { Console.Clear(); } catch { Print("exc"); }
//Debug.WriteLine("deb");

////Output.Clear();


//var e = new Exception("failed");
//var e = new ArgumentException(null, "paramName");
//var e = new FormatException();
//var e = new InvalidOperationException();
//var e = new NotImplementedException();
//var e = new NotSupportedException();
//var e = new OperationCanceledException();
//var e = new TimeoutException();
//var e = new WaitTimeoutException();
//var e = new WaitTimeoutException(null, new Exception("inner"));
//var e = new WaitTimeoutException();
//Print(e.Message);


//Print(1);
//Input.Key("Ctrl+K");
//Cat.Key("Ctrl+K");

//ShowRen.MessageDialog("dddd");
//Meow.MessageDialog("dddd");

//Test_str();

//Print($"{(int)Control.ModifierKeys:X}");
//Print($"{(int)Keys.Control:X}");
//Print($"{(int)K.Control:X}");
//Keys("");
//Key("");
//SendKeys


//Print((IntPtr)WndSpec.NoTopmost);
//Print(Wnd.Find("Untitled - Notepad"));

//TestUtil.Test_str();

//string s = "file.txt";
//Print(s.likeS("*.txt"));

////Print(s.Reverse());

//switch(s) {
//case "*.txt":
//	Print("txt");
//	break;
//case "*.moo":
//	Print("moo");
//	break;
//default:
//	Print("none");
//	break;
//}

//if(s.likeI("*.txt")) {
//	Print("txt");
//} else if(s.likeI("*.moo")) {
//	Print("moo");
//} else {
//	Print("none");
//}

//if(s.endsWithI(".txt")) {
//	Print("txt");
//} else if(s.endsWithI(".moo")) {
//	Print("moo");
//} else {
//	Print("none");
//}

//if(Regex.IsMatch(s, "one")) {
//	Print("txt");
//} else if(Regex.IsMatch(s, "two")) {
//	Print("moo");
//} else {
//	Print("none");
//}


//Print(K.A);
//Keys("dd");
//Text("uu");

//Trigger.Hotkey["Ctrl+K"] =O=> { Print("lambda"); };
//Trigger.Hotkey["Ctrl+K"] = delegate(HotkeyTriggers.Message m) { Print("delegate"); };

//HotkeyTriggers.TestFireTrigger();

//var k=new TestIndexers();
//Print(k[3]); k[7]=5;
//Print(k[3, 4]); k[7, 2]=5;
//Print(k[3]); k[7]=5;
//Print(k["AAA"]); k["BBB"]="C";
//TestIndexers.Hotkey["test"]="moo";



////var thr=new Thread(AppDomainThread);
////thr.Start();
//AppDomainThread();
////Uuoo(1);
////Uuoo(2);
////Uuoo(3);
//MessageBox.Show("main domain, tid="+Thread.CurrentThread.ManagedThreadId.ToString());


//System.AppDomain.CreateDomain(
//System.Collections.ArrayList k=new System.Collections.ArrayList();
//k.Add(object
//System.Collections.Hashtable t=new System.Collections.Hashtable();
//t.Add(
//System.Collections.Generic.HashSet<

//		return;
//			//Print(OptParam(b:5));

//			//try { Print(1); }catch {}

//			//for(int j=0; j<5; j++)
//			//{
//			//	TestLocal();
//			//	//Print("returned");
//			//	//GC.Collect(0, GCCollectionMode.Forced, true);
//			//	Perf.First();
//			//	GC.Collect();
//			//	Perf.Next();
//			//	//Print("collected");
//			//	GC.WaitForFullGCComplete();
//			//	//Print("waited");
//			//}

//			//long g1, g2;
//			//g1=Stopwatch.GetTimestamp();
//			//Perf.First();
//			////Thread.Sleep(1000);
//			//g2=Stopwatch.GetTimestamp();

//			//Print(g2-g1);
//			//return;

//			string script = @"
//import System
////import System.Runtime.InteropServices
//import Moo
//import Catkeys.Winapi

////[DllImport(""user32.dll"")]
////def MessageBox(hWnd as int, text as string, caption as string, type as int) as int:
////	pass

//static def Main():
//	i =8
//	print ""Hello, World!""
//	api.MessageBox(0, ""text $(i)"", ""cap"", 0);

//	print Class1.Add(1, 2);

//	//print ""Press a key . . . mm""; Console.ReadKey(true)
//";
////static def stringManip(item as string):
////	return ""'${item}' ? What the hell are you talking about ? ""
////";

//			for (int i = 0; i < 1; i++)
//			{
//				Stopwatch sw = new Stopwatch();
//				long t1, t2 = 0, t3 = 0, t4 = 0, t5 = 0;

//				sw.Start();
//				BooCompiler compiler = new BooCompiler();
//				//compiler.Parameters.Input.Add(new StringInput("_script_", "print('Hello!')"));
//				compiler.Parameters.Input.Add(new StringInput("Script", script + "//" + i.ToString()));
//				compiler.Parameters.Pipeline = new CompileToMemory();
//				//compiler.Parameters.Pipeline = new CompileToFile();
//				//compiler.Parameters.Ducky = true;
//				//Print(compiler.Parameters.BooAssembly.FullName);
//				//Print(compiler.Parameters.Debug);
//				compiler.Parameters.Debug = false; //default true; 20% faster when Release
//				//compiler.Parameters.Environment.Provide.
//				//compiler.Parameters.GenerateInMemory=false; //default is true even if new CompileToFile()
//				//Print(compiler.Parameters.GenerateInMemory);
//				//Print(compiler.Parameters.OutputAssembly);
//				//compiler.Parameters.OutputAssembly=@"q:\test\boo.dll";

//				compiler.Parameters.AddAssembly(Assembly.LoadFile(@"Q:\test\Moo.dll")); //ok
//				//compiler.Parameters.LoadAssembly(@"Q:\test\Moo.dll", true); //no effect
//				//compiler.Parameters.LoadReferencesFromPackage(@"Q:\test\Moo.dll"); //error
//				//compiler.Parameters.References.Add(Assembly.LoadFile(@"Q:\test\Moo.dll")); //ok
//				compiler.Parameters.AddAssembly(Assembly.LoadFile(@"C:\Users\G\Documents\SharpDevelop Projects\Test\Winapi\bin\Release\Winapi.dll"));

//				CompilerContext context = compiler.Run();
//				t1 = sw.ElapsedTicks;
//				//Note that the following code might throw an error if the Boo script had bugs.
//				//Poke context.Errors to make sure.
//				if (context.GeneratedAssembly != null)
//				{
//					//SaveAssembly(context.GeneratedAssembly, @"q:\test\boo.exe");
//					//Print(context.GeneratedAssembly.FullName);
//					//Print(context.GeneratedAssembly.EntryPoint.ToString()); //void Main()
//					//Print(context.GeneratedAssembly.);

//					Type scriptModule = context.GeneratedAssembly.GetType("ScriptModule");
//					//Print(scriptModule == null);
//					MethodInfo met = scriptModule.GetMethod("Main");

//					//MethodInfo[] a = scriptModule.GetMethods();
//					//foreach(MethodInfo m in a)
//					//{
//					//Print(m.Name);
//					//}

//					met.Invoke(null, null);

//					//string output = (string)stringManip.Invoke(null, new object[] { "Tag" });
//					//Print(output);
//				}
//				else
//				{
//					foreach (CompilerError error in context.Errors)
//						Print(error);
//				}

//				double f = Stopwatch.Frequency / 1000000.0;
//				Print("speed: {0} {1} {2} {3} {4}", (long)(t1 / f), (long)((t2 - t1) / f), (long)((t3 - t2) / f), (long)((t4 - t3) / f), (long)((t5 - t4) / f));
//			}
//			Print("Press a key . . . ");
//			Console.ReadKey(true);
//}

//static void SaveAssembly(Assembly a, string file)
//{
//	using (FileStream stream = new FileStream(file, FileMode.Create))
//	{
//		BinaryFormatter formatter = new BinaryFormatter();

//		formatter.Serialize(stream, a); //error, assembly not marked as serializable
//	}
//}
