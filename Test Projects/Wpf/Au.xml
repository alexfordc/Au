<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Au</name>
    </assembly>
    <members>
        <member name="F:Au.Types.Api.WINDOWPLACEMENT.flags">
            <summary> WPF_ </summary>
        </member>
        <member name="F:Au.Types.Api.AuExtraInfo">
            <summary>
            Extra info value of key and mouse events sent by functions of this library.
            </summary>
        </member>
        <member name="M:Au.Types.Api.PROPVARIANT.Dispose">
            <summary>
            Calls PropVariantClear.
            </summary>
        </member>
        <member name="M:Au.Types.Api.SizeOf``1(``0)">
            <summary>
            Gets the native size of a struct variable.
            Returns Marshal.SizeOf(typeof(T)).
            Speed: the same (in Release config) as Marshal.SizeOf(typeof(T)), and 2 times faster than Marshal.SizeOf(v).
            </summary>
        </member>
        <member name="M:Au.Types.Api.SizeOf``1">
            <summary>
            Gets the native size of a type.
            Returns Marshal.SizeOf(typeof(T)).
            </summary>
        </member>
        <member name="M:Au.Types.Api.GetProcAddress(System.String,System.String)">
            <summary>
            Gets dll module handle (Api.GetModuleHandle) or loads dll (Api.LoadLibrary), and returns unmanaged exported function address (Api.GetProcAddress).
            See also: GetDelegate.
            </summary>
        </member>
        <member name="M:Au.Types.Api.GetDelegate``1(``0@,System.String,System.String)">
            <summary>
            Calls <see cref="M:Au.Types.Api.GetProcAddress(System.String,System.String)"/> (loads dll or gets handle) and <see cref="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.Api.GetDelegate``1(``0@,System.IntPtr,System.String)">
            <summary>
            Calls API <see cref="M:Au.Types.Api.GetProcAddress(System.IntPtr,System.String)"/> and <see cref="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.Api.GetDelegate``1(System.IntPtr,``0@)">
            <summary>
            Calls <see cref="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)"/>.
            </summary>
            <typeparam name="T">Delegate type.</typeparam>
            <param name="f">Unmanaged function address.</param>
            <param name="deleg">Receives managed delegate of type T.</param>
        </member>
        <member name="M:Au.Types.Api.ReleaseComObject``1(``0)">
            <summary>
            If o is not null, calls <see cref="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.Api.SetDIBitsToDevice(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Void*,System.Void*,System.UInt32)">
            <summary>
            lpbmi can be BITMAPINFOHEADER/BITMAPV5HEADER or BITMAPCOREHEADER.
            </summary>
        </member>
        <member name="M:Au.Types.Api.SECURITY_ATTRIBUTES.#ctor">
            <summary>
            Creates SECURITY_ATTRIBUTES that allows UAC low integrity level processes to open the kernel object.
            </summary>
        </member>
        <member name="M:Au.Types.Cpp.Cpp_AccFromWindow(System.Int32,Au.Wnd,Au.Types.AccOBJID,Au.Types.Cpp.Cpp_Acc@,Au.Types.BSTR@)">
            <summary>
            flags: 1 not inproc, 2 get only name.
            </summary>
        </member>
        <member name="M:Au.Types.Cpp.Cpp_RegexCompile(System.String,Au.Types.LPARAM,Au.Types.RXFlags,System.Int32@,Au.Types.BSTR@)">
            <summary>This and related API are documented in the C++ dll project.</summary>
        </member>
        <member name="T:Au.Types.Cpp.RegexMatch">
            <summary>This and related API are documented in the C++ dll project.</summary>
        </member>
        <member name="M:Au.Types.Cpp.Cpp_RegexMatch(System.Runtime.InteropServices.HandleRef,System.String,Au.Types.LPARAM,Au.Types.LPARAM,Au.Types.RXMatchFlags,Au.Types.Cpp.PcreCalloutT,Au.Types.Cpp.RegexMatch@,Au.Types.BSTR@)">
            <summary>This and related API are documented in the C++ dll project.</summary>
        </member>
        <member name="T:Au.Types.AFFlags">
            <summary>
            Flags for <see cref="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,System.String,Au.Wnd.ChildFinder)"/> and similar functions.
            </summary>
        </member>
        <member name="F:Au.Types.AFFlags.Reverse">
            <summary>
            Search in reverse order. It can make faster.
            When control class or id is specified in the <i>prop</i> argument, controls are searched not in reverse order. Only accessible objects in them are searched in reverse order.
            </summary>
        </member>
        <member name="F:Au.Types.AFFlags.HiddenToo">
            <summary>
            The accessible object can be invisible.
            Without this flag skips objects that are invisible (have state INVISIBLE) or are descendants of invisible WINDOW, DOCUMENT, PROPERTYPAGE, GROUPING, ALERT, MENUPOPUP.
            Regardless of this flag, always skips invisible standard objects of nonclient area: TITLEBAR, MENUBAR, SCROLLBAR, GRIP.
            </summary>
        </member>
        <member name="F:Au.Types.AFFlags.MenuToo">
            <summary>
            Always search in MENUITEM.
            Without this flag skips MENUITEM descendant objects (for speed), unless role is MENUITEM or MENUPOPUP or searching in web page.
            </summary>
        </member>
        <member name="F:Au.Types.AFFlags.ClientArea">
            <summary>
            Search only in the client area of the window or control.
            Skips the title bar, standard menubars and scrollbars. Searches only in the client area root object (but will not find the object itself).
            When control class or id is specified in the <i>prop</i> argument, this flag is applied to these controls. Not applied to other controls.
            Don't use this flag when searching in Acc or web page (role prefix "web:" etc) or with flag UIA.
            </summary>
        </member>
        <member name="F:Au.Types.AFFlags.NotInProc">
            <summary>
            Search without loading dll into the target process.
            Disadvantages: 1. Much slower. 2. Some properties are not supported, for example HTML attributes (while searching and later). 3. And more.
            Even without this flag, the default search method is not used with Windows Store app windows, console windows, most Java windows, windows of protected processes and processes of higher <see cref="T:Au.Process_.UacInfo">UAC</see> integrity level, Firefox web page if its multiprocess feature is not disabled.
            Some windows have child controls that belong to a different process or thread than the window. Example - Internet Explorer. When searching in such windows, the default search method is not used when searching in these controls. Workaround - find the control(s) and search in it/them. For it can be used one of: 1. With Internet Explorer use role prefix "web:". 2. Find the control with <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/> and search in it. 3. Use <see cref="M:Au.Acc.Finder.Find(Au.Wnd,Au.Wnd.ChildFinder)"/>.
            Don't need this flag when searching in Acc (then it is inherited from the Acc variable).
            See also: <see cref="P:Au.Acc.MiscFlags"/>.
            </summary>
        </member>
        <member name="F:Au.Types.AFFlags.UIA">
            <summary>
            Use UI Automation API.
            Need this flag to find objects in windows that don't support accessible objects but support UI Automation elements.
            Examples of such windows: Microsoft Edge web browser (web page), JavaFX applications.
            Objects found with this flag never have HtmlX properties, but can have <see cref="P:Au.Acc.UiaId"/>.
            This flag can be used with most other windows too.
            Don't use this flag when searching in Acc (then it is inherited from the Acc variable) or web page (role prefix "web:" etc).
            See also: <see cref="P:Au.Acc.MiscFlags"/>.
            </summary>
        </member>
        <member name="T:Au.Types.LibEnum">
            <summary>
            A workaround to add internal members to public enums.
            </summary>
        </member>
        <member name="F:Au.Types.LibEnum.AFFlags_Mark">
            <summary>
            Used by tools like "Find accessible object", together with AccMiscFlags_Marked.
            </summary>
        </member>
        <member name="F:Au.Types.LibEnum.AccMiscFlags_Marked">
            <summary>
            Used by tools like "Find accessible object", together with AFFlags_Mark.
            </summary>
        </member>
        <member name="T:Au.Types.AWFlags">
            <summary>
            Flags for <see cref="M:Au.Acc.FromWindow(Au.Wnd,Au.Types.AccOBJID,Au.Types.AWFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.AWFlags.NoThrow">
            <summary>Don't throw exception when fails. Then returns null.</summary>
        </member>
        <member name="F:Au.Types.AWFlags.NotInProc">
            <summary>
            Don't load dll into the target process.
            More info: <see cref="F:Au.Types.AFFlags.NotInProc"/>.
            </summary>
        </member>
        <member name="T:Au.Types.AXYFlags">
            <summary>
            Flags for <see cref="M:Au.Acc.FromXY(Au.Types.POINT,Au.Types.AXYFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.AXYFlags.UIA">
            <summary>
            Use UI Automation API.
            Need this flag with some windows that don't support accessible objects but support UI Automation elements.
            When this flag is not specified, the function detects most such windows and uses UI Automation API, but the detection is not perfect.
            More info: <see cref="F:Au.Types.AFFlags.UIA"/>.
            This flag can be used with most other windows too.
            </summary>
        </member>
        <member name="F:Au.Types.AXYFlags.PreferLink">
            <summary>
            Get the direct parent object if it's LINK or BUTTON.
            Usually links have one or more children of type TEXT, STATICTEXT, IMAGE or other.
            </summary>
        </member>
        <member name="F:Au.Types.AXYFlags.NotInProc">
            <summary>
            Don't load dll into the target process.
            More info: <see cref="F:Au.Types.AFFlags.NotInProc"/>.
            </summary>
        </member>
        <member name="F:Au.Types.AXYFlags.NoThrow">
            <summary>Don't throw exception when fails. Then returns null.</summary>
        </member>
        <member name="T:Au.Types.AccMiscFlags">
            <summary>
            Flags returned by <see cref="P:Au.Acc.MiscFlags"/>.
            </summary>
        </member>
        <member name="F:Au.Types.AccMiscFlags.InProc">
            <summary>
            This accessible object was retrieved by the dll loaded into its process.
            More info: <see cref="F:Au.Types.AFFlags.NotInProc"/>.
            </summary>
        </member>
        <member name="F:Au.Types.AccMiscFlags.UIA">
            <summary>
            This accessible object was retrieved using UI Automation API.
            More info: <see cref="F:Au.Types.AFFlags.UIA"/>.
            </summary>
        </member>
        <member name="F:Au.Types.AccMiscFlags.Java">
            <summary>
            This accessible object was retrieved using Java Access Bridge API.
            More info: <see cref="T:Au.Acc"/>.
            </summary>
        </member>
        <member name="T:Au.Types.AccOBJID">
            <summary>
            Accessible object ids of window parts and some special objects.
            Used with <see cref="M:Au.Acc.FromWindow(Au.Wnd,Au.Types.AccOBJID,Au.Types.AWFlags)"/>
            </summary>
            <remarks>
            The names are as in API <msdn>AccessibleObjectFromWindow</msdn> documentation but without prefix "OBJID_". Except Java and UIA.
            </remarks>
        </member>
        <member name="F:Au.Types.AccOBJID.QUERYCLASSNAMEIDX">
            <summary>
            Can be used with API <msdn>WM_GETOBJECT</msdn>, not with <see cref="M:Au.Acc.FromWindow(Au.Wnd,Au.Types.AccOBJID,Au.Types.AWFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.AccOBJID.NATIVEOM">
            <summary>
            Can be used with API <msdn>AccessibleObjectFromWindow</msdn>, not with <see cref="M:Au.Acc.FromWindow(Au.Wnd,Au.Types.AccOBJID,Au.Types.AWFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.AccOBJID.Java">
            <summary>
            The root Java object. Can be used when the window's class name starts with "SunAwt".
            </summary>
        </member>
        <member name="F:Au.Types.AccOBJID.UIA">
            <summary>
            Use UI Automation API.
            More info: <see cref="F:Au.Types.AFFlags.UIA"/>.
            </summary>
        </member>
        <member name="T:Au.Types.AccROLE">
            <summary>
            Standard roles of accessible objects.
            Used with <see cref="P:Au.Acc.RoleInt"/>
            </summary>
            <remarks>
            Most names are as in API <msdn>IAccessible.get_accRole</msdn> documentation but without prefix "ROLE_SYSTEM_". These are renamed: PUSHBUTTON to BUTTON, CHECKBUTTON to CHECKBOX, GRAPHIC to IMAGE, OUTLINE to TREE, OUTLINEITEM to TREEITEM, OUTLINEBUTTON to TREEBUTTON,
            </remarks>
        </member>
        <member name="T:Au.Types.AccSTATE">
            <summary>
            Accessible object state flags.
            Used by <see cref="P:Au.Acc.State"/>.
            </summary>
            <remarks>
            Most names are as in API <msdn>IAccessible.get_accState</msdn> documentation but without prefix "STATE_SYSTEM_".
            </remarks>
        </member>
        <member name="T:Au.Types.AccSELFLAG">
            <summary>
            Accessible object selection flags.
            Used by <see cref="M:Au.Acc.Select(Au.Types.AccSELFLAG)"/>.
            </summary>
            <remarks>
            The names are as in API <msdn>IAccessible.accSelect</msdn> documentation but without prefix "SELFLAG_".
            </remarks>
        </member>
        <member name="T:Au.Types.AccEVENT">
            <summary>
            Event constants for <see cref="T:Au.Util.AccHook"/>. See API <msdn>SetWinEventHook</msdn>.
            </summary>
            <remarks>
            The names are as in API documentation but without prefix "EVENT_".
            </remarks>
        </member>
        <member name="T:Au.Types.AccHookFlags">
            <summary>
            Flags for <see cref="T:Au.Util.AccHook"/>. See API <msdn>SetWinEventHook</msdn>.
            </summary>
            <remarks>
            The names are as in API documentation but without prefix "WINEVENT_".
            There are no flags for OUTOFCONTEXT and INCONTEXT. OUTOFCONTEXT is default (0). INCONTEXT cannot be used in managed code.
            </remarks>
        </member>
        <member name="F:Au.Types.AccHookFlags.SKIPOWNTHREAD">
            <summary>Don't receive events generated by this thread.</summary>
        </member>
        <member name="F:Au.Types.AccHookFlags.SKIPOWNPROCESS">
            <summary>Don't receive events generated by threads of this process.</summary>
        </member>
        <member name="T:Au.Types.AccProperties">
            <summary>
            Used with <see cref="M:Au.Acc.GetProperties(System.String,Au.Types.AccProperties@)"/>.
            </summary>
        </member>
        <member name="T:Au.Types.BIEvents">
            <summary>
            Used with <see cref="T:Au.BlockUserInput"/> class to specify what user input types to block (keys, mouse).
            </summary>
        </member>
        <member name="F:Au.Types.BIEvents.None">
            <summary>
            Do not block.
            </summary>
        </member>
        <member name="F:Au.Types.BIEvents.Keys">
            <summary>
            Block keys. Except if generated by functions of this library.
            </summary>
        </member>
        <member name="F:Au.Types.BIEvents.MouseClicks">
            <summary>
            Block mouse clicks and wheel. Except if generated by functions of this library.
            </summary>
        </member>
        <member name="F:Au.Types.BIEvents.MouseMoving">
            <summary>
            Block mouse moving. Except if generated by functions of this library.
            </summary>
        </member>
        <member name="F:Au.Types.BIEvents.All">
            <summary>
            Block keys, mouse clicks, wheel and mouse moving. Except if generated by functions of this library.
            This flag incluses flags <b>Keys</b>, <b>MouseClicks</b> and <b>MouseMoving</b>.
            </summary>
        </member>
        <member name="T:Au.Types.ClipFormats">
            <summary>
            Some clipboard format ids.
            These and other standard and registered format ids can be used with <see cref="T:Au.Clipb.Data"/> class functions.
            </summary>
        </member>
        <member name="F:Au.Types.ClipFormats.Text">
            <summary>The text format. Standard, API constant CF_UNICODETEXT. The default format of <see cref="T:Au.Clipb.Data"/> add/get text functions.</summary>
        </member>
        <member name="F:Au.Types.ClipFormats.Image">
            <summary>The image format. Standard, API constant CF_BITMAP. Used by <see cref="T:Au.Clipb.Data"/> add/get image functions.</summary>
        </member>
        <member name="F:Au.Types.ClipFormats.Files">
            <summary>The file-list format. Standard, API constant CF_HDROP. Used by <see cref="T:Au.Clipb.Data"/> add/get files functions.</summary>
        </member>
        <member name="P:Au.Types.ClipFormats.Html">
            <summary>The HTML format. Registered, name "HTML Format". Used by <see cref="T:Au.Clipb.Data"/> add/get HTML functions.</summary>
        </member>
        <member name="P:Au.Types.ClipFormats.Rtf">
            <summary>The RTF format. Registered, name "Rich Text Format". Used by <see cref="T:Au.Clipb.Data"/> add/get RTF functions.</summary>
        </member>
        <member name="P:Au.Types.ClipFormats.ClipboardViewerIgnore">
            <summary>
            The "Clipboard Viewer Ignore" registered format.
            </summary>
            <remarks>
            Some clipboard viewer/manager programs don't try to get clipboard data if this format is present. For example Ditto, Clipdiary.
            The copy/paste functions of this library add this format to the clipboard to avoid displaying the temporary text/data in these programs, which also could make the paste function slower and less reliable.
            </remarks>
        </member>
        <member name="M:Au.Types.ClipFormats.Register(System.String,System.Text.Encoding)">
            <summary>
            Registers a clipboard format and returns its id. If already registered, just returns id.
            </summary>
            <param name="name">Format name.</param>
            <param name="textEncoding">Text encoding, if it's a text format. Used by <see cref="M:Au.Clipb.Data.GetText(System.Int32)"/>, <see cref="M:Au.Clipb.Data.AddText(System.String,System.Int32)"/> and functions that call them. For example <see cref="P:System.Text.Encoding.UTF8"/> or <see cref="P:System.Text.Encoding.Default"/> (ANSI). If null, text of unknown formats is considered Unicode UTF-16 (no encoding/decoding needed).</param>
            <remarks>Calls API <msdn>RegisterClipboardFormat</msdn>.</remarks>
        </member>
        <member name="M:Au.Types.ClipFormats.LibGetTextEncoding(System.Int32,System.Boolean@)">
            <summary>
            Gets text encoding for format.
            Returns null if UTF-16 or if the format is unknown and not in s_textEncoding.
            </summary>
        </member>
        <member name="T:Au.Types.Native">
            <summary>
            Windows API types and constants used with public functions (parameters etc) of this library.
            Also several helper functions.
            </summary>
        </member>
        <member name="M:Au.Types.Native.ClearError">
            <summary>
            Calls API <msdn>SetLastError</msdn>(0), which clears the Windows API error code of this thread.
            Need it before calling some functions if you want to use <see cref="M:Au.Types.Native.GetError"/> or <see cref="M:Au.Types.Native.GetErrorMessage"/>.
            </summary>
        </member>
        <member name="M:Au.Types.Native.SetError(System.Int32)">
            <summary>
            Calls API <msdn>SetLastError</msdn>, which sets the Windows API error code of this thread.
            </summary>
        </member>
        <member name="M:Au.Types.Native.GetError">
             <summary>
             Gets the Windows API error code of this thread.
             Calls <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
             </summary>
             <remarks>
             Many Windows API functions, when failed, set an error code. Code 0 means no error. It is stored in an internal thread-specific int variable. But only if the API declaration's DllImport attribute has SetLastError = true.
             Some functions of this library simply call these API functions and don't throw exception when API fail. For example, most Wnd propery-get functions.
             When failed, they return false/0/null/empty. Then you can call <b>Native.GetError</b> to get the error code. Also you can use <see cref="M:Au.Types.Native.GetErrorMessage"/>.
             
             Most of these functions set the code only when failed, and don't clear old error code when succeeded. Therefore may need to call <see cref="M:Au.Types.Native.ClearError"/> before.
            
             Windows API error code definitions and documentation are not included in this library. You can look for them in API function documentation on the internet.
             </remarks>
             <example>
             <code><![CDATA[
             Wnd w = Wnd.Find("Notepag");
             //if(w.Is0) return; //assume you don't use this
             Native.ClearError();
             bool enabled = w.IsEnabled; //returns true if enabled, false if disabled or failed
             int e = Native.GetError();
             if(e != 0) { Print(e, Native.GetErrorMessage(e)); return; } //1400, Invalid window handle
             Print(enabled);
             ]]></code>
             </example>
        </member>
        <member name="M:Au.Types.Native.GetErrorMessage">
            <summary>
            Gets the text message of the Windows API error code of this thread.
            Returns null if the code is 0.
            The string always ends with ".".
            </summary>
        </member>
        <member name="M:Au.Types.Native.GetErrorMessage(System.Int32)">
            <summary>
            Gets the text message of a Windows API error code.
            Returns null if errorCode is 0.
            The string always ends with ".".
            </summary>
        </member>
        <member name="T:Au.Types.Native.MSG">
            <summary><msdn>MSG</msdn></summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.Native.GUITHREADINFO">
            <summary><msdn>GUITHREADINFO</msdn></summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.Native.CREATESTRUCT">
            <summary><msdn>CREATESTRUCT</msdn></summary>
            <remarks>
            lpszClass is unavailable, because often it is atom. Instead use <see cref="P:Au.Wnd.ClassName"/>.
            </remarks>
            <tocexclude />
        </member>
        <member name="T:Au.Types.Native.MOUSEHOOKSTRUCT">
            <summary><msdn>MOUSEHOOKSTRUCT</msdn></summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.Native.CWPSTRUCT">
            <summary><msdn>CWPSTRUCT</msdn></summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.Native.CWPRETSTRUCT">
            <summary><msdn>CWPRETSTRUCT</msdn></summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.Native.SIGDN">
            <summary><msdn>SIGDN</msdn></summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.Native.WNDPROC">
            <summary><msdn>WNDPROC</msdn></summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.Native.SWP">
            <summary><msdn>SetWindowPos</msdn></summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.Native.HWND">
            <summary><msdn>SetWindowPos</msdn></summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.Native.GWL">
            <summary><msdn>GetWindowLong</msdn></summary>
            <tocexclude />
        </member>
        <member name="F:Au.Types.Native.GWL.WNDPROC">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GWL.USERDATA">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GWL.STYLE">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GWL.ID">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GWL.HWNDPARENT">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GWL.HINSTANCE">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GWL.EXSTYLE">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GWL.DWL_MSGRESULT">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GWL.DWL_DLGPROC_32">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GWL.DWL_DLGPROC_64">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GWL.DWL_USER_32">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GWL.DWL_USER_64">
            <exclude />
        </member>
        <member name="P:Au.Types.Native.GWL.DWLP_DLGPROC">
            <exclude />
        </member>
        <member name="P:Au.Types.Native.GWL.DWLP_USER">
            <exclude />
        </member>
        <member name="T:Au.Types.Native.GCL">
            <summary><msdn>WNDCLASSEX</msdn>, <msdn>GetClassLong</msdn></summary>
            <tocexclude />
        </member>
        <member name="F:Au.Types.Native.GCL.ATOM">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GCL.WNDPROC">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GCL.STYLE">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GCL.MENUNAME">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GCL.HMODULE">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GCL.HICONSM">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GCL.HICON">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GCL.HCURSOR">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GCL.HBRBACKGROUND">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GCL.CBWNDEXTRA">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GCL.CBCLSEXTRA">
            <exclude />
        </member>
        <member name="T:Au.Types.Native.WS">
            <summary><msdn>CreateWindowEx</msdn></summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.Native.WS_EX">
            <summary><msdn>CreateWindowEx</msdn></summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.Native.SMTO">
            <summary><msdn>SendMessageTimeout</msdn></summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.KMod">
            <summary>
            Modifier keys as flags.
            </summary>
            <remarks>
            The values don't match those in the .NET enum <see cref="T:System.Windows.Forms.Keys"/>. This library does not use the .NET enum for modifier keys, mostly because it: does not have Win as modifier flag; confusing names, for example Alt and Menu.
            </remarks>
            <seealso cref="M:Au.Keyb.Misc.KModToKeys(Au.Types.KMod)"/>
            <seealso cref="M:Au.Keyb.Misc.KModFromKeys(System.Windows.Forms.Keys)"/>
            <seealso cref="T:Au.Types.KKey"/>
        </member>
        <member name="T:Au.Types.KKey">
            <summary>
            Virtual-key codes.
            </summary>
            <remarks>
            The values are the same as the native VK_ constants. Also the same as in the <see cref="T:System.Windows.Forms.Keys"/> enum, but not as in the WPF <b>Key</b> enum.
            Some key names are different than VK_/Keys, for example Alt instead of VK_MENU/Menu.
            Most rare and obsolete keys are not included. You can use Keys or VK_ (int) like <c>(KKey)Keys.Attn</c>.
            This library does not use the .NET <b>Keys</b> enum, mostly because it includes modifier key flags and it's easy to confuse eg Shift (flag) with ShiftKey (key). Also this library does not use the WPF <b>Key</b> enum; its values don't match the native VK_ constants that must be used with API functions.
            </remarks>
            <seealso cref="T:Au.Types.KMod"/>
        </member>
        <member name="F:Au.Types.KKey.Cancel">
            <summary>Ctrl+Pause.</summary>
        </member>
        <member name="F:Au.Types.KKey.Clear">
            <summary>Shift+NumPad5, or NumPad5 when NumLock off.</summary>
        </member>
        <member name="F:Au.Types.KKey.D0">
            <summary>The 0 ) key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D1">
            <summary>The 1 ! key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D2">
            <summary>The 2 @ key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D3">
            <summary>The 3 # key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D4">
            <summary>The 4 $ key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D5">
            <summary>The 5 % key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D6">
            <summary>The 6 ^ key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D7">
            <summary>The 7 &amp; key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D8">
            <summary>The 8 * key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D9">
            <summary>The 9 ( key.</summary>
        </member>
        <member name="F:Au.Types.KKey.Win">
            <summary>The left Win key.</summary>
        </member>
        <member name="F:Au.Types.KKey.RWin">
            <summary>The right Win key.</summary>
        </member>
        <member name="F:Au.Types.KKey.Apps">
            <summary>The Application/Menu key.</summary>
        </member>
        <member name="F:Au.Types.KKey.Multiply">
            <summary>The numpad * key.</summary>
        </member>
        <member name="F:Au.Types.KKey.Add">
            <summary>The numpad + key.</summary>
        </member>
        <member name="F:Au.Types.KKey.Subtract">
            <summary>The numpad - key.</summary>
        </member>
        <member name="F:Au.Types.KKey.Decimal">
            <summary>The numpad . key.</summary>
        </member>
        <member name="F:Au.Types.KKey.Divide">
            <summary>The numpad / key.</summary>
        </member>
        <member name="F:Au.Types.KKey.LShift">
            <summary>The left Shift key.</summary>
        </member>
        <member name="F:Au.Types.KKey.RShift">
            <summary>The right Shift key.</summary>
        </member>
        <member name="F:Au.Types.KKey.LCtrl">
            <summary>The left Ctrl key.</summary>
        </member>
        <member name="F:Au.Types.KKey.RCtrl">
            <summary>The right Ctrl key.</summary>
        </member>
        <member name="F:Au.Types.KKey.LAlt">
            <summary>The left Alt key.</summary>
        </member>
        <member name="F:Au.Types.KKey.RAlt">
            <summary>The right Alt key.</summary>
        </member>
        <member name="F:Au.Types.KKey.Packet">
            <summary>VK_PACKET. Not a key.</summary>
        </member>
        <member name="T:Au.Types.KHotkey">
            <summary>
            Defines a hotkey as <see cref="T:Au.Types.KMod"/> and <see cref="T:Au.Types.KKey"/>.
            Has implicit conversion operators from string like "Ctrl+Shift+K", tuple (KMod, KKey), enum KKey, enum Keys.
            </summary>
        </member>
        <member name="P:Au.Types.KHotkey.Mod">
            <summary>
            Modifier keys (flags).
            </summary>
        </member>
        <member name="P:Au.Types.KHotkey.Key">
            <summary>
            Key without modifier keys.
            </summary>
        </member>
        <member name="M:Au.Types.KHotkey.#ctor(Au.Types.KMod,Au.Types.KKey)">
            
        </member>
        <member name="M:Au.Types.KHotkey.op_Implicit(System.String)~Au.Types.KHotkey">
            <summary>Implicit conversion from string like "Ctrl+Shift+K".</summary>
            <exception cref="T:System.ArgumentException">"Error in hotkey."</exception>
        </member>
        <member name="M:Au.Types.KHotkey.op_Implicit(System.ValueTuple{Au.Types.KMod,Au.Types.KKey})~Au.Types.KHotkey">
            <summary>Implicit conversion from tuple (KMod, KKey).</summary>
        </member>
        <member name="M:Au.Types.KHotkey.op_Implicit(Au.Types.KKey)~Au.Types.KHotkey">
            <summary>Implicit conversion from <see cref="T:Au.Types.KKey"/> (hotkey without modifiers).</summary>
        </member>
        <member name="M:Au.Types.KHotkey.op_Implicit(System.Windows.Forms.Keys)~Au.Types.KHotkey">
            <summary>Implicit conversion from <see cref="T:System.Windows.Forms.Keys"/> like <c>Keys.Ctrl|Keys.B</c>.</summary>
        </member>
        <member name="M:Au.Types.KHotkey.op_Explicit(Au.Types.KHotkey)~System.Windows.Forms.Keys">
            <summary>Explicit conversion to <see cref="T:System.Windows.Forms.Keys"/>.</summary>
        </member>
        <member name="M:Au.Types.KHotkey.Deconstruct(Au.Types.KMod@,Au.Types.KKey@)">
            <summary>Allows to split a <b>KHotkey</b> variable like <c>var (mod, key) = hotkey;</c></summary>
        </member>
        <member name="T:Au.Types.OsdShowMode">
            <summary>
            Whether <see cref="M:Au.Osd.Show"/> waits or shows the OSD window in this or new thread.
            </summary>
            <remarks>
            If this thread has windows, any value can be used, but usually <b>Auto</b> (default) or <b>ThisThread</b> is the best.
            </remarks>
        </member>
        <member name="F:Au.Types.OsdShowMode.Auto">
            <summary>Depends on <see cref="P:Au.Thread_.IsUI"/>. If it is true, uses <b>ThisThread</b>, else <b>WeakThread</b>. Does not wait.</summary>
        </member>
        <member name="F:Au.Types.OsdShowMode.ThisThread">
            <summary>
            Show the OSD window in this thread and don't wait.
            Should not be used if this thread does not process messages and therefore cannot have windows.
            </summary>
        </member>
        <member name="F:Au.Types.OsdShowMode.WeakThread">
            <summary>Show the OSD window in new thread and don't wait. Set <see cref="P:System.Threading.Thread.IsBackground"/>=true, so that the OSD is closed when other threads of this app end.</summary>
        </member>
        <member name="F:Au.Types.OsdShowMode.StrongThread">
            <summary>Show the OSD window in new thread and don't wait. Set <see cref="P:System.Threading.Thread.IsBackground"/>=false, so that the OSD is not closed when other threads of this app end.</summary>
        </member>
        <member name="F:Au.Types.OsdShowMode.Wait">
            <summary>
            Show the OSD window in this thread and wait until it disappears.
            Waits <see cref="P:Au.Osd.SecondsTimeout"/> seconds. While waiting, dispatches messages etc; see <see cref="M:Au.Time.SleepDoEvents(System.Int32)"/>.
            </summary>
        </member>
        <member name="T:Au.Types.WIArea">
            <summary>
            Defines the search area for <see cref="M:Au.WinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,Au.Types.WIAlso})"/> and similar functions.
            </summary>
            <remarks>
            It can be a window/control, accessible object, another image or a rectangle in screen.
            Also allows to specify a rectangle in it, which makes the search area smaller and the function faster.
            Has implicit conversions from Wnd, Acc, Bitmap, RECT (rectangle in screen), tuple (Wnd, RECT), tuple (Acc, RECT).
            Example: <c>WinImage.Find((w, (left, top, width, height)), "image.png");</c>.
            </remarks>
        </member>
        <member name="T:Au.Types.WIFlags">
            <summary>
            Flags for <see cref="M:Au.WinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,Au.Types.WIAlso})"/> and similar functions.
            </summary>
        </member>
        <member name="F:Au.Types.WIFlags.WindowDC">
            <summary>
            Get pixels from the device context (DC) of the window client area, not from screen DC.
            Not used when area is Bitmap.
            Notes:
            Usually much faster.
            Can get pixels from window parts that are covered by other windows or offscreen. But not from hidden and minimized windows.
            Does not work on Windows 7 if Aero theme is turned off. Then this flag is ignored.
            If the window is DPI-scaled, the image must be captured from its non-scaled version.
            Cannot find images in some windows (including Windows Store apps), and in some window parts (glass). All pixels captured from these windows/parts are black.
            </summary>
        </member>
        <member name="T:Au.Types.WIAlso">
            <summary>
            Used with <see cref="M:Au.WinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,Au.Types.WIAlso})"/> and <see cref="M:Au.WinImage.Wait(System.Double,Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,Au.Types.WIAlso})"/>. Its callback function (parameter <i>also</i>) can return one of these values.
            </summary>
        </member>
        <member name="F:Au.Types.WIAlso.OkReturn">
            <summary>
            Stop searching.
            Let the main function (<b>Find</b> or <b>Wait</b>) return current result.
            </summary>
        </member>
        <member name="F:Au.Types.WIAlso.OkFindMore">
            <summary>
            Find more instances of current image. If used list of images, also search for other images.
            Then let the main function return current result.
            </summary>
        </member>
        <member name="F:Au.Types.WIAlso.OkFindMoreOfThis">
            <summary>
            Find more instances of current image. When used list of images, don't search for other images.
            Then let the main function return current result.
            </summary>
        </member>
        <member name="F:Au.Types.WIAlso.OkFindMoreOfList">
            <summary>
            If used list of images, search for other images. Don't search for more instances of current image.
            Then let the main function return current result.
            </summary>
        </member>
        <member name="F:Au.Types.WIAlso.NotFound">
            <summary>
            Stop searching.
            Let <b>Find</b> return null. Let <b>Wait</b> continue waiting. But if a <b>Find...Return</b> value used previously, return that result.
            </summary>
        </member>
        <member name="F:Au.Types.WIAlso.FindOther">
            <summary>
            Find more instances of current image. If used list of images, also search for other images.
            If not found, let <b>Find</b> return null; let <b>Wait</b> continue waiting; but if a <b>Find...Return</b> value used previously, return that result.
            </summary>
        </member>
        <member name="F:Au.Types.WIAlso.FindOtherOfThis">
            <summary>
            Find more instances of current image. When used list of images, don't search for other images.
            If not found, let <b>Find</b> return null; let <b>Wait</b> continue waiting; but if a <b>Find...Return</b> value used previously, return that result.
            </summary>
        </member>
        <member name="F:Au.Types.WIAlso.FindOtherOfList">
            <summary>
            If used list of images, search for other images. Don't search for more instances of current image.
            If not found, let <b>Find</b> return null; let <b>Wait</b> continue waiting; but if a <b>Find...Return</b> value used previously, return that result.
            </summary>
        </member>
        <member name="T:Au.Types.OptDebug">
            <summary>
            Options for showing run-time warnings and other info that can be useful to find problems in code at run time.
            </summary>
        </member>
        <member name="P:Au.Types.OptDebug.Verbose">
            <summary>
            If true, some library functions may display more warnings and other info.
            If not explicitly set, the default value depends on the build configuration of the entry assymbly: true if Debug, false if Release.
            </summary>
        </member>
        <member name="M:Au.Types.OptDebug.DisableWarnings(System.String[])">
            <summary>
            Disables one or more run-time warnings.
            </summary>
            <param name="warningsWild">One or more warnings as case-insensitive wildcard strings. See <see cref="M:Au.String_.Like_(System.String,System.String,System.Boolean)"/>.</param>
            <remarks>
            Adds the strings to an internal list. When <see cref="M:Au.NoClass.PrintWarning(System.String,System.Int32,System.String)"/> is called, it looks in the list. If it finds the warning in the list, it does not show the warning.
            It's easy to auto-restore warnings with 'using', like in the second example. Restoring is optional.
            </remarks>
            <example>
            This code in script template disables two warnings for all new scripts.
            <code><![CDATA[
            Opt.Static.Debug.DisableWarnings("*part of warning 1 text*", "*part of warning 2 text*");
            ]]></code>
            Temporarily disable all warnings for this thread.
            <code><![CDATA[
            Opt.Debug.Verbose = true;
            PrintWarning("one");
            using(Opt.Debug.DisableWarnings("*")) {
            	PrintWarning("two");
            }
            PrintWarning("three");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Types.OptDebug.IsWarningDisabled(System.String)">
            <summary>
            Returns true if the specified warning text matches a wildcard string added with <see cref="M:Au.Types.OptDebug.DisableWarnings(System.String[])"/>.
            </summary>
            <param name="text">Warning text. Case-insensitive.</param>
        </member>
        <member name="T:Au.Types.OptDebug.RestoreWarnings">
            <summary>Infrastructure.</summary>
            <tocexclude />
        </member>
        <member name="M:Au.Types.OptDebug.RestoreWarnings.Dispose">
            <summary>Restores warnings.</summary>
        </member>
        <member name="T:Au.Types.OptMouse">
            <summary>
            Options for functions of class <see cref="T:Au.Mouse"/>.
            </summary>
            <seealso cref="P:Au.Opt.Mouse"/>
            <seealso cref="P:Au.Opt.Static.Mouse"/>
            <remarks>
            Total <c>Click(x, y)</c> time is: mouse move + <see cref="P:Au.Types.OptMouse.MoveSleepFinally"/> + button down + <see cref="P:Au.Types.OptMouse.ClickSpeed"/> + button down + <see cref="P:Au.Types.OptMouse.ClickSpeed"/> + <see cref="P:Au.Types.OptMouse.ClickSleepFinally"/>.
            </remarks>
        </member>
        <member name="M:Au.Types.OptMouse.#ctor(Au.Types.OptMouse)">
            <summary>
            Initializes this instance with default values or values copied from another instance.
            </summary>
            <param name="cloneOptions">If not null, copies its options into this variable.</param>
        </member>
        <member name="M:Au.Types.OptMouse._LibReset(Au.Types.OptMouse)">
            <summary>
            Copies options from o, or sets default if o==null. Like ctor does.
            </summary>
        </member>
        <member name="P:Au.Types.OptMouse.ClickSpeed">
            <summary>
            How long to wait (milliseconds) after sending each mouse button down or up event (2 events for click, 4 for double-click).
            Default: 20. Valid values: 0 - 1000 (1 s). Valid values for <see cref="P:Au.Opt.Static.Mouse"/>: 0 - 100 (1 s).
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="P:Au.Types.OptMouse.MoveSpeed">
            <summary>
            If not 0, makes mouse movements slower, not instant.
            Default: 0. Valid values: 0 (instant) - 10000 (slowest). Valid values for <see cref="P:Au.Opt.Static.Mouse"/>: 0 - 100.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            Used by <see cref="M:Au.Mouse.Move(Au.Types.POINT)"/>, <see cref="M:Au.Mouse.Click(System.Boolean)"/> and other functions that generate mouse movement events, except <see cref="M:Au.Mouse.MoveRecorded(System.String,System.Double)"/>.
            It is not milliseconds or some other unit. It adds intermediate mouse movements and small delays when moving the mouse cursor to the specified point. The speed also depends on the distance.
            Value 0 (default) does not add intermediate mouse movements. Adds at least 1 if some mouse buttons are pressed. Value 1 adds at least 1 intermediate mouse movement. Values 10-50 are good for visually slow movements.
            </remarks>
        </member>
        <member name="P:Au.Types.OptMouse.ClickSleepFinally">
            <summary>
            How long to wait (milliseconds) before a 'mouse click' or 'mouse wheel' function returns.
            Default: 10. Valid values: 0 - 10000 (10 s). Valid values for <see cref="P:Au.Opt.Static.Mouse"/>: 0 - 100.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            The 'click' functions also sleep <see cref="P:Au.Types.OptMouse.ClickSpeed"/> ms after button down and up. Default <b>ClickSpeed</b> is 20, default <b>ClickSleepFinally</b> is 10, therefore default click time without mouse-move is 20+20+10=50.
            </remarks>
        </member>
        <member name="P:Au.Types.OptMouse.MoveSleepFinally">
            <summary>
            How long to wait (milliseconds) after moving the mouse cursor. Used in 'move+click' functions too.
            Default: 10. Valid values: 0 - 1000 (1 s). Valid values for <see cref="P:Au.Opt.Static.Mouse"/>: 0 - 100.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            Used by <see cref="M:Au.Mouse.Move(Au.Types.POINT)"/> (finally), <see cref="M:Au.Mouse.Click(System.Boolean)"/> (between moving and clicking) and other functions that generate mouse movement events.
            </remarks>
        </member>
        <member name="P:Au.Types.OptMouse.Relaxed">
            <summary>
            Make some functions less strict (throw less exceptions etc).
            Default: false.
            </summary>
            <remarks>
            This option is used by these functions:
            <list type="bullet">
            <item><see cref="M:Au.Mouse.Move(Au.Types.POINT)"/>, <see cref="M:Au.Mouse.Click(System.Boolean)"/> and other functions that move the cursor (mouse pointer):
            false - throw exception if cannot move the cursor to the specified x y. For example it the x y is not in screen.
            true - try to move anyway. Don't throw exception, regardless of the final cursor position (which probably will be at a screen edge).
            </item>
            <item><see cref="M:Au.Mouse.Move(Au.Types.POINT)"/>, <see cref="M:Au.Mouse.Click(System.Boolean)"/> and other functions that move the cursor (mouse pointer):
            false - before moving the cursor, wait while a mouse button is pressed by the user or another thread. It prevents an unintended drag-drop.
            true - do not wait.
            </item>
            <item><see cref="M:Au.Mouse.Click(System.Boolean)"/> and other functions that click or press a mouse button using window coordinates:
            false - don't allow to click in another window. If need, activate the specified window (or its top-level parent). If that does not help, throw exception. However if the window is a control, allow x y anywhere in its top-level parent window.
            true - allow to click in another window. Don't activate the window and don't throw exception.
            </item>
            </list>
            </remarks>
        </member>
        <member name="T:Au.Types.OptKey">
            <summary>
            Options for functions of class <see cref="T:Au.Keyb"/>.
            Some options also are used with <see cref="T:Au.Clipb"/> functions that send keys (Ctrl+V etc).
            </summary>
            <seealso cref="P:Au.Opt.Key"/>
            <seealso cref="P:Au.Opt.Static.Key"/>
        </member>
        <member name="M:Au.Types.OptKey.#ctor(Au.Types.OptKey)">
            <summary>
            Initializes this instance with default values or values copied from another instance.
            </summary>
            <param name="cloneOptions">If not null, copies its options into this variable.</param>
        </member>
        <member name="M:Au.Types.OptKey.LibReset(Au.Types.OptKey)">
            <summary>
            Copies options from o, or sets default if o==null. Like ctor does.
            </summary>
        </member>
        <member name="M:Au.Types.OptKey.LibGetHookOptionsOrThis(Au.Wnd)">
            <summary>
            Returns this variable or OptKey cloned from this variable and possibly modified by Hook.
            </summary>
            <param name="wFocus">The focused or active window. Use Lib.GetWndFocusedOrActive().</param>
        </member>
        <member name="P:Au.Types.OptKey.TextSpeed">
            <summary>
            How long to wait (milliseconds) between pressing and releasing each character key of 'text' parameters of <see cref="M:Au.Keyb.Text(System.String,System.Object[])"/>, <see cref="M:Au.Keyb.Key(System.Object[])"/> and similar functions.
            Default: 0. Valid values: 0 - 1000 (1 second). Valid values for <see cref="P:Au.Opt.Static.Key"/>: 0 - 10.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            Not used for 'keys' parameters. See <see cref="P:Au.Types.OptKey.KeySpeed"/>.
            </remarks>
        </member>
        <member name="P:Au.Types.OptKey.KeySpeed">
            <summary>
            How long to wait (milliseconds) between pressing and releasing each key of 'keys' parameters of <see cref="M:Au.Keyb.Key(System.Object[])"/> and similar functions.
            Default: 1. Valid values: 0 - 1000 (1 second). Valid values for <see cref="P:Au.Opt.Static.Key"/>: 0 - 10.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            Not used for 'text' parameters. See <see cref="P:Au.Types.OptKey.TextSpeed"/>.
            </remarks>
        </member>
        <member name="P:Au.Types.OptKey.KeySpeedClipboard">
            <summary>
            How long to wait (milliseconds) between sending Ctrl+V and Ctrl+C keys of clipboard functions (paste, copy).
            Default: 5. Valid values: 0 - 1000 (1 second). Valid values for <see cref="P:Au.Opt.Static.Key"/>: 0 - 50.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            In most apps copy/paste works without this delay. Known apps that need it: Internet Explorer's address bar, BlueStacks.
            </remarks>
        </member>
        <member name="P:Au.Types.OptKey.SleepFinally">
            <summary>
            How long to wait (milliseconds) before a 'send keys or text' function returns.
            Default: 10. Valid values: 0 - 10000 (10 seconds). Valid values for <see cref="P:Au.Opt.Static.Key"/>: 0 - 100.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            Not used by <see cref="M:Au.Clipb.CopyText(System.Boolean,Au.Types.OptKey)"/>.
            </remarks>
        </member>
        <member name="P:Au.Types.OptKey.TextOption">
            <summary>
            How functions send text to the active window (keys, clipboard, etc).
            Default: <see cref="F:Au.Types.KTextOption.Characters"/>.
            </summary>
        </member>
        <member name="P:Au.Types.OptKey.PasteLength">
            <summary>
            To send text use clipboard (like with option <see cref="F:Au.Types.KTextOption.Paste"/>) if text length is &gt;= this value.
            Default: 300.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="P:Au.Types.OptKey.PasteEnter">
            <summary>
            When pasting text that ends with newline characters, remove the last newline and after pasting send the Enter key.
            Default: false.
            </summary>
            <remarks>
            Some apps remove the last newline when pasting. For example Word, WordPad, OpenOffice, LibreOffice, standard rich text controls. This option is a workaround.
            </remarks>
        </member>
        <member name="P:Au.Types.OptKey.RestoreClipboard">
            <summary>
            Whether to restore clipboard data when copying or pasting text.
            Default: true.
            By default restores only text. See also <see cref="P:Au.Types.OptKey.RestoreClipboardAllFormats"/>, <see cref="P:Au.Types.OptKey.RestoreClipboardExceptFormats"/>.
            </summary>
        </member>
        <member name="P:Au.Types.OptKey.RestoreClipboardAllFormats">
            <summary>
            When copying or pasting text, restore clipboard data of all formats that are possible to restore.
            Default: false - restore only text.
            </summary>
            <remarks>
            Restoring data of all formats set by some apps can be slow or cause problems. More info: <see cref="P:Au.Types.OptKey.RestoreClipboardExceptFormats"/>.
            
            This property is static, not thread-static. It should be set (if need) at the very start of the script (eg in the script template) and not changed later.
            </remarks>
            <seealso cref="P:Au.Types.OptKey.RestoreClipboard"/>
            <seealso cref="P:Au.Types.OptKey.RestoreClipboardExceptFormats"/>
        </member>
        <member name="P:Au.Types.OptKey.RestoreClipboardExceptFormats">
            <summary>
            When copying or pasting text, and <see cref="P:Au.Types.OptKey.RestoreClipboardAllFormats"/> is true, do not restore clipboard data of these formats.
            Default: null.
            </summary>
            <remarks>
            To restore clipboard data, the copy/paste functions at first get clipboard data. Getting data of some formats set by some apps can be slow (100 ms or more) or cause problems (the app can change something in its window or even show a dialog).
            It also depends on whether this is the first time the data is being retrieved. The app can render data on demand, when some app is retrieving it from the clipboard first time; then can be slow etc.
            
            You can use function <see cref="M:Au.Types.OptKey.PrintClipboard"/> to see format names and get-data times.
            
            There are several kinds of clipboard formats - registered, standard, private and display. Only registered formats have string names. For standard formats use API contant names, like "CF_WAVE". Private, display and metafile formats are never restored.
            These formats are never restored: CF_METAFILEPICT, CF_ENHMETAFILE, CF_PALETTE, CF_OWNERDISPLAY, CF_DSPx formats, CF_GDIOBJx formats, CF_PRIVATEx formats. Some other formats too, but they are automatically synthesized from other formats if need. Also does not restore if data size is 0 or &gt; 10 MB.
            
            This property is static, not thread-static. It should be set (if need) at the very start of the script (eg in the script template) and not changed later.
            </remarks>
            <seealso cref="P:Au.Types.OptKey.RestoreClipboard"/>
            <seealso cref="M:Au.Types.OptKey.PrintClipboard"/>
        </member>
        <member name="M:Au.Types.OptKey.PrintClipboard">
            <summary>
            Prints some info about current clipboard data.
            </summary>
            <remarks>
            Shows this info in the output, for each clipboard format: format name, time spent to get data (microseconds), data size (bytes), and whether this format would be restored (depends on <see cref="P:Au.Types.OptKey.RestoreClipboardExceptFormats"/>).
            <note type="note">Copy something to the clipboard each time before calling this function. Don't use <see cref="M:Au.Clipb.CopyText(System.Boolean,Au.Types.OptKey)"/> and don't call this function in loop. Else it shows small times.</note>
            The time depends on app, etc. More info: <see cref="P:Au.Types.OptKey.RestoreClipboardExceptFormats"/>.
            </remarks>
        </member>
        <member name="P:Au.Types.OptKey.NoModOff">
            <summary>
            When starting to send keys or text, don't release modifier keys.
            Default: false.
            </summary>
        </member>
        <member name="P:Au.Types.OptKey.NoCapsOff">
            <summary>
            When starting to send keys or text, don't turn off CapsLock.
            Default: false.
            </summary>
        </member>
        <member name="P:Au.Types.OptKey.NoBlockInput">
            <summary>
            While sending or pasting keys or text, don't block user-pressed keys.
            Default: false.
            </summary>
            <remarks>
            If false (default), user-pressed keys are sent afterwards. If true, user-pressed keys can be mixed with script-pressed keys, which is particularly dangerous when modifier keys are mixed (and combined) with non-modifier keys.
            </remarks>
        </member>
        <member name="P:Au.Types.OptKey.Hook">
            <summary>
            Callback function that can modify options of 'send keys or text' functions depending on active window etc.
            Default: null.
            </summary>
            <remarks>
            The callback function is called by <see cref="M:Au.NoClass.Key(System.Object[])"/>, <see cref="M:Au.NoClass.Text(System.String,System.Object[])"/>, <see cref="M:Au.Keyb.Send(System.Boolean)"/>, <see cref="M:Au.NoClass.Paste(System.String)"/> and similar functions. Not called by <see cref="M:Au.Clipb.CopyText(System.Boolean,Au.Types.OptKey)"/>.
            </remarks>
            <seealso cref="T:Au.Types.KOHookData"/>
        </member>
        <member name="T:Au.Types.KOHookData">
            <summary>
            Parameter type of the <see cref="P:Au.Types.OptKey.Hook"/> callback function.
            </summary>
        </member>
        <member name="F:Au.Types.KOHookData.opt">
            <summary>
            Options used by the 'send keys or text' function. The callback function can modify them, except Hook, NoModOff, NoCapsOff, NoBlockInput.
            </summary>
        </member>
        <member name="F:Au.Types.KOHookData.w">
            <summary>
            The focused control. If there is no focused control - the active window. Use <c>w.Window</c> to get top-level window; if <c>w.Window == w</c>, <b>w</b> is the active window, else the focused control. The callback function is not called if there is no active window.
            </summary>
        </member>
        <member name="T:Au.Types.KTextOption">
            <summary>
            How functions send text.
            See <see cref="P:Au.Types.OptKey.TextOption"/>.
            </summary>
            <remarks>
            There are three ways to send text to the active app using keys: 1. Characters (default) - use special key code VK_PACKET. 2. Keys - press keybord keys. 3. Paste - use the clipboard and Ctrl+V.
            Most but not all apps support all three ways. Most Unicode characters cannot be sent with <b>Keys</b>.
            Depending on text, the 'send text' functions may use other method than specified. For some characters or for whole text. More info below.
            Many apps don't support Unicode surrogate pairs sent as keys. If the text contains such characters, is used <b>Paste</b> instead of other options (implicitly). These characters are rarely used.
            </remarks>
        </member>
        <member name="F:Au.Types.KTextOption.Characters">
            <summary>
            Send text characters using special key code VK_PACKET.
            Few apps don't support it.
            This option is default.
            Supports most Unicode characters.
            For newlines is used key Enter (implicitly).
            </summary>
        </member>
        <member name="F:Au.Types.KTextOption.Keys">
            <summary>
            Send text keys, with Shift or other modifiers where need, depending on the keyboard layout of the active window. The numpad keys are not used.
            All apps support it.
            Cannot send characters that cannot be typed using the keyboard. For example most Unicode characters. For these characters is used the <b>Characters</b> option (implicitly).
            </summary>
        </member>
        <member name="F:Au.Types.KTextOption.Paste">
            <summary>
            Paste text using the clipboard and Ctrl+V.
            Few apps don't support it.
            This option is recommended for long text, because other ways then are too slow.
            Other options are unreliable when text length is more than 4000 or 5000 and the target app is too slow to process sent characters. Then <see cref="P:Au.Types.OptKey.TextSpeed"/> can help.
            Also, other options are unreliable when the target app modifies typed text, for example has such features as auto-complete or auto-indent. However some apps modify even pasted text, for example trim the last newline.
            When pasting text, previous clipboard data is lost.
            </summary>
        </member>
        <member name="T:Au.Types.OptWaitFor">
            <summary>
            Options for 'wait for' functions.
            </summary>
            <seealso cref="P:Au.Opt.WaitFor"/>
            <seealso cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/>
            <seealso cref="T:Au.WaitFor.Loop"/>
        </member>
        <member name="P:Au.Types.OptWaitFor.Period">
            <summary>
            The sleep time between checking the wait condition. Milliseconds.
            Default: 10. Valid values: 1-1000.
            </summary>
            <remarks>
            Most 'wait for' functions of this library use <see cref="T:Au.WaitFor.Loop"/>, which repeatedly checks the wait condition and sleeps (waits) several ms. This property sets the initial sleep time, which then is incremented by <b>Period</b>/10 ms (default 1 ms) in each loop until reaches <b>Period</b>*50 (default 500 ms).
            This property makes the response time shorter or longer. If &lt;10, makes it shorter (faster response), but increases CPU usage; if &gt;10, makes it longer (slower response).
            </remarks>
            <seealso cref="P:Au.WaitFor.Loop.Period"/>
        </member>
        <member name="P:Au.Types.OptWaitFor.DoEvents">
            <summary>
            Use <see cref="M:Au.Time.SleepDoEvents(System.Int32)"/> instead of <see cref="M:Au.Time.Sleep(System.Int32)"/>.
            Default: false.
            </summary>
            <remarks>
            Use this property when need to process Windows messages, events, hooks, timers, etc while waiting. More info: <see cref="M:Au.Time.SleepDoEvents(System.Int32)"/>.
            </remarks>
            <seealso cref="M:Au.WaitFor.MessagesAndCondition(System.Double,System.Func{System.Boolean})"/>
        </member>
        <member name="M:Au.Types.OptWaitFor.#ctor(System.Int32,System.Boolean)">
            
        </member>
        <member name="M:Au.Types.OptWaitFor.op_Implicit(System.Int32)~Au.Types.OptWaitFor">
            <summary>
            Implicit conversion from int. Sets <see cref="P:Au.Types.OptWaitFor.Period"/>.
            </summary>
        </member>
        <member name="M:Au.Types.OptWaitFor.op_Implicit(System.Boolean)~Au.Types.OptWaitFor">
            <summary>
            Implicit conversion from bool. Sets <see cref="P:Au.Types.OptWaitFor.DoEvents"/>.
            </summary>
        </member>
        <member name="T:Au.Types.Screen_">
            <summary>
            Used to specify a screen (display, monitor) using screen index, window, control, <see cref="T:Au.Acc"/>, point, rectangle, <see cref="T:System.Windows.Forms.Screen"/>, <see cref="F:Au.Types.Screen_.OfActiveWindow"/> or <see cref="F:Au.Types.Screen_.OfMouse"/>.
            </summary>
            <remarks>
            Used mostly for function parameters. The caller can specify screen index (int), window (Wnd etc), <see cref="T:System.Windows.Forms.Screen"/> object, etc. There are implicit conversion operators from these types. The <b>Screen_</b> variable holds the specified value. When the function needs screen properties, it calls <see cref="M:Au.Types.Screen_.GetScreen"/> to get <see cref="T:System.Windows.Forms.Screen"/> object corresponding that value at that time.
            </remarks>
        </member>
        <member name="M:Au.Types.Screen_.op_Implicit(System.Windows.Forms.Screen)~Au.Types.Screen_">
            <summary>
            Creates variable that holds <see cref="T:System.Windows.Forms.Screen"/> object. If invalid, will be used the primary screen.
            </summary>
        </member>
        <member name="M:Au.Types.Screen_.op_Implicit(System.Int32)~Au.Types.Screen_">
            <summary>
            Creates variable that holds screen index. Later will be called <see cref="M:Au.Types.Screen_.ScreenFromIndex(System.Int32)"/>.
            </summary>
            <param name="screenIndex"><inheritdoc cref="M:Au.Types.Screen_.ScreenFromIndex(System.Int32)"/></param>
        </member>
        <member name="M:Au.Types.Screen_.op_Implicit(Au.Wnd)~Au.Types.Screen_">
            <summary>
            Creates variable that holds window handle. Later will be called <see cref="M:Au.Types.Screen_.ScreenFromWindow(Au.Wnd)"/>. If invalid, will be used the primary screen.
            </summary>
        </member>
        <member name="M:Au.Types.Screen_.op_Implicit(System.Windows.Forms.Control)~Au.Types.Screen_">
            <summary>
            Creates variable that holds <see cref="T:System.Windows.Forms.Control"/>. Later will be called <see cref="M:System.Windows.Forms.Screen.FromControl(System.Windows.Forms.Control)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.Screen_.op_Implicit(System.Windows.Window)~Au.Types.Screen_">
            <summary>
            Creates variable that holds <see cref="T:System.Windows.Window"/>. Later will be called <see cref="M:Au.Types.Screen_.ScreenFromWindow(Au.Wnd)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.Screen_.op_Implicit(Au.Types.POINT)~Au.Types.Screen_">
            <summary>
            Creates variable that holds <see cref="T:Au.Types.POINT"/>. Later will be called <see cref="M:System.Windows.Forms.Screen.FromPoint(System.Drawing.Point)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.Screen_.op_Implicit(Au.Types.RECT)~Au.Types.Screen_">
            <summary>
            Creates variable that holds <see cref="T:Au.Types.RECT"/>. Later will be called <see cref="M:System.Windows.Forms.Screen.FromRectangle(System.Drawing.Rectangle)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.Screen_.op_Implicit(Au.Acc)~Au.Types.Screen_">
            <summary>
            Creates variable that holds <see cref="T:Au.Acc"/>. Later will be called <see cref="M:System.Windows.Forms.Screen.FromRectangle(System.Drawing.Rectangle)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.Screen_.Primary">
            <summary>
            Screen index of the primary screen. Value 0.
            Values greater than 0 are used for non-primary screens: 1 - first non-primary, 2 second...
            </summary>
        </member>
        <member name="F:Au.Types.Screen_.OfMouse">
            <summary>
            Special screen index to specify the screen of the mouse pointer. Value -1.
            </summary>
        </member>
        <member name="F:Au.Types.Screen_.OfActiveWindow">
            <summary>
            Special screen index to specify the screen of the active window. Value -2.
            </summary>
        </member>
        <member name="M:Au.Types.Screen_.ScreenFromIndex(System.Int32)">
            <summary>
            Gets <see cref="T:System.Windows.Forms.Screen"/> object from screen index.
            </summary>
            <param name="screenIndex">
            Values greater than 0 are used for non-primary screens: 1 - first non-primary, 2 second...
            Also can be <see cref="F:Au.Types.Screen_.Primary"/> (0), <see cref="F:Au.Types.Screen_.OfMouse"/> (-1), <see cref="F:Au.Types.Screen_.OfActiveWindow"/> (-2).
            If invalid, prints warning and gets the primary screen.
            </param>
            <remarks>
            Uses <see cref="P:System.Windows.Forms.Screen.AllScreens"/> to get screen indices. They may not match the indices that you can see in Control Panel.
            </remarks>
        </member>
        <member name="M:Au.Types.Screen_.ScreenFromWindow(Au.Wnd)">
            <summary>
            Gets <see cref="T:System.Windows.Forms.Screen"/> object of the screen that contains the specified window (the biggest part of it) or is nearest to it.
            If w handle is 0 or invalid, gets the primary screen (<see cref="M:System.Windows.Forms.Screen.FromHandle(System.IntPtr)"/> would return an invalid object if the window handle is invalid).
            </summary>
        </member>
        <member name="M:Au.Types.Screen_.GetScreen">
            <summary>
            Gets <see cref="T:System.Windows.Forms.Screen"/> object from the value stored in this variable (screen index, window handle, etc).
            If the value is null or invalid or fails, gets the primary screen.
            </summary>
            <remarks>
            Uses <see cref="P:System.Windows.Forms.Screen.AllScreens"/> to get screen indices. They may not match the indices that you can see in Control Panel.
            </remarks>
        </member>
        <member name="P:Au.Types.Screen_.Value">
            <summary>
            Gets the value as object.
            </summary>
        </member>
        <member name="P:Au.Types.Screen_.IsNull">
            <summary>
            true if this variable does not have a value.
            </summary>
        </member>
        <member name="P:Au.Types.Screen_.PrimaryWidth">
            <summary>
            Gets primary screen width.
            </summary>
        </member>
        <member name="P:Au.Types.Screen_.PrimaryHeight">
            <summary>
            Gets primary screen height.
            </summary>
        </member>
        <member name="P:Au.Types.Screen_.PrimaryRect">
            <summary>
            Gets primary screen rectangle.
            </summary>
        </member>
        <member name="M:Au.Types.Screen_.GetRect(Au.Types.Screen_,System.Boolean)">
            <summary>
            Gets screen rectangle.
            </summary>
            <param name="screen">Screen index etc. If default - primary screen.</param>
            <param name="workArea">Get work area rectangle.</param>
        </member>
        <member name="P:Au.Types.Screen_.PrimaryWorkArea">
            <summary>
            Gets primary screen work area.
            </summary>
        </member>
        <member name="M:Au.Types.Screen_.IsInAnyScreen(Au.Types.POINT)">
            <summary>
            Returns true if point p is in some screen.
            </summary>
        </member>
        <member name="M:Au.Types.Screen_.IsInAnyScreen(Au.Types.RECT)">
            <summary>
            Returns true if rectangle r intersects with some screen.
            </summary>
        </member>
        <member name="M:Au.Types.Screen_.IsInAnyScreen(Au.Wnd)">
            <summary>
            Returns true if rectangle of window w intersects with some screen.
            </summary>
        </member>
        <member name="T:Au.Types.ExtensionMethods">
            <summary>
            Adds extension methods to some .NET classes.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.GetIndex_(System.Windows.Forms.Screen)">
            <summary>
            Gets screen index that can be used with <see cref="T:Au.Types.Screen_"/> and functions that use it.
            Primary screen is 0. Values greater than 0 are used for non-primary screens: 1 - first non-primary, 2 second...
            </summary>
            <param name="t"></param>
            <exception cref="T:Au.Types.AuException">Failed (probably the Screen object is invalid).</exception>
        </member>
        <member name="M:Au.Types.ExtensionMethods.OrThrow(Au.Wnd)">
            <summary>
            If this is default(Wnd), throws <see cref="T:Au.Types.NotFoundException"/>, else returns this.
            </summary>
            <exception cref="T:Au.Types.NotFoundException"></exception>
            <example>
            <code><![CDATA[
            var w = Wnd.Find("Example").OrThrow();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Types.ExtensionMethods.OrThrow(Au.Acc)">
            <summary>
            If this is null, throws <see cref="T:Au.Types.NotFoundException"/>, else returns this.
            </summary>
            <exception cref="T:Au.Types.NotFoundException"></exception>
            <example>
            <code><![CDATA[
            var w = Wnd.Find("Example").OrThrow();
            
            var a1 = Acc.Find(w, "web:LINK", "Example").OrThrow();
            
            var a2 = (Acc.Find(w, ...)?.Find(...)).OrThrow();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Types.ExtensionMethods.OrThrow(Au.WinImage)">
            <summary>
            If this is null, throws <see cref="T:Au.Types.NotFoundException"/>, else returns this.
            </summary>
            <exception cref="T:Au.Types.NotFoundException"></exception>
            <example>
            <code><![CDATA[
            var w = Wnd.Find("Example").OrThrow();
            var wi = WinImage.Find(w, ...).OrThrow();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Types.ExtensionMethods.MouseMove(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <inheritdoc cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>
            <summary>
            Moves the cursor (mouse pointer) to the position x y relative to this window.
            </summary>
            <exception cref="T:Au.Types.NotFoundException">Window not found (this variable is 0).</exception>
            <seealso cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>
        </member>
        <member name="M:Au.Types.ExtensionMethods.MouseClick(Au.Wnd,Au.Types.Coord,Au.Types.Coord,Au.Types.MButton,System.Boolean)">
            <inheritdoc cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>
            <summary>
            Clicks, double-clicks, presses or releases a mouse button at position x y relative to this window.
            </summary>
            <exception cref="T:Au.Types.NotFoundException">Window not found (this variable is 0).</exception>
            <seealso cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>
        </member>
        <member name="M:Au.Types.ExtensionMethods.MouseMove(Au.Acc,Au.Types.Coord,Au.Types.Coord)">
            <inheritdoc cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>
            <summary>
            Moves the cursor (mouse pointer) to this accessible object.
            </summary>
            <param name="t"></param>
            <param name="x">X coordinate in the bounding rectangle of this object. Default - center.</param>
            <param name="y">Y coordinate in the bounding rectangle of this object. Default - center.</param>
            <exception cref="T:Au.Types.NotFoundException">Accessible object not found (this variable is null).</exception>
            <exception cref="T:Au.Types.AuException">
            Failed to get object rectangle (<see cref="M:Au.Acc.GetRect(Au.Types.RECT@,Au.Wnd)"/>) or container window (<see cref="P:Au.Acc.WndContainer"/>).
            <inheritdoc cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>
            </exception>
        </member>
        <member name="M:Au.Types.ExtensionMethods.MouseClick(Au.Acc,Au.Types.Coord,Au.Types.Coord,Au.Types.MButton)">
            <inheritdoc cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>
            <summary>
            Clicks this accessible object.
            </summary>
            <param name="t"></param>
            <param name="x">X coordinate in the bounding rectangle of this object. Default - center.</param>
            <param name="y">Y coordinate in the bounding rectangle of this object. Default - center.</param>
            <param name="button">Which button and how to use it.</param>
            <exception cref="T:Au.Types.NotFoundException">Accessible object not found (this variable is null).</exception>
            <exception cref="T:Au.Types.AuException">
            Failed to get object rectangle (<see cref="M:Au.Acc.GetRect(Au.Types.RECT@,Au.Wnd)"/>) or container window (<see cref="P:Au.Acc.WndContainer"/>).
            <inheritdoc cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>
            </exception>
        </member>
        <member name="M:Au.Types.ExtensionMethods.MouseMove(Au.WinImage,Au.Types.Coord,Au.Types.Coord)">
            <inheritdoc cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>
            <summary>
            Moves the mouse to the found image.
            </summary>
            <param name="t"></param>
            <param name="x">X coordinate in the found image. Default - center.</param>
            <param name="y">Y coordinate in the found image. Default - center.</param>
            <exception cref="T:Au.Types.NotFoundException">Image not found (this variable is null).</exception>
            <exception cref="T:System.InvalidOperationException">area is Bitmap.</exception>
        </member>
        <member name="M:Au.Types.ExtensionMethods.MouseClick(Au.WinImage,Au.Types.Coord,Au.Types.Coord,Au.Types.MButton)">
            <inheritdoc cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>
            <summary>
            Clicks the found image.
            </summary>
            <param name="t"></param>
            <param name="x">X coordinate in the found image. Default - center.</param>
            <param name="y">Y coordinate in the found image. Default - center.</param>
            <param name="button">Which button and how to use it.</param>
            <exception cref="T:Au.Types.NotFoundException">Image not found (this variable is null).</exception>
            <exception cref="T:System.InvalidOperationException">area is Bitmap.</exception>
        </member>
        <member name="M:Au.Types.ExtensionMethods.CreateHandle_(System.Windows.Forms.Control)">
            <summary>
            If control handle still not created, creates handle.
            Like <see cref="M:System.Windows.Forms.Control.CreateHandle"/>, which is protected.
            Unlike <see cref="M:System.Windows.Forms.Control.CreateControl"/>, creates handle even if invisible, and does not create child control handles.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.MouseClientXY_(System.Windows.Forms.Control)">
            <summary>
            Gets mouse cursor position in client area coordinates.
            Returns default(POINT) if handle not created.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.MouseWindowXY_(System.Windows.Forms.Control)">
            <summary>
            Gets mouse cursor position in window coordinates.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.SetCueBanner_(System.Windows.Forms.TextBox,System.String,System.Boolean)">
            <summary>
            Sets the textual cue, or tip, that is displayed by the control when it does not have text.
            Sends API <msdn>EM_SETCUEBANNER</msdn>.
            Does nothing if Multiline.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.SetCueBanner_(System.Windows.Forms.ComboBox,System.String)">
            <summary>
            Sets the textual cue, or tip, that is displayed by the edit control when it does not have text.
            Sends API <msdn>CB_SETCUEBANNER</msdn>.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.Add_``1(System.Windows.Forms.ContainerControl,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.String,System.Windows.Forms.AnchorStyles)">
            <summary>
            Creates a control, sets its commonly used properties (Bounds, Text, tooltip, Anchor) and adds it to the Controls collection of this.
            </summary>
            <typeparam name="T">Control class.</typeparam>
            <param name="t"></param>
            <param name="x">Left.</param>
            <param name="y">Top.</param>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
            <param name="text">The <see cref="P:System.Windows.Forms.Control.Text"/> property.</param>
            <param name="tooltip">Tooltip text.
            This function creates a ToolTip component and assigns it to the Tag property of this.</param>
            <param name="anchor">The <see cref="P:System.Windows.Forms.Control.Anchor"/> property.</param>
        </member>
        <member name="M:Au.Types.ExtensionMethods.Attribute_(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
            <summary>
            Gets XML attribute value.
            If the attribute does not exist, returns null.
            If the attribute value is empty, returns "".
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.Attribute_(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.String)">
            <summary>
            Gets XML attribute value.
            If the attribute does not exist, returns defaultValue.
            If the attribute value is empty, returns "".
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.Attribute_(System.Xml.Linq.XElement,System.String@,System.Xml.Linq.XName)">
            <summary>
            Gets XML attribute value.
            If the attribute does not exist, sets value=null and returns false.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.Attribute_(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Int32)">
            <summary>
            Gets attribute value converted to int (<see cref="M:Au.String_.ToInt_(System.String)"/>).
            If the attribute does not exist, returns defaultValue.
            If the attribute value is empty or does not begin with a valid number, returns 0.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.Attribute_(System.Xml.Linq.XElement,System.Int32@,System.Xml.Linq.XName)">
            <summary>
            Gets attribute value converted to int (<see cref="M:Au.String_.ToInt_(System.String)"/>).
            If the attribute does not exist, sets value=0 and returns false.
            If the attribute value is empty or does not begin with a valid number, sets value=0 and returns true.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.Attribute_(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Single)">
            <summary>
            Gets attribute value converted to float (<see cref="M:Au.String_.ToFloat_(System.String,System.Boolean)"/>).
            If the attribute does not exist, returns defaultValue.
            If the attribute value is empty or is not a valid float number, returns 0F.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.Attribute_(System.Xml.Linq.XElement,System.Single@,System.Xml.Linq.XName)">
            <summary>
            Gets attribute value converted to float (<see cref="M:Au.String_.ToFloat_(System.String,System.Boolean)"/>).
            If the attribute does not exist, sets value=0F and returns false.
            If the attribute value is empty or is not a valid number, sets value=0F and returns true.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.HasAttribute_(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
            <summary>
            Returns true if this element has the specified attribute.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.Descendant_(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
            <summary>
            Gets the first found descendant element.
            Returns null if not found.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.Descendant_(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Xml.Linq.XName,System.String,System.Boolean)">
            <summary>
            Gets the first found descendant element that has the specified attribute.
            Returns null if not found.
            </summary>
            <param name="t"></param>
            <param name="name">Element name. If null, can be any name.</param>
            <param name="attributeName">Attribute name.</param>
            <param name="attributeValue">Attribute value. If null, can be any value.</param>
            <param name="ignoreCase">Case-insensitive attributeValue.</param>
        </member>
        <member name="M:Au.Types.ExtensionMethods.Element_(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Xml.Linq.XName,System.String,System.Boolean)">
            <summary>
            Gets the first found direct child element that has the specified attribute.
            Returns null if not found.
            </summary>
            <param name="t"></param>
            <param name="name">Element name. If null, can be any name.</param>
            <param name="attributeName">Attribute name.</param>
            <param name="attributeValue">Attribute value. If null, can be any value.</param>
            <param name="ignoreCase">Case-insensitive attributeValue.</param>
        </member>
        <member name="M:Au.Types.ExtensionMethods.PreviousElement_(System.Xml.Linq.XElement)">
            <summary>
            Gets previous sibling element.
            Returns null if no element.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.NextElement_(System.Xml.Linq.XElement)">
            <summary>
            Gets next sibling element.
            Returns null if no element.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.ToString_(System.Double,System.String)">
            <summary>
            Converts double to string.
            Uses invariant culture, therefore decimal point is always '.', not ',' etc.
            Calls <see cref="M:System.Double.ToString(System.String,System.IFormatProvider)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.ToString_(System.Single,System.String)">
            <summary>
            Converts double to string.
            Uses invariant culture, therefore decimal point is always '.', not ',' etc.
            Calls <see cref="M:System.Single.ToString(System.String,System.IFormatProvider)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.ToString_(System.Decimal,System.String)">
            <summary>
            Converts double to string.
            Uses invariant culture, therefore decimal point is always '.', not ',' etc.
            Calls <see cref="M:System.Decimal.ToString(System.String,System.IFormatProvider)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.IsEmpty_(System.Drawing.Rectangle)">
            <summary>
            Returns true if t.Width &lt;= 0 || t.Height &lt;= 0.
            This extension method has been added because Rectangle.IsEmpty returns true only when all fields are 0, which is not very useful.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.Has_``1(``0,``0)">
            <summary>
            Returns true if this enum variable has flag(s) f (all bits).
            Compiled as inlined code <c>(t &amp; flag) == flags</c>. The same as Enum.HasFlag, but much much faster.
            The enum type must be of size 4 (default).
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.HasAny_``1(``0,``0)">
            <summary>
            Returns true if this enum variable has one or more flag bits specified in f.
            Compiled as inlined code <c>(t &amp; flags) != 0</c>. This is different from Enum.HasFlag.
            The enum type must be of size 4 (default).
            </summary>
        </member>
        <member name="T:Au.Types.WICFlags">
            <summary>
            Flags for <see cref="M:Au.WinImage.CaptureUI(Au.Types.WICResult@,Au.Types.WICFlags,Au.Types.AnyWnd)"/>.
            </summary>
            <remarks>
            Only one of flags <b>Image</b>, <b>Color</b> and <b>Rectangle</b> can be used. If none, can capture image or color.
            </remarks>
        </member>
        <member name="F:Au.Types.WICFlags.Image">
            <summary>Can capture only image, not color.</summary>
        </member>
        <member name="F:Au.Types.WICFlags.Color">
            <summary>Can capture only color, not image.</summary>
        </member>
        <member name="F:Au.Types.WICFlags.Rectangle">
            <summary>Capture only rectangle, not image/color.</summary>
        </member>
        <member name="F:Au.Types.WICFlags.WindowDC">
            <summary>
            Get pixels from the client area device context (DC) of a user-selected window, not from screen DC.
            More info: <see cref="F:Au.Types.WIFlags.WindowDC"/>.
            </summary>
        </member>
        <member name="T:Au.Types.WICResult">
            <summary>
            Results of <see cref="M:Au.WinImage.CaptureUI(Au.Types.WICResult@,Au.Types.WICFlags,Au.Types.AnyWnd)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.WICResult.image">
            <summary>
            Captured image.
            null if captured single pixel color or used flag <see cref="F:Au.Types.WICFlags.Rectangle"/>.
            </summary>
        </member>
        <member name="F:Au.Types.WICResult.color">
            <summary>
            Captured color.
            </summary>
        </member>
        <member name="F:Au.Types.WICResult.rect">
            <summary>
            Location of the captured image or rectangle, in screen coordinates.
            </summary>
        </member>
        <member name="F:Au.Types.WICResult.wnd">
            <summary>
            Window or control containing the captured image or rectangle, if whole image is in its client area.
            In some cases may be incorrect, for example if windows moved/opened/closed/etc while capturing.
            </summary>
        </member>
        <member name="T:Au.Types.RXMatch">
            <summary>
            Regular expression match info.
            Used with <see cref="T:Au.Regex_"/> class functions and String extension methods like <see cref="M:Au.String_.RegexMatch_(System.String,System.String,Au.Types.RXMatch@,Au.Types.RXFlags)"/>.
            </summary>
            <remarks>
            Contains info about a regular expression match found in the subject string: index, length, substring, etc.
            Also contains an array of group matches, as <see cref="T:Au.Types.RXGroup"/>. Groups are regular expression parts enclosed in (), except (?...).
            Group matches can be accessed like array elements. Group 0 is whole match. Group 1 is the first group. See examples.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "ab cd-45-ef gh";
            if(s.RegexMatch_(@"\b([a-z]+)-(\d+)\b", out RXMatch m))
            	Print(
            		m.GroupCountPlusOne, //3 (whole match and 2 groups)
            		m.Index, //3, same as m[0].Index
            		m.Value, //"cd-45-ef", same as m[0].Value
            		m[1].Index, //3
            		m[1].Value, //"cd"
            		m[2].Index, //6
            		m[2].Value //"45"
            		);
            ]]></code>
            A group in the subject string may not exist even if whole match found. Then its Exists property is false, Index -1, Length 0, Value null.
            <code><![CDATA[
            var s = "ab cd--ef gh";
            if(s.RegexMatch_(@"\b([a-z]+)-(\d+)?-([a-z]+)\b", out RXMatch m))
            	Print(
            		m.GroupCountPlusOne, //4 (whole match and 3 groups)
            		m[2].Exists, //false
            		m[2].Index, //-1
            		m[2].Length, //0
            		m[2].Value //null
            		);
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Types.RXMatch.GroupCountPlusOne">
            <summary>
            The number of groups in the regular expression, + 1 for the whole match.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Index">
            <summary>
            Start offset of the match in the subject string. The same as that of group 0.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.EndIndex">
            <summary>
            <see cref="P:Au.Types.RXMatch.Index"/> + <see cref="P:Au.Types.RXMatch.Length"/>. The same as that of group 0.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Length">
            <summary>
            Length of the match in the subject string. The same as that of group 0.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Value">
            <summary>
            The match (substring) in the subject string. The same as that of group 0.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Subject">
            <summary>
            The subject string in which this match was found.
            </summary>
        </member>
        <member name="M:Au.Types.RXMatch.ToString">
            <summary>
            Returns <see cref="P:Au.Types.RXMatch.Value"/>.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.IndexNoK">
            <summary>
            Start offset of whole match regardless of \K.
            When the regular expression contains \K, this is different (less) than <see cref="P:Au.Types.RXMatch.Index"/>.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Mark">
            <summary>
            The name of a found mark, or null.
            Marks can be inserted in regular expression pattern like (*MARK:name) or (*:name).
            After a full successful match, it is the last mark encountered on the matching path through the pattern. After a "no match" or a partial match, it is the last encountered mark. For example, consider this pattern: "^(*MARK:A)((*MARK:B)a|b)c". When it matches "bc", the mark is A. The B mark is "seen" in the first branch of the group, but it is not on the matching path. On the other hand, when this pattern fails to match "bx", the mark is B.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Exists">
            <summary>
            Gets the return value of the <see cref="M:Au.Regex_.Match(System.String,Au.Types.RXMatch@,Au.Types.RXMore)"/> call.
            Can be false only when the function returned false but a mark is available (see <see cref="P:Au.Types.RXMatch.Mark"/>). Otherwise, when the function returns flase, it returns null instead of a RXMatch object.
            When false, all properties except Exists and Mark have undefined values or throw exception.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.IsPartial">
            <summary>
            Returns true if this match is partial.
            Partial match is possible if used a PARTIAL_ flag.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Item(System.Int32)">
            <summary>
            Gets group info. Index 0 is whole match. Index 1 is the first group.
            </summary>
            <param name="group">1-based group index, or 0 for whole match.</param>
            <exception cref="T:System.IndexOutOfRangeException">The group index is &lt; 0 or &gt;= <see cref="P:Au.Types.RXMatch.GroupCountPlusOne"/>.</exception>
        </member>
        <member name="P:Au.Types.RXMatch.Item(System.String)">
            <summary>
            Gets group info of a named group.
            </summary>
            <param name="groupName">
            Group name.
            In regular expression, to set name of group <c>(text)</c>, use <c>(?&lt;NAME&gt;text)</c>.
            </param>
            <exception cref="T:System.ArgumentException">Unknown group name.</exception>
            <remarks>
            If more than 1 group have this name, prefers the first group that matched (<see cref="P:Au.Types.RXGroup.Exists"/> is true).
            </remarks>
        </member>
        <member name="M:Au.Types.RXMatch.GroupNumberFromName(System.String)">
            <summary>
            Finds a named group and returns its 1-based index.
            Returns -1 if not found.
            </summary>
            <param name="groupName">
            Group name.
            In regular expression, to set name of group <c>(text)</c>, use <c>(?&lt;NAME&gt;text)</c>.
            </param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <remarks>
            If more than 1 group have this name, prefers the first group that matched (<see cref="P:Au.Types.RXGroup.Exists"/> is true).
            </remarks>
            <seealso cref="M:Au.Regex_.GroupNumberFromName(System.String)"/>
        </member>
        <member name="M:Au.Types.RXMatch.GroupNumberFromName(System.String,System.Boolean@)">
            <summary>
            Finds a named group and returns its 1-based index.
            Returns -1 if not found.
            </summary>
            <param name="groupName">
            Group name.
            In regular expression, to set name of group <c>(text)</c>, use <c>(?&lt;NAME&gt;text)</c>.
            </param>
            <param name="notUnique">Receives true if more than 1 group have this name.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <remarks>
            If more than 1 group have this name, prefers the first group that matched (<see cref="P:Au.Types.RXGroup.Exists"/> is true).
            </remarks>
            <seealso cref="M:Au.Regex_.GroupNumberFromName(System.String)"/>
        </member>
        <member name="M:Au.Types.RXMatch.ExpandReplacement(System.String)">
            <summary>
            Returns the expanded version of the specified replacement pattern.
            </summary>
            <param name="repl">
            Replacement pattern.
            Can consist of any combination of literal text and substitutions like $1.
            Supports .NET regular expression substitution syntax. See <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)"/>. Also replaces $* with the name of the last encountered mark.
            </param>
            <remarks>
            Works like <see cref="M:System.Text.RegularExpressions.Match.Result(System.String)"/>.
            See also: <see cref="M:Au.Regex_.Replace(System.String,System.String,System.Int32,Au.Types.RXMore)"/>.
            </remarks>
        </member>
        <member name="T:Au.Types.RXGroup">
            <summary>
            Regular expression group match info.
            Used with <see cref="T:Au.Types.RXMatch"/>, <see cref="T:Au.Regex_"/> and some String extension methods.
            </summary>
            <remarks>
            Groups are regular expression parts enclosed in (). Except non-capturing parts, like (?:...) and (?options). A RXGroup variable contains info about a group found in the subject string: index, length, substring.
            
            Some groups specified in regular expression may not exist in the subject string even if it matches the regular expression. For example, regular expression "A(\d+)?B" matches string "AB", but group (\d+) does not exist. Then <see cref="P:Au.Types.RXGroup.Exists"/> is false, <see cref="P:Au.Types.RXGroup.Index"/> -1, <see cref="P:Au.Types.RXGroup.Length"/> 0, <see cref="P:Au.Types.RXGroup.Value"/> null.
            
            When a group matches multiple times, the RXGroup variable contains only the last instance. For example, if subject is <c>"begin 12 345 67 end"</c> and regular expression is <c>(\d+ )+</c>, value of group 1 is <c>"67"</c>. If you need all instances (<c>"12"</c>, <c>"345"</c>, <c>"67"</c>), instead use .NET <see cref="T:System.Text.RegularExpressions.Regex"/> and <see cref="P:System.Text.RegularExpressions.Group.Captures"/>. Also you can get all instances with <see cref="P:Au.Regex_.Callout"/>.
            
            Examples and more info: <see cref="T:Au.Types.RXMatch"/>, <see cref="T:Au.Regex_"/>.
            </remarks>
        </member>
        <member name="P:Au.Types.RXGroup.Index">
            <summary>
            Start offset of the group match in the subject string.
            </summary>
        </member>
        <member name="P:Au.Types.RXGroup.EndIndex">
            <summary>
            <see cref="P:Au.Types.RXGroup.Index"/> + <see cref="P:Au.Types.RXGroup.Length"/>.
            </summary>
        </member>
        <member name="P:Au.Types.RXGroup.Length">
            <summary>
            Length of the group match in the subject string.
            </summary>
        </member>
        <member name="P:Au.Types.RXGroup.Value">
            <summary>
            String value of the group match in the subject string.
            </summary>
        </member>
        <member name="P:Au.Types.RXGroup.Exists">
            <summary>
            Returns true if the group exists in the subject string, false if does not exist.
            More info in <see cref="T:Au.Types.RXGroup"/> topic. Example in <see cref="T:Au.Types.RXMatch"/> topic.
            </summary>
            <remarks>
            Other ways to detect it: if a group does not exist, its Index is -1 and Value is null.
            </remarks>
        </member>
        <member name="M:Au.Types.RXGroup.ToString">
            <summary>
            Returns <see cref="P:Au.Types.RXGroup.Value"/>.
            </summary>
        </member>
        <member name="T:Au.Types.RXMore">
            <summary>
            Rarely used parameters for <see cref="T:Au.Regex_"/> class functions.
            </summary>
            <remarks>
            The constructor allows you to set initial values of fields. You can modify them later if need. Regex_ functions don't modify them.
            
            The start/end fields can be used to specify part of subject string. When a function has parameter <i>group</i>, the start/end fields don't depend on it; they are used to specify where to search for whole match.
            </remarks>
        </member>
        <member name="F:Au.Types.RXMore.start">
            <summary>
            The start index (offset) in the subject string.
            Default 0. Valid values are from 0 to (including) subject length.
            The subject part before it is not ignored if regular expression starts with a lookbehind assertion or anchor, eg <c>^</c> or <c>\b</c> or <c>(?&lt;=...)</c>. Instead of <c>^</c> you can use <c>\G</c>. More info in PCRE documentation topic <see href="https://www.pcre.org/current/doc/html/pcre2api.html">pcre2api</see>, chapter "The string to be matched by pcre2_match()".
            </summary>
        </member>
        <member name="F:Au.Types.RXMore.end">
            <summary>
            The end index (offset) in the subject string. As if the string ends here.
            If negative (default -1), is used subject string length. Else valid values are from <see cref="F:Au.Types.RXMore.start"/> to (including) subject length.
            </summary>
        </member>
        <member name="F:Au.Types.RXMore.matchFlags">
            <summary>
            Options.
            The same options also can be set when calling Regex_ constructor. Constructor's flags and matchFlags are added, which means that matchFlags cannot unset flags set when calling constructor.
            </summary>
        </member>
        <member name="M:Au.Types.RXMore.#ctor(System.Int32,System.Int32,Au.Types.RXMatchFlags)">
            <summary>
            Sets field values.
            If <paramref name="end"/> is -1 (default), will be used subject string length.
            </summary>
        </member>
        <member name="T:Au.Types.RXCalloutFunc">
            <summary>
            Delegate type of callout callback function.
            See <see cref="P:Au.Regex_.Callout"/>.
            </summary>
        </member>
        <member name="T:Au.Types.RXCalloutData">
            <summary>
            Managed version of PCRE API struct pcre2_callout_block.
            When you set <see cref="P:Au.Regex_.Callout"/>, your callout function's parameter is of this type.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            Most properties are pcre2_callout_block fields as documented in PCRE help. Other properties and methods are easier/safer versions of unsafe fields like offset_vector.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.Result">
            <summary>
            Sets the return value of the callout function, as documented in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            Default 0.
            If 1, matching fails at the current point, but the testing of other matching possibilities goes ahead, just as if a lookahead assertion had failed.
            If -1 (PCRE2_ERROR_NOMATCH), the match function returns false (no match). Values less tan -2 are PCRE error codes and cause exception.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.callout_number">
            <summary>
            Callout number, eg 5 for "(?C5)".
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.capture_top">
            <summary>
            One more than the number of the highest numbered captured group so far.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.capture_last">
            <summary>
            The number of the most recently captured group.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.start_match">
            <summary>
            The offset within the subject string at which the current match attempt started. But depends on \K etc.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.current_position">
            <summary>
            The current offset within the subject string.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.pattern_position">
            <summary>
            The offset in the regular expression to the next item to be matched.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.next_item_length">
            <summary>
            The length of the next item to be processed in the regular expression.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.callout_string_offset">
            <summary>
            The callout string offset in the regular expression. Used with callouts like "(?C'calloutString')".
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.callout_string">
            <summary>
            The callout string, eg "xyz" for "(?C'xyz')".
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.mark">
            <summary>
            The most recently passed (*MARK), (*PRUNE), or (*THEN) item in the match, or null if no such items have been passed.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="M:Au.Types.RXCalloutData.Group(System.Int32)">
            <summary>
            Gets the start index and length of the specified group in the subject string.
            </summary>
            <param name="group">Group number (1-based index).</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="group"/> must be &gt; 0 and &lt; capture_top.</exception>
        </member>
        <member name="M:Au.Types.RXCalloutData.GroupValue(System.Int32)">
            <summary>
            Gets the value (substring) of the specified group.
            </summary>
            <param name="group">Group number (1-based index).</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="group"/> must be &gt; 0 and &lt; capture_top.</exception>
        </member>
        <member name="P:Au.Types.RXCalloutData.LastGroup">
            <summary>
            Gets the start index and length of the most recently captured group in the subject string.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.LastGroupValue">
            <summary>
            Gets the value (substring) of the most recently captured group.
            </summary>
        </member>
        <member name="T:Au.Types.RXFlags">
            <summary>
            Flags for <see cref="T:Au.Regex_"/> constructor.
            Documented in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2api.html">pcre2api</see>.
            </summary>
            <remarks>
            Many options also can be specified in regular expression (RE):
            <list type="bullet">
            <item>These can be anywhere in RE: (?i) CASELESS, (?m) MULTILINE, (?s) DOTALL, (?n) NO_AUTO_CAPTURE, (?x) EXTENDED, (?xx) EXTENDED_MORE, (?J) DUPNAMES, (?U) UNGREEDY. Can be multiple, like (?ms). Can be unset, like (?-i). RE "\Qtext\E" is like RE "text" with flag LITERAL.</item>
            <item>Instead of ANCHORED can be used \A or \G at the start of RE. Or ^, except in multiline mode.</item>
            <item>Instead of ENDANCHORED can be used \z at the end of RE. Or $, except in multiline mode.</item>
            <item>Flag UTF is implicitly added if RE contains non-ASCII characters and there is no flag NEVER_UTF.</item>
            <item>These must be at the very start and are named like flags: (*UTF), (*UCP), (*NOTEMPTY), (*NOTEMPTY_ATSTART), (*NO_AUTO_POSSESS), (*NO_DOTSTAR_ANCHOR), (*NO_START_OPT).</item>
            <item>More info in <see href="https://www.pcre.org/current/doc/html/pcre2pattern.html">PCRE syntax reference</see>.</item>
            </list>
            Some of RXFlags flags also exist in <see cref="T:Au.Types.RXMatchFlags"/>. You can set them either when calling Regex_ constructor or when calling Regex_ functions that have parameter <i>more</i>. You can use different flags for each function call with the same Regex_ variable.
            </remarks>
        </member>
        <member name="F:Au.Types.RXFlags.UTF">
            <summary>
            Fully support Unicode text (case-insensitivity etc). More info in PCRE documentation topic <see href="https://www.pcre.org/current/doc/html/pcre2unicode.html">pcre2unicode</see>.
            This flag is implicitly added if regular expression contains non-ASCII characters and there is no flag NEVER_UTF.
            </summary>
        </member>
        <member name="T:Au.Types.RXMatchFlags">
            <summary>
            Flags for <see cref="M:Au.Regex_.Match(System.String,Au.Types.RXMatch@,Au.Types.RXMore)"/> and other <see cref="T:Au.Regex_"/> class functions.
            Documented in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2api.html">pcre2api</see>.
            </summary>
            <remarks>
            These flags also exist in <see cref="T:Au.Types.RXFlags"/> (Regex_ constructor flags). You can set them either when calling constructor or when calling other functions.
            </remarks>
        </member>
        <member name="T:Au.Types.Separators">
            <summary>
            Contains several string constants that can be used with some 'split string' functions of this library to specify separators.
            </summary>
        </member>
        <member name="F:Au.Types.Separators.Whitespace">
            <summary>
            Specifies that separators are all characters for which <see cref="M:System.Char.IsWhiteSpace(System.Char)"/> returns true.
            </summary>
        </member>
        <member name="F:Au.Types.Separators.Word">
            <summary>
            Specifies that separators are all characters for which <see cref="M:System.Char.IsLetterOrDigit(System.Char)"/> returns false.
            </summary>
        </member>
        <member name="F:Au.Types.Separators.Line">
            <summary>
            Specifies that separators are substrings "\r\n", as well as single characters '\r' and '\n'.
            </summary>
        </member>
        <member name="T:Au.Types.SegFlags">
            <summary>
            Flags for <see cref="M:Au.String_.Segments_(System.String,System.String,Au.Types.SegFlags)"/> and some other functions.
            </summary>
        </member>
        <member name="F:Au.Types.SegFlags.NoEmpty">
            <summary>
            Don't return empty substrings.
            For example, is string is "one  two " and separators is " ", return {"one", "two"} instead of {"one", "", "two", ""}.
            </summary>
        </member>
        <member name="T:Au.Types.SegParser">
            <summary>
            Splits a string or <b>StringSegment</b> into substrings as <see cref="T:Au.StringSegment"/> variables.
            </summary>
            <remarks>
            Used with foreach. Also used internally by some functions of this library, for example <see cref="M:Au.String_.Split_(System.String,System.String,Au.Types.SegFlags)"/> and <see cref="M:Au.String_.SplitLines_(System.String,System.Boolean)"/>.
            Normally you don't create <b>SegParser</b> instances explicitly; instead use <see cref="M:Au.String_.Segments_(System.String,System.String,Au.Types.SegFlags)"/> or <see cref="M:Au.StringSegment.Split(System.String,Au.Types.SegFlags)"/> with foreach.
            </remarks>
        </member>
        <member name="M:Au.Types.SegParser.#ctor(System.String,System.String,Au.Types.SegFlags)">
            <summary>
            Initializes this instance to split a string.
            </summary>
            <param name="s">The string.</param>
            <param name="separators">A string containing characters that delimit substrings. Or one of <see cref="T:Au.Types.Separators"/> constants.</param>
            <param name="flags"></param>
        </member>
        <member name="M:Au.Types.SegParser.#ctor(Au.StringSegment@,System.String,Au.Types.SegFlags)">
            <summary>
            Initializes this instance to split a <see cref="T:Au.StringSegment"/>.
            </summary>
            <param name="seg">The StringSegment.</param>
            <param name="separators">A string containing characters that delimit substrings. Or one of <see cref="T:Au.Types.Separators"/> constants.</param>
            <param name="flags"></param>
        </member>
        <member name="M:Au.Types.SegParser.GetEnumerator">
            <tocexclude />
        </member>
        <member name="M:Au.Types.SegParser.System#Collections#Generic#IEnumerable{Au#StringSegment}#GetEnumerator">
            <tocexclude />
        </member>
        <member name="M:Au.Types.SegParser.System#Collections#IEnumerable#GetEnumerator">
            <tocexclude />
        </member>
        <member name="P:Au.Types.SegParser.Current">
            <tocexclude />
        </member>
        <member name="P:Au.Types.SegParser.System#Collections#IEnumerator#Current">
            <tocexclude />
        </member>
        <member name="M:Au.Types.SegParser.MoveNext">
            <tocexclude />
        </member>
        <member name="M:Au.Types.SegParser.Dispose">
            <tocexclude />
        </member>
        <member name="M:Au.Types.SegParser.Reset">
            <tocexclude />
        </member>
        <member name="M:Au.Types.SegParser.ToStringArray(System.Int32)">
            <summary>
            Returns segment values as string[].
            </summary>
            <param name="maxCount">The maximum number of substrings to get. If negative (default), gets all.</param>
        </member>
        <member name="T:Au.Types.HookData">
            <summary>
            Contains types of hook data for hook procedures installed by <see cref="T:Au.Util.WinHook"/> and <see cref="T:Au.Util.AccHook"/>.
            </summary>
        </member>
        <member name="T:Au.Types.HookData.Keyboard">
            <summary>
            Hook data for the hook procedure installed by <see cref="M:Au.Util.WinHook.Keyboard(System.Func{Au.Types.HookData.Keyboard,System.Boolean})"/>.
            More info: <msdn>LowLevelKeyboardProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.Keyboard.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.IsExtended">
            <summary>
            Is extended key.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.IsInjected">
            <summary>
            true if the event was generated by API such as <msdn>SendInput</msdn>.
            false if the event was generated by the keyboard.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.IsAlt">
            <summary>
            Key Alt is pressed.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.IsUp">
            <summary>
            Is key-up event.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.Mod">
            <summary>
            If the key is a modifier key (Shift, Ctrl, Alt, Win), returns the modifier flag. Else returns 0.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.Key">
            <summary>
            If <b>vkCode</b> is a left or right modifier key code (LShift, LCtrl, LAlt, RShift, RCtrl, RAlt, RWin), returns the common modifier key code (Shift, Ctrl, Alt, Win). Else returns <b>vkCode</b>.
            </summary>
        </member>
        <member name="M:Au.Types.HookData.Keyboard.IsKey(Au.Types.KKey)">
            <summary>
            Returns true if <paramref name="key"/> == <b>vkCode</b> or <paramref name="key"/> is Shift, Ctrl, Alt or Win and <b>vkCode</b> is LShift/RShift, LCtrl/RCtrl, LAlt/RAlt or RWin.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.LibSendInputFlags">
            <summary>
            Converts flags to API SendInput flags KEYEVENTF_KEYUP and KEYEVENTF_EXTENDEDKEY.
            </summary>
        </member>
        <member name="M:Au.Types.HookData.Keyboard.ToString">
            
        </member>
        <member name="P:Au.Types.HookData.Keyboard.vkCode">
            <summary><msdn>KBDLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.scanCode">
            <summary><msdn>KBDLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.flags">
            <summary><msdn>KBDLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.time">
            <summary><msdn>KBDLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.dwExtraInfo">
            <summary><msdn>KBDLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="T:Au.Types.HookData.Mouse">
            <summary>
            Hook data for the hook procedure installed by <see cref="M:Au.Util.WinHook.Mouse(System.Func{Au.Types.HookData.Mouse,System.Boolean})"/>.
            More info: <msdn>LowLevelMouseProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.Mouse.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.Event">
            <summary>
            What event it is (button, move, wheel).
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.IsButtonDown">
            <summary>
            Is button-down event.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.IsButtonUp">
            <summary>
            Is button-up event.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.IsButton">
            <summary>
            Is button event (down or up).
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.IsWheel">
            <summary>
            Is wheel event.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.IsInjected">
            <summary>
            true if the event was generated by API such as <msdn>SendInput</msdn>.
            false if the event was generated by the mouse.
            </summary>
        </member>
        <member name="M:Au.Types.HookData.Mouse.ToString">
            
        </member>
        <member name="P:Au.Types.HookData.Mouse.pt">
            <summary><msdn>MSLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.mouseData">
            <summary><msdn>MSLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.flags">
            <summary><msdn>MSLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.time">
            <summary><msdn>MSLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.dwExtraInfo">
            <summary><msdn>MSLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="T:Au.Types.HookData.MouseEvent">
            <summary>
            Mouse hook event types. See <see cref="P:Au.Types.HookData.Mouse.Event"/>.
            </summary>
        </member>
        <member name="T:Au.Types.HookData.ThreadCbt">
            <summary>
            Hook data for the hook procedure installed by <see cref="M:Au.Util.WinHook.ThreadCbt(System.Func{Au.Types.HookData.ThreadCbt,System.Boolean},System.Int32)"/>.
            More info: <msdn>CBTProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCbt.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCbt.code">
            <summary><msdn>CBTProc</msdn></summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCbt.wParam">
            <summary><msdn>CBTProc</msdn></summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCbt.lParam">
            <summary><msdn>CBTProc</msdn></summary>
        </member>
        <member name="M:Au.Types.HookData.ThreadCbt.ActivationInfo(System.Boolean@,Au.Wnd@)">
            <summary>
            Returns the window handle of the window being activated and gets some more info.
            </summary>
            <param name="fMouse">true if the reason is the mouse.</param>
            <param name="wPrevActive">The previously active window, or default(Wnd).</param>
            <exception cref="T:System.InvalidOperationException"><b>code</b> is not CbtEvent.ACTIVATE.</exception>
        </member>
        <member name="M:Au.Types.HookData.ThreadCbt.CreationInfo(Au.Types.Native.CREATESTRUCT*@,Au.Wnd@)">
            <summary>
            Returns the window handle and gets more info about the created window.
            </summary>
            <param name="c"><msdn>CREATESTRUCT</msdn>. You can modify x y cx cy.</param>
            <param name="wInsertAfter">Window whose position in the Z order precedes that of the window being created, or default(Wnd).</param>
            <exception cref="T:System.InvalidOperationException"><b>code</b> is not CbtEvent.CREATEWND.</exception>
        </member>
        <member name="M:Au.Types.HookData.ThreadCbt.MouseInfo(Au.Types.Native.MOUSEHOOKSTRUCT*@)">
            <summary>
            Returns the mouse message and gets some more info about the mouse event.
            </summary>
            <param name="m"><msdn>MOUSEHOOKSTRUCT</msdn>.</param>
            <exception cref="T:System.InvalidOperationException"><b>code</b> is not CbtEvent.CLICKSKIPPED.</exception>
        </member>
        <member name="M:Au.Types.HookData.ThreadCbt.KeyInfo(System.UInt32@)">
            <summary>
            Returns the key code and gets some more info about the keyboard event.
            </summary>
            <param name="lParam"><i>lParam</i> of the key message. Specifies the repeat count, scan code, etc. See <msdn>WM_KEYDOWN</msdn>.</param>
            <exception cref="T:System.InvalidOperationException"><b>code</b> is not CbtEvent.KEYSKIPPED.</exception>
        </member>
        <member name="M:Au.Types.HookData.ThreadCbt.FocusInfo(Au.Wnd@)">
            <summary>
            Returns the window handle and gets some more info about the focus event.
            </summary>
            <param name="wLostFocus">The previously focused window, or default(Wnd).</param>
            <exception cref="T:System.InvalidOperationException"><b>code</b> is not CbtEvent.SETFOCUS.</exception>
        </member>
        <member name="M:Au.Types.HookData.ThreadCbt.MoveSizeInfo(Au.Types.RECT*@)">
            <summary>
            Returns the window handle and gets some more info about the move-size event.
            </summary>
            <param name="r">The new rectangle of the window.</param>
            <exception cref="T:System.InvalidOperationException"><b>code</b> is not CbtEvent.MOVESIZE.</exception>
        </member>
        <member name="M:Au.Types.HookData.ThreadCbt.MinMaxInfo(System.Int32@)">
            <summary>
            Returns the window handle and gets some more info about the minimize-maximize-restore event.
            </summary>
            <param name="showState">The new show state. See <msdn>ShowWindow</msdn>. Minimized 6, maximized 3, restored 9.</param>
            <exception cref="T:System.InvalidOperationException"><b>code</b> is not CbtEvent.MINMAX.</exception>
        </member>
        <member name="T:Au.Types.HookData.CbtEvent">
            <summary>
            CBT hook event types. Used with <see cref="T:Au.Types.HookData.ThreadCbt"/>.
            More info: <msdn>CBTProc</msdn>.
            </summary>
        </member>
        <member name="T:Au.Types.HookData.ThreadGetMessage">
            <summary>
            Hook data for the hook procedure installed by <see cref="M:Au.Util.WinHook.ThreadGetMessage(System.Action{Au.Types.HookData.ThreadGetMessage},System.Int32)"/>.
            More info: <msdn>GetMsgProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadGetMessage.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadGetMessage.PM_NOREMOVE">
            <summary>
            The message has not been removed from the queue, because called API <msdn>PeekMessage</msdn> with flag PM_NOREMOVE.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadGetMessage.msg">
            <summary>
            Message parameters.
            </summary>
        </member>
        <member name="T:Au.Types.HookData.ThreadKeyboard">
            <summary>
            Hook data for the hook procedure installed by <see cref="M:Au.Util.WinHook.ThreadKeyboard(System.Func{Au.Types.HookData.ThreadKeyboard,System.Boolean},System.Int32)"/>.
            More info: <msdn>KeyboardProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadKeyboard.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadKeyboard.PM_NOREMOVE">
            <summary>
            The message has not been removed from the queue, because called API <msdn>PeekMessage</msdn> with flag PM_NOREMOVE.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadKeyboard.key">
            <summary>
            The key code.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadKeyboard.lParam">
            <summary>
            <i>lParam</i> of the key message. Specifies the key state, scan code, etc. See <msdn>KeyboardProc</msdn>.
            </summary>
        </member>
        <member name="T:Au.Types.HookData.ThreadMouse">
            <summary>
            Hook data for the hook procedure installed by <see cref="M:Au.Util.WinHook.ThreadMouse(System.Func{Au.Types.HookData.ThreadMouse,System.Boolean},System.Int32)"/>.
            More info: <msdn>MouseProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadMouse.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadMouse.PM_NOREMOVE">
            <summary>
            The message has not been removed from the queue, because called API <msdn>PeekMessage</msdn> with flag PM_NOREMOVE.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadMouse.message">
            <summary>
            The mouse message, for example WM_MOUSEMOVE.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadMouse.m">
            <summary>
            More info about the mouse message.
            </summary>
        </member>
        <member name="T:Au.Types.HookData.ThreadCallWndProc">
            <summary>
            Hook data for the hook procedure installed by <see cref="M:Au.Util.WinHook.ThreadCallWndProc(System.Action{Au.Types.HookData.ThreadCallWndProc},System.Int32)"/>.
            More info: <msdn>CallWndProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCallWndProc.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCallWndProc.sentByOtherThread">
            <summary>
            True if the message was sent by another thread.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCallWndProc.msg">
            <summary>
            Message parameters.
            </summary>
        </member>
        <member name="T:Au.Types.HookData.ThreadCallWndProcRet">
            <summary>
            Hook data for the hook procedure installed by <see cref="M:Au.Util.WinHook.ThreadCallWndProcRet(System.Action{Au.Types.HookData.ThreadCallWndProcRet},System.Int32)"/>.
            More info: <msdn>CallWndRetProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCallWndProcRet.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCallWndProcRet.sentByOtherThread">
            <summary>
            True if the message was sent by another thread.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCallWndProcRet.msg">
            <summary>
            Message parameters and the return value.
            </summary>
        </member>
        <member name="M:Au.Types.HookData.ReplyMessage(System.Boolean)">
            <summary>
            Calls API <msdn>ReplyMessage</msdn>, which allows to use <see cref="T:Au.Acc"/> and COM in the hook procedure.
            </summary>
            <param name="cancelEvent">
            Don't notify the target window about the event, and don't call other hook procedures.
            This value is used instead of the return value of the hook procedure, which is ignored.
            </param>
            <remarks>
            It can be used as a workaround for this problem: in low-level hook procedure some functions don't work with some windows. For example cannot get an accessible object or use a COM object. Error/exception "An outgoing call cannot be made since the application is dispatching an input-synchronous call (0x8001010D)".
            </remarks>
        </member>
        <member name="T:Au.Types.HookData.AccHookData">
            <summary>
            Hook data for the hook procedure installed by <see cref="T:Au.Util.AccHook"/>.
            More info: <msdn>WinEventProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.AccHookData.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="F:Au.Types.HookData.AccHookData.aEvent">
            <summary><msdn>WinEventProc</msdn></summary>
        </member>
        <member name="F:Au.Types.HookData.AccHookData.wnd">
            <summary><msdn>WinEventProc</msdn></summary>
        </member>
        <member name="F:Au.Types.HookData.AccHookData.idObject">
            <summary><msdn>WinEventProc</msdn></summary>
        </member>
        <member name="F:Au.Types.HookData.AccHookData.idChild">
            <summary><msdn>WinEventProc</msdn></summary>
        </member>
        <member name="F:Au.Types.HookData.AccHookData.idThread">
            <summary><msdn>WinEventProc</msdn></summary>
        </member>
        <member name="F:Au.Types.HookData.AccHookData.eventTime">
            <summary><msdn>WinEventProc</msdn></summary>
        </member>
        <member name="M:Au.Types.HookData.AccHookData.GetAcc">
            <inheritdoc cref="M:Au.Acc.FromEvent(Au.Wnd,System.Int32,System.Int32)"/>
        </member>
        <member name="T:Au.Types.NamespaceDoc">
            <summary>
            This namespace contains:
            <list type="bullet">
            <item>Types of function parameters and return values.</item>
            <item>Exception classes, some base classes, some other types.</item>
            <item>Extension methods for various .NET classes.</item>
            </list>
            </summary>
        </member>
        <member name="T:Au.Types.Coord">
            <summary>
            Contains x or y coordinate. Used for parameters of functions like Mouse.Move, Wnd.Move.
            Allows to easily specify coordinates of these types: normal, reverse (from right or bottom of a rectangle), fractional (fraction of width or height of a rectangle), null.
            Also has functions to convert to normal coodinates.
            </summary>
        </member>
        <member name="T:Au.Types.Coord.CoordType">
            <summary>
            Coord variable value type.
            </summary>
        </member>
        <member name="F:Au.Types.Coord.CoordType.None">
            <summary>
            No value. The variable is default(Coord).
            </summary>
        </member>
        <member name="F:Au.Types.Coord.CoordType.Normal">
            <summary>
            <see cref="P:Au.Types.Coord.Value"/> is pixel offset from left or top of a rectangle.
            </summary>
        </member>
        <member name="F:Au.Types.Coord.CoordType.Reverse">
            <summary>
            <see cref="P:Au.Types.Coord.Value"/> is pixel offset from right or bottom of a rectangle, towards left or top.
            </summary>
        </member>
        <member name="F:Au.Types.Coord.CoordType.Fraction">
            <summary>
            <see cref="P:Au.Types.Coord.FractionValue"/> is fraction of a rectangle, where 0.0 is left or top, and 1.0 is right or bottom (outside of the rectangle).
            </summary>
        </member>
        <member name="P:Au.Types.Coord.Type">
            <summary>
            Value type.
            </summary>
        </member>
        <member name="P:Au.Types.Coord.Value">
            <summary>
            Non-fraction value.
            </summary>
        </member>
        <member name="P:Au.Types.Coord.FractionValue">
            <summary>
            Fraction value.
            </summary>
        </member>
        <member name="P:Au.Types.Coord.IsEmpty">
            <summary>
            Returns true if Type == None (when assigned default(Coord)).
            </summary>
        </member>
        <member name="M:Au.Types.Coord.op_Implicit(System.Int32)~Au.Types.Coord">
            <summary>
            Creates Coord of Normal type.
            </summary>
        </member>
        <member name="M:Au.Types.Coord.Reverse(System.Int32)">
            <summary>
            Creates Coord of Reverse type.
            Value 0 is at the right or bottom, and does not belong to the rectangle. Positive values are towards left or top.
            </summary>
        </member>
        <member name="M:Au.Types.Coord.Fraction(System.Double)">
            <summary>
            Creates Coord of Fraction type.
            Value 0.0 is the left or top of the rectangle. Value 1.0 is the right or bottom of the rectangle. Values &lt;0.0 and &gt;=1.0 are outside of the rectangle.
            </summary>
        </member>
        <member name="P:Au.Types.Coord.Center">
            <summary>
            Returns <c>Fraction(0.5)</c>.
            </summary>
            <seealso cref="M:Au.Types.Coord.Fraction(System.Double)"/>
        </member>
        <member name="P:Au.Types.Coord.Max">
            <summary>
            Returns <c>Reverse(0)</c>.
            This point will be outside of the rectangle. See also <see cref="P:Au.Types.Coord.MaxInside"/>.
            </summary>
            <seealso cref="M:Au.Types.Coord.Reverse(System.Int32)"/>
        </member>
        <member name="P:Au.Types.Coord.MaxInside">
            <summary>
            Returns <c>Reverse(1)</c>.
            This point will be inside of the rectangle, at the very right or bottom, assuming the rectangle is not empty.
            </summary>
            <seealso cref="M:Au.Types.Coord.Reverse(System.Int32)"/>
        </member>
        <member name="M:Au.Types.Coord.NormalizeInRect(Au.Types.Coord,Au.Types.Coord,Au.Types.RECT,System.Boolean,System.Boolean)">
            <summary>
            Converts fractional/reverse coordinates to normal coordinates in a rectangle.
            </summary>
            <param name="x">X coordinate relative to r.</param>
            <param name="y">Y coordinate relative to r.</param>
            <param name="r">The rectangle.</param>
            <param name="widthHeight">Use only width and height of r. If false (default), the function adds r offset (left and top).</param>
            <param name="centerIfEmpty">If x or y is default(Coord), use Coord.Center. Not used with widthHeight.</param>
        </member>
        <member name="M:Au.Types.Coord.NormalizeInWindow(Au.Types.Coord,Au.Types.Coord,Au.Wnd,System.Boolean,System.Boolean)">
            <summary>
            Returns normal coordinates relative to the client area of a window. Converts fractional/reverse coordinates etc.
            </summary>
            <param name="x">X coordinate relative to the client area of w.</param>
            <param name="y">Y coordinate relative to the client area of w.</param>
            <param name="w">The window.</param>
            <param name="nonClient">x y are relative to the entire w rectangle, not to its client area.</param>
            <param name="centerIfEmpty">If x or y is default(Coord), use Coord.Center.</param>
        </member>
        <member name="M:Au.Types.Coord.Normalize(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.Types.Screen_,System.Boolean,System.Boolean)">
            <summary>
            Returns normal coordinates relative to the primary screen. Converts fractional/reverse coordinates etc.
            </summary>
            <param name="x">X coordinate relative to the specified screen (default - primary).</param>
            <param name="y">Y coordinate relative to the specified screen (default - primary).</param>
            <param name="workArea">x y are relative to the work area.</param>
            <param name="screen">If used, x y are relative to this screen. Default - primary screen.</param>
            <param name="widthHeight">Use only width and height of the screen rectangle. If false, the function adds its offset (left and top, which can be nonzero if using the work area or a non-primary screen).</param>
            <param name="centerIfEmpty">If x or y is default(Coord), use Coord.Center.</param>
        </member>
        <member name="M:Au.Types.Coord.ToString">
            
        </member>
        <member name="T:Au.Types.PopupXY">
            <summary>
            Can be used to specify coordinates for various popup windows and other UI objects.
            </summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(System.ValueTuple{Au.Types.Coord,Au.Types.Coord})~Au.Types.PopupXY">
            <summary>Specifies position relative to the work area of the primary screen.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(System.ValueTuple{Au.Types.Coord,Au.Types.Coord,System.Boolean})~Au.Types.PopupXY">
            <summary>Specifies position relative to the primary screen or its work area.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(System.ValueTuple{Au.Types.Coord,Au.Types.Coord,Au.Types.Screen_})~Au.Types.PopupXY">
            <summary>Specifies position relative to the work area of the specified screen.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(System.ValueTuple{Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.Types.Screen_})~Au.Types.PopupXY">
            <summary>Specifies position relative to the specified screen or its work area.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(System.ValueTuple{Au.Types.Coord,Au.Types.Coord,Au.Types.Screen_,System.Boolean})~Au.Types.PopupXY">
            <summary>Specifies position relative to the specified screen or its work area.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(Au.Types.POINT)~Au.Types.PopupXY">
            <summary>Specifies position relative to the primary screen.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(Au.Types.Screen_)~Au.Types.PopupXY">
            <summary>Specifies the center of the work area of the specified screen.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(System.ValueTuple{Au.Types.Screen_,System.Boolean})~Au.Types.PopupXY">
            <summary>Specifies the center of the specified screen or its work area.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(System.ValueTuple{System.Boolean,Au.Types.Screen_})~Au.Types.PopupXY">
            <summary>Specifies the center of the specified screen or its work area.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(System.ValueTuple{Au.Types.RECT,Au.Types.Coord,Au.Types.Coord})~Au.Types.PopupXY">
            <summary>Specifies position in the specified rectangle which is relative to the primary screen.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(Au.Types.RECT)~Au.Types.PopupXY">
            <summary>Specifies the center of the specified rectangle which is relative to the primary screen.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(System.ValueTuple{Au.Wnd,Au.Types.Coord,Au.Types.Coord})~Au.Types.PopupXY">
            <summary>Specifies position in the specified window.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(Au.Wnd)~Au.Types.PopupXY">
            <summary>Specifies the center of the specified window.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(System.Windows.Forms.Control)~Au.Types.PopupXY">
            <summary>Specifies the center of the specified control or form.</summary>
        </member>
        <member name="P:Au.Types.PopupXY.Mouse">
            <summary>
            Gets point coordinates below mouse cursor, for showing a tooltip-like popup.
            </summary>
        </member>
        <member name="M:Au.Types.PopupXY.GetScreen">
            <summary>
            Gets <see cref="T:System.Windows.Forms.Screen"/> specified in <see cref="F:Au.Types.PopupXY.screen"/>. If not specified, gets that of the screen that contains the specified point.
            </summary>
        </member>
        <member name="T:Au.Types.AnyWnd">
            <summary>
            Window handle.
            Used for function parameters where the function needs a window handle as <see cref="T:Au.Wnd"/> but also allows to pass a variable of any of these types: System.Windows.Forms.Control (Form or any control class), System.Windows.Window (WPF window), IntPtr (window handle).
            </summary>
        </member>
        <member name="M:Au.Types.AnyWnd.op_Implicit(Au.Wnd)~Au.Types.AnyWnd">
            <summary> Assignment of a value of type Wnd. </summary>
        </member>
        <member name="M:Au.Types.AnyWnd.op_Implicit(System.IntPtr)~Au.Types.AnyWnd">
            <summary> Assignment of a value of type Wnd. </summary>
        </member>
        <member name="M:Au.Types.AnyWnd.op_Implicit(System.Windows.Forms.Control)~Au.Types.AnyWnd">
            <summary> Assignment of a value of type System.Windows.Forms.Control (Form or any control class). </summary>
        </member>
        <member name="M:Au.Types.AnyWnd.op_Implicit(System.Windows.Window)~Au.Types.AnyWnd">
            <summary> Assignment of a value of type System.Windows.Window (WPF window). </summary>
        </member>
        <member name="P:Au.Types.AnyWnd.Wnd">
            <summary>
            Gets the window or control handle as Wnd.
            Returns default(Wnd) if not assigned.
            </summary>
        </member>
        <member name="P:Au.Types.AnyWnd.IsEmpty">
            <summary>
            true if this is default(AnyWnd).
            </summary>
        </member>
        <member name="T:Au.Types.MultiString">
            <summary>
            Used for function parameters to specify multiple strings.
            Contains a string like "One|Two|Three" or string[] or List&lt;string&gt;. Has implicit conversion operators from these types.
            </summary>
        </member>
        <member name="F:Au.Types.MultiString.Value">
            <summary>
            The raw value.
            </summary>
        </member>
        <member name="M:Au.Types.MultiString.op_Implicit(System.String)~Au.Types.MultiString">
            <summary> Assignment of a value of type string. </summary>
        </member>
        <member name="M:Au.Types.MultiString.op_Implicit(System.String[])~Au.Types.MultiString">
            <summary> Assignment of a value of type string[]. </summary>
        </member>
        <member name="M:Au.Types.MultiString.op_Implicit(System.Collections.Generic.List{System.String})~Au.Types.MultiString">
            <summary> Assignment of a value of type List&lt;string&gt;. </summary>
        </member>
        <member name="M:Au.Types.MultiString.ToArray(System.Char)">
            <summary>
            Converts the value to string[].
            </summary>
            <param name="separator">If the value is string, use this character to split it. Default '|'.</param>
            <remarks>
            If the value was string or List, converts to string[] and stores the string[] in <b>Value</b>. If null, returns empty array.
            </remarks>
        </member>
        <member name="T:Au.Types.PNFlags">
            <summary>
            flags for <see cref="M:Au.Path_.Normalize(System.String,System.String,Au.Types.PNFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.PNFlags.DoNotExpandDosPath">
            <summary>Don't call API <msdn>GetLongPathName</msdn>.</summary>
        </member>
        <member name="F:Au.Types.PNFlags.DoNotPrefixLongPath">
            <summary>Don't call <see cref="M:Au.Path_.PrefixLongPathIfNeed(System.String)"/>.</summary>
        </member>
        <member name="F:Au.Types.PNFlags.DoNotRemoveEndSeparator">
            <summary>Don't remove '\\' character at the end.</summary>
        </member>
        <member name="F:Au.Types.PNFlags.CanBeUrlOrShell">
            <summary>If path is not a file-system path but looks like URL (eg "http:..." or "file:...") or starts with "::", don't throw exception and don't process more (only expand environment variables).</summary>
        </member>
        <member name="T:Au.Types.SRFlags">
            <summary>
            flags for <see cref="M:Au.Shell.Run(System.String,System.String,Au.Types.SRFlags,Au.Types.SRMore)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.SRFlags.ShowErrorUI">
            <summary>
            Show error message box if fails, for example if file not found.
            Note: this does not disable exceptions. Still need exception handling. Or call <see cref="M:Au.Shell.TryRun(System.String,System.String,Au.Types.SRFlags,Au.Types.SRMore)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.SRFlags.WaitForExit">
            <summary>
            If started new process, wait until it exits.
            Uses <see cref="M:System.Threading.WaitHandle.WaitOne"/>.
            </summary>
        </member>
        <member name="F:Au.Types.SRFlags.NeedProcessHandle">
            <summary>
            Get process handle (<see cref="P:Au.Types.SRResult.ProcessHandle"/>), if possible.
            </summary>
        </member>
        <member name="T:Au.Types.SRMore">
            <summary>
            More parameters for <see cref="M:Au.Shell.Run(System.String,System.String,Au.Types.SRFlags,Au.Types.SRMore)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.SRMore.WorkingDirectory">
            <summary>
            Initial working directory for the new process.
            Some programs look for their files in the working directory and fail to start if it is not the program's directory.
            If null (default), the function gets parent directory path from the <i>file</i> parameter, if possible (if full path is specified or found).
            If this is "" or invalid or the function cannot find full path, the new process will inherit the curent working directory of this process.
            </summary>
        </member>
        <member name="F:Au.Types.SRMore.Verb">
            <summary>
            File's right-click menu command, also known as verb. For example "edit", "print", "properties". The default verb is bold in the menu.
            Not all menu items will work. Some may have different name than in the menu. Use verb "RunAs" for "Run as administrator".
            </summary>
        </member>
        <member name="F:Au.Types.SRMore.OwnerWindow">
            <summary>
            Owner window for error message boxes.
            Also, new window should be opened on the same screen. However many programs ignore it.
            </summary>
        </member>
        <member name="F:Au.Types.SRMore.WindowState">
            <summary>
            Preferred window state.
            Many programs ignore it.
            </summary>
        </member>
        <member name="T:Au.Types.SRResult">
            <summary>
            Results of <see cref="M:Au.Shell.Run(System.String,System.String,Au.Types.SRFlags,Au.Types.SRMore)"/>.
            </summary>
        </member>
        <member name="P:Au.Types.SRResult.ProcessExitCode">
            <summary>
            The exit code of the process.
            0 if no flag <b>WaitForExit</b> or if cannot wait.
            </summary>
            <remarks>
            Usually the exit code is 0 or a process-defined error code.
            </remarks>
        </member>
        <member name="P:Au.Types.SRResult.ProcessId">
            <summary>
            The process id.
            0 if used flag <b>WaitForExit</b> or if did not start new process (eg opened the document in an existing process) or if cannot get it.
            </summary>
        </member>
        <member name="P:Au.Types.SRResult.ProcessHandle">
            <summary>
            If used flag <b>NeedProcessHandle</b>, contains process handle. Later the <see cref="T:System.Threading.WaitHandle"/> variable must be disposed.
            null if no flag or if did not start new process (eg opened the document in an existing process) or if cannot get it.
            </summary>
            <example>
            This code does the same as <c>Shell.Run(@"notepad.exe", flags: SRFlags.WaitForExit);</c>
            <code><![CDATA[
            var r = Shell.Run(@"notepad.exe", flags: SRFlags.NeedProcessHandle);
            using(var h = r.ProcessHandle) h?.WaitOne();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Types.SRResult.ToString">
            <summary>
            Returns <see cref="P:Au.Types.SRResult.ProcessId"/> as string.
            </summary>
        </member>
        <member name="T:Au.Types.SetAddRemove">
            <summary>
            Specifies whether to set, add or remove flags.
            </summary>
        </member>
        <member name="F:Au.Types.SetAddRemove.Set">
            <summary>Set flags = the specified value.</summary>
        </member>
        <member name="F:Au.Types.SetAddRemove.Add">
            <summary>Add the specified flags, don't change others.</summary>
        </member>
        <member name="F:Au.Types.SetAddRemove.Remove">
            <summary>Remove the specified flags, don't change others.</summary>
        </member>
        <member name="F:Au.Types.SetAddRemove.Xor">
            <summary>Toggle the specified flags, don't change others.</summary>
        </member>
        <member name="T:Au.Types.AuException">
            <summary>
            The base exception used in this library.
            Some constructors support Windows API error code. Then Message will contain its error description.
            If the string passed to the constructor starts with "*", replaces the "*" with "Failed to ". If does not end with ".", appends ".".
            </summary>
        </member>
        <member name="M:Au.Types.AuException.#ctor">
            <summary>
            Sets Message = "Failed.".
            Sets NativeErrorCode = 0.
            </summary>
        </member>
        <member name="M:Au.Types.AuException.#ctor(System.String)">
            <summary>
            Sets Message = message.
            Sets NativeErrorCode = 0.
            </summary>
        </member>
        <member name="M:Au.Types.AuException.#ctor(System.Int32)">
            <summary>
            Sets Message = "Failed. " + Native.GetErrorMessage(winApiErrorCode).
            Sets NativeErrorCode = (winApiErrorCode != 0) ? winApiErrorCode : Native.GetError().
            </summary>
        </member>
        <member name="M:Au.Types.AuException.#ctor(System.Int32,System.String)">
            <summary>
            Sets Message = message + " " + Native.GetErrorMessage(winApiErrorCode).
            Sets NativeErrorCode = (winApiErrorCode != 0) ? winApiErrorCode : Native.GetError().
            </summary>
        </member>
        <member name="M:Au.Types.AuException.#ctor(System.String,System.Exception)">
            <summary>
            Sets Message = message + "\r\n\t" + innerException.Message.
            Sets NativeErrorCode = 0.
            </summary>
        </member>
        <member name="M:Au.Types.AuException.#ctor(System.Int32,System.String,System.Exception)">
            <summary>
            Sets Message = message + " " + Native.GetErrorMessage(winApiErrorCode) + "\r\n\t" + innerException.Message.
            Sets NativeErrorCode = (winApiErrorCode != 0) ? winApiErrorCode : Native.GetError().
            </summary>
        </member>
        <member name="P:Au.Types.AuException.NativeErrorCode">
            <summary> Gets the Windows API error code. </summary>
        </member>
        <member name="P:Au.Types.AuException.Message">
            <summary> Gets error message. </summary>
        </member>
        <member name="F:Au.Types.AuException.FormattedMessage">
            <summary> String created by FormatMessage(), which should be called by the Message override if null. Initially null. </summary>
        </member>
        <member name="M:Au.Types.AuException.FormatMessage(System.String,System.String)">
            <summary>
            Formats error message. Sets and returns FormattedMessage.
            As base text, uses the text passed to the constructor (default "Failed.").
            If it starts with "*", replaces the "*" with "Failed to ".
            If it ends with "*", replaces the "*" with commonPostfix if it is not empty.
            If then the message does not end with ".", appends ".".
            If appendMessage is null, uses Native.GetErrorMessage(NativeErrorCode) if NativeErrorCode not 0.
            If then appendMessage is not empty, appends " " and appendMessage.
            Also appends InnerException.Message in new tab-indented line if InnerException is not null.
            </summary>
        </member>
        <member name="M:Au.Types.AuException.ThrowIfHresultNot0(System.Int32,System.String)">
            <summary>
            If errorCode is not 0, throws AuException that includes the code and its message.
            More info: <see cref="M:Au.Types.AuException.FormatMessage(System.String,System.String)"/>.
            </summary>
            <param name="errorCode">Windows API error code or HRESULT.</param>
            <param name="message">Main message. The message of the error code will be appended to it.</param>
        </member>
        <member name="M:Au.Types.AuException.ThrowIfHresultNegative(System.Int32,System.String)">
            <summary>
            If errorCode is less than 0, throws AuException that includes the code and its message.
            More info: <see cref="M:Au.Types.AuException.FormatMessage(System.String,System.String)"/>.
            </summary>
            <param name="errorCode">Windows API error code or HRESULT.</param>
            <param name="message">Main message. The message of the error code will be appended to it.</param>
        </member>
        <member name="T:Au.Types.WndException">
            <summary>
            Exception thrown mostly by <see cref="T:Au.Wnd"/> functions.
            </summary>
            <remarks>
            Some constructors support Windows API error code. Then Message also will contain its error description.
            If error code ERROR_INVALID_WINDOW_HANDLE, Message also depends on whether the window handle is 0.
            If parameter 'winApiErrorCode' is 0 or not used: if the window handle is invalid, uses ERROR_INVALID_WINDOW_HANDLE.
            If the string passed to the constructor starts with "*", replaces the "*" with "Failed to ". If ends with "*", replaces the "*" with " window.". If does not end with ".", appends ".".
            </remarks>
        </member>
        <member name="M:Au.Types.WndException.#ctor(Au.Wnd)">
            <summary>
            Sets NativeErrorCode = w.IsAlive ? 0 : ERROR_INVALID_WINDOW_HANDLE.
            Sets Message = "Failed.".
            </summary>
        </member>
        <member name="M:Au.Types.WndException.#ctor(Au.Wnd,System.String)">
            <summary>
            Sets NativeErrorCode = w.IsAlive ? 0 : ERROR_INVALID_WINDOW_HANDLE.
            </summary>
        </member>
        <member name="M:Au.Types.WndException.#ctor(Au.Wnd,System.Int32)">
            <summary>
            Sets NativeErrorCode = (winApiErrorCode != 0) ? winApiErrorCode : (w.IsAlive ? Native.GetError() : ERROR_INVALID_WINDOW_HANDLE).
            Sets Message = "Failed.".
            </summary>
        </member>
        <member name="M:Au.Types.WndException.#ctor(Au.Wnd,System.Int32,System.String)">
            <summary>
            Sets NativeErrorCode = (winApiErrorCode != 0) ? winApiErrorCode : (w.IsAlive ? Native.GetError() : ERROR_INVALID_WINDOW_HANDLE).
            </summary>
        </member>
        <member name="M:Au.Types.WndException.#ctor(Au.Wnd,System.String,System.Exception)">
            <summary>
            Sets NativeErrorCode = w.IsAlive ? 0 : ERROR_INVALID_WINDOW_HANDLE.
            </summary>
        </member>
        <member name="M:Au.Types.WndException.#ctor(Au.Wnd,System.Int32,System.String,System.Exception)">
            <summary>
            Sets NativeErrorCode = (winApiErrorCode != 0) ? winApiErrorCode : (w.IsAlive ? Native.GetError() : ERROR_INVALID_WINDOW_HANDLE).
            </summary>
        </member>
        <member name="P:Au.Types.WndException.Window">
            <summary> Gets the window passed to the constructor. </summary>
        </member>
        <member name="P:Au.Types.WndException.Message">
            <summary> Gets error message. </summary>
        </member>
        <member name="T:Au.Types.NotFoundException">
            <summary>
            Functions that search for an object can throw this exception when not found.
            </summary>
        </member>
        <member name="M:Au.Types.NotFoundException.#ctor">
            <summary>
            Sets Message = "Not found.".
            </summary>
        </member>
        <member name="M:Au.Types.NotFoundException.#ctor(System.String)">
            <summary>
            Sets Message = message.
            </summary>
        </member>
        <member name="T:Au.Types.LPARAM">
            <summary>
            Similar to IntPtr (can be 32-bit or 64-bit), but more useful for usually-non-pointer values, eg wParam/lParam of SendMessage.
            Unlike IntPtr:
            	Has implicit casts from most integral types. And explicit casts to.
            	Does not check overflow when casting from uint etc. IntPtr throws exception on overflow, which can create bugs.
            </summary>
            <remarks>
            There is no struct WPARAM. Use LPARAM instead, because it is the same in all cases except when casting to long or ulong (ambigous signed/unsigned).
            There is no cast operators for enum. When need, cast through int or uint. For Wnd cast through IntPtr.
            </remarks>
        </member>
        <member name="T:Au.Types.POINT">
            <summary>
            Point coordinates x y.
            </summary>
        </member>
        <member name="M:Au.Types.POINT.op_Implicit(System.ValueTuple{Au.Types.Coord,Au.Types.Coord,System.Boolean})~Au.Types.POINT">
            <summary>Specifies position relative to the primary screen or its work area. Calls <see cref="M:Au.Types.Coord.Normalize(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.Types.Screen_,System.Boolean,System.Boolean)"/>.</summary>
        </member>
        <member name="M:Au.Types.POINT.op_Implicit(System.ValueTuple{Au.Types.Coord,Au.Types.Coord,Au.Types.Screen_,System.Boolean})~Au.Types.POINT">
            <summary>Specifies position relative to the specified screen or its work area. Calls <see cref="M:Au.Types.Coord.Normalize(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.Types.Screen_,System.Boolean,System.Boolean)"/>.</summary>
        </member>
        <member name="M:Au.Types.POINT.op_Implicit(System.ValueTuple{Au.Types.RECT,Au.Types.Coord,Au.Types.Coord})~Au.Types.POINT">
            <summary>Specifies position in the specified rectangle which is relative to the primary screen. Calls <see cref="M:Au.Types.Coord.NormalizeInRect(Au.Types.Coord,Au.Types.Coord,Au.Types.RECT,System.Boolean,System.Boolean)"/>.</summary>
        </member>
        <member name="M:Au.Types.POINT.Offset(System.Int32,System.Int32)">
            <summary>Adds x and y to this.x and this.y.</summary>
        </member>
        <member name="M:Au.Types.POINT.op_Addition(Au.Types.POINT,System.ValueTuple{System.Int32,System.Int32})">
            <summary>Returns <c>new POINT(p.x + d.x, p.y + d.y)</c>.</summary>
        </member>
        <member name="T:Au.Types.SIZE">
            <summary>
            Width and height.
            </summary>
        </member>
        <member name="M:Au.Types.SIZE.op_Addition(Au.Types.SIZE,System.ValueTuple{System.Int32,System.Int32})">
            <summary>Returns <c>new SIZE(z.width + d.x, z.height + d.y)</c>.</summary>
        </member>
        <member name="T:Au.Types.RECT">
            <summary>
            Rectangle coordinates left top right bottom.
            </summary>
            <remarks>
            This type can be used with Windows API functions. The .NET <b>Rectangle</b>/<b>Rect</b>/<b>Int32Rect</b> can't, because their fields are different.
            Has implicit conversions from/to <b>Rectangle</b> and <b>RectangleF</b>.
            </remarks>
        </member>
        <member name="M:Au.Types.RECT.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Initializes this instance.
            </summary>
            <param name="left"></param>
            <param name="top"></param>
            <param name="rightOrWidth">right or width, depending on <paramref name="useWidthHeight"/>.</param>
            <param name="bottomOrHeight">bottom or height, depending on <paramref name="useWidthHeight"/>.</param>
            <param name="useWidthHeight">If true (default), rightOrWidth/bottomOrHeight are width/height. Else right/bottom.</param>
        </member>
        <member name="M:Au.Types.RECT.Set(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sets fields like the constructor <see cref="M:Au.Types.RECT.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)"/>.
            </summary>
        </member>
        <member name="P:Au.Types.RECT.Is0">
            <summary>
            Returns true if all fields == 0.
            </summary>
        </member>
        <member name="P:Au.Types.RECT.IsEmpty">
            <summary>
            Returns true if the rectangle is empty or invalid: <c>right&lt;=left || bottom&lt;=top;</c>
            </summary>
        </member>
        <member name="P:Au.Types.RECT.Width">
            <summary>
            Gets or sets width.
            </summary>
        </member>
        <member name="P:Au.Types.RECT.Height">
            <summary>
            Gets or sets height.
            </summary>
        </member>
        <member name="P:Au.Types.RECT.CenterX">
            <summary>
            Gets horizontal center.
            </summary>
        </member>
        <member name="P:Au.Types.RECT.CenterY">
            <summary>
            Gets vertical center.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Contains(System.Int32,System.Int32)">
            <summary>
            Returns true if this rectangle contains the specified point.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Contains(Au.Types.POINT)">
            <summary>
            Returns true if this rectangle contains the specified point.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Contains(Au.Types.RECT)">
            <summary>
            Returns true if this rectangle contains entire specified rectangle.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Inflate(System.Int32,System.Int32)">
            <summary>
            Makes this rectangle bigger or smaller: <c>left-=dx; right+=dx; top-=dy; bottom+=dy;</c>
            Use negative dx/dy to make the rectangle smaller. Note: too big negative dx/dy can make it invalid (right&lt;left or bottom&lt;top).
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Intersect(Au.Types.RECT)">
            <summary>
            Replaces this rectangle with the intersection of itself and the specified rectangle.
            Returns true if the rectangles intersect.
            If they don't intersect, makes this RECT empty (IsEmpty would return true).
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Intersect(Au.Types.RECT,Au.Types.RECT)">
            <summary>
            Returns the intersection rectangle of two rectangles.
            If they don't intersect, returns empty rectangle (IsEmpty would return true).
            </summary>
        </member>
        <member name="M:Au.Types.RECT.IntersectsWith(Au.Types.RECT)">
            <summary>
            Returns true if this rectangle and another rectangle intersect.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Offset(System.Int32,System.Int32)">
            <summary>
            Moves this rectangle by the specified offsets: <c>left+=dx; right+=dx; top+=dy; bottom+=dy;</c>
            Negative dx moves to the left. Negative dy moves up.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Union(Au.Types.RECT)">
            <summary>
            Replaces this rectangle with the union of itself and the specified rectangle.
            Union is the smallest rectangle that contains two full rectangles.
            Returns true if finally this rectangle is not empty.
            If either rectangle is empty (Width or Height is &lt;=0), the result is another rectangle. If both empty - empty rectangle.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Union(Au.Types.RECT,Au.Types.RECT)">
            <summary>
            Returns the union of two rectangles.
            Union is the smallest rectangle that contains two full rectangles.
            If either rectangle is empty (Width or Height is &lt;=0), the result is another rectangle. If both empty - empty rectangle.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Normalize(System.Boolean)">
            <summary>
            If width or height are negative, modifies this rectangle so that they would not be negative.
            </summary>
            <param name="swap">true - swap right/left, bottom/top; false - set right = left, bottom = top.</param>
        </member>
        <member name="M:Au.Types.RECT.MoveInScreen(Au.Types.Coord,Au.Types.Coord,Au.Types.Screen_,System.Boolean,System.Boolean)">
            <summary>
            Moves this rectangle to the specified coordinates in the specified screen, and ensures that whole rectangle is in screen.
            Final rectangle coordinates are relative to the primary screen.
            </summary>
            <param name="x">X coordinate in the specified screen. If default(Coord) - screen center. Can be Coord.Reverse etc.</param>
            <param name="y">Y coordinate in the specified screen. If default(Coord) - screen center. Can be Coord.Reverse etc.</param>
            <param name="screen">Use this screen (see <see cref="T:Au.Types.Screen_"/>). If null (default), uses the primary screen.</param>
            <param name="workArea">Use the work area, not whole screen. Default true.</param>
            <param name="ensureInScreen">If part of rectangle is not in screen, move and/or resize it so that entire rectangle would be in screen. Default true.</param>
            <remarks>
            This function can be used to calculate new window location before creating it. If window already exists, use <see cref="M:Au.Wnd.MoveInScreen(Au.Types.Coord,Au.Types.Coord,Au.Types.Screen_,System.Boolean,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:Au.Types.RECT.MoveInRect(Au.Types.RECT,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Moves this rectangle to the specified coordinates in another rectangle <paramref name="r"/>.
            </summary>
            <param name="x">X coordinate relative to <paramref name="r"/>. Default - center. Can be Coord.Reverse etc.</param>
            <param name="y">Y coordinate relative to <paramref name="r"/>. Default - center. Can be Coord.Reverse etc.</param>
            <param name="r">Another rectangle.</param>
            <param name="ensureInRect">If part of rectangle is not in <paramref name="r"/>, move and/or resize it so that entire rectangle would be in <paramref name="r"/>. Default true.</param>
        </member>
        <member name="M:Au.Types.RECT.EnsureInScreen(Au.Types.Screen_,System.Boolean)">
            <summary>
            Adjusts this rectangle to ensure that whole rectangle is in screen.
            Initial and final rectangle coordinates are relative to the primary screen.
            </summary>
            <param name="screen">Use this screen (see <see cref="T:Au.Types.Screen_"/>). If null (default), uses screen of the rectangle (or nearest).</param>
            <param name="workArea">Use the work area, not whole screen. Default true.</param>
            <remarks>
            This function can be used to calculate new window location before creating it. If window already exists, use <see cref="M:Au.Wnd.EnsureInScreen(Au.Types.Screen_,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="T:Au.Types.ColorInt">
            <summary>
            Color, as int in 0xAARRGGBB format.
            Can convert from/to <see cref="T:System.Drawing.Color"/>, <see cref="T:System.Windows.Media.Color"/>, int (0xAARRGGBB), Windows native COLORREF (0xBBGGRR), string.
            </summary>
        </member>
        <member name="F:Au.Types.ColorInt.color">
            <summary>
            Color value in 0xAARRGGBB format.
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.#ctor(System.Int32,System.Boolean)">
            <summary>
            Creates ColorInt from color value in 0xAARRGGBB format.
            </summary>
            <param name="colorARGB"></param>
            <param name="makeOpaque">Set alpha = 0xFF.</param>
        </member>
        <member name="M:Au.Types.ColorInt.op_Implicit(System.Int32)~Au.Types.ColorInt">
            <summary>
            Creates ColorInt from int color value in 0xRRGGBB format.
            Makes opaque (alpha 0xFF).
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.op_Implicit(System.UInt32)~Au.Types.ColorInt">
            <summary>
            Creates ColorInt from uint color value in 0xRRGGBB format.
            Makes opaque (alpha 0xFF).
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.op_Implicit(System.Drawing.Color)~Au.Types.ColorInt">
            <summary>
            Creates ColorInt from <see cref="T:System.Drawing.Color"/>.
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.op_Implicit(System.Windows.Media.Color)~Au.Types.ColorInt">
            <summary>
            Creates ColorInt from <see cref="T:System.Windows.Media.Color"/>.
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.FromString(System.String,Au.Types.ColorInt@)">
            <summary>
            Creates ColorInt from color name (<see cref="M:System.Drawing.Color.FromName(System.String)"/>) or string "0xRRGGBB" or "#RRGGBB".
            </summary>
            <remarks>
            If s is a hex number that contains 6 or less hex digits, makes opaque (alpha 0xFF).
            If s is null or invalid, sets c.color = 0 and returns false.
            </remarks>
        </member>
        <member name="M:Au.Types.ColorInt.FromBGR(System.Int32,System.Boolean)">
            <summary>
            Creates ColorInt (0xRRGGBB) from Windows native COLORREF (0xBBGGRR).
            </summary>
            <param name="colorBGR">Color in 0xBBGGRR format.</param>
            <param name="makeOpaque">Set alpha = 0xFF.</param>
        </member>
        <member name="M:Au.Types.ColorInt.ToBGR(System.Boolean)">
            <summary>
            Creates Windows native COLORREF (0xBBGGRR) from ColorInt (0xRRGGBB).
            Returns color in COLORREF format. Does not modify this variable.
            </summary>
            <param name="zeroAlpha">Set the alpha byte = 0.</param>
        </member>
        <member name="M:Au.Types.ColorInt.op_Explicit(Au.Types.ColorInt)~System.Int32">
            <summary>Creates int from ColorInt.</summary>
        </member>
        <member name="M:Au.Types.ColorInt.op_Explicit(Au.Types.ColorInt)~System.UInt32">
            <summary>Creates int from ColorInt.</summary>
        </member>
        <member name="M:Au.Types.ColorInt.op_Explicit(Au.Types.ColorInt)~System.Drawing.Color">
            <summary>Creates <see cref="T:System.Drawing.Color"/> from ColorInt.</summary>
        </member>
        <member name="M:Au.Types.ColorInt.op_Explicit(Au.Types.ColorInt)~System.Windows.Media.Color">
            <summary>Creates <see cref="T:System.Windows.Media.Color"/> from ColorInt.</summary>
        </member>
        <member name="M:Au.Types.ColorInt.SwapRB(System.Int32)">
            <summary>
            Converts color from ARGB (0xAARRGGBB) to ABGR (0xAABBGGRR) or vice versa (swaps the red and blue bytes).
            ARGB is used in .NET, GDI+ and HTML/CSS.
            ABGR is used by most Windows native API.
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.Brightness0to255">
            <summary>
            Calculates color's perceived brightness.
            Returns a value in range 0 (brightness of black color) to 1 (brightness of white color).
            </summary>
            <remarks>
            Unlike Color.GetBrightness, this function gives different weights for red, green and blue components.
            Does not use alpha.
            </remarks>
        </member>
        <member name="M:Au.Types.ColorInt.AdjustLuminance(System.Int32,System.Boolean)">
            <summary>
            Changes color's luminance (makes darker or brighter).
            Returns new color. Does not modify this variable.
            </summary>
            <param name="n">The luminance in units of 0.1 percent of the range (which depends on totalRange). Can be from -1000 to 1000.</param>
            <param name="totalRange">If true, n is in the whole luminance range (from minimal to maximal possible). If false, n is in the range from current luminance of the color to the maximal (if n positive) or minimal (if n negative) luminance.</param>
            <remarks>
            Calls API <msdn>ColorAdjustLuma</msdn>.
            Does not change hue and saturation. Does not use alpha.
            </remarks>
        </member>
        <member name="M:Au.Types.VARIANT.Dispose">
            <summary>
            Calls VariantClear.
            </summary>
        </member>
        <member name="M:Au.Types.VARIANT.ToString">
            <summary>
            Converts to string.
            Does not cache.
            </summary>
        </member>
        <member name="M:Au.Types.VARIANT.ToStringAndDispose(System.Boolean)">
            <summary>
            Converts to string.
            By default adds to our string cache.
            Disposes this VARIANT.
            </summary>
        </member>
        <member name="P:Au.Types.BSTR.Is0">
            <summary>
            Returns true if the string is null.
            </summary>
        </member>
        <member name="P:Au.Types.BSTR.Item(System.Int32)">
            <summary>
            Unsafe.
            </summary>
        </member>
        <member name="M:Au.Types.BSTR.ToString">
            <summary>
            Converts to string.
            Does not dispose. Doen not cache.
            </summary>
        </member>
        <member name="M:Au.Types.BSTR.ToStringAndDispose(System.Boolean)">
            <summary>
            Converts to string and frees the BSTR (calls Dispose()).
            By default adds to our string cache.
            </summary>
        </member>
        <member name="T:Au.Types.BaseMT">
            <summary>
            Base class of <see cref="T:Au.AuMenu"/> and <see cref="T:Au.AuToolbar"/>.
            </summary>
        </member>
        <member name="P:Au.Types.BaseMT.ItemThread">
            <summary>
            In what thread to execute item callback functions.
            Default: current thread.
            </summary>
            <remarks>
            If current thread is a UI thread (has windows etc), and item callback functions execute some long automations in the same thread, current thread probably is hung during that time. Use this property to avoid it.
            This property is applied to items added afterwards.
            </remarks>
        </member>
        <member name="P:Au.Types.BaseMT.ExceptionHandling">
            <summary>
            Whether/how to handle unhandled exceptions in item code.
            Default: <see cref="F:Au.Types.MTExcept.Exception"/> (don't handle exceptions if <see cref="P:Au.Types.BaseMT.ItemThread"/> is <see cref="F:Au.Types.MTThread.Current"/> (default), else show warning).
            </summary>
            <remarks>
            This property is applied to items added afterwards.
            </remarks>
        </member>
        <member name="P:Au.Types.BaseMT.MainToolStrip">
            <summary>
            Gets ToolStrip of AuMenu and AuToolbar, which override this.
            </summary>
        </member>
        <member name="P:Au.Types.BaseMT.LastItem">
            <summary>
            Gets the last added item as <see cref="T:System.Windows.Forms.ToolStripItem"/>, which is the base type of <see cref="T:System.Windows.Forms.ToolStripMenuItem"/>, <see cref="T:System.Windows.Forms.ToolStripButton"/> and other supported types.
            </summary>
        </member>
        <member name="E:Au.Types.BaseMT.ItemAdded">
            <summary>
            Occurs when an item is added.
            Allows to set item properties in single place instead of after each 'add item' code line.
            For example, the event handler can set item properties common to all items, or set item properties encoded in item text.
            </summary>
        </member>
        <member name="P:Au.Types.BaseMT.IconFlags">
            <summary>
            Flags to pass to <see cref="M:Au.Icons.GetFileIcon(System.String,System.Int32,Au.Types.GIFlags)"/>. See <see cref="T:Au.Types.GIFlags"/>.
            </summary>
            <remarks>
            This property is applied to all items.
            </remarks>
        </member>
        <member name="P:Au.Types.BaseMT.IconSize">
            <summary>
            Image width and height.
            Also can be enum <see cref="P:Au.Types.BaseMT.IconSize"/>, cast to int.
            </summary>
            <exception cref="T:System.InvalidOperationException">The 'set' function is called after adding items.</exception>
            <remarks>
            This property is applied to all items, and can be set only before adding items (else exception).
            To set different icon size for a submenu: <c>using(m.Submenu("sub")) { m.LastMenuItem.DropDown.ImageScalingSize = new Size(24, 24);</c>
            </remarks>
        </member>
        <member name="P:Au.Types.BaseMT.ExtractIconPathFromCode">
            <summary>
            When adding items without explicitly specified icon, extract icon from item code.
            </summary>
            <remarks>
            This property is applied to items added afterwards.
            </remarks>
        </member>
        <member name="M:Au.Types.BaseMT._IconPathFromCode(System.Reflection.MethodInfo)">
            <summary>
            Gets icon path from code that contains string like @"c:\windows\system32\notepad.exe" or @"%Folders.System%\notepad.exe" or URL/shell.
            Also supports code patterns like 'Folders.System + "notepad.exe"' or 'Folders.Virtual.RecycleBin'.
            Returns null if no such string/pattern.
            </summary>
        </member>
        <member name="M:Au.Types.BaseMT.Finalize">
            
        </member>
        <member name="T:Au.Types.MTClickArgs">
            <summary>
            Data passed to Click event handler functions of AuMenu and AuToolbar.
            </summary>
        </member>
        <member name="P:Au.Types.MTClickArgs.Item">
            <summary>
            Gets the clicked item as ToolStripItem.
            </summary>
        </member>
        <member name="P:Au.Types.MTClickArgs.MenuItem">
            <summary>
            Gets the clicked item as ToolStripMenuItem.
            Returns null if it is not ToolStripMenuItem.
            </summary>
        </member>
        <member name="M:Au.Types.MTClickArgs.ToString">
            <summary>
            Gets item text.
            </summary>
        </member>
        <member name="T:Au.Types.MTThread">
            <summary>
            Used with <see cref="P:Au.Types.BaseMT.ItemThread"/>.
            </summary>
        </member>
        <member name="F:Au.Types.MTThread.Current">
            <summary>
            Execute item callback functions in current thread. This is default.
            </summary>
        </member>
        <member name="F:Au.Types.MTThread.ThreadPool">
            <summary>
            Execute item callback functions in thread pool threads (<see cref="M:System.Threading.Tasks.Task.Run(System.Action)"/>).
            Note: current thread does not wait until the callback function finishes.
            </summary>
        </member>
        <member name="F:Au.Types.MTThread.StaThread">
            <summary>
            Execute item callback functions in new STA threads (<see cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)"/>).
            Note: current thread does not wait until the callback function finishes.
            </summary>
        </member>
        <member name="F:Au.Types.MTThread.StaBackgroundThread">
            <summary>
            Execute item callback functions in new STA background threads (<see cref="P:System.Threading.Thread.IsBackground"/>).
            Note: current thread does not wait until the callback function finishes.
            </summary>
        </member>
        <member name="T:Au.Types.MTExcept">
            <summary>
            Used with <see cref="P:Au.Types.BaseMT.ExceptionHandling"/>.
            </summary>
        </member>
        <member name="F:Au.Types.MTExcept.Exception">
            <summary>
            Don't handle exceptions. This is default.
            However if <see cref="P:Au.Types.BaseMT.ItemThread"/> is not <see cref="F:Au.Types.MTThread.Current"/>, handles exceptions and shows warning.
            </summary>
        </member>
        <member name="F:Au.Types.MTExcept.Warning">
            <summary>Handle exceptions. On exception call <see cref="M:Au.NoClass.PrintWarning(System.String,System.Int32,System.String)"/>.</summary>
        </member>
        <member name="F:Au.Types.MTExcept.Silent">
            <summary>Handle exceptions. On exception do nothing.</summary>
        </member>
        <member name="T:Au.Types.MButton">
            <summary>
            <i>button</i> parameter type for <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,System.Boolean)"/> and similar functions.
            </summary>
            <remarks>
            There are two groups of values:
            1. Button (Left, Right, Middle, X1, X2). Default or 0: Left.
            2. Action (Down, Up, DoubleClick). Default: click.
            Multiple values from the same group cannot be combined. For example Left|Right is invalid.
            Values from different groups can be combined. For example Right|Down.
            </remarks>
        </member>
        <member name="F:Au.Types.MButton.Left">
            <summary>The left button.</summary>
        </member>
        <member name="F:Au.Types.MButton.Right">
            <summary>The right button.</summary>
        </member>
        <member name="F:Au.Types.MButton.Middle">
            <summary>The middle button.</summary>
        </member>
        <member name="F:Au.Types.MButton.X1">
            <summary>The 4-th button.</summary>
        </member>
        <member name="F:Au.Types.MButton.X2">
            <summary>The 5-th button.</summary>
        </member>
        <member name="F:Au.Types.MButton.Down">
            <summary>(flag) Press and don't release.</summary>
        </member>
        <member name="F:Au.Types.MButton.Up">
            <summary>(flag) Don't press, only release.</summary>
        </member>
        <member name="F:Au.Types.MButton.DoubleClick">
            <summary>(flag) Double-click.</summary>
        </member>
        <member name="T:Au.Types.MButtons">
            <summary>
            Flags for mouse buttons.
            Used with functions that check mouse button states (pressed or released).
            </summary>
            <remarks>
            The values are the same as <see cref="T:System.Windows.Forms.MouseButtons"/>, therefore can be cast to/from.
            </remarks>
        </member>
        <member name="F:Au.Types.MButtons.Left">
            <summary>The left button.</summary>
        </member>
        <member name="F:Au.Types.MButtons.Right">
            <summary>The right button.</summary>
        </member>
        <member name="F:Au.Types.MButtons.Middle">
            <summary>The middle button.</summary>
        </member>
        <member name="F:Au.Types.MButtons.X1">
            <summary>The 4-th button.</summary>
        </member>
        <member name="F:Au.Types.MButtons.X2">
            <summary>The 5-th button.</summary>
        </member>
        <member name="T:Au.Types.MRelease">
            <summary>
            The Dispose function releases mouse buttons pressed by the function that returned this variable.
            </summary>
            <tocexclude />
        </member>
        <member name="M:Au.Types.MRelease.op_Implicit(Au.Types.MButton)~Au.Types.MRelease">
            
        </member>
        <member name="M:Au.Types.MRelease.Dispose">
            <summary>
            Releases mouse buttons pressed by the function that returned this variable.
            </summary>
        </member>
        <member name="T:Au.Types.MCursor">
            <summary>
            Standard cursor ids.
            Used with <see cref="M:Au.Mouse.WaitForCursor(System.Double,Au.Types.MCursor,System.Boolean)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.MCursor.Arrow">
            <summary>Standard arrow.</summary>
        </member>
        <member name="F:Au.Types.MCursor.IBeam">
            <summary>I-beam (text editing).</summary>
        </member>
        <member name="F:Au.Types.MCursor.Wait">
            <summary>Hourglass.</summary>
        </member>
        <member name="F:Au.Types.MCursor.Cross">
            <summary>Crosshair.</summary>
        </member>
        <member name="F:Au.Types.MCursor.UpArrow">
            <summary>Vertical arrow.</summary>
        </member>
        <member name="F:Au.Types.MCursor.SizeNWSE">
            <summary>Double-pointed arrow pointing northwest and southeast.</summary>
        </member>
        <member name="F:Au.Types.MCursor.SizeNESW">
            <summary>Double-pointed arrow pointing northeast and southwest.</summary>
        </member>
        <member name="F:Au.Types.MCursor.SizeWE">
            <summary>Double-pointed arrow pointing west and east.</summary>
        </member>
        <member name="F:Au.Types.MCursor.SizeNS">
            <summary>Double-pointed arrow pointing north and south.</summary>
        </member>
        <member name="F:Au.Types.MCursor.SizeAll">
            <summary>Four-pointed arrow pointing north, south, east, and west.</summary>
        </member>
        <member name="F:Au.Types.MCursor.No">
            <summary>Slashed circle.</summary>
        </member>
        <member name="F:Au.Types.MCursor.Hand">
            <summary>Hand.</summary>
        </member>
        <member name="F:Au.Types.MCursor.AppStarting">
            <summary>Standard arrow and small hourglass.</summary>
        </member>
        <member name="F:Au.Types.MCursor.Help">
            <summary>Arrow and question mark.</summary>
        </member>
        <member name="T:Au.Types.ProcessInfo">
            <summary>
            Contains process id, name and session id.
            </summary>
            <tocexclude />
        </member>
        <member name="F:Au.Types.ProcessInfo.SessionId">
            <summary>User session id.</summary>
        </member>
        <member name="F:Au.Types.ProcessInfo.ProcessId">
            <summary>Process id.</summary>
        </member>
        <member name="F:Au.Types.ProcessInfo.Name">
            <summary>Executable file name, like "notepad.exe".</summary>
        </member>
        <member name="M:Au.Types.ProcessInfo.#ctor(System.Int32,System.Int32,System.String)">
            
        </member>
        <member name="M:Au.Types.ProcessInfo.ToString">
            
        </member>
        <member name="T:Au.Types.Wildex">
            <summary>
            This class implements <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">wildcard expression</conceptualLink> parsing and matching (comparing).
            Typically used in 'find' functions. For example, <see cref="M:Au.Wnd.Find(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/> uses it to compare window name, class name and program.
            The 'find' function creates a Wildex instance (which parses the wildcard expression), then calls <see cref="M:Au.Types.Wildex.Match(System.String)"/> for each item (eg window) to compare some its property text.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid "**options " or regular expression.</exception>
            <example>
            <code><![CDATA[
            //This version does not support wildcard expressions.
            Document Find1(string name, string date)
            {
            	return Documents.Find(x => x.Name.Equals_(name) && x.Date.Equals_(date));
            }
            
            //This version supports wildcard expressions.
            //null-string arguments are not compared.
            Document Find2(string name, string date)
            {
            	Wildex n = name, d = date; //null if the string is null
            	return Documents.Find(x => (n == null || n.Match(x.Name)) && (d == null || d.Match(x.Date)));
            }
            
            //Example of calling such function.
            //Find item whose name is "example" (case-insensitive) and date starts with "2017-".
            var item = x.Find2("example", "2017-*");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Types.Wildex.#ctor(System.String)">
            <param name="wildcardExpression">
            <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">Wildcard expression</conceptualLink>.
            Cannot be null (throws exception).
            "" will match "".
            </param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException">Invalid "**options " or regular expression.</exception>
        </member>
        <member name="M:Au.Types.Wildex.op_Implicit(System.String)~Au.Types.Wildex">
            <summary>
            Creates new Wildex from wildcard expression string.
            If the string is null, returns null.
            </summary>
            <param name="wildcardExpression">
            <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">Wildcard expression</conceptualLink>.
            </param>
        </member>
        <member name="M:Au.Types.Wildex.Match(System.String)">
            <summary>
            Compares a string with the <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">wildcard expression</conceptualLink> used to create this <see cref="T:Au.Types.Wildex"/>.
            Returns true if they match.
            </summary>
            <param name="s">String. If null, returns false. If "", returns true if it was "" or "*" or a regular expression that matches "".</param>
        </member>
        <member name="T:Au.Types.Wildex.WildType">
            <summary>
            The type of text (wildcard expression) used when creating the Wildex variable.
            </summary>
        </member>
        <member name="F:Au.Types.Wildex.WildType.Text">
            <summary>
            Simple text (option t, or no *? characters and no t r R options).
            Match() calls <see cref="M:Au.String_.Equals_(System.String,System.String,System.Boolean)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.Wildex.WildType.Wildcard">
            <summary>
            Wildcard (has *? characters and no t r R options).
            Match() calls <see cref="M:Au.String_.Like_(System.String,System.String,System.Boolean)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.Wildex.WildType.RegexPcre">
            <summary>
            PCRE regular expression (option r).
            Match() calls <see cref="M:Au.Regex_.IsMatch(System.String,Au.Types.RXMore)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.Wildex.WildType.RegexNet">
            <summary>
            .NET egular expression (option R).
            Match() calls <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.Wildex.WildType.Multi">
            <summary>
            Multiple parts (option m).
            Match() calls Match() for each part (see <see cref="P:Au.Types.Wildex.MultiArray"/>) and returns true if all negative (option n) parts return true (or there are no such parts) and some positive (no option n) part returns true (or there are no such parts).
            If you want to implement a different logic, call Match() for each <see cref="P:Au.Types.Wildex.MultiArray"/> element (instead of calling Match() for this variable).
            </summary>
        </member>
        <member name="P:Au.Types.Wildex.Text">
            <summary>
            Gets the wildcard or simple text.
            null if TextType is Regex or Multi.
            </summary>
        </member>
        <member name="P:Au.Types.Wildex.RegexPcre">
            <summary>
            Gets the Regex object created from regular expression string.
            null if TextType is not RegexPcre (no option r).
            </summary>
        </member>
        <member name="P:Au.Types.Wildex.RegexNet">
            <summary>
            Gets the Regex object created from regular expression string.
            null if TextType is not RegexNet (no option R).
            </summary>
        </member>
        <member name="P:Au.Types.Wildex.MultiArray">
            <summary>
            Array of Wildex variables, one for each part in multi-part text.
            null if TextType is not Multi (no option m).
            </summary>
        </member>
        <member name="P:Au.Types.Wildex.TextType">
            <summary>
            Gets the type of text (wildcard, regex, etc).
            </summary>
        </member>
        <member name="P:Au.Types.Wildex.IgnoreCase">
            <summary>
            Is case-insensitive?
            </summary>
        </member>
        <member name="P:Au.Types.Wildex.Not">
            <summary>
            Has option n?
            </summary>
        </member>
        <member name="M:Au.Types.Wildex.ToString">
            
        </member>
        <member name="M:Au.Types.Wildex.HasWildcards(System.String)">
            <summary>
            Returns true if string contains wildcard characters: '*', '?'.
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="T:Au.Types.DIcon">
            <summary>
            Standard icons for <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String)"/> and similar functions.
            </summary>
        </member>
        <member name="F:Au.Types.DIcon.App">
            <summary>
            Your application icon.
            It is the first native icon of the entry assembly of this appdomain; if there are no icons - of the program file of this process (if it's different); if there are no icons too - the default program icon.
            </summary>
        </member>
        <member name="T:Au.Types.DEdit">
            <summary>
            Text edit field type for <see cref="M:Au.AuDialog.ShowTextInputEx(System.String,System.String,Au.Types.DEdit,System.Object,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs},System.String,System.Action{Au.Types.DEventArgs})"/> and <see cref="M:Au.AuDialog.SetEditControl(Au.Types.DEdit,System.Object)"/>.
            </summary>
        </member>
        <member name="T:Au.Types.DFlags">
            <summary>
            Flags for <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String)"/> and similar functions.
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.CommandLinks">
            <summary>
            Display custom buttons as a column of command-links, not as a row of classic buttons.
            Command links can have multi-line text. The first line has bigger font.
            More info about custom buttons: <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.EndThread">
            <summary>
            Call <see cref="M:System.Threading.Thread.Abort"/> if selected OK button when there are no other buttons. Also when selected Cancel, No, and on timeout.
            The same as <see cref="P:Au.AuDialog.FlagEndThread"/>.
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.ExpandDown">
            <summary>
            Show expanded text in footer.
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.OwnerCenter">
            <summary>
            Show the dialog in the center of the owner window.
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.RawXY">
            <summary>
            x y are relative to the primary screen (ignore <see cref="P:Au.AuDialog.Screen"/> etc). Don't ensure thet entire window is in screen.
            More info: <see cref="M:Au.AuDialog.SetXY(Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. 
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.Topmost">
            <summary>
            Make the dialog a topmost window (always on top of other windows), regardless of AuDialog.Options.TopmostIfNoOwnerWindow etc.
            More info: <see cref="P:Au.AuDialog.FlagTopmost"/>. 
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.Wider">
            <summary>
            Set <see cref="P:Au.AuDialog.Width"/> = 700.
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.XCancel">
            <summary>
            Allow to cancel even if there is no Cancel button.
            It adds X (Close) button to the title bar, and also allows to close the dialog with the Esc key.
            When the dialog is closed with the X button or Esc, the returned result button id is 0 if there is no Cancel button; else the same as when clicked the Cancel button.
            The same as <see cref="P:Au.AuDialog.FlagXCancel"/>.
            </summary>
        </member>
        <member name="T:Au.Types.DResult">
            <summary>
            Result of <see cref="M:Au.AuDialog.ShowEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/> and similar functions: button id, radio button id, check box state, edit field text.
            </summary>
        </member>
        <member name="F:Au.Types.DResult.Timeout">
            <summary>
            Returned <see cref="P:Au.Types.DResult.Button"/> value on timeout.
            </summary>
        </member>
        <member name="P:Au.Types.DResult.Button">
            <summary>
            Gets selected button id.
            On timeout it is DResult.Timeout.
            </summary>
        </member>
        <member name="P:Au.Types.DResult.RadioButton">
            <summary>
            Gets selected (checked) radio button id.
            </summary>
        </member>
        <member name="P:Au.Types.DResult.IsChecked">
            <summary>
            Gets check box state.
            </summary>
        </member>
        <member name="P:Au.Types.DResult.EditText">
            <summary>
            Gets edit field text.
            </summary>
        </member>
        <member name="M:Au.Types.DResult.op_Implicit(Au.Types.DResult)~System.Int32">
            <summary>
            Converts DResult to int.
            Allows to use code <c>switch(AuDialog.ShowEx(...))</c> instead of <c>switch(AuDialog.ShowEx(...).Button)</c> .
            </summary>
        </member>
        <member name="M:Au.Types.DResult.ToString">
            <summary>
            Formats string $"Button={Button}, RadioButton={RadioButton}, IsChecked={IsChecked}, EditText={EditText}".
            </summary>
        </member>
        <member name="T:Au.Types.DEventArgs">
            <summary>
            Arguments for <see cref="T:Au.AuDialog"/> event handlers.
            </summary>
            <remarks>
            To return a non-zero value from the callback function, assign the value to the <b>returnValue</b> field.
            More info: <msdn>TaskDialogCallbackProc</msdn>.
            </remarks>
        </member>
        <member name="P:Au.Types.DEventArgs.LinkHref">
            <summary>
            Clicked hyperlink href attribute value. Use in <see cref="E:Au.AuDialog.HyperlinkClicked"/> event handler.
            </summary>
        </member>
        <member name="P:Au.Types.DEventArgs.Button">
            <summary>
            Clicked button id. Use in <see cref="E:Au.AuDialog.ButtonClicked"/> event handler.
            </summary>
        </member>
        <member name="P:Au.Types.DEventArgs.TimerTimeMS">
            <summary>
            Dialog timer time in milliseconds. Use in <see cref="E:Au.AuDialog.Timer"/> event handler.
            The event handler can set <b>returnValue</b>=1 to reset this.
            </summary>
        </member>
        <member name="P:Au.Types.DEventArgs.DoNotCloseDialog">
            <summary>
            Your <see cref="E:Au.AuDialog.ButtonClicked"/> event handler function can use this to prevent closing the dialog.
            </summary>
        </member>
        <member name="P:Au.Types.DEventArgs.EditText">
            <summary>
            Gets or sets edit field text.
            </summary>
        </member>
        <member name="T:Au.Types.TDSend">
            <summary>
            Can be used through <see cref="P:Au.AuDialog.Send"/>, to interact with dialog while it is open.
            </summary>
            <remarks>
            Example (in an event handler): <c>e.dialog.Close();</c>
            </remarks>
        </member>
        <member name="M:Au.Types.TDSend.Message(Au.Types.TDApi.TDM,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>
            Sends a message to the dialog.
            </summary>
            <remarks>
            Call this method while the dialog is open, eg in an event handler.
            Example (in an event handler): <c>e.dialog.Send.Message(TDApi.TDM.CLICK_VERIFICATION, 1);</c>
            Also there are several other functions to send some messages: change text, close dialog, enable/disable buttons, update progress.
            Reference: <msdn>task dialog messages</msdn>.
            NAVIGATE_PAGE currently not supported.
            </remarks>
        </member>
        <member name="M:Au.Types.TDSend.ChangeText1(System.String,System.Boolean)">
            <summary>
            Changes the main big-font text.
            </summary>
            <remarks>
            Call this method while the dialog is open, eg in an event handler.
            </remarks>
        </member>
        <member name="M:Au.Types.TDSend.ChangeText2(System.String,System.Boolean)">
            <summary>
            Changes the main small-font text.
            </summary>
            <remarks>
            Call this method while the dialog is open, eg in an event handler.
            </remarks>
        </member>
        <member name="M:Au.Types.TDSend.ChangeFooterText(System.String,System.Boolean)">
            <summary>
            Changes the footer text.
            </summary>
            <remarks>
            Call this method while the dialog is open, eg in an event handler.
            </remarks>
        </member>
        <member name="M:Au.Types.TDSend.ChangeExpandedText(System.String,System.Boolean)">
            <summary>
            Changes the expanded area text.
            </summary>
            <remarks>
            Call this method while the dialog is open, eg in an event handler.
            </remarks>
        </member>
        <member name="M:Au.Types.TDSend.Close(System.Int32)">
            <summary>
            Clicks a button. Normally it closes the dialog.
            </summary>
            <param name="buttonId">A button id or some other number that will be returned by ShowDialog.</param>
            <remarks>
            Call this method while the dialog is open, eg in an event handler.
            Sends message TDApi.TDM.CLICK_BUTTON.
            </remarks>
        </member>
        <member name="M:Au.Types.TDSend.EnableButton(System.Int32,System.Boolean)">
            <summary>
            Enables or disables a button.
            </summary>
            <remarks>
            Call this method while the dialog is open, eg in an event handler.
            Example: <c>d.Created += e => { e.dialog.Send.EnableButton(4, false); };</c>
            Sends message TDApi.TDM.ENABLE_BUTTON.
            </remarks>
        </member>
        <member name="M:Au.Types.TDSend.Progress(System.Int32)">
            <summary>
            Sets progress bar value, 0 to 100.
            </summary>
            <remarks>
            Call this method while the dialog is open, eg in an event handler.
            Sends message TDApi.TDM.SET_PROGRESS_BAR_POS.
            </remarks>
        </member>
        <member name="T:Au.Types.TDApi">
            <summary>
            Constants for task dialog API messages etc.
            Can be used with <see cref="T:Au.AuDialog"/>.
            </summary>
        </member>
        <member name="T:Au.Types.TDApi.TDM">
            <summary>
            Messages that your event handler can send to the dialog.
            Reference: <msdn>task dialog messages</msdn>.
            </summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.TDApi.TDN">
            <summary>
            Notification messages that your event handler receives.
            Reference: <msdn>task dialog notifications</msdn>.
            </summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.TDApi.TDE">
            <summary>
            Constants for TDApi.TDM.SET_ELEMENT_TEXT and TDApi.TDM.UPDATE_ELEMENT_TEXT messages and AuDialog.Send.Text().
            </summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.TDApi.TDIE">
            <summary>
            Constants for TDApi.TDM.UPDATE_ICON message.
            </summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.WHFlags">
            <summary>
            Flags for <see cref="M:Au.WaitFor.Handle(System.Double,Au.Types.WHFlags,System.IntPtr[])"/>
            </summary>
        </member>
        <member name="F:Au.Types.WHFlags.All">
            <summary>
            Wait until all handles are signaled.
            </summary>
        </member>
        <member name="F:Au.Types.WHFlags.DoEvents">
            <summary>
            While waiting, dispatch Windows messages, events, hooks etc. Like <see cref="M:Au.Time.SleepDoEvents(System.Int32)"/>.
            </summary>
        </member>
        <member name="T:Au.Types.WaitMsgCallback">
            <summary>
            Delegate type for <see cref="M:Au.WaitFor.PostedMessage(System.Double,Au.Types.WaitMsgCallback)"/>.
            </summary>
        </member>
        <member name="T:Au.Types.LibWaitVariable">
            <summary>
            Used with LibWait etc instead of ref bool.
            </summary>
        </member>
        <member name="T:Au.Types.WProp">
            <summary>
            Sets, gets, removes and lists window properties using API <msdn>SetProp</msdn> and co.
            </summary>
        </member>
        <member name="P:Au.Types.WProp.Item(System.String)">
            <summary>
            Gets a window property.
            Calls API <msdn>GetProp</msdn> and returns its return value.
            </summary>
            <param name="name">Property name.</param>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Types.WProp.Item(System.UInt16)">
            <summary>
            Gets a window property.
            Calls API <msdn>GetProp</msdn> and returns its return value.
            </summary>
            <param name="atom">Property name atom in the global atom table.</param>
            <remarks>
            This overload uses atom instead of string. I's about 3 times faster. See API <msdn>GlobalAddAtom</msdn>, <msdn>GlobalDeleteAtom</msdn>.
            </remarks>
        </member>
        <member name="M:Au.Types.WProp.Set(System.String,Au.Types.LPARAM)">
            <summary>
            Sets a window property.
            Calls API <msdn>SetProp</msdn> and returns its return value.
            </summary>
            <param name="name">Property name.</param>
            <param name="value">Property value.</param>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            
            Later call <see cref="M:Au.Types.WProp.Remove(System.String)"/> to remove the property. If you use many unique property names and don't remove the properties, the property name strings can fill the global atom table which is of a fixed size (about 48000) and which is used by all processes for various purposes.
            </remarks>
        </member>
        <member name="M:Au.Types.WProp.Set(System.UInt16,Au.Types.LPARAM)">
            <summary>
            Sets a window property.
            Calls API <msdn>SetProp</msdn> and returns its return value.
            </summary>
            <param name="atom">Property name atom in the global atom table.</param>
            <param name="value">Property value.</param>
            <remarks>
            This overload uses atom instead of string. I's about 3 times faster. See API <msdn>GlobalAddAtom</msdn>, <msdn>GlobalDeleteAtom</msdn>.
            </remarks>
        </member>
        <member name="M:Au.Types.WProp.Remove(System.String)">
            <summary>
            Removes a window property.
            Calls API <msdn>RemoveProp</msdn> and returns its return value.
            </summary>
            <param name="name">Property name. Other overload allows to use global atom instead, which is faster.</param>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Types.WProp.Remove(System.UInt16)">
            <summary>
            Removes a window property.
            Calls API <msdn>RemoveProp</msdn> and returns its return value.
            </summary>
            <param name="atom">Property name atom in the global atom table.</param>
        </member>
        <member name="M:Au.Types.WProp.GetList">
            <summary>
            Gets list of window properties.
            Uses API <msdn>EnumPropsEx</msdn>.
            </summary>
            <remarks>
            Returns 0-length list if fails. Fails if invalid window or access denied (<see cref="T:Au.Process_.UacInfo">UAC</see>). Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="M:Au.Types.WProp.ToString">
            <summary>
            Calls <see cref="M:Au.Types.WProp.GetList"/> and converts to string.
            </summary>
        </member>
        <member name="T:Au.Types.WCFlags">
            <summary>
            'flags' parameter of <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/>.
            <note>
            </note>
            </summary>
        </member>
        <member name="F:Au.Types.WCFlags.HiddenToo">
            <summary>Can find hidden controls.</summary>
        </member>
        <member name="F:Au.Types.WCFlags.DirectChild">
            <summary>Skip indirect descendant controls (children of children and so on).</summary>
        </member>
        <member name="T:Au.Types.WXYFlags">
            <summary>
            Flags for <see cref="M:Au.Wnd.FromXY(Au.Types.POINT,Au.Types.WXYFlags)"/> and <see cref="M:Au.Wnd.FromMouse(Au.Types.WXYFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.WXYFlags.NeedWindow">
            <summary>
            Need top-level window. If at that point is a control, gets its top-level parent.
            Don't use together with NeedControl.
            If none of flags NeedWindow and NeedControl are specified, the function gets exactly what is at that point (control or top-level window).
            </summary>
        </member>
        <member name="F:Au.Types.WXYFlags.NeedControl">
            <summary>
            Need a control (child window). Returns default(Wnd) if there is no control at that point.
            Don't use together with NeedWindow.
            If none of flags NeedWindow and NeedControl are specified, the function gets exactly what is at that point (control or top-level window).
            </summary>
        </member>
        <member name="F:Au.Types.WXYFlags.Raw">
            <summary>
            Just call API <msdn>WindowFromPoint</msdn>.
            Faster but less accurate with controls. Does not see disabled controls, does not prefer non-transparent controls.
            Not used with flag NeedWindow.
            </summary>
        </member>
        <member name="T:Au.Types.WFFlags">
            <summary>
            'flags' parameter of <see cref="M:Au.Wnd.Find(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.WFFlags.HiddenToo">
            <summary>
            Can find hidden windows. See <see cref="P:Au.Wnd.IsVisibleEx"/>.
            Use this carefully. Always use className, not just name, because there are many hidden tooltip windows etc that could match the name.
            </summary>
        </member>
        <member name="F:Au.Types.WFFlags.SkipCloaked">
            <summary>
            Skip cloaked windows. See <see cref="P:Au.Wnd.IsCloaked"/>.
            Cloaked are windows hidden not in the classic way, therefore Wnd.IsVisible does not detect it, but Wnd.IsCloaked detects. For example, windows on inactive Windows 10 virtual desktops; inactive Windows Store apps on Windows 8.
            </summary>
        </member>
        <member name="T:Au.Types.WFEtc">
            <summary>
            <i>programEtc</i> of <see cref="M:Au.Wnd.Find(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.WFEtc.op_Implicit(System.String)~Au.Types.WFEtc">
            <summary>Program name like "notepad.exe", or null.</summary>
        </member>
        <member name="M:Au.Types.WFEtc.Process(System.Int32)">
            <summary>Process id.</summary>
        </member>
        <member name="M:Au.Types.WFEtc.Thread(System.Int32)">
            <summary>Thread id.</summary>
        </member>
        <member name="M:Au.Types.WFEtc.Owner(Au.Types.AnyWnd)">
            <summary>Owner window.</summary>
        </member>
        <member name="M:Au.Types.WFEtc.GetValue(Au.Types.Wildex@,System.Int32@,System.Int32@,Au.Wnd@)">
            <summary>
            Gets program name or process id or thread id or owner window.
            Other variables will be null/0.
            </summary>
            <exception cref="T:System.ArgumentException">The value is "" or 0.</exception>
        </member>
        <member name="T:Au.Types.SUBCLASSPROC">
            <summary>API <msdn>SUBCLASSPROC</msdn></summary>
        </member>
        <member name="T:Au.Types.FileDir">
            <summary>
            File system entry type - file, directory, and whether it exists.
            Returned by <see cref="M:Au.Files.ExistsAs(System.String,System.Boolean)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.FileDir.NotFound">
            <summary>Does not exist, or failed to get attributes.</summary>
        </member>
        <member name="F:Au.Types.FileDir.File">
            <summary>Is file, or symbolic link to a file.</summary>
        </member>
        <member name="F:Au.Types.FileDir.Directory">
            <summary>Is directory, or symbolic link to a directory.</summary>
        </member>
        <member name="T:Au.Types.FileDir2">
            <summary>
            File system entry type - file, directory, symbolic link, whether it exists and is accessible.
            Returned by <see cref="M:Au.Files.ExistsAs2(System.String,System.Boolean)"/>.
            The enum value NotFound is 0; AccessDenied is negative ((int)0x80000000); other values are greater than 0.
            </summary>
        </member>
        <member name="F:Au.Types.FileDir2.NotFound">
            <summary>Does not exist.</summary>
        </member>
        <member name="F:Au.Types.FileDir2.File">
            <summary>Is file. Attributes: Directory no, ReparsePoint no.</summary>
        </member>
        <member name="F:Au.Types.FileDir2.Directory">
            <summary>Is directory. Attributes: Directory yes, ReparsePoint no.</summary>
        </member>
        <member name="F:Au.Types.FileDir2.SymLinkFile">
            <summary>Is symbolic link to a file. Attributes: Directory no, ReparsePoint yes.</summary>
        </member>
        <member name="F:Au.Types.FileDir2.SymLinkDirectory">
            <summary>Is symbolic link to a directory, or is a mounted folder. Attributes: Directory yes, ReparsePoint yes.</summary>
        </member>
        <member name="F:Au.Types.FileDir2.AccessDenied">
            <summary>Exists but this process cannot access it and get attributes.</summary>
        </member>
        <member name="T:Au.Types.FAFlags">
            <summary>
            Flags for <see cref="M:Au.Files.GetAttributes(System.String,System.IO.FileAttributes@,Au.Types.FAFlags)"/> and some other functions.
            </summary>
        </member>
        <member name="F:Au.Types.FAFlags.UseRawPath">
            <summary>Pass path to the API as it is, without any normalizing and validating.</summary>
        </member>
        <member name="F:Au.Types.FAFlags.DoNotThrow">
            <summary>
            If failed, return false and don't throw exception.
            Then, if you need error info, you can use <see cref="M:Au.Types.Native.GetError"/>. If the file/directory does not exist, it will return ERROR_FILE_NOT_FOUND or ERROR_PATH_NOT_FOUND or ERROR_NOT_READY.
            If failed and the native error code is ERROR_ACCESS_DENIED or ERROR_SHARING_VIOLATION, the returned attributes will be (FileAttributes)(-1). The file probably exists but is protected so that this process cannot access and use it. Else attributes will be 0.
            </summary>
        </member>
        <member name="T:Au.Types.FileProperties">
            <summary>
            File or directory properties. Used with <see cref="M:Au.Files.GetProperties(System.String,Au.Types.FileProperties@,Au.Types.FAFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.FileProperties.Attributes">
            
        </member>
        <member name="F:Au.Types.FileProperties.Size">
            <summary>File size. For directories it is usually 0.</summary>
        </member>
        <member name="F:Au.Types.FileProperties.LastWriteTimeUtc">
            
        </member>
        <member name="F:Au.Types.FileProperties.CreationTimeUtc">
            
        </member>
        <member name="F:Au.Types.FileProperties.LastAccessTimeUtc">
            <summary>Note: this is unreliable. The operating system may not record this time automatically.</summary>
        </member>
        <member name="T:Au.Types.FEFlags">
            <summary>
            flags for <see cref="M:Au.Files.EnumDirectory(System.String,Au.Types.FEFlags,System.Func{Au.Types.FEFile,System.Boolean},System.Action{System.String})"/>.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.AndSubdirectories">
            <summary>
            Enumerate subdirectories too.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.AndSymbolicLinkSubdirectories">
            <summary>
            Also enumerate symbolic link and mounted folder target directories. Use with AndSubdirectories.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.SkipHidden">
            <summary>
            Skip files and subdirectories that have Hidden attribute.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.SkipHiddenSystem">
            <summary>
            Skip files and subdirectories that have Hidden and System attributes (both).
            These files/directories usually are created and used only by the operating system. Drives usually have several such directories. Another example - thumbnail cache files.
            Without this flag the function skips only these hidden-system root directories when enumerating a drive: "$Recycle.Bin", "System Volume Information", "Recovery". If you want to include them too, use network path of the drive, for example @"\\localhost\D$\" for D drive.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.IgnoreAccessDeniedErrors">
            <summary>
            If fails to get contents of the directory or a subdirectory because of its security settings, assume that the [sub]directory is empty.
            Without this flag then throws exception or calls errorHandler.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.DisableRedirection">
            <summary>
            Temporarily disable file system redirection in this thread of this 32-bit process running on 64-bit Windows.
            Then you can enumerate the 64-bit System32 folder in your 32-bit process.
            Uses API <msdn>Wow64DisableWow64FsRedirection</msdn>.
            For vice versa (in 64-bit process enumerate the 32-bit System folder), instead use path Folders.SystemX86.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.UseRawPath">
            <summary>
            Don't call <see cref="M:Au.Path_.Normalize(System.String,System.String,Au.Types.PNFlags)"/>(directoryPath) and don't throw exception for non-full path.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.NeedRelativePaths">
            <summary>
            Let <see cref="P:Au.Types.FEFile.Name"/> be path relative to the specified directory path. Like @"\name.txt" or @"\subdirectory\name.txt" instead of "name.txt".
            </summary>
        </member>
        <member name="T:Au.Types.FCFlags">
            <summary>
            flags for <see cref="M:Au.Files.Copy(System.String,System.String,Au.Types.IfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})"/> and some other similar functions.
            Used only when copying directory.
            </summary>
        </member>
        <member name="F:Au.Types.FCFlags.SkipHiddenSystem">
            <summary>
            Skip descendant files and directories that have Hidden and System attributes (both).
            They usually are created and used only by the operating system. Drives usually have several such directories. Another example - thumbnail cache files.
            They often are protected and would fail to copy, ruining whole copy operation.
            Without this flag the function skips only these hidden-system root directories when enumerating a drive: "$Recycle.Bin", "System Volume Information", "Recovery".
            </summary>
        </member>
        <member name="F:Au.Types.FCFlags.IgnoreAccessDeniedErrors">
            <summary>
            If fails to get contents of the directory or a subdirectory because of its security settings, don't throw exception but assume that the [sub]directory is empty.
            </summary>
        </member>
        <member name="T:Au.Types.FEFile">
            <summary>
            Contains name and other main properties of a file or subdirectory retrieved by <see cref="M:Au.Files.EnumDirectory(System.String,Au.Types.FEFlags,System.Func{Au.Types.FEFile,System.Boolean},System.Action{System.String})"/>.
            The values are not changed after creating the variable.
            </summary>
        </member>
        <member name="M:Au.Types.FEFile.#ctor(System.String,System.String,Au.Types.Api.WIN32_FIND_DATA@,System.Int32)">
            
        </member>
        <member name="P:Au.Types.FEFile.Name">
            
        </member>
        <member name="P:Au.Types.FEFile.FullPath">
            
        </member>
        <member name="P:Au.Types.FEFile.Size">
            <summary>
            Returns file size. For directories it is usually 0.
            </summary>
        </member>
        <member name="P:Au.Types.FEFile.LastWriteTimeUtc">
            
        </member>
        <member name="P:Au.Types.FEFile.CreationTimeUtc">
            
        </member>
        <member name="P:Au.Types.FEFile.Attributes">
            
        </member>
        <member name="P:Au.Types.FEFile.IsDirectory">
            <summary>
            Returns true if is directory or symbolic link to a directory or mounted folder.
            </summary>
        </member>
        <member name="P:Au.Types.FEFile.Level">
            <summary>
            Descendant level.
            0 if direct child of directoryPath, 1 if child of child, an so on.
            </summary>
        </member>
        <member name="M:Au.Types.FEFile.SkipThisDirectory">
            <summary>
            Call this function if don't want to enumerate children of this subdirectory.
            </summary>
        </member>
        <member name="M:Au.Types.FEFile.ToString">
            <summary>
            Returns FullPath.
            </summary>
        </member>
        <member name="T:Au.Types.IfExists">
            <summary>
            What to do if the destination directory contains a file or directory with the same name as the source file or directory when copying, moving or renaming.
            Used with <see cref="M:Au.Files.Copy(System.String,System.String,Au.Types.IfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})"/>, <see cref="M:Au.Files.Move(System.String,System.String,Au.Types.IfExists)"/> and similar functions.
            When renaming or moving, if the destination is the same as the source, these options are ignored and the destination is simply renamed. For example when renaming "file.txt" to "FILE.TXT".
            </summary>
        </member>
        <member name="F:Au.Types.IfExists.Fail">
            <summary>Throw exception. Default.</summary>
        </member>
        <member name="F:Au.Types.IfExists.Delete">
            <summary>Delete destination.</summary>
        </member>
        <member name="F:Au.Types.IfExists.RenameExisting">
            <summary>Rename (backup) destination.</summary>
        </member>
        <member name="F:Au.Types.IfExists.MergeDirectory">
            <summary>
            If destination directory exists, merge the source directory into it, replacing existing files.
            If destination file exists, deletes it.
            If destination directory exists and source is file, fails.
            </summary>
        </member>
        <member name="T:Au.Types.GIFlags">
            <summary>
            Flags for <see cref="M:Au.Icons.GetFileIcon(System.String,System.Int32,Au.Types.GIFlags)"/> and similar functions.
            </summary>
        </member>
        <member name="F:Au.Types.GIFlags.LiteralPath">
            <summary>
            The 'file' argument is literal full path. Don't parse "path,index", don't support ".ext" (file type icon), don't make fully-qualified, etc.
            </summary>
        </member>
        <member name="F:Au.Types.GIFlags.SearchPath">
            <summary>
            If file is not full path, call <see cref="M:Au.Files.SearchPath(System.String,System.String[])"/>.
            Without this flag searches only in <see cref="P:Au.Folders.ThisAppImages"/>; with this flag also searches there first.
            </summary>
        </member>
        <member name="T:Au.Types.IconSize">
            <summary>
            Standard icon sizes.
            </summary>
            <seealso cref="M:Au.Icons.GetShellIconSize(Au.Types.IconSize)"/>
            <tocexclude />
        </member>
        <member name="F:Au.Types.IconSize.SysSmall">
            <summary>
            Icons displayed in window title bar and system notification area (tray). Usually 16x16 when normal DPI, the same as <b>Small</b>.
            </summary>
        </member>
        <member name="F:Au.Types.IconSize.Small">
            <summary>
            Small icons displayed in Explorer folders. Usually 16x16 when normal DPI.
            </summary>
        </member>
        <member name="F:Au.Types.IconSize.Large">
            <summary>
            Large icons displayed in Explorer folders. Usually 32x32 when normal DPI.
            </summary>
        </member>
        <member name="F:Au.Types.IconSize.ExtraLarge">
            <summary>
            Extra large icons displayed in Explorer folders. Usually 48x48 when normal DPI.
            </summary>
        </member>
        <member name="F:Au.Types.IconSize.Jumbo">
            <summary>
            256x256 icons displayed in Explorer folders.
            </summary>
        </member>
        <member name="T:Au.Types.StockIcon">
            <summary><msdn>SHSTOCKICONID</msdn></summary>
            <seealso cref="M:Au.Icons.GetStockIcon(Au.Types.StockIcon,System.Int32)"/>
        </member>
        <member name="T:Au.Types.STIFlags">
            <summary>
            Flags for String_.ToIntX functions.
            </summary>
        </member>
        <member name="F:Au.Types.STIFlags.NoHex">
            <summary>
            Don't support hexadecimal numbers (numbers with prefix "0x").
            </summary>
        </member>
        <member name="F:Au.Types.STIFlags.IsHexWithout0x">
            <summary>
            The number in string is hexadecimal without a prefix, like "1A".
            </summary>
        </member>
        <member name="T:Au.Acc">
            <summary>
            Accessible object.
            Finds controls and smaller objects in a window or web page. Clicks, gets properties, etc.
            </summary>
            <remarks>
            Accessible objects (AO) are various user interface (UI) objects in windows and controls. For example buttons, links, list items. This class can find them, get properties, click, etc. Especially useful with web pages, because there are no controls. And many other windows don't use controls but support AO. But not all UI objects are AO.
            
            An Acc instance holds an AO COM pointer (<msdn>IAccessible</msdn>) and a simple element id (int). Most Acc functions wrap IAccessible interface functions or/and related API.
            
            Acc functions that get properties don't throw exception when the wrapped IAccessible/etc function failed (returned an error code of HRESULT type). Then they return "" (string properties), 0, false, null or empty collection, dependin on return type. Applications implement AOs differently, often with bugs, and their IAccessible interface functions return a variety of error codes. It's impossible to reliably detect whether the error code means a serious error or the property is merely unavailable. These Acc functions also set the last error code of this thread = the return value (HRESULT) of the IAccessible function, and callers can use <see cref="M:Au.Types.Native.GetError"/> to get it. If Native.GetError returns 1 (S_FALSE), in most cases it's not an error, just the property is unavailable. On error it will probably be a negative error code.
            
            You can dispose Acc variables to release the COM object, but it is not necessary (GC will do it later).
            
            An Acc variable cannot be used in multiple threads. Only Dispose can be called in any thread.
            
            AOs are implemented and live in their applications. This class just communicates with them.
            
            Many applications have various problems with their AOs: bugs, incorrect/nonstandard/partial implementation, or initially disabled. This class implements workarounds for known problems, where possible.
            
            Known problematic applications:
            <list type="bullet">
            <item>
            Chrome web browser. Also Opera and other apps that use Chrome code; window class name is like "Chrome_WidgetWin_1".
            
            Web page AOs initially are disabled (missing). Workarounds:
            Functions Find, Wait and FindAll enable it if used role prefix "web:" or "chrome:". Functions FromXY, FromMouse and Focused enable it if window class name starts with "Chrome". However Chrome does it lazily, therefore first time the functions often get wrong AO. Note: this auto-enabing may fail with future Chrome versions.
            Other ways to enable Chrome AOs: 1. Start Chrome with command line --force-renderer-accessibility. 2. In the future the script editor will have an option to enable Chrome AOs when it starts.
            
            Some new web browser versions add new features or bugs that break something. AOs are especially vulnerable, because they are considered second-class citizens.
            </item>
            <item>
            Firefox web browser.
            
            By default, the Find function is 50-100 times slower than it could be. Also for this reason the Wait function consumes much CPU. And HTML attributes may be unavailable. See <see cref="F:Au.Types.AFFlags.NotInProc"/>. Workaround: disable the Firefox multiprocess feature: open URL about:config, find browser.tabs.remote.autostart, set it = false, restart Firefox. If there is no such option, right-click and create it, as Boolean. If there are more than one similar options, set them all = false. Note: Firefox may reset it when upgrading or reinstalling, or even remove it in the future. If this does not work, google how to disable Firefox multiprocess.
            
            When Firefox starts, its web page AOs are unavailable. It creates them only when somebody asks (eg function Find), but does it lazily, and Find at first fails. Workaround: use Wait, not Find.
            
            Ocassionally Firefox briefly turns off its web page AOs. Workaround: use Wait, not Find. With other web browsers also it's better to use Wait.
            
            Some new web browser versions add new features or bugs that break something. AOs are especially vulnerable, because they are considered second-class citizens.
            </item>
            <item>
            Edge web browser, JavaFX and other applications that don't have true accessible objects but have UI Automation elements.
            
            To find AOs in these applications, need flag <see cref="F:Au.Types.AFFlags.UIA"/>.
            </item>
            <item>
            Java applications that use AWT/Swing (window class name starts with "SunAwt").
            
            Not supported on 32-bit OS.
            
            Must be enabled Java Access Bridge (JAB).
            If JAB is disabled or does not work, the "Find accessible object" tool shows an "enable" link when you try to capture something in a Java window. The link calls Au.Tools.Form_Acc.Java.EnableDisableJabUI. Or you can enable JAB in Control Panel -> Ease of Access Center -> Use the computer without a display. Or use jabswitch.exe. Then restart Java apps. Also may need to restart apps that tried to use Java AOs.
            
            Your process must have the same 32/64 bitness as the installed Java. To remove this limitation, install Java 32-bit and 64-bit (they coexist).
            </item>
            <item>
            OpenOffice.
            
            Often crashes after using AOs, usually when closing. Noticed in OpenOffice 4.1.4; may be fixed in newer versions.
            </item>
            <item>
            LibreOffice.
            
            AOs are unavailable unless this process is 32-bit (when LibreOffice is 64-bit). Also need flag <see cref="F:Au.Types.AFFlags.NotInProc"/>.
            </item>
            <item>
            In some windows, AO of some controls are not connected to AO of parent control. Then Find cannot find them if searches in whole window.
            
            Workaround: search only in that control. For example, use prop "class" or id". If it's a web browser control, use role prefix "web:". Or find the control with <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/> and search in it. Or use <see cref="M:Au.Acc.Finder.Find(Au.Wnd,Au.Wnd.ChildFinder)"/>.
            </item>
            <item>
            AOs of many standard Windows controls have bugs when they are retrieved without loading dll into the target process (see <see cref="F:Au.Types.AFFlags.NotInProc"/>).
            Known bugs: 1. Toolbar buttons don't have Name in some cases. 2. <see cref="M:Au.Acc.Focus(System.Boolean)"/> and <see cref="M:Au.Acc.Select(Au.Types.AccSELFLAG)"/> often don't work properly.
            
            Workaround: don't use <see cref="F:Au.Types.AFFlags.NotInProc"/>, or use <see cref="F:Au.Types.AFFlags.UIA"/>.
            </item>
            <item>
            Function Find is much slower when cannot load dll into the target process. More info: <see cref="F:Au.Types.AFFlags.NotInProc"/>. Function Wait then consumes much more CPU.
            </item>
            <item>
            If the process has different 32/64 bitness than this process, to load the dll is launched rundll32.exe, which makes slower by about 50 ms first time.
            </item>
            <item>
            Currently this library does not support auto-scaled windows when using high DPI (text size 125%, 150% or more).
            If the target process is auto-scaled and this process isn't (or vice versa, or they have a different scaling factor), most coordinate-related functions don't work properly. For example, they get wrong AO rectangles.
            </item>
            </list>
            </remarks>
            <example>
            Click link "Example" in Chrome.
            <code><![CDATA[
            var w = Wnd.Find("* Chrome").OrThrow();
            var a = Acc.Find(w, "web:LINK", "Example").OrThrow();
            a.DoAction();
            ]]></code>
            Click a link, wait for new web page, click a link in it.
            <code><![CDATA[
            var w = Wnd.Find("* Chrome").OrThrow();
            var a = Acc.Wait(1, w, "web:LINK", "Link 1");
            a.DoActionAndWaitForNewWebPage();
            a = Acc.Wait(10, w, "web:LINK", "Link 2");
            a.DoActionAndWaitForNewWebPage();
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Acc.WndContainer">
            <summary>
            Gets the container window or control of this accessible object.
            Uses API <msdn>WindowFromAccessibleObject</msdn>.
            </summary>
            <remarks>
            Returns default(Wnd) if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            All objects must support this property, but some have bugs and can fail (return default(Wnd)) or return a wrong window.
            </remarks>
        </member>
        <member name="P:Au.Acc.WndTopLevel">
            <summary>
            Gets the top-level window that contains this accessible object.
            Uses API <msdn>WindowFromAccessibleObject</msdn> and API <msdn>GetAncestor</msdn>.
            </summary>
            <remarks>
            Returns default(Wnd) if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            All objects must support this property, but some have bugs and can return default(Wnd).
            </remarks>
        </member>
        <member name="P:Au.Acc.Rect">
            <summary>
            Gets location of this accessible object in screen.
            </summary>
            <remarks>
            Calls <see cref="M:Au.Acc.GetRect(Au.Types.RECT@)"/>.
            Returns empty rectangle if failed or this property is unavailable. Supports <see cref="M:Au.Types.Native.GetError"/>.
            Most but not all objects support this property.
            </remarks>
        </member>
        <member name="M:Au.Acc.GetRect(Au.Types.RECT@)">
            <summary>
            Gets location of this accessible object in screen.
            Uses <msdn>IAccessible.accLocation</msdn>.
            </summary>
            <param name="r">Receives object rectangle in screen coordinates.</param>
            <remarks>
            Returns false if failed or this property is unavailable. Supports <see cref="M:Au.Types.Native.GetError"/>.
            Most but not all objects support this property.
            </remarks>
        </member>
        <member name="M:Au.Acc.GetRect(Au.Types.RECT@,Au.Wnd)">
            <summary>
            Gets location of this accessible object in the client area of window w.
            Uses <msdn>IAccessible.accLocation</msdn> and <see cref="M:Au.Wnd.MapScreenToClient(Au.Types.RECT@)"/>.
            </summary>
            <param name="r">Receives object rectangle in w client area coordinates.</param>
            <param name="w">Window or control.</param>
            <remarks>
            Returns false if failed or this property is unavailable. Supports <see cref="M:Au.Types.Native.GetError"/>.
            Most but not all objects support this property.
            </remarks>
        </member>
        <member name="P:Au.Acc.RoleInt">
            <summary>
            Gets standard non-string role, as enum AccROLE.
            Uses <msdn>IAccessible.get_accRole</msdn>.
            </summary>
            <remarks>
            Most objects have a standard role, as enum <see cref="T:Au.Types.AccROLE"/>. Some objects have a custom role, usually as string, for example in web pages in Firefox and Chrome.
            Returns 0 if role is string or if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            All objects must support this property. If failed, probably the object is invalid, for example its window was closed.
            </remarks>
        </member>
        <member name="P:Au.Acc.Role">
            <summary>
            Gets standard or custom role, as string.
            Uses <msdn>IAccessible.get_accRole</msdn>.
            </summary>
            <remarks>
            Most objects have a standard role, as enum <see cref="T:Au.Types.AccROLE"/>. Some objects have a custom role, usually as string, for example in web pages in Firefox and Chrome.
            For standard roles this function returns enum <see cref="T:Au.Types.AccROLE"/> member name. For string roles - the string. For unknown non-string roles - the int value like "0" or "500".
            Returns "" if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            All objects must support this property. If failed, probably the object is invalid, for example its window was closed.
            </remarks>
        </member>
        <member name="P:Au.Acc.State">
            <summary>
            Gets object state (flags).
            Uses <msdn>IAccessible.get_accState</msdn>.
            </summary>
            <remarks>
            Returns 0 if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
            <example>
            <code><![CDATA[
            if(a.State.Has_(AccSTATE.INVISIBLE)) Print("has state INVISIBLE");
            if(a.IsInvisible) Print("invisible");
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Acc.IsChecked">
            <summary> Calls <see cref="P:Au.Acc.State"/> and returns true if has state CHECKED. </summary>
        </member>
        <member name="P:Au.Acc.IsDisabled">
            <summary> Calls <see cref="P:Au.Acc.State"/> and returns true if has state UNAVAILABLE. </summary>
            <remarks>Does not check whether this object is in a disabled parent/ancestor object.</remarks>
        </member>
        <member name="P:Au.Acc.IsFocused">
            <summary> Calls <see cref="P:Au.Acc.State"/> and returns true if has state FOCUSED. </summary>
        </member>
        <member name="P:Au.Acc.IsInvisible">
            <summary> Calls <see cref="P:Au.Acc.State"/> and returns true if has state INVISIBLE and does not have state OFFSCREEN. </summary>
            <remarks>
            If the object has both INVISIBLE and OFFSCREEN states, it is either invisible or just offscreen, depending on application etc. Then this function works like Find and similar functions: for most objects returns false (is visible), but for objects that have these roles returns true (invisible): WINDOW, DOCUMENT, PROPERTYPAGE, GROUPING, ALERT, MENUPOPUP.
            Does not check whether this object is in an invisible parent/ancestor object.
            </remarks>
        </member>
        <member name="P:Au.Acc.IsOffscreen">
            <summary> Calls <see cref="P:Au.Acc.State"/> and returns true if has state OFFSCREEN. </summary>
        </member>
        <member name="P:Au.Acc.IsPassword">
            <summary> Calls <see cref="P:Au.Acc.State"/> and returns true if has state PROTECTED. </summary>
            <remarks>This state is used for password fields.</remarks>
        </member>
        <member name="P:Au.Acc.IsPressed">
            <summary> Calls <see cref="P:Au.Acc.State"/> and returns true if has state PRESSED. </summary>
        </member>
        <member name="P:Au.Acc.IsReadonly">
            <summary> Calls <see cref="P:Au.Acc.State"/> and returns true if has state READONLY. </summary>
        </member>
        <member name="P:Au.Acc.IsSelected">
            <summary> Calls <see cref="P:Au.Acc.State"/> and returns true if has state SELECTED. </summary>
        </member>
        <member name="M:Au.Acc._BstrToString(System.Int32,Au.Types.BSTR)">
            <summary>
            Converts BSTR to string and disposes the BSTR.
            If hr is not 0, returns "" (never null).
            </summary>
        </member>
        <member name="P:Au.Acc.Name">
            <summary>
            Gets name.
            Uses <msdn>IAccessible.get_accName</msdn>.
            </summary>
            <remarks>
            Object name usually is its read-only text (eg button text, link text), or its adjacent read-only text (eg text label by this edit box). It usually does not change, therefore can be used to find or identify the object.
            Returns "" if name is unavailable or if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="M:Au.Acc.LibNameOfWindow(Au.Wnd)">
            <summary>
            Gets <see cref="P:Au.Acc.Name"/> of window/control w.
            Returns null if w invalid. Returns "" if failed to get name.
            </summary>
        </member>
        <member name="P:Au.Acc.Value">
            <summary>
            Gets or sets value.
            Uses <msdn>IAccessible.get_accValue</msdn> or <msdn>IAccessible.put_accValue</msdn>.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to set value.</exception>
            <remarks>
            Object value usually is its editable text or some other value that can be changed at run time, therefore in most cases it cannot be used to find or identify the object reliably.
            The 'get' function returns "" if this property is unavailable or if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            Most objects don't support 'set'.
            </remarks>
        </member>
        <member name="P:Au.Acc.Description">
            <summary>
            Gets description.
            Uses <msdn>IAccessible.get_accDescription</msdn>.
            </summary>
            <remarks>
            Returns "" if this property is unavailable or if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="P:Au.Acc.Help">
            <summary>
            Gets help text.
            Uses <msdn>IAccessible.get_accHelp</msdn>.
            </summary>
            <remarks>
            Returns "" if this property is unavailable or if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="P:Au.Acc.UiaId">
            <summary>
            Gets UI Automation element AutomationId property.
            </summary>
            <remarks>
            Only objects found with flag <see cref="F:Au.Types.AFFlags.UIA"/> can have this property.
            Returns "" if this property is unavailable or if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="P:Au.Acc.KeyboardShortcut">
            <summary>
            Gets keyboard shortcut.
            Uses <msdn>IAccessible.get_accKeyboardShortcut</msdn>.
            </summary>
            <remarks>
            Returns "" if this property is unavailable or if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="P:Au.Acc.DefaultAction">
            <summary>
            Gets default action.
            Uses <msdn>IAccessible.get_accDefaultAction</msdn>.
            </summary>
            <remarks>
            Returns "" if this property is unavailable or if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            If this is a Java accessible object, returns all actions that can be used with <see cref="M:Au.Acc.DoJavaAction(System.String)"/>, like "action1, action2, action3", from which the first is considered default and is used by <see cref="M:Au.Acc.DoAction"/>.
            </remarks>
        </member>
        <member name="M:Au.Acc.DoAction">
            <summary>
            Performs the object's default action (see <see cref="P:Au.Acc.DefaultAction"/>). Usually it is 'click', 'press' or similar.
            Uses <msdn>IAccessible.accDoDefaultAction</msdn>.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Fails if the object does not have a default action. Then you can use <see cref="M:Au.Types.ExtensionMethods.MouseClick(Au.Acc,Au.Types.Coord,Au.Types.Coord,Au.Types.MButton)" r=""/>, or try <see cref="M:Au.Acc.VirtualClick"/>, <see cref="M:Au.Acc.Select(Au.Types.AccSELFLAG)"/>, <see cref="M:Au.Acc.Focus(System.Boolean)"/> and keyboard functions.
            The action can take long time, for example show a dialog. This function normally does not wait. It allows the caller to automate the dialog. If it waits, try <see cref="M:Au.Acc.DoJavaAction(System.String)"/> or one of the above functions (MouseClick etc).
            </remarks>
        </member>
        <member name="M:Au.Acc.VirtualClick">
            <summary>
            Posts mouse-left-click message to the container window, using coordinates of this object.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to get rectangle, or the object is invisible/offscreen.</exception>
            <remarks>
            Does not move the mouse.
            Does not wait until the target application finishes processing the message.
            Works not with all objects.
            Use (try) this function when the object does not support <see cref="M:Au.Acc.DoAction"/>. When both don't work, use MouseClick.
            </remarks>
        </member>
        <member name="M:Au.Acc.VirtualRightClick">
            <summary>
            Posts mouse-right-click message to the container window, using coordinates of this object.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to get rectangle, or the object is invisible/offscreen.</exception>
            <remarks>
            Does not move the mouse.
            Does not wait until the target application finishes processing the message.
            Works not with all objects. When does not work, use MouseClick.
            </remarks>
        </member>
        <member name="M:Au.Acc.DoJavaAction(System.String)">
            <summary>
            Performs one of actions supported by this Java accessible object.
            </summary>
            <param name="action">
            Action name. See <see cref="P:Au.Acc.DefaultAction"/>.
            If null (default), performs default action (like <see cref="M:Au.Acc.DoAction"/>) or posts Space key message. More info in Remarks.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Read more about Java accessible objects in <see cref="T:Au.Acc"/> topic.
            
            Problem: if the action opens a dialog, DoAction/DoJavaAction do not return until the dialog is closed (or fail after some time). The caller then waits and cannot automate the dialog. Also then this process cannot exit until the dialog is closed. If the action parameter is null and the object is focusable, this function tries a workaround: it makes the object (button etc) focused and posts Space key message, which should press the button; then this function does not wait.
            </remarks>
        </member>
        <member name="M:Au.Acc.DoActionAndWaitForNewWebPage(System.Double,System.Action{Au.Acc})">
            <summary>
            Calls <see cref="M:Au.Acc.DoAction"/> or <paramref name="action"/> and waits until window name changes and web page name changes.
            </summary>
            <param name="secondsTimeout">
            <inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/>
            Default 60 seconds.
            </param>
            <param name="action">If used, calls it instead of <see cref="M:Au.Acc.DoAction"/>.</param>
            <returns><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></returns>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
            <exception cref="T:Au.Types.AuException">Failed. For example, when this object is invalid, or its top-level window does not contain a web page.</exception>
            <exception cref="T:Au.Types.WndException">The window was closed while waiting.</exception>
            <exception cref="T:System.Exception">Exceptions thrown by <see cref="M:Au.Acc.DoAction"/> or by the <paramref name="action"/> function.</exception>
            <remarks>
            This function is used to click a link in a web page and wait until current web page is gone. It prevents a following 'wait for object' function from finding a matching object in the old page, which would be bad.
            This function does not wait until the new page is completely loaded. There is no reliable/universal way for it. Instead, after calling it you can call a 'wait for object' function which waits for a known object that must be in the new page.
            This function cannot be used when the new page has the same title as current page. Then it waits until <paramref name="secondsTimeout"/> time or forever. The same if the action does not open a web page.
            </remarks>
        </member>
        <member name="M:Au.Acc.Select(Au.Types.AccSELFLAG)">
            <summary>
            Selects or deselects.
            </summary>
            <param name="how">Specifies whether to select, focus, add to selection etc. Can be two flags, for example <c>AccSELFLAG.TAKEFOCUS | AccSELFLAG.TAKESELECTION</c>.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <exception cref="T:Au.Types.WndException">Failed to activate the window (<see cref="M:Au.Wnd.Activate"/>) or focus the control (<see cref="M:Au.Wnd.Focus"/>).</exception>
            <remarks>
            Uses <msdn>IAccessible.accSelect</msdn>.
            Not all objects support it. Most objects support not all flags. It depends on object <see cref="T:Au.Types.AccSTATE">states</see> FOCUSABLE, SELECTABLE, MULTISELECTABLE, EXTSELECTABLE, DISABLED.
            Many object have bugs, especially with flag TAKEFOCUS. More bugs when the object found with flag <see cref="F:Au.Types.AFFlags.NotInProc"/>.
            </remarks>
        </member>
        <member name="M:Au.Acc.Focus(System.Boolean)">
            <summary>
            Makes this object focused for keyboard input.
            </summary>
            <param name="andSelect">Add flag TAKESELECTION. Note: it is for selecting a list item, not for selecting text in a text box.</param>
            <remarks>
            Calls <see cref="M:Au.Acc.Select(Au.Types.AccSELFLAG)"/> with flag TAKEFOCUS and optionally TAKESELECTION.
            Not all objects support this action and not all work correctly. More info in Select documentation.
            </remarks>
        </member>
        <member name="P:Au.Acc.SelectedChildren">
            <summary>
            Gets selected direct child items.
            Returns empty array if there are no selected items of if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
        </member>
        <member name="P:Au.Acc.ChildCount">
            <summary>
            Gets the number of direct child objects.
            Uses <msdn>IAccessible.get_accChildCount</msdn>.
            </summary>
        </member>
        <member name="M:Au.Acc.GetProperties(System.String,Au.Types.AccProperties@)">
            <summary>
            Gets multiple properties.
            </summary>
            <param name="props">
            Which properties to get. Each character specifies a property:
            'R' - <see cref="P:Au.Acc.Role"/>.
            'n' - <see cref="P:Au.Acc.Name"/>.
            'v' - <see cref="P:Au.Acc.Value"/>.
            'd' - <see cref="P:Au.Acc.Description"/>.
            'h' - <see cref="P:Au.Acc.Help"/>.
            'a' - <see cref="P:Au.Acc.DefaultAction"/>.
            'k' - <see cref="P:Au.Acc.KeyboardShortcut"/>.
            'u' - <see cref="P:Au.Acc.UiaId"/>.
            's' - <see cref="P:Au.Acc.State"/>.
            'r' - <see cref="P:Au.Acc.Rect"/>.
            'w' - <see cref="P:Au.Acc.WndContainer"/>.
            'o' - <see cref="M:Au.Acc.Html(System.Boolean)"/> outer.
            'i' - <see cref="M:Au.Acc.Html(System.Boolean)"/> inner.
            '@' - <see cref="M:Au.Acc.HtmlAttributes"/>.
            </param>
            <param name="result">Receives results.</param>
            <exception cref="T:System.ArgumentException">Unknown property character.</exception>
            <remarks>
            The returned variable contains values of properties specified in <paramref name="props"/>. When a property is empty or failed to get, the member variable is "", empty dictionary or default value of that type; never null.
            
            Normally this function is faster than calling multiple property functions, because it makes single remote procedure call. But not if this accessible object was found with flag <see cref="F:Au.Types.AFFlags.NotInProc"/> etc.
            
            Returns false if fails, for example when the object's window is closed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="M:Au.Acc.Navigate(System.String,System.Double)">
            <summary>
            Gets an adjacent or related accessible object (AO) - next, child, parent, etc.
            Returns null if not found.
            </summary>
            <param name="navig">
            String consisting of one or more navigation direction strings separated by space, like "parent next child4 first".
            <list type="bullet">
            <item>"next" - next sibling AO in the same parent AO.</item>
            <item>"previous" - previous sibling AO in the same parent AO.</item>
            <item>"first" - first child AO.</item>
            <item>"last" - last child AO.</item>
            <item>"parent" - parent (container) AO.</item>
            <item>"child" - child AO by 1-based index. Example: "child3" (3-th child). Negative index means from end, for example -1 is the last child.</item>
            <item>"#N" - N is a numeric value to pass to <msdn>IAccessible.accNavigate</msdn> as navDir. Can be any standard or custom value supported by the AO.</item>
            </list>
            Can be only 2 letters, like "pr" for "previous".
            A string like "next3" or "next,3" is the same as "next next next". Except for "child".
            
            For "next", "previous", "firstchild", "lastchild", "#N" is used <msdn>IAccessible.accNavigate</msdn>. Not all AOs support it. Some AOs skip invisible siblings. Instead you can use "parent childN" or "childN".
            For "parent" is used <msdn>IAccessible.get_accParent</msdn>. Few AOs don't support. Some AOs return a different parent than in the AO tree.
            For "child" is used API <msdn>AccessibleChildren</msdn>.
            </param>
            <param name="secondsToWait">Wait for the wanted AO max this number of seconds. If negative, waits forever.</param>
            <exception cref="T:System.ArgumentException">Invalid navig string.</exception>
            <example>
            <code><![CDATA[
            a = a.Navigate("parent next ch3", true);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Acc.Html(System.Boolean)">
            <summary>
            Gets HTML.
            </summary>
            <param name="outer">If true, gets outer HTML (with tag and attributes), else inner HTML.</param>
            <remarks>
            Returns "" if this is not a HTML element or if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            Works with Firefox, Chrome, Internet Explorer and apps that use their code (Thunderbird, Opera, web browser controls...). This object must be found without flag NotInProc.
            If this is the root of web page (role DOCUMENT or PANE), gets web page body HTML.
            </remarks>
        </member>
        <member name="M:Au.Acc.HtmlAttribute(System.String)">
            <summary>
            Gets a HTML attribute.
            </summary>
            <param name="name">Attribute name, for example "href", "id", "class". Full, case-sensitive.</param>
            <remarks>
            Returns "" if this is not a HTML element or does not have the specified attribute or failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            Works with Firefox, Chrome, Internet Explorer and apps that use their code (Thunderbird, Opera, web browser controls...). This object must be found without flag NotInProc.
            </remarks>
            <exception cref="T:System.ArgumentException">name is null/""/invalid.</exception>
        </member>
        <member name="M:Au.Acc.HtmlAttributes">
            <summary>
            Gets all HTML attributes.
            </summary>
            <remarks>
            Returns empty dictionary if this is not a HTML element or does not have attributes or failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            Works with Firefox, Chrome, Internet Explorer and apps that use their code (Thunderbird, Opera, web browser controls...). This object must be found without flag NotInProc.
            </remarks>
        </member>
        <member name="M:Au.Acc.ScrollTo">
            <summary>
            Scrolls this accessible object into view.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to scroll, or the object does not support scrolling.</exception>
            <remarks>
            This function works with these objects:
            <list type="bullet">
            <item>Web page objects in Firefox, Chrome, Internet Explorer and apps that use their code (Thunderbird, Opera, web browser controls...). With Find use role prefix "web:", "firefox:" or "chrome:", and don't use flag <see cref="F:Au.Types.AFFlags.NotInProc"/>.</item>
            <item>Objects in Edge browser, standard treeview and listview controls, some other. With Find use flag <see cref="F:Au.Types.AFFlags.UIA"/>.</item>
            </list>
            </remarks>
        </member>
        <member name="T:Au.Acc.Finder">
            <summary>
            Contains accessible object (AO) properties and is used to find the AO.
            </summary>
            <remarks>
            Can be used instead of <see cref="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,System.String,Au.Wnd.ChildFinder)"/>.
            </remarks>
            <example>
            Find window that contains certain AO, and get the AO too.
            <code><![CDATA[
            var f = new Acc.Finder("BUTTON", "Apply"); //AO properties
            Wnd w = Wnd.Find(className: "#32770", also: t => f.Find(t));
            Print(w);
            Print(f.Result);
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Acc.Finder.Result">
            <summary>
            The found accessible object.
            null if not found. null if used <see cref="P:Au.Acc.Finder.ResultGetProperty"/>.
            </summary>
        </member>
        <member name="P:Au.Acc.Finder.ResultProperty">
            <summary>
            The requested propery of the found accessible object, depending on <see cref="P:Au.Acc.Finder.ResultGetProperty"/>.
            null if: 1. Object not found. 2. <b>ResultGetProperty</b> not used or is '-'. 3. Failed to get the property.
            </summary>
            <remarks>
            The type depends on the property. Most properties are String. Others: <see cref="P:Au.Acc.Rect"/>, <see cref="P:Au.Acc.State"/>, <see cref="P:Au.Acc.WndContainer"/>, <see cref="M:Au.Acc.HtmlAttributes"/>.
            </remarks>
        </member>
        <member name="P:Au.Acc.Finder.ResultGetProperty">
            <summary>
            Set this when you need only some property of the accessible object (name, etc) and not the object itself.
            The value is a character, the same as with <see cref="M:Au.Acc.GetProperties(System.String,Au.Types.AccProperties@)"/>, for example 'n' for Name. Use '-' if you don't need any property.
            </summary>
            <exception cref="T:System.ArgumentException">Used parameter <i>also</i> or <i>navig</i>.</exception>
        </member>
        <member name="P:Au.Acc.Finder.NavigFailed">
            <summary>
            true if used parameter <i>navig</i> and the intermediate object was found but the navigation did not find the final object.
            </summary>
        </member>
        <member name="M:Au.Acc.Finder.#ctor(System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,System.String)">
            <summary>
            Stores the specified accessible object properties in this object. Reference: <see cref="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,System.String,Au.Wnd.ChildFinder)"/>.
            Does not search now. For it call <b>Find</b> or <b>Wait</b>.
            </summary>
        </member>
        <member name="M:Au.Acc.Finder.Find(Au.Wnd,Au.Wnd.ChildFinder)">
            <summary>
            Finds accessible object (AO) in the specified control of window w.
            Returns true if found. The <see cref="P:Au.Acc.Finder.Result"/> property will be the found AO.
            </summary>
            <param name="w">Window that contains the control.</param>
            <param name="controls">Control properties. This functions searches in all matching controls.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Acc.Finder.Find(Au.Wnd)"/>.</exception>
            <remarks>
            Alternatively you can specify control class name or id in role. How this function is different: 1. Allows to specify more control properties. 2. Works better/faster when the control is of a different process or thread than the parent window; else slightly slower.
            </remarks>
        </member>
        <member name="M:Au.Acc.Finder.Find(Au.Wnd)">
            <summary>
            Finds accessible object (AO) in window w, like <see cref="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,System.String,Au.Wnd.ChildFinder)"/>.
            Returns true if found. The <see cref="P:Au.Acc.Finder.Result"/> property will be the found AO.
            </summary>
            <param name="w">Window or control that contains the AO.</param>
            <exception cref="T:System.ArgumentException">
            <i>role</i> is "" or invalid.
            <i>name</i> is invalid wildcard expression ("**options " or regular expression).
            <i>prop</i> has invalid format or contains unknown property names or invalid wildcard expressions.
            Using flag <see cref="F:Au.Types.AFFlags.UIA"/> when searching in web page (role prefix "web:" etc).
            </exception>
            <exception cref="T:Au.Types.WndException">Invalid window.</exception>
            <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher <see cref="T:Au.Process_.UacInfo">UAC</see> integrity level process.</exception>
        </member>
        <member name="M:Au.Acc.Finder.Find(Au.Acc)">
            <summary>
            Finds accessible object (AO) in another AO, like <see cref="M:Au.Acc.Find(System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,System.String)"/>.
            Returns true if found. The <see cref="P:Au.Acc.Finder.Result"/> property will be the found AO.
            </summary>
            <param name="a">Direct or indirect parent AO.</param>
            <exception cref="T:System.ArgumentNullException">a is null.</exception>
            <exception cref="T:System.ArgumentException">
            <i>role</i> is "" or invalid or has a prefix ("web:" etc).
            <i>name</i> is invalid wildcard expression ("**options " or regular expression).
            <i>prop</i> has invalid format or contains unknown property names or invalid wildcard expressions.
            Using flag <see cref="F:Au.Types.AFFlags.UIA"/>.
            <see cref="P:Au.Acc.SimpleElementId"/> is not 0.
            </exception>
            <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher <see cref="T:Au.Process_.UacInfo">UAC</see> integrity level process.</exception>
        </member>
        <member name="M:Au.Acc.Finder.Wait(System.Double,Au.Wnd)">
            <summary>
            Finds accessible object (AO) in window w.
            The same as <see cref="M:Au.Acc.Finder.Find(Au.Wnd)"/>, but waits until the AO is found or the given time expires.
            </summary>
            <param name="secondsTimeout"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></param>
            <param name="w">Window or control that contains the AO.</param>
            <returns><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></returns>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Acc.Finder.Find(Au.Wnd)"/>.</exception>
        </member>
        <member name="M:Au.Acc.Finder.Wait(System.Double,Au.Acc)">
            <summary>
            Finds accessible object (AO) in another AO.
            The same as <see cref="M:Au.Acc.Finder.Find(Au.Acc)"/>, but waits until the AO is found or the given time expires.
            </summary>
            <param name="secondsTimeout"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></param>
            <param name="a">Direct or indirect parent AO.</param>
            <returns><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></returns>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Acc.Finder.Find(Au.Acc)"/>.</exception>
        </member>
        <member name="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,System.String,Au.Wnd.ChildFinder)">
             <summary>
             Finds accessible object (AO) in window.
             Returns the found AO. Returns null if not found. See examples.
             </summary>
             <param name="w">Window or control that contains the AO.</param>
             <param name="role">
             AO role, like "LINK". Or path, like "ROLE/ROLE/ROLE".
             See <see cref="P:Au.Acc.Role"/>. Can be used standard roles (see <see cref="T:Au.Types.AccROLE"/>) and custom roles (like "div" in Firefox).
             This parameter is string. If you want to use <see cref="T:Au.Types.AccROLE"/>: <c>nameof(AccROLE.CHECKBOX)</c>.
             Case-sensitive, not wildcard. Use null to match any role. Cannot be "".
             
             Role or path can have a prefix:
             <list type="bullet">
             <item>
             "web:" - search only in the visible web page, not in whole window.
             Examples: "web:LINK", "web:/LIST/LISTITEM/LINK".
             Supports Firefox, Chrome, Internet Explorer (IE) and apps that use their code. With other windows, searches in the first found visible AO that has DOCUMENT role.
             <note type="note">Chrome web page accessible objects normally are disabled (don't exist). Use prefix "web:" or "chrome:" to enable.</note>
             Tip: To search only NOT in web pages, use <paramref name="prop"/> "notin=DOCUMENT" (Chrome, Firefox) or "notin=PANE" (IE).
             </item>
             <item>"firefox:" - search only in the visible web page of Firefox or Firefox-based web browser. If w window class name starts with "Mozilla", can be used "web:" instead.</item>
             <item>"chrome:" - search only in the visible web page of Chrome or Chrome-based web browser. If w window class name starts with "Chrome", can be used "web:" instead.</item>
             </list>
             Prefix cannot be used if: <paramref name="prop"/> contains "id" or "class"; with flag <see cref="F:Au.Types.AFFlags.UIA"/>; searching in Acc (<see cref="M:Au.Acc.Find(System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,System.String)"/>).
            
             Can be used path consisting of roles separated by "/". Examples:
             <list type="bullet">
             <item>"web:DOCUMENT/div/LIST/LISTITEM/LINK" - find LINK using its full path in web page.</item>
             <item>"web:/div/LIST//LINK" - the empty parts mean 'any role'. For example don't need to specify DOCUMENT because in web pages the first part is always DOCUMENT (Firefox, Chrome) or PANE (IE).</item>
             <item>"web:/div/LIST[4]/LISTITEM[-1]/LINK" - the 4 is 1-based index of div child from which to start searching (4-th, then 3-th, 5-th and so on). It can make faster. Negative means 'index from end', for example use -1 to search in reverse order. Flag <see cref="F:Au.Types.AFFlags.Reverse"/> is not applied to path parts with indexes. If index is invalid, will use the nearest valid index.</item>
             <item>"web:/div/LIST[4!]/LISTITEM[-1!]/LINK" - like the above, but the LIST must be exactly 4-th child (don't search 3-th, 5-th etc) and the LISTITEM must be the last child. This can be useful when waiting (uses less CPU), however useless if AO indices in the window or web page change often.</item>
             <item>"web://[4]/[-1!]/[2]" - index without role.</item>
             <item>"CLIENT/WINDOW/TREE/TREEITEM[-1]" - path in window or control. The first path part is a direct child AO of the WINDOW AO of the window/control. The WINDOW AO itself is not included in the search; if you need it, instead use <see cref="M:Au.Acc.FromWindow(Au.Wnd,Au.Types.AccOBJID,Au.Types.AWFlags)"/>.</item>
             </list>
             </param>
             <param name="name">
             AO name (<see cref="P:Au.Acc.Name"/>).
             String format: <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">wildcard expression</conceptualLink>.
             null means 'any'. "" means 'empty or unavailable'.
             </param>
             <param name="prop">
             Other AO properties and search settings.
             Format: one or more "name=value", separated with "\0" or "\0 ", like "description=xxx\0 @href=yyy". Names must match case. Values of string properties are wildcard expressions.
             
             <list type="bullet">
             <item>
             "class" - search only in child controls that have this class name (see <see cref="P:Au.Wnd.ClassName"/>).
             Cannot be used when searching in Acc.
             </item>
             <item>
             "id" - search only in child controls that have this id (see <see cref="P:Au.Wnd.ControlId"/>).
             Cannot be used when searching in Acc.
             </item>
             <item>
             "value" - <see cref="P:Au.Acc.Value"/>.
             </item>
             <item>
             "description" - <see cref="P:Au.Acc.Description"/>.
             </item>
             <item>
             "state" - <see cref="P:Au.Acc.State"/>. List of states that the AO must have and/or not have.
             Example: "state=CHECKED, FOCUSABLE, !DISABLED".
             Example: "state=0x100010, !0x1".
             Will find AO that has all states without "!" prefix and does not have any of states with "!" prefix.
             </item>
             <item>
             "rect" - <see cref="P:Au.Acc.Rect"/>. Can be specified left, top, width and/or height, using <see cref="M:Au.Types.RECT.ToString"/> format.
             Example: "rect={L=1155 T=1182 W=132 H=13}".
             Example: "rect={W=132 T=1182}".
             The L T coordinates are relative to the primary screen.
             </item>
             <item>
             "level" - level (see <see cref="P:Au.Acc.Level"/>) at which the AO can be found. Can be exact level, or minimal and maximal level separated by space.
             The default value is 0 1000.
             Alternatively you can use path in role, like "////LINK".
             </item>
             <item>
             "elem" - <see cref="P:Au.Acc.SimpleElementId"/>.
             </item>
             <item>
             "action" - <see cref="P:Au.Acc.DefaultAction"/>.
             </item>
             <item>
             "key" - <see cref="P:Au.Acc.KeyboardShortcut"/>.
             </item>
             <item>
             "help" - <see cref="P:Au.Acc.Help"/>.
             </item>
             <item>
             "uiaid" - <see cref="P:Au.Acc.UiaId"/>.
             </item>
             <item>
             "maxcc" - when searching, skip children of AO that have more than this number of direct children. It can make faster.
             The default value is 10000. It also prevents hanging or crashing when an AO in the object tree has large number of children. For example OpenOffice Calc TABLE has one billion children.
             </item>
             <item>
             "notin" - when searching, skip children of AO that have these roles. It can make faster.
             Example: "notin=TREE,LIST,TOOLBAR".
             Roles in the list must be separated with "," or ", ". Case-sensitive, not wildcard.
             See also: <see cref="F:Au.Types.AFFlags.MenuToo"/>.
             </item>
             <item>
             "@attr" - <see cref="M:Au.Acc.HtmlAttribute(System.String)"/>. Here "attr" is any attribute name.
             Example: "@id=example".
             </item>
             </list>
             </param>
             <param name="flags"></param>
             <param name="also">
             Callback function. Called for each matching AO. Let it return true if this is the wanted AO.
             Example, the AO must contain point x y: <c>o => o.GetRect(out var r, o.WndTopLevel) &amp;&amp; r.Contains(266, 33)</c>
             </param>
             <param name="skip">
             0-based index of matching AO.
             For example, if 1, the function skips the first matching AO and returns the second.
             </param>
             <param name="navig">If not null, call <see cref="M:Au.Acc.Navigate(System.String,System.Double)"/> with this string and return its result.</param>
             <param name="controls">
             Properties of child controls where to search.
             This is an alternative for class/id in <paramref name="prop"/>. Allows to specify more control properties. Works better/faster when the control is of a different process or thread than the parent window; else slightly slower.
             </param>
             <exception cref="T:System.ArgumentException">
             <paramref name="role"/> is "" or invalid.
             <paramref name="name"/> is invalid wildcard expression ("**options " or regular expression).
             <paramref name="prop"/> has invalid format or contains unknown property names or invalid wildcard expressions.
             <paramref name="navig"/> string is invalid.
             Using flag <see cref="F:Au.Types.AFFlags.UIA"/> when searching in web page (role prefix "web:" etc).
             </exception>
             <exception cref="T:Au.Types.WndException">Invalid window (if the function has parameter <paramref name="w"/>).</exception>
             <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher <see cref="T:Au.Process_.UacInfo">UAC</see> integrity level process.</exception>
             <remarks>
             To create code for this function, use dialog "Find accessible object". It is form <b>Au.Tools.Form_Acc</b> in Au.Tools.dll.
             
             Walks the tree of accessible objects, until finds a matching AO.
             Uses <see cref="T:Au.Acc.Finder"/>. You can use it directly. See example.
             In wildcard expressions supports PCRE regular expressions (prefix "**r ") but not .NET regular expressions (prefix "**R "). They are similar.
             To find web page AOs usually it's better to use <see cref="M:Au.Acc.Wait(System.Double,Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,System.String)"/> instead, it's more reliable.
             More info in <see cref="T:Au.Acc"/> topic.
             </remarks>
             <example>
             Find link "Example" in web page, and click. Throw NotFoundException if not found.
             <code><![CDATA[
             var w = Wnd.Find("* Chrome").OrThrow();
             var a = Acc.Find(w, "web:LINK", "Example").OrThrow();
             a.DoAction();
             ]]></code>
             Try to find link "Example" in web page. Return if not found.
             <code><![CDATA[
             var w = Wnd.Find("* Chrome").OrThrow();
             var a = Acc.Find(w, "web:LINK", "Example");
             if(a == null) { Print("not found"); return; }
             a.DoAction();
             ]]></code>
             Use a Finder.
             <code><![CDATA[
             var w = Wnd.Find("* Chrome").OrThrow();
             var f = new Acc.Finder("BUTTON", "Example");
             if(!f.Find(w)) { Print("not found"); return; }
             Acc a = f.Result;
             a.DoAction();
             ]]></code>
             </example>
        </member>
        <member name="M:Au.Acc.Find(System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,System.String)">
            <inheritdoc cref="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,System.String,Au.Wnd.ChildFinder)"/>
            <summary>
            Finds a descendant accessible object (AO) of this AO.
            Returns the found AO. Returns null if not found.
            </summary>
            <exception cref="T:System.ArgumentException">
            <paramref name="role"/> is "" or invalid or has a prefix ("web:" etc).
            <paramref name="name"/> is invalid wildcard expression ("**options " or regular expression).
            <paramref name="prop"/> has invalid format or contains unknown property names or invalid wildcard expressions or "class", "id".
            <paramref name="navig"/> string is invalid.
            Using flag <see cref="F:Au.Types.AFFlags.UIA"/>.
            <see cref="P:Au.Acc.SimpleElementId"/> is not 0.
            </exception>
        </member>
        <member name="M:Au.Acc.Wait(System.Double,Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,System.String)">
            <inheritdoc cref="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,System.String,Au.Wnd.ChildFinder)"/>
            <summary>
            Finds accessible object (AO) in window. Waits until the AO is found or the given time expires.
            </summary>
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits infinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, after that time interval returns null.
            </param>
            <returns>Returns the found AO. On timeout returns null if <paramref name="secondsTimeout"/> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
        </member>
        <member name="M:Au.Acc.Wait(System.Double,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,System.String)">
            <inheritdoc cref="M:Au.Acc.Find(System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,System.String)"/>
            <summary>
            Finds a descendant accessible object (AO) of this AO. Waits until the AO is found or the given time expires.
            </summary>
            <param name="secondsTimeout"><inheritdoc cref="M:Au.Acc.Wait(System.Double,Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,System.String)"/></param>
            <returns><inheritdoc cref="M:Au.Acc.Wait(System.Double,Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,System.String)"/></returns>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.Acc.Wait(System.Double,Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,System.String)"/></exception>
        </member>
        <member name="M:Au.Acc.FindAll(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean})">
            <inheritdoc cref="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,System.String,Au.Wnd.ChildFinder)"/>
            <summary>
            Finds all matching accessible objects in window.
            Returns array of 0 or more elements.
            </summary>
            <example>
            Get all taskbar buttons (Windows 10).
            <code><![CDATA[
            var w = Wnd.Find(null, "Shell_TrayWnd").OrThrow();
            foreach(var a in Acc.FindAll(w, "BUTTON", prop: "level=7")) Print(a);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Acc.FindAll(System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean})">
            <inheritdoc cref="M:Au.Acc.Find(System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,System.String)"/>
            <summary>
            Finds all matching descendant accessible objects (AO) of this AO.
            Returns array of 0 or more elements.
            </summary>
            <example>
            Get all taskbar buttons (Windows 10).
            <code><![CDATA[
            var w = Wnd.Find(null, "Shell_TrayWnd").OrThrow();
            var atb = Acc.Find(w, "TOOLBAR", "Running applications").OrThrow();
            foreach(var a in atb.FindAll("BUTTON", prop: "level=0")) Print(a);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Acc.#ctor(System.IntPtr,System.Int32,System.Boolean)">
            <summary>
            Creates Acc from IAccessible and child id.
            By default does not AddRef.
            iacc must not be Is0.
            </summary>
        </member>
        <member name="M:Au.Acc.#ctor(Au.Types.Cpp.Cpp_Acc,System.Boolean)">
            <summary>
            Creates Acc from Cpp_Acc.
            By default does not AddRef.
            x.acc must not be Is0.
            </summary>
        </member>
        <member name="M:Au.Acc._Set(System.IntPtr,System.Int32,Au.Acc._Misc,System.Boolean)">
            <summary>
            Sets fields.
            _iacc must be 0, iacc not 0.
            </summary>
        </member>
        <member name="M:Au.Acc.Dispose(System.Boolean)">
            
        </member>
        <member name="M:Au.Acc.Dispose">
            <summary>
            Releases IAccessible COM object and clears this variable.
            </summary>
        </member>
        <member name="M:Au.Acc.Finalize">
            
        </member>
        <member name="P:Au.Acc.SimpleElementId">
            <summary>
            Gets or changes simple element id, also known as child id.
            </summary>
            <remarks>
            Most accessible objects (AO) are not simple elements. Then this property is 0.
            Often (but not always) this property is the 1-based item index in parent AO. For example LISTITEM in LIST.
            The 'set' function sometimes can be used as a fast alternative to <see cref="M:Au.Acc.Navigate(System.String,System.Double)"/>. It modifies only this variable. It does not check whether the value is valid.
            Simple elements cannot have child AOs.
            </remarks>
        </member>
        <member name="P:Au.Acc.MiscFlags">
            <summary>
            Returns some additional info about this variable, such as how the accessible object was retrieved (inproc, UIA, Java).
            </summary>
        </member>
        <member name="P:Au.Acc.Level">
            <summary>
            Gets or sets indentation level for <see cref="M:Au.Acc.ToString"/>.
            </summary>
            <remarks>
            When Find or similar function finds an accessible object, it sets this property of the Acc variable.
            When searching in a window or control, at level 0 are direct children of the WINDOW object of the window or control. When searching in Acc, at level 0 are direct children of the Acc. When searching in web page (role prefix "web:" etc), at level 0 is the web page object (role DOCUMENT or PANE).
            </remarks>
        </member>
        <member name="P:Au.Acc._Disposed">
            <summary>
            Returns true if this variable is disposed.
            </summary>
        </member>
        <member name="M:Au.Acc.FromWindow(Au.Wnd,Au.Types.AccOBJID,Au.Types.AWFlags)">
            <summary>
            Gets accessible object of window or control or its standard part - client area, titlebar etc.
            Uses API <msdn>AccessibleObjectFromWindow</msdn>.
            </summary>
            <param name="w">Window or control.</param>
            <param name="objid">Window part id. Default AccOBJID.WINDOW. Also can be a custom id supported by that window, cast int to AccOBJID.</param>
            <param name="flags">Flags.</param>
            <exception cref="T:Au.Types.WndException">Invalid window.</exception>
            <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher <see cref="T:Au.Process_.UacInfo">UAC</see> integrity level process.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="objid"/> is QUERYCLASSNAMEIDX or NATIVEOM.</exception>
        </member>
        <member name="M:Au.Acc.FromXY(Au.Types.POINT,Au.Types.AXYFlags)">
            <summary>
            Gets accessible object from point.
            </summary>
            <param name="p">
            Coordinates relative to the primary screen.
            Tip: When need coordinates relative to another screen or/and the work area, use <see cref="M:Au.Types.Coord.Normalize(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.Types.Screen_,System.Boolean,System.Boolean)"/> or tuple (x, y, workArea) etc. Example: <c>var a = Acc.FromXY((x, y, true));</c>. Also when need <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.
            </param>
            <param name="flags"></param>
            <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher <see cref="T:Au.Process_.UacInfo">UAC</see> integrity level process.</exception>
            <remarks>
            Uses API <msdn>AccessibleObjectFromPoint</msdn>.
            </remarks>
        </member>
        <member name="M:Au.Acc.FromMouse(Au.Types.AXYFlags)">
            <summary>
            Gets accessible object from mouse cursor (pointer) position.
            Uses API <msdn>AccessibleObjectFromPoint</msdn>.
            </summary>
            <param name="flags"></param>
            <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher <see cref="T:Au.Process_.UacInfo">UAC</see> integrity level process.</exception>
        </member>
        <member name="M:Au.Acc.Focused(System.Boolean)">
            <summary>
            Gets the accessible object that has the keyboard focus.
            Returns null if fails.
            </summary>
            <param name="useUIAutomation">
            Use UI Automation API.
            Need this with windows that don't support accessible objects but support UI Automation elements. Can be used with most other windows too.
            More info: <see cref="F:Au.Types.AFFlags.UIA"/>.
            </param>
        </member>
        <member name="M:Au.Acc.FromEvent(Au.Wnd,System.Int32,System.Int32)">
            <summary>
            Gets the accessible object that generated the event that is currently being processed by the callback function used with API <msdn>SetWinEventHook</msdn> or <see cref="T:Au.Util.AccHook"/>.
            Returns null if failed. Suports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <param name="w"></param>
            <param name="idObject"></param>
            <param name="idChild"></param>
            <remarks>
            The parameters are of the callback function.
            Uses API <msdn>AccessibleObjectFromEvent</msdn>.
            Often fails because the object already does not exist, because the callback function is called asynchronously, especially when the event is OBJECT_DESTROY, OBJECT_HIDE, SYSTEM_*END.
            Returns null if failed. Always check the return value, to avoid NullReferenceException. An exception in the callback function kills this process.
            </remarks>
        </member>
        <member name="T:Au.Acc._FuncId">
            <summary>
            Used only for debug.
            </summary>
        </member>
        <member name="M:Au.Acc._Hresult(Au.Acc._FuncId,System.Int32)">
            <summary>
            Calls Native.SetError and returns hr.
            In Debug config also outputs error in red.
            If hr looks like not an error but just the property or action is unavailable, changes it to S_FALSE and does not show error. These are: S_FALSE, DISP_E_MEMBERNOTFOUND, E_NOTIMPL.
            _FuncId also can be char, like (_FuncId)'n' for name.
            </summary>
        </member>
        <member name="M:Au.Acc.ToString">
            <summary>
            Formats string from main properties of this accessible object.
            </summary>
            <remarks>
            The string starts with role. Other properties have format like x="value", where x is a property character like with <see cref="M:Au.Acc.GetProperties(System.String,Au.Types.AccProperties@)"/>; character e is <see cref="P:Au.Acc.SimpleElementId"/>. HTML attributes have format @name="value". In string values are used C# escape sequences, for example \r\n for new line.
            Indentation depends on <see cref="P:Au.Acc.Level"/>.
            </remarks>
            <seealso cref="M:Au.Acc.PrintAll(Au.Wnd,System.String,Au.Types.AFFlags,System.String)"/>
        </member>
        <member name="M:Au.Acc.PrintAll(Au.Wnd,System.String,Au.Types.AFFlags,System.String)">
            <summary>
            Displays properties of all found accessible objects of window w.
            </summary>
            <remarks>
            Uses <see cref="M:Au.Acc.ToString"/>.
            Catches exceptions. On exception prints $"!exception! exceptionType exceptionMessage".
            Parameters are of <see cref="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,System.String,Au.Wnd.ChildFinder)"/>.
            By default skips invisible objects and objects in menus. Use flags to include them.
            Chrome web page accessible objects normally are disabled (missing) when it starts. Use role prefix "web:" or "chrome:" to enable. See example.
            </remarks>
            <example>
            Displays visible accessible objects in Chrome web page.
            <code><![CDATA[
            Output.Clear();
            var w = Wnd.Find("* Chrome").OrThrow();
            Print("---- all ----");
            Acc.PrintAll(w, "web:");
            Print("---- links ----");
            Acc.PrintAll(w, "web:LINK");
            ]]></code>
            </example>
        </member>
        <member name="T:Au.Util.IconsAsync">
            <summary>
            Gets file icons asynchronously.
            </summary>
            <remarks>
            Use to avoid waiting until all icons are extracted before displaying them in a UI (menu etc).
            Instead you show the UI without icons, and then asynchronously receive icons when they are extracted.
            At first call <see cref="M:Au.Util.IconsAsync.Add(System.String,System.Object)"/> (for each file) or <see cref="M:Au.Util.IconsAsync.AddRange(System.Collections.Generic.IEnumerable{Au.Util.IconsAsync.Item})"/>. Then call <see cref="M:Au.Util.IconsAsync.GetAllAsync(Au.Util.IconsAsync.Callback,System.Int32,Au.Types.GIFlags,System.Object)"/>.
            Create a callback function of type <see cref="T:Au.Util.IconsAsync.Callback"/> and pass its delegate to <b>GetAllAsync</b>.
            </remarks>
            <seealso cref="T:Au.Icons.ImageCache"/>
        </member>
        <member name="M:Au.Util.IconsAsync.Add(System.String,System.Object)">
            <summary>
            Adds a file path to an internal collection.
            </summary>
            <param name="file">File path etc. See <see cref="M:Au.Icons.GetFileIcon(System.String,System.Int32,Au.Types.GIFlags)"/>.</param>
            <param name="obj">Something to pass to your callback function together with icon handle for this file.</param>
        </member>
        <member name="M:Au.Util.IconsAsync.AddRange(System.Collections.Generic.IEnumerable{Au.Util.IconsAsync.Item})">
            <summary>
            Adds multiple file paths to an internal collection.
            The same as calling <see cref="M:Au.Util.IconsAsync.Add(System.String,System.Object)"/> multiple times.
            This function copies the list.
            </summary>
        </member>
        <member name="P:Au.Util.IconsAsync.Count">
            <summary>
            Gets the number of added items.
            <see cref="M:Au.Util.IconsAsync.GetAllAsync(Au.Util.IconsAsync.Callback,System.Int32,Au.Types.GIFlags,System.Object)"/> sets it = 0.
            </summary>
        </member>
        <member name="M:Au.Util.IconsAsync.GetAllAsync(Au.Util.IconsAsync.Callback,System.Int32,Au.Types.GIFlags,System.Object)">
            <summary>
            Starts getting icons of added files.
            </summary>
            <param name="callback">A callback function delegate.</param>
            <param name="iconSize">Icon width and height. Also can be enum <see cref="T:Au.Types.IconSize"/>, cast to int.</param>
            <param name="flags"><see cref="T:Au.Types.GIFlags"/></param>
            <param name="objCommon">Something to pass to callback functions.</param>
            <remarks>
            After this function returns, icons are asynchronously extracted with <see cref="M:Au.Icons.GetFileIconHandle(System.String,System.Int32,Au.Types.GIFlags)"/>, and callback called with icon handle (or default(IntPtr) if failed).
            The callback is called in this thread. This thread must have a message loop (eg Application.Run).
            If you'll need more icons, you can add more files and call this function again with the same <b>IconsAsync</b> instance, even if getting old icons if still not finished.
            </remarks>
        </member>
        <member name="M:Au.Util.IconsAsync.Clear">
            <summary>
            Clears the internal collection of file paths added with Add().
            </summary>
        </member>
        <member name="M:Au.Util.IconsAsync.Cancel">
            <summary>
            Stops getting icons and calling callback functions.
            </summary>
        </member>
        <member name="M:Au.Util.IconsAsync.Dispose">
            <summary>
            Calls <see cref="M:Au.Util.IconsAsync.Cancel"/>.
            </summary>
        </member>
        <member name="M:Au.Util.IconsAsync.Finalize">
            
        </member>
        <member name="T:Au.Util.IconsAsync.Item">
            <summary>
            For <see cref="M:Au.Util.IconsAsync.AddRange(System.Collections.Generic.IEnumerable{Au.Util.IconsAsync.Item})"/>. 
            </summary>
            <tocexclude />
        </member>
        <member name="T:Au.Util.IconsAsync.Result">
            <summary>
            For <see cref="T:Au.Util.IconsAsync.Callback"/>. 
            </summary>
            <tocexclude />
        </member>
        <member name="F:Au.Util.IconsAsync.Result.file">
            <summary>file passed to <see cref="M:Au.Util.IconsAsync.Add(System.String,System.Object)"/>.</summary>
        </member>
        <member name="F:Au.Util.IconsAsync.Result.obj">
            <summary>obj passed to <see cref="M:Au.Util.IconsAsync.Add(System.String,System.Object)"/>.</summary>
        </member>
        <member name="F:Au.Util.IconsAsync.Result.hIcon">
            <summary>Icon handle. To get managed object from it, use <b>Icons.HandleToX</b> functions; else finally call <see cref="M:Au.Icons.DestroyIconHandle(System.IntPtr)"/>. Can be default(IntPtr).</summary>
        </member>
        <member name="M:Au.Util.IconsAsync.Result.#ctor(System.String,System.Object)">
            <summary>Icon converted to Image object, if used IconFlags.NeedImage and the thread pool decided to convert handle to Image. You should call Dispose() when finished using it. Can be null.</summary>
        </member>
        <member name="T:Au.Util.IconsAsync.Callback">
            <summary>
            For <see cref="M:Au.Util.IconsAsync.GetAllAsync(Au.Util.IconsAsync.Callback,System.Int32,Au.Types.GIFlags,System.Object)"/>. 
            </summary>
            <param name="result">Contains icon, as well as the input parameters.</param>
            <param name="objCommon">objCommon passed to <see cref="M:Au.Util.IconsAsync.GetAllAsync(Au.Util.IconsAsync.Callback,System.Int32,Au.Types.GIFlags,System.Object)"/>.</param>
            <param name="nLeft">How many icons is still to get. Eg 0 if this is the last icon.</param>
            <tocexclude />
        </member>
        <member name="T:Au.Util.RegisterHotkey">
            <summary>
            Registers a hotkey using API <msdn>RegisterHotKey</msdn>. Unregisters when disposing.
            </summary>
            <remarks>
            The variable must be disposed, either explicitly (call <b>Dispose</b> or <b>Unregister</b>) or with the 'using' pattern.
            </remarks>
            <example>
            <code><![CDATA[
            static void TestRegisterHotkey()
            {
            	var f = new FormRegisterHotkey();
            	f.ShowDialog();
            }
            
            class FormRegisterHotkey :Form
            {
            	Au.Util.RegisterHotkey _hk1, _hk2;
            
            	protected override void WndProc(ref Message m)
            	{
            		switch(m.Msg) {
            		case Api.WM_CREATE: //0x1
            			bool r1 = _hk2.Register(1, "Ctrl+Alt+F10", this);
            			bool r2 = _hk1.Register(2, (KMod.Ctrl | KMod.Shift, KKey.D), this); //Ctrl+Shift+D
            			Print(r1, r2);
            			break;
            		case Api.WM_DESTROY: //0x2
            			_hk1.Unregister();
            			_hk2.Unregister();
            			break;
            		case RegisterHotkey.WM_HOTKEY:
            			Print(m.WParam);
            			break;
            		}
            		base.WndProc(ref m);
            	}
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Util.RegisterHotkey.Register(System.Int32,Au.Types.KHotkey,Au.Types.AnyWnd)">
            <summary>
            Registers a hotkey using API <msdn>RegisterHotKey</msdn>.
            Returns false if fails. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <param name="id">Hotkey id. Must be 0 to 0xBFFF. It will be <i>wParam</i> of the <msdn>WM_HOTKEY</msdn> message.</param>
            <param name="hotkey">Hotkey. Can be: string like "Ctrl+Shift+Alt+Win+K", tuple (KMod, KKey), enum KKey, enum Keys, struct KHotkey.</param>
            <param name="window">Window/form that will receive the <msdn>WM_HOTKEY</msdn> message. Must be of this thread. If default, the message must be retrieved in the message loop of this thread.</param>
            <exception cref="T:System.ArgumentException">Error in hotkey string.</exception>
            <exception cref="T:System.InvalidOperationException">This variable already registered a hotkey.</exception>
            <remarks>
            Fails if the hotkey is currently registered by this or another application or used by Windows. Also if F12.
            A single variable cannot register multiple hotkeys simultaneously. Use multiple variables, for example array.
            </remarks>
            <seealso cref="M:Au.Keyb.WaitForHotkey(System.Double,Au.Types.KHotkey,System.Boolean)"/>
            <example><inheritdoc cref="T:Au.Util.RegisterHotkey"/></example>
        </member>
        <member name="M:Au.Util.RegisterHotkey.Unregister">
            <summary>
            Unregisters the hotkey.
            </summary>
            <remarks>
            Called implicitly when disposing this variable.
            Must be called from the same thread as when registering, and the window must be still alive.
            If fails, calls <see cref="M:Au.NoClass.PrintWarning(System.String,System.Int32,System.String)"/>.
            </remarks>
        </member>
        <member name="M:Au.Util.RegisterHotkey.Dispose">
            <summary>
            Calls <see cref="M:Au.Util.RegisterHotkey.Unregister"/>.
            </summary>
        </member>
        <member name="F:Au.Util.RegisterHotkey.WM_HOTKEY">
            <summary>
            This message is posted to the window or to the thread's message loop.
            More info: <msdn>WM_HOTKEY</msdn>.
            </summary>
        </member>
        <member name="T:Au.Util.OutputServer">
            <summary>
            Receives messages sent by <see cref="M:Au.Output.Write(System.String)"/> and related methods (<b>Print</b> etc).
            </summary>
            <remarks>
            If server is global, clients can be multiple appdomains and processes, including this. Else only this appdomain.
            Works asynchronously, to make writing messages faster.
            When a client writes a message, the message arrives to the server with some delay and is placed in a queue.
            You then can get/remove messages from the queue (call <see cref="M:Au.Util.OutputServer.GetMessage(Au.Util.OutputServer.Message@)"/>) and display them in a window (for example).
            You can be notified about new messages.
            
            Recommended setup (see example):
            1. When your application starts, create an <b>OutputServer</b> instance and assign to a static variable. Call <see cref="M:Au.Util.OutputServer.Start"/>.
            2. When your application creates its output window, call <see cref="M:Au.Util.OutputServer.SetNotifications(System.Action,System.Windows.Forms.Control)"/> to register callback function.
            3. In the callback function get/remove/display all new messages.
            4. Call <see cref="M:Au.Util.OutputServer.Stop"/> when closing the window. Optional but recommended.
            </remarks>
            <example>
            Simple program with output window.
            <code><![CDATA[
            class OutputFormExample :Form
            {
            	TextBox _tb;
            
            	public OutputFormExample()
            	{
            		_tb = new TextBox();
            		_tb.ReadOnly = true;
            		_tb.Multiline = true;
            		_tb.ScrollBars = ScrollBars.Both;
            		_tb.WordWrap = false;
            		_tb.Dock = DockStyle.Fill;
            		_tb.TabStop = false;
            		this.Controls.Add(_tb);
            
            		_os.SetNotifications(_ProcessMessages, this);
            	}
            
            	void _ProcessMessages()
            	{
            		while(_os.GetMessage(out var m)) {
            			switch(m.Type) {
            			case Au.Util.OutputServer.MessageType.Clear:
            				_tb.Clear();
            				break;
            			case Au.Util.OutputServer.MessageType.Write:
            				//_tb.AppendText(m.Text);
            				_tb.AppendText($"{DateTime.FromFileTimeUtc(m.TimeUtc).ToLocalTime()}  {m.Domain}  {m.Text}");
            				break;
            			}
            		}
            	}
            
            	static Au.Util.OutputServer _os = new Au.Util.OutputServer(isGlobal: false);
            
            	[STAThread]
            	public static void Main()
            	{
            		_os.Start();
            
            		//test Print and Clear, before and after creating window
            		Output.IgnoreConsole = true;
            		Print("test before setting notifications");
            		Task.Run(() => { 1.s(); Print("test after"); 1.s(); Output.Clear(); 1.s(); Print("test after Clear"); });
            
            		Application.Run(new OutputFormExample());
            		_os.Stop();
            	}
            }
            ]]></code>
            </example>
        </member>
        <member name="T:Au.Util.OutputServer.MessageType">
            <tocexclude />
            <summary>
            See <see cref="P:Au.Util.OutputServer.Message.Type"/>.
            </summary>
        </member>
        <member name="F:Au.Util.OutputServer.MessageType.Write">
            <summary>
            Add line to the output window.
            All <see cref="T:Au.Util.OutputServer.Message"/> members can be used.
            </summary>
        </member>
        <member name="F:Au.Util.OutputServer.MessageType.Clear">
            <summary>
            Clear the output window.
            Only <see cref="P:Au.Util.OutputServer.Message.Type"/> is used.
            </summary>
        </member>
        <member name="T:Au.Util.OutputServer.Message">
            <tocexclude />
            <summary>
            Contains message text and/or related info.
            More info: <see cref="T:Au.Util.OutputServer"/>, <see cref="M:Au.Util.OutputServer.GetMessage(Au.Util.OutputServer.Message@)"/>.
            </summary>
        </member>
        <member name="P:Au.Util.OutputServer.Message.Type">
            <summary>
            Message type.
            Currently there are 2 types - Write and Clear.
            </summary>
        </member>
        <member name="P:Au.Util.OutputServer.Message.Text">
            <summary>
            Message text.
            Used with MessageType.Write.
            </summary>
        </member>
        <member name="P:Au.Util.OutputServer.Message.TimeUtc">
            <summary>
            Message time in FILETIME format, UTC.
            Used with MessageType.Write.
            To convert to string: <c>DateTime.FromFileTimeUtc(m.TimeUtc).ToLocalTime().ToString()</c>.
            </summary>
        </member>
        <member name="P:Au.Util.OutputServer.Message.Domain">
            <summary>
            The name of the appdomain that called the Write/Print/etc method.
            Used with MessageType.Write.
            </summary>
        </member>
        <member name="M:Au.Util.OutputServer.#ctor(System.Boolean)">
            <param name="isGlobal">
            If true, will receive output from all appdomains and processes that don't have local server.
            </param>
        </member>
        <member name="M:Au.Util.OutputServer.Start">
            <summary>
            Starts server.
            Returns false if server already exists (if global - in any process).
            </summary>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
        </member>
        <member name="M:Au.Util.OutputServer.Stop">
            <summary>
            Stops server.
            </summary>
        </member>
        <member name="M:Au.Util.OutputServer.Finalize">
            <summary>
            Calls Stop.
            </summary>
        </member>
        <member name="M:Au.Util.OutputServer.SetNotifications(System.Action,System.Windows.Forms.Control)">
            <summary>
            Sets callback function, to be notified about server events.
            </summary>
            <param name="cbFunc">
            Callback function's delegate. Called when one or more messages are available.
            It should call <see cref="M:Au.Util.OutputServer.GetMessage(Au.Util.OutputServer.Message@)"/> until it returns false.
            See example in class help.
            </param>
            <param name="c">A control or form. The callback function will be called in its thread. If null, the callback function will be called in other thread.</param>
        </member>
        <member name="M:Au.Util.OutputServer.LibLocalWrite(System.String,System.Int64,System.String)">
            <summary>
            Adds s directly to _messages and sets timer.
            If s is null, it is 'Clear' command.
            Else if !NoNewline, appends "\r\n".
            Used with local server only.
            </summary>
        </member>
        <member name="M:Au.Util.OutputServer.GetMessage(Au.Util.OutputServer.Message@)">
            <summary>
            Gets next message and removes from the queue.
            Returns false if there are no messages.
            </summary>
            <remarks>
            Messages are added to an internal queue when clients call <see cref="M:Au.Output.Write(System.String)"/> etc. They contain the text, time, etc. This function gets the oldest message and removes it from the queue.
            </remarks>
        </member>
        <member name="P:Au.Util.OutputServer.MessageCount">
            <summary>
            Gets the count of messages in the queue.
            </summary>
        </member>
        <member name="P:Au.Util.OutputServer.NoNewline">
            <summary>
            Let messages don't end with "\r\n".
            </summary>
            <remarks>
            This can be used for performance, to avoid string copying when using local server. Does not affect performance of global server.
            </remarks>
        </member>
        <member name="P:Au.Util.OutputServer.LibMailslotName">
            <summary>
            Gets mailslot name like @"\\.\mailslot\Au.Output\" + sessionId.
            </summary>
        </member>
        <member name="P:Au.Util.OutputServer.LibTimerName">
            <summary>
            Gets waitable timer name like "timer.Au.Output".
            </summary>
        </member>
        <member name="T:Au.Util.OutputServer.LibSharedMemoryData">
            <summary>
            Shared memory variables. Used with global server only.
            </summary>
        </member>
        <member name="P:Au.Util.ILInstruction.RawData">
            <summary>
            Gets the raw data.
            </summary>
        </member>
        <member name="P:Au.Util.ILInstruction.Data">
            <summary>
            Gets the data.
            </summary>
        </member>
        <member name="P:Au.Util.ILInstruction.Address">
            <summary>
            Gets the address of the instruction.
            </summary>
        </member>
        <member name="P:Au.Util.ILInstruction.InstructionIndex">
            <summary>
            Gets the index of the instruction.
            </summary>
            <value>
            The index of the instruction.
            </value>
        </member>
        <member name="P:Au.Util.ILInstruction.DataValue">
            <summary>
            Gets the value as integer
            </summary>
            <value>The data value.</value>
        </member>
        <member name="P:Au.Util.ILInstruction.Length">
            <summary>
            Gets the length of the instructions and operands.
            </summary>
            <value>The length.</value>
        </member>
        <member name="M:Au.Util.ILInstruction.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="T:Au.Util.ILReader">
            <summary>
            Reads IL instructions from a byte stream.
            </summary>
            <remarks>Allows generated code to be viewed without debugger or enabled debug assemblies.</remarks>
        </member>
        <member name="F:Au.Util.ILReader.instructionLookup">
            <summary>
            The _instruction lookup.
            </summary>
        </member>
        <member name="F:Au.Util.ILReader.intermediateLanguageProvider">
            <summary>
            The IL reader provider.
            </summary>
        </member>
        <member name="M:Au.Util.ILReader.#ctor(System.Reflection.MethodInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:Au.Util.ILReader"/> class.
            </summary>
            <param name="method">
            The method.
            </param>
        </member>
        <member name="P:Au.Util.ILReader.Instructions">
            <summary>
            Gets the instructions.
            </summary>
            <value>The instructions.</value>
        </member>
        <member name="M:Au.Util.ILReader.CreateILReaderProvider(System.Reflection.MethodInfo)">
            <summary>
            Creates the IL reader provider.
            </summary>
            <param name="methodInfo">The MethodInfo object that represents the method to read..</param>
            <returns>
            The ILReader provider.
            </returns>
        </member>
        <member name="M:Au.Util.ILReader.IsInstructionPrefix(System.Int16)">
            <summary>
            Checks to see if the IL instruction is a prefix indicating the length of the instruction is two bytes long.
            </summary>
            <param name="value">The IL instruction as a byte.</param>
            <remarks>IL instructions can either be 1 or 2 bytes.</remarks>
            <returns>True if this IL instruction is a prefix indicating the instruction is two bytes long.</returns>
        </member>
        <member name="M:Au.Util.ILReader.GetLookupTable">
            <summary>
            The get lookup table.
            </summary>
            <returns>
            A dictionary of IL instructions.
            </returns>
        </member>
        <member name="M:Au.Util.ILReader.GetSize(System.Reflection.Emit.OperandType)">
            <summary>
            Gets the size of a operand.
            </summary>
            <param name="operandType">Defines the type of operand.</param>
            <returns>The size in bytes of the operand type.</returns>
        </member>
        <member name="T:Au.Util.StringMisc">
            <summary>
            Miscellaneous string functions. Parsing etc.
            </summary>
        </member>
        <member name="M:Au.Util.StringMisc.ParseParam3Stars(System.String@,System.String[])">
            <summary>
            Parses a function parameter that can optionally have a "***name " prefix, like "***id 100".
            Returns: 0 - s does not start with "***"; i+1 - s starts with "***names[i] "; -1 - s is invalid.
            </summary>
            <param name="s">Parameter. If starts with "***" and is valid, receives the 'value' part; else unchanged. Can be null.</param>
            <param name="names">List of supported 'name'.</param>
            <remarks>
            Used to parse parameters like <i>name</i> of <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Au.Util.StringMisc.RemoveUnderlineAmpersand(System.String)">
            <summary>
            Removes '&amp;' characters from string.
            Replaces "&amp;&amp;" with "&amp;".
            Returns new string if s has '&amp;' characters, else returns s.
            </summary>
            <remarks>
            Character '&amp;' is used to underline next character in displayed text of dialog controls and menu items. Two '&amp;' are used to display single '&amp;'.
            The underline is displayed when using the keyboard (eg Alt key) to select dialog controls and menu items.
            </remarks>
        </member>
        <member name="T:Au.Util.LibScreenDC">
            <summary>
            Helps to get and release screen DC with the 'using(...){...}' pattern.
            Uses API GetDC and ReleaseDC.
            </summary>
        </member>
        <member name="T:Au.Util.LibWindowDC">
            <summary>
            Helps to get and release window DC with the 'using(...){...}' pattern.
            Uses API GetDC and ReleaseDC.
            If w is default(Wnd), gets screen DC.
            </summary>
        </member>
        <member name="T:Au.Util.LibCompatibleDC">
            <summary>
            Helps to create and delete screen DC with the 'using(...){...}' pattern.
            Uses API CreateCompatibleDC and DeleteDC.
            </summary>
        </member>
        <member name="T:Au.Util.MemoryBitmap">
            <summary>
            Creates and manages native bitmap handle and memory DC (GDI device context).
            The bitmap is selected in the DC.
            </summary>
        </member>
        <member name="P:Au.Util.MemoryBitmap.Hdc">
            <summary>
            DC handle.
            </summary>
        </member>
        <member name="P:Au.Util.MemoryBitmap.Hbitmap">
            <summary>
            Bitmap handle.
            </summary>
        </member>
        <member name="M:Au.Util.MemoryBitmap.#ctor">
            <summary>
            Does nothing. Later you can call Create or Attach.
            </summary>
        </member>
        <member name="M:Au.Util.MemoryBitmap.#ctor(System.Int32,System.Int32)">
            <summary>
            Calls <see cref="M:Au.Util.MemoryBitmap.Create(System.Int32,System.Int32)"/>.
            </summary>
            <exception cref="T:System.ArgumentException">width or height is less than 1.</exception>
            <exception cref="T:Au.Types.AuException">Failed. Probably there is not enough memory for bitmap of specified size (need with*height*4 bytes).</exception>
        </member>
        <member name="M:Au.Util.MemoryBitmap.Dispose">
            <summary>
            Deletes the bitmap and DC.
            </summary>
        </member>
        <member name="M:Au.Util.MemoryBitmap.Finalize">
            
        </member>
        <member name="M:Au.Util.MemoryBitmap.GetHdc">
            
        </member>
        <member name="M:Au.Util.MemoryBitmap.ReleaseHdc">
            
        </member>
        <member name="M:Au.Util.MemoryBitmap.Delete">
            <summary>
            Deletes the bitmap and DC.
            </summary>
        </member>
        <member name="M:Au.Util.MemoryBitmap.Create(System.Int32,System.Int32)">
            <summary>
            Creates new memory DC and bitmap of specified size and selects it into the DC.
            Returns false if failed.
            In any case deletes previous bitmap and DC.
            </summary>
            <param name="width">Width, pixels. Must be &gt; 0.</param>
            <param name="height">Height, pixels. Must be &gt; 0.</param>
        </member>
        <member name="M:Au.Util.MemoryBitmap.Attach(System.IntPtr)">
            <summary>
            Sets this variable to manage an existing bitmap.
            Selects the bitmap into a memory DC.
            Deletes previous bitmap and DC.
            </summary>
            <param name="hBitmap">Native bitmap handle.</param>
        </member>
        <member name="M:Au.Util.MemoryBitmap.Detach">
            <summary>
            Deletes memory DC, clears this variable and returns its bitmap (native bitmap handle).
            The returned bitmap is not selected into a DC. Will need to delete it with API DeleteObject.
            </summary>
        </member>
        <member name="T:Au.Util.LibNativeFont">
            <summary>
            Creates and manages native font handle.
            </summary>
        </member>
        <member name="T:Au.Util.Cursors_">
            <summary>
            Helps to load cursors, etc.
            </summary>
        </member>
        <member name="M:Au.Util.Cursors_.LoadCursorFromFile(System.String,System.Int32)">
            <summary>
            Loads cursor from file.
            Returns null if fails.
            </summary>
            <param name="file">.cur or .ani file. If not full path, uses <see cref="P:Au.Folders.ThisAppImages"/>.</param>
            <param name="size">Width and height. If 0, uses system default size, which depends on DPI (the "text size" system setting).</param>
            <remarks>
            This function exists because <see cref="T:System.Windows.Forms.Cursor"/> constructors don't support colors, ani cursors and custom size.
            </remarks>
        </member>
        <member name="M:Au.Util.Cursors_.HandleToCursor(System.IntPtr,System.Boolean)">
            <summary>
            Converts unmanaged cursor to Cursor object.
            Returns null if hCur is default(IntPtr).
            </summary>
            <param name="hCursor">Cursor handle.</param>
            <param name="destroyCursor">If true (default), the returned variable owns the unmanaged cursor and destroys it when disposing. If false, the returned variable just uses the unmanaged cursor and will not destroy; if need, the caller later should destroy it with API <msdn>DestroyCursor</msdn>.</param>
        </member>
        <member name="M:Au.Util.Cursors_.LoadCursorFromMemory(System.Byte[],System.Int32)">
            <summary>
            Creates cursor from cursor file data in memory, for example from a managed resource.
            Returns null if fails.
            </summary>
            <param name="cursorData">Data of .cur or .ani file.</param>
            <param name="size">Width and height. If 0, uses system default size, which depends on DPI (the "text size" system setting).</param>
            <remarks>
            This function exists because <see cref="T:System.Windows.Forms.Cursor"/> constructors don't support colors, ani cursors and custom size.
            </remarks>
        </member>
        <member name="M:Au.Util.Cursors_.HashCursor(System.IntPtr)">
            <summary>
            Calculates 64-bit FNV1 hash of a mouse cursor's mask bitmap.
            Returns 0 if fails.
            </summary>
            <param name="hCursor">Native cursor handle. See <see cref="M:Au.Util.Cursors_.GetCurrentCursor(System.IntPtr@)"/>.</param>
        </member>
        <member name="M:Au.Util.Cursors_.GetCurrentCursor(System.IntPtr@)">
            <summary>
            Gets the native handle of the current mouse cursor.
            Returns false if the cursor is currently invisible.
            </summary>
            <remarks>
            It is the system cursor, not the cursor of this thread.
            Don't destroy the cursor.
            </remarks>
        </member>
        <member name="T:Au.Util.LibGDI">
            <summary>
            Misc GDI util.
            </summary>
        </member>
        <member name="T:Au.Util.WinHook">
            <summary>
            Helps with windows hooks. See <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <remarks>
            The thread that uses hooks must process Windows messages. For example have a window/dialog/messagebox, or use a 'wait-for' function that dispatches messages or has such option (see <see cref="P:Au.Opt.WaitFor"/>).
            The variable must be disposed, either explicitly (call <b>Dispose</b> or <b>Uninstall</b>) or with the 'using' pattern.
            </remarks>
        </member>
        <member name="M:Au.Util.WinHook.Keyboard(System.Func{Au.Types.HookData.Keyboard,System.Boolean})">
            <summary>
            Installs low-level keyboard hook (WH_KEYBOARD_LL).
            See <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <param name="hookProc">
            Hook procedure.
            Must return as soon as possible, or the system hangs and removes the hook.
            If returns true or calls <see cref="M:Au.Types.HookData.ReplyMessage(System.Boolean)"/>, the event is cancelled (not visible to apps and other hooks). Event data cannot be modified.
            </param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            //using Au.Util;
            var stop = false;
            using(WinHook.Keyboard(x =>
            {
            	Print(x);
            	if(x.vkCode == KKey.Escape) { stop = true; return true; } //return true to cancel the event
            	return false;
            })) {
            	MessageBox.Show("Low-level keyboard hook.", "Test");
            	//or
            	//WaitFor.MessagesAndCondition(-10, () => stop); //wait max 10 s for Esc key
            	//Print("the end");
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Util.WinHook.Mouse(System.Func{Au.Types.HookData.Mouse,System.Boolean})">
            <summary>
            Installs low-level mouse hook (WH_MOUSE_LL).
            See <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <param name="hookProc">
            Hook procedure.
            Must return as soon as possible, or the system hangs and removes the hook.
            If returns true or calls <see cref="M:Au.Types.HookData.ReplyMessage(System.Boolean)"/>, the event is cancelled (not visible to apps and other hooks). Event data cannot be modified.
            </param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            //using Au.Util;
            var stop = false;
            using(WinHook.Mouse(x =>
            {
            	Print(x);
            	if(x.Event == HookData.MouseEvent.RightButton) { stop = x.IsButtonUp; return true; } //return true to cancel the event
            	return false;
            })) {
            	MessageBox.Show("Low-level mouse hook.", "Test");
            	//or
            	//WaitFor.MessagesAndCondition(-10, () => stop); //wait max 10 s for right-click
            	//Print("the end");
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Util.WinHook.ThreadCbt(System.Func{Au.Types.HookData.ThreadCbt,System.Boolean},System.Int32)">
            <summary>
            Installs WH_CBT hook for a thread of this process.
            See <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <param name="hookProc">
            Hook procedure.
            Must return as soon as possible.
            If returns true, the event is cancelled. For some events you can modify some fields of event data.
            </param>
            <param name="threadId">Native thread id, or 0 for this thread. The thread must belong to this process.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            //using Au.Util;
            using(WinHook.ThreadCbt(x =>
            {
            	Print(x.code);
            	switch(x.code) {
            	case HookData.CbtEvent.ACTIVATE:
            		Print(x.ActivationInfo(out _, out _));
            		break;
            	case HookData.CbtEvent.CREATEWND:
            		Print(x.CreationInfo(out var c, out _), c->x, c->lpszName);
            		break;
            	case HookData.CbtEvent.CLICKSKIPPED:
            		Print(x.MouseInfo(out var m), m->pt, m->hwnd);
            		break;
            	case HookData.CbtEvent.KEYSKIPPED:
            		Print(x.KeyInfo(out _));
            		break;
            	case HookData.CbtEvent.SETFOCUS:
            		Print(x.FocusInfo(out Wnd wPrev), wPrev);
            		break;
            	case HookData.CbtEvent.MOVESIZE:
            		Print(x.MoveSizeInfo(out var r), r->ToString());
            		break;
            	case HookData.CbtEvent.MINMAX:
            		Print(x.MinMaxInfo(out var state), state);
            		break;
            	case HookData.CbtEvent.DESTROYWND:
            		Print((Wnd)x.wParam);
            		break;
            	}
            	return false;
            })) {
            	MessageBox.Show("CBT hook.", "Test", MessageBoxButtons.OKCancel);
            	//new Form().ShowDialog(); //to test MINMAX
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Util.WinHook.ThreadGetMessage(System.Action{Au.Types.HookData.ThreadGetMessage},System.Int32)">
            <summary>
            Installs WH_GETMESSAGE hook for a thread of this process.
            See <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <param name="hookProc">
            Hook procedure.
            Must return as soon as possible.
            The event cannot be cancelled. As a workaround, you can set msg->message=0. Also can modify other fields.
            </param>
            <param name="threadId">Native thread id, or 0 for this thread. The thread must belong to this process.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            //using Au.Util;
            using(WinHook.ThreadGetMessage(x =>
            {
            	Print(x.msg->ToString(), x.PM_NOREMOVE);
            })) MessageBox.Show("hook");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Util.WinHook.ThreadKeyboard(System.Func{Au.Types.HookData.ThreadKeyboard,System.Boolean},System.Int32)">
            <summary>
            Installs WH_GETMESSAGE hook for a thread of this process.
            See <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <param name="hookProc">
            Hook procedure.
            Must return as soon as possible.
            If returns true, the event is cancelled.
            </param>
            <param name="threadId">Native thread id, or 0 for this thread. The thread must belong to this process.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            //using Au.Util;
            using(WinHook.ThreadKeyboard(x =>
            {
            	Print(x.key, 0 != (x.lParam & 0x80000000) ? "up" : "", x.lParam, x.PM_NOREMOVE);
            	return false;
            })) MessageBox.Show("hook");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Util.WinHook.ThreadMouse(System.Func{Au.Types.HookData.ThreadMouse,System.Boolean},System.Int32)">
            <summary>
            Installs WH_MOUSE hook for a thread of this process.
            See <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <param name="hookProc">
            Hook procedure.
            Must return as soon as possible.
            If returns true, the event is cancelled.
            </param>
            <param name="threadId">Native thread id, or 0 for this thread. The thread must belong to this process.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            //using Au.Util;
            using(WinHook.ThreadMouse(x =>
            {
            	Print(x.message, x.m->pt, x.m->hwnd, x.PM_NOREMOVE);
            	return false;
            })) MessageBox.Show("hook");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Util.WinHook.ThreadCallWndProc(System.Action{Au.Types.HookData.ThreadCallWndProc},System.Int32)">
            <summary>
            Installs WH_CALLWNDPROC hook for a thread of this process.
            See <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <param name="hookProc">
            Hook procedure.
            Must return as soon as possible.
            The event cannot be cancelled or modified.
            </param>
            <param name="threadId">Native thread id, or 0 for this thread. The thread must belong to this process.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            //using Au.Util;
            using(WinHook.ThreadCallWndProc(x =>
            {
            	ref var m = ref *x.msg;
            	var mm = Message.Create(m.hwnd.Handle, (int)m.message, m.wParam, m.lParam);
            	Print(mm, x.sentByOtherThread);
            })) MessageBox.Show("hook");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Util.WinHook.ThreadCallWndProcRet(System.Action{Au.Types.HookData.ThreadCallWndProcRet},System.Int32)">
            <summary>
            Installs WH_CALLWNDPROCRET hook for a thread of this process.
            See <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <param name="hookProc">
            Hook procedure.
            Must return as soon as possible.
            The event cannot be cancelled or modified.
            </param>
            <param name="threadId">Native thread id, or 0 for this thread. The thread must belong to this process.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            //using Au.Util;
            using(WinHook.ThreadCallWndProcRet(x =>
            {
            	ref var m = ref *x.msg;
            	var mm = Message.Create(m.hwnd.Handle, (int)m.message, m.wParam, m.lParam); mm.Result = m.lResult;
            	Print(mm, x.sentByOtherThread);
            })) MessageBox.Show("hook");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Util.WinHook.#ctor(System.Int32,System.Delegate,System.Int32)">
            <summary>
            Installs hook of the specified type.
            This ctor is private, because our dispatcher hook procedure does not know how to call hookProc.
            </summary>
            <param name="hookType">One of WH_ constants that are used with API <msdn>SetWindowsHookEx</msdn>.</param>
            <param name="hookProc">Delegate of the hook procedure of correct type.</param>
            <param name="tid">Thread id or: 0 (default) this thread, -1 global hook.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
        </member>
        <member name="M:Au.Util.WinHook.Unhook">
            <summary>
            Uninstalls the hook if installed.
            </summary>
        </member>
        <member name="M:Au.Util.WinHook.Dispose">
            <summary>
            Calls <see cref="M:Au.Util.WinHook.Unhook"/>.
            </summary>
        </member>
        <member name="M:Au.Util.WinHook.Finalize">
            
        </member>
        <member name="T:Au.Util.AccHook">
            <summary>
            Helps with accessible object event hooks. See <msdn>SetWinEventHook</msdn>.
            </summary>
            <remarks>
            The thread that uses hooks must process Windows messages. For example have a window/dialog/messagebox, or use a 'wait-for' function that dispatches messages or has such option (see <see cref="P:Au.Opt.WaitFor"/>).
            The variable must be disposed, either explicitly (call <b>Dispose</b> or <b>Uninstall</b>) or with the 'using' pattern.
            </remarks>
            <example>
            <code><![CDATA[
            //using Au.Util;
            bool stop = false;
            using(new AccHook(AccEVENT.SYSTEM_FOREGROUND, 0, x =>
            {
            	Print(x.wnd);
            	var a = x.GetAcc();
            	Print(a);
            	if(x.wnd.ClassNameIs("Shell_TrayWnd")) stop = true;
            })) {
            	MessageBox.Show("hook");
            	//or
            	//WaitFor.MessagesAndCondition(-10, () => stop); //wait max 10 s for activated taskbar
            	//Print("the end");
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Util.AccHook.#ctor(Au.Types.AccEVENT,Au.Types.AccEVENT,System.Action{Au.Types.HookData.AccHookData},System.Int32,System.Int32,Au.Types.AccHookFlags)">
            <summary>
            Installs hook.
            Calls API <msdn>SetWinEventHook</msdn>.
            </summary>
            <param name="eventMin">Specifies the event constant for the lowest event value in the range of events that are handled by the hook function. This parameter can be set to AccEVENT.MIN to indicate the lowest possible event value. Events reference: <msdn>SetWinEventHook</msdn>.</param>
            <param name="eventMax">Specifies the event constant for the highest event value in the range of events that are handled by the hook function. This parameter can be set to AccEVENT.MAX to indicate the highest possible event value. If 0, uses <paramref name="eventMin"/>.</param>
            <param name="hookProc">Delegate of the hook procedure.</param>
            <param name="idProcess">Specifies the id of the process from which the hook function receives events. If 0 - all processes on the current desktop.</param>
            <param name="idThread">Specifies the native id of the thread from which the hook function receives events. If 0 - all threads.</param>
            <param name="flags"></param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example><inheritdoc cref="T:Au.Util.AccHook"/></example>
        </member>
        <member name="M:Au.Util.AccHook.Unhook">
            <summary>
            Uninstalls the hook if installed.
            </summary>
            <remarks>
            Must be called from the same thread that installed the hook.
            </remarks>
        </member>
        <member name="M:Au.Util.AccHook.Dispose">
            <summary>
            Calls <see cref="M:Au.Util.AccHook.Unhook"/>.
            </summary>
        </member>
        <member name="M:Au.Util.AccHook.Finalize">
            
        </member>
        <member name="T:Au.Util.Recording">
            <summary>
            Functions for keyboard/mouse/etc recorder tools.
            </summary>
        </member>
        <member name="M:Au.Util.Recording.MouseToString(System.Collections.Generic.IEnumerable{System.UInt32},System.Boolean)">
            <summary>
            Converts multiple recorded mouse movements to string for <see cref="M:Au.Mouse.MoveRecorded(System.String,System.Double)"/>.
            </summary>
            <param name="recorded">
            List of x y distances from previous.
            The first distance is from the mouse position before the first movement; at run time it will be distance from <see cref="P:Au.Mouse.LastMoveXY"/>.
            To create uint value from distance dx dy use this code: <c>Math_.MakeUint(dx, dy)</c>.
            </param>
            <param name="withSleepTimes">
            <paramref name="recorded"/> also contains sleep times (milliseconds) alternating with distances.
            It must start with a sleep time. Example: {time1, dist1, time2, dist2}. Another example: {time1, dist1, time2, dist2, time3}. This is invalid: {dist1, time1, dist2, time2}.
            </param>
        </member>
        <member name="T:Au.Util.LibCharPtr">
            <summary>
            String functions that work with char* and ANSI byte* strings.
            </summary>
        </member>
        <member name="M:Au.Util.LibCharPtr.Length(System.Char*)">
            <summary>
            Finds unmanaged UTF-16 string length (number of characters).
            Scans the string until '\0' character found.
            </summary>
            <param name="p">'\0'-terminated UTF-16 string. Can be null.</param>
        </member>
        <member name="M:Au.Util.LibCharPtr.Length(System.Char*,System.Int32)">
            <summary>
            Finds unmanaged UTF-16 string length (number of characters).
            Scans the string until '\0' character found, but not exceeding the specified length.
            </summary>
            <param name="p">'\0'-terminated UTF-16 string. Can be null.</param>
            <param name="nMax">Max allowed string length. The function returns nMax if does not find '\0' character within first nMax characters.</param>
        </member>
        <member name="M:Au.Util.LibCharPtr.Length(System.Byte*)">
            <summary>
            Finds unmanaged ANSI string length (number of bytes).
            Scans the string until '\0' character found.
            </summary>
            <param name="p">'\0'-terminated ANSI string. Can be any ANSI encoding, for example UTF8; this function counts bytes, not multi-byte characters. Can be null.</param>
        </member>
        <member name="M:Au.Util.LibCharPtr.Length(System.Byte*,System.Int32)">
            <summary>
            Finds unmanaged ANSI string length (number of bytes).
            Scans the string until '\0' character found, but not exceeding the specified length.
            </summary>
            <param name="p">'\0'-terminated ANSI string. Can be any encoding, for example UTF8; this function counts bytes, not multi-byte characters. Can be null.</param>
            <param name="nMax">Max allowed string length. The function returns nMax if does not find '\0' character within first nMax characters.</param>
        </member>
        <member name="M:Au.Util.LibCharPtr.EndsWith(System.Char*,System.Int32,System.String,System.Boolean)">
            <summary>
            Returns true if unmanaged UTF-16 string p ends with string s.
            </summary>
            <param name="p">UTF-16 string. Can be null.</param>
            <param name="len">p length.</param>
            <param name="s">Cannot be null.</param>
            <param name="ignoreCase">Case-insensitive.</param>
        </member>
        <member name="M:Au.Util.LibCharPtr.AsciiStartsWith(System.Byte*,System.String)">
            <summary>
            Returns true if unmanaged ANSI string p starts with string s. Case-sensitive.
            </summary>
            <param name="p">'\0'-terminated ANSI string. Can be null.</param>
            <param name="s">Must contain only ASCII characters. Cannot be null.</param>
        </member>
        <member name="M:Au.Util.LibCharPtr.AsciiStartsWithI(System.Byte*,System.String)">
            <summary>
            Returns true if unmanaged ANSI string p starts with string s. Case-insensitive.
            </summary>
            <param name="p">'\0'-terminated ANSI string. Can be null.</param>
            <param name="s">Must contain only ASCII characters. Cannot be null.</param>
        </member>
        <member name="M:Au.Util.LibCharPtr.AsciiFindChar(System.Byte*,System.Int32,System.Byte)">
            <summary>
            Finds character in unmanaged ANSI string which can be binary.
            </summary>
            <param name="p">ANSI string. Can be null.</param>
            <param name="len">Length of p to search in.</param>
            <param name="ch">ASCII character.</param>
        </member>
        <member name="M:Au.Util.LibCharPtr.AsciiFindString(System.Byte*,System.Int32,System.String)">
            <summary>
            Finds substring in unmanaged ANSI string which can be binary.
            Returns -1 if not found or if s is null/"" or s2 is "".
            </summary>
            <param name="p">ANSI string. Can be null.</param>
            <param name="len">Length of p to search in.</param>
            <param name="s">Substring to find. Must contain only ASCII characters. Cannot be null.</param>
        </member>
        <member name="M:Au.Util.LibCharPtr.Equals(System.Char*,System.Int32,System.String)">
            <summary>
            Case-sensitive compares native string with managed string and returns true if they are equal.
            </summary>
            <param name="p">Native string.</param>
            <param name="len">p length. Returns false if it is != s.Length.</param>
            <param name="s">Managed string.</param>
        </member>
        <member name="T:Au.Util.LibArrayBuilder`1">
            <summary>
            Like List or StringBuilder, used as a temporary variable-size array to create final fixed-size array.
            To avoid much garbage (and many reallocations when growing), uses native memory heap. See <see cref="T:Au.Util.NativeHeap"/>.
            Must be explicitly disposed to free the native memory. Does not have a finalizer because is struct (to avoid garbage).
            Does not support reference types. Does not call Dispose.
            </summary>
        </member>
        <member name="P:Au.Util.LibArrayBuilder`1.Ptr">
            <summary>
            Gets array memory address (address of element 0).
            </summary>
        </member>
        <member name="P:Au.Util.LibArrayBuilder`1.Count">
            <summary>
            Gets the number of elements.
            </summary>
        </member>
        <member name="P:Au.Util.LibArrayBuilder`1.ByteCount">
            <summary>
            Gets the number of bytes in the array (Count*sizeof(T)).
            </summary>
        </member>
        <member name="P:Au.Util.LibArrayBuilder`1.Capacity">
            <summary>
            Gets or sets the total number of elements (not bytes) the internal memory can hold without resizing.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">(the 'set' function) value less than Count. Instead use ReAlloc or Free.</exception>
        </member>
        <member name="M:Au.Util.LibArrayBuilder`1.Alloc(System.Int32,System.Boolean)">
            <summary>
            Allocates count elements. Sets Count=count.
            Frees previously allocated memory.
            Returns memory address (address of element 0).
            </summary>
            <param name="count">Element count.</param>
            <param name="zeroInit">Set all bytes = 0. If false, the memory is uninitialized, ie random byte values. Default true. Slower when true.</param>
        </member>
        <member name="M:Au.Util.LibArrayBuilder`1.ReAlloc(System.Int32,System.Boolean)">
            <summary>
            Adds or removes elements at the end. Sets Count=count.
            Preserves Math.Min(Count, count) existing elements.
            Returns memory address (address of element 0).
            </summary>
            <param name="count">New element count.</param>
            <param name="zeroInit">Set all added bytes = 0. If false, the added memory is uninitialized, ie random byte values. Default true. Slower when true.</param>
            <remarks>
            The new memory usually is at a new location. The preserved elements are copied there.
            Sets Count=count. To allocate more memory without changing Count, change Capacity instead.
            </remarks>
        </member>
        <member name="M:Au.Util.LibArrayBuilder`1.Free">
            <summary>
            Frees memory. Sets Count and Capacity = 0.
            </summary>
        </member>
        <member name="M:Au.Util.LibArrayBuilder`1.AddR(`0@)">
            <summary>
            Adds one element.
            The same as Add, but uses 'in'. Use to avoid copying values of big types.
            </summary>
        </member>
        <member name="M:Au.Util.LibArrayBuilder`1.Add(`0)">
            <summary>
            Adds one element.
            </summary>
        </member>
        <member name="M:Au.Util.LibArrayBuilder`1.Add">
            <summary>
            Adds one zero-inited element and returns its reference.
            </summary>
        </member>
        <member name="M:Au.Util.LibArrayBuilder`1._EnsureCapacity">
            <summary>
            Capacity = Math.Max(_cap * 2, s_minCap).
            </summary>
        </member>
        <member name="P:Au.Util.LibArrayBuilder`1.Item(System.Int32)">
            <summary>
            Gets element reference.
            </summary>
            <param name="i">Element index.</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:Au.Util.LibArrayBuilder`1.ToArray">
            <summary>
            Copies elements to a new managed array.
            </summary>
        </member>
        <member name="T:Au.Util.StringCache">
            <summary>
            Caches managed strings created from unmanaged char* buffers.
            </summary>
            <remarks>
            Can be used in possibly very frequently called functions to avoid much string garbage and frequent garbage collections.
            For example, <b>Wnd.ClassName</b> and <b>Wnd.Name</b> use this. They are called by <b>Wnd.Wait</b> for each window (can be hundreds of them) repeatedly. It could create megabytes of garbage (window classname and name strings) in a few seconds. Every loop creates almost the same set of strings, therefore it makes sense to cache them.
            To allow GC free the cached strings, use a WeakReferenc&lt;StringCache&gt; object. See example.
            </remarks>
            <example>
            <code><![CDATA[
            internal static unsafe string GetCachedString(char* p, int len)
            {
            	lock(_cacheWR) {
            		if(!_cacheWR.TryGetTarget(out var cache)) _cacheWR.SetTarget(cache = new StringCache());
            		return cache.Add(p, len);
            	}
            }
            static WeakReference<StringCache> _cacheWR = new WeakReference<StringCache>(null);
            
            //When char[] is used as text buffer.
            internal static unsafe string GetCachedString(char[] a, int len)
            {
            	Debug.Assert(len < a.Length);
            	fixed (char* p = a) return GetCachedString(p, len);
            }
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Util.StringCache.Count">
            <summary>
            Number of elements in this cache.
            </summary>
        </member>
        <member name="M:Au.Util.StringCache.Add(System.Char*,System.Int32)">
            <summary>
            Searches in the cache for a managed string that matches unmanaged string p of length len.
            If finds, returns it. Else adds <c>new string(p, 0, len)</c> to the cache and returns it.
            </summary>
            <param name="p">Unmanaged string.</param>
            <param name="len">p length.</param>
            <remarks>
            speed when found in cache: similar to <c>new string(p, 0, len)</c>.
            </remarks>
        </member>
        <member name="M:Au.Util.StringCache.LibAdd(System.Char*,System.Int32,System.Boolean)">
            <summary>
            Gets string cached in a weak-referenced internal static LibStringCache object.
            Locks and calls <see cref="M:Au.Util.StringCache.Add(System.Char*,System.Int32)"/>.
            </summary>
            <param name="p">Unmanaged string.</param>
            <param name="len">p length.</param>
            <param name="lenIsMaxLen">Call <c>len = LibCharPtr.Length(p, len)</c>.</param>
        </member>
        <member name="M:Au.Util.StringCache.LibAdd(System.Char[],System.Int32)">
            <summary>
            Gets string cached in a weak-referenced internal static LibStringCache object.
            Locks and calls <see cref="M:Au.Util.StringCache.Add(System.Char*,System.Int32)"/>.
            </summary>
            <param name="a">Text buffer.</param>
            <param name="len">Length of valid text in a.</param>
        </member>
        <member name="M:Au.Util.StringCache.LibAdd(System.Char*)">
            <summary>
            This overload calls LibCharPtr.Length.
            </summary>
        </member>
        <member name="M:Au.Util.StringCache.LibAdd(System.Char[])">
            <summary>
            This overload calls LibCharPtr.Length.
            </summary>
        </member>
        <member name="M:Au.Util.StringCache.LibAdd(System.String,System.Int32,System.Int32)">
            <summary>
            Gets substring of string s as a string cached in a weak-referenced internal static LibStringCache object.
            Locks and calls <see cref="M:Au.Util.StringCache.Add(System.Char*,System.Int32)"/>.
            </summary>
            <param name="s">The string containing the substring. Can be null/"" if other parameters are 0.</param>
            <param name="startIndex">Start of substring in s.</param>
            <param name="count">Length of substring.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="T:Au.Util.LibTables">
            <summary>
            Lookup tables for various functions of this library.
            Multiple appdomains share the same tables.
            </summary>
        </member>
        <member name="F:Au.Util.LibTables._lowerCaseTable">
            <summary>
            Gets native-memory char[0x10000] containing lower-case versions of the first 0x10000 characters.
            Auto-creates when called first time. The memory is shared by appdomains.
            </summary>
        </member>
        <member name="P:Au.Util.LibTables.Base64">
            <summary>
            Gets table for <see cref="M:Au.Convert_.Base64Decode(System.Char*,System.Int32,System.Void*,System.Int32)"/> and co.
            Auto-creates when called first time. The memory is shared by appdomains.
            </summary>
        </member>
        <member name="P:Au.Util.LibTables.Hex">
            <summary>
            Gets table for <see cref="M:Au.Convert_.HexDecode(System.String,System.Void*,System.Int32,System.Int32)"/> and co.
            Auto-creates when called first time. The memory is shared by appdomains.
            </summary>
        </member>
        <member name="T:Au.Util.AppDomain_">
            <summary>
            Extends <see cref="T:System.AppDomain"/>.
            </summary>
        </member>
        <member name="M:Au.Util.AppDomain_.GetDefaultDomain(System.Boolean@)">
            <summary>
            Gets default appdomain.
            </summary>
            <param name="isCurrentDomain">Receives true if called from default appdomain.</param>
        </member>
        <member name="M:Au.Util.AppDomain_.GetDefaultDomain">
            <summary>
            Gets default appdomain.
            </summary>
        </member>
        <member name="E:Au.Util.AppDomain_.Exit">
            <summary>
            Occurs when current appdomain exits.
            </summary>
            <remarks>
            The event handler is called when one of these AppDomain events occur, with their parameters:
            <see cref="E:System.AppDomain.ProcessExit"/> (in default domain);
            <see cref="E:System.AppDomain.DomainUnload"/> (in non-default domain);
            <see cref="E:System.AppDomain.UnhandledException"/>.
            The event handler is called before static object finalizers.
            </remarks>
        </member>
        <member name="T:Au.Util.SharedMemory">
            <summary>
            Memory that can be used by multiple processes and app domains.
            Faster and more raw/unsafe than System.IO.MemoryMappedFiles.MemoryMappedFile.
            </summary>
            <seealso cref="M:Au.Wnd.Misc.InterProcessSendData(Au.Wnd,System.Int32,System.String,Au.Wnd)"/>
        </member>
        <member name="M:Au.Util.SharedMemory.CreateOrGet(System.String,System.UInt32,System.Boolean@)">
            <summary>
            Creates named shared memory of specified size. Opens if already exists.
            Returns shared memory address in this process.
            Calls API <msdn>CreateFileMapping</msdn> and API <msdn>MapViewOfFile</msdn>.
            </summary>
            <param name="name">Shared memory name. Case-insensitive.</param>
            <param name="size">Shared memory size. Ignored if the shared memory already exists.</param>
            <param name="created">Receives true if created and not opened.</param>
            <exception cref="T:Au.Types.AuException">The API failed.</exception>
            <remarks>
            Once the memory is created, it is alive at least until this process ends. Other processes can keep the memory alive even after that.
            There is no Close function to close the native shared memory object handle. The OS closes it when this process ends.
            </remarks>
        </member>
        <member name="T:Au.Util.LibSharedMemory">
            <summary>
            Memory shared by all appdomains and by other related processes.
            </summary>
        </member>
        <member name="F:Au.Util.LibSharedMemory.Size">
            <summary>
            Shared memory size.
            </summary>
        </member>
        <member name="F:Au.Util.LibSharedMemory._sm">
            <summary>
            Creates or opens shared memory on demand in a thread-safe and process-safe way.
            </summary>
        </member>
        <member name="P:Au.Util.LibSharedMemory.Ptr">
            <summary>
            Gets pointer to the shared memory.
            </summary>
        </member>
        <member name="T:Au.Util.LibProcessMemory">
            <summary>
            Memory shared by all appdomains of current process.
            Size 0x10000 (64 KB). Initially zero.
            </summary>
            <remarks>
            When need to prevent simultaneous access of the memory by multiple threads, use <c>lock("uniqueString"){...}</c> .
            It locks in all appdomains, because literal strings are interned, ie shared by all appdomains.
            Using some other object with 'lock' would lock only in that appdomain. Maybe except Type.
            Use this only in single module, because ngened modules have own interned strings.
            </remarks>
        </member>
        <member name="P:Au.Util.LibProcessMemory.Ptr">
            <summary>
            Gets pointer to the memory.
            </summary>
        </member>
        <member name="F:Au.Util.LibProcessMemory.Size">
            <summary>
            Memory size.
            </summary>
        </member>
        <member name="T:Au.Util.NativeHeap">
            <summary>
            Allocates memory from native heap of this process using heap API.
            Uses the common heap of this process, API <msdn>GetProcessHeap</msdn>.
            Usually slightly faster than Marshal class functions.
            </summary>
        </member>
        <member name="M:Au.Util.NativeHeap.Alloc(Au.Types.LPARAM,System.Boolean)">
            <summary>
            Allocates new memory block and returns its address.
            Calls API <msdn>HeapAlloc</msdn>.
            </summary>
            <param name="size">Byte count.</param>
            <param name="zeroInit">Set all bytes = 0. If false (default), the memory is uninitialized, ie random byte values. Slower when true.</param>
            <exception cref="T:System.OutOfMemoryException">Failed. Probably size is too big.</exception>
            <remarks>The memory is unmanaged and will not be freed automatically. Always call <see cref="M:Au.Util.NativeHeap.Free(System.Void*)"/> when done or <see cref="M:Au.Util.NativeHeap.ReAlloc(System.Void*,Au.Types.LPARAM,System.Boolean)"/> if need to resize it without losing data.</remarks>
        </member>
        <member name="M:Au.Util.NativeHeap.ReAlloc(System.Void*,Au.Types.LPARAM,System.Boolean)">
            <summary>
            Reallocates a memory block to make it bigger or smaller.
            Returns its address, which in most cases is different than the old memory block address.
            Preserves data in Math.Min(old size, new size) bytes of old memory (copies from old memory if need).
            Calls API <msdn>HeapReAlloc</msdn> or <msdn>HeapAlloc</msdn>.
            </summary>
            <param name="mem">Old memory address. If null, allocates new memory like Alloc.</param>
            <param name="size">New byte count.</param>
            <param name="zeroInit">When size is growing, set all added bytes = 0. If false (default), the added memory is uninitialized, ie random byte values. Slower when true.</param>
            <exception cref="T:System.OutOfMemoryException">Failed. Probably size is too big.</exception>
            <remarks>The memory is unmanaged and will not be freed automatically. Always call <see cref="M:Au.Util.NativeHeap.Free(System.Void*)"/> when done or ReAlloc if need to resize it without losing data.</remarks>
        </member>
        <member name="M:Au.Util.NativeHeap.Free(System.Void*)">
            <summary>
            Frees a memory block.
            Does nothing if mem is null.
            Calls API <msdn>HeapFree</msdn>.
            </summary>
        </member>
        <member name="T:Au.Util.Buffers">
            <summary>
            Allocates memory buffers that can be used with API functions and not only.
            Can allocate arrays of any value type - char[], byte[] etc.
            </summary>
            <example>
            <code><![CDATA[
            class Example
            {
            	public static void Test()
            	{
            		Wnd w = Wnd.FindFast(null, "Notepad");
            		string s = GetWndText(w);
            		Print(s);
            	}
            
            	public static string GetWndText(Wnd w)
            	{
            		for(int na = 300; ; na *= 2) {
            			var b = _GetCharBuffer(ref na);
            			int nr = GetWindowText(w, b, na);
            			if(nr < na - 1) return (nr > 0) ? b.ToString(nr) : "";
            		}
            	}
            
            	//this variable manages the buffer
            	[ThreadStatic] static WeakReference<char[]> t_char;
            
            	//a helper method
            	static Au.Util.Buffers.CharBuffer _GetCharBuffer(ref int n) { var r = Au.Util.Buffers.Get(n, ref t_char); n = r.Length - 1; return r; }
            
            	//we'll use this API in this example
            	[DllImport("user32.dll", EntryPoint = "GetWindowTextW")]
            	static extern int GetWindowText(Wnd hWnd, [Out] char[] lpString, int nMaxCount);
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Util.Buffers.Get``1(System.Int32,System.WeakReference{``0[]}@)">
            <summary>
            Allocates new or gets "cached" array of type T of length n or more.
            The returned array is managed by a WeakReference&lt;T[]&gt; variable provided by the caller. Its contents is undefined.
            </summary>
            <typeparam name="T">Any value type, for example char, byte, RECT.</typeparam>
            <param name="n">
            How many elements you need.
            If array in the WeakReference variable is null or too small, creates new array and stores it there.
            For byte[] and char[] types actually allocates Math.Max(n, 300)+1 elements. The 300 is to avoid future reallocations. The +1 can be used for example for '\0' character at the end of string.</param>
            <param name="weakReference">
            A reference to a WeakReference variable that manages the returned array. If null, this function will create it.
            The variable should be [ThreadStatic] static. Or can be a non-static field of a long-living object. Must not be simply static, it's not thread-safe (unless locked).
            </param>
            <remarks>
            Used to avoid creating much garbage when array allocations are needed frequently. Also is faster than code like <c>var b=new byte[1000]</c> or StringBuilder.
            The WeakReference variable allows the array to be garbage-collected if it is not used when GC runs. It is automatic and safe. Next time this function will create new array.
            Actually this function is a wrapper for WeakReference&lt;T[]&gt; functions TryGetTarget/SetTarget. Makes it easier to use.
            </remarks>
        </member>
        <member name="T:Au.Util.Buffers.CharBuffer">
            <summary>
            Provides functions to convert char[] to string easily.
            Assign char[] and call the ToString functions. Example: <see cref="T:Au.Util.Buffers"/>.
            </summary>
        </member>
        <member name="F:Au.Util.Buffers.CharBuffer.A">
            <summary>
            The array that is stored in this variable.
            </summary>
        </member>
        <member name="M:Au.Util.Buffers.CharBuffer.op_Implicit(Au.Util.Buffers.CharBuffer)~System.Char[]">
            
        </member>
        <member name="M:Au.Util.Buffers.CharBuffer.op_Implicit(System.Char[])~Au.Util.Buffers.CharBuffer">
            
        </member>
        <member name="M:Au.Util.Buffers.CharBuffer.ToString">
            <summary>
            Converts the array, which contains native '\0'-terminated UTF-16 string, to String.
            Unlike code <c>new string(charArray)</c>, gets array part until '\0' character, not whole array.
            </summary>
        </member>
        <member name="M:Au.Util.Buffers.CharBuffer.ToString(System.Int32)">
            <summary>
            Converts the array, which contains native UTF-16 string of n length, to String.
            Uses <c>new string(A, 0, n)</c>, which throws exception if the array is null or n is invalid.
            </summary>
            <param name="n">String length.</param>
        </member>
        <member name="M:Au.Util.Buffers.CharBuffer.LibToStringCached">
            <summary>
            The same as <see cref="M:Au.Util.Buffers.CharBuffer.ToString"/>, but uses our StringCache.
            </summary>
        </member>
        <member name="M:Au.Util.Buffers.CharBuffer.LibToStringCached(System.Int32)">
            <summary>
            The same as <see cref="M:Au.Util.Buffers.CharBuffer.ToString(System.Int32)"/>, but uses our StringCache.
            </summary>
            <param name="n">String length.</param>
        </member>
        <member name="M:Au.Util.Buffers.CharBuffer.LibToStringFromAnsi(System.Int32,System.Text.Encoding)">
            <summary>
            Converts the buffer, which contains native ANSI string of n length, to String.
            </summary>
            <param name="n">String length.</param>
            <param name="enc">If null, uses system's default ANSI encoding.</param>
        </member>
        <member name="T:Au.Util.LibStringBuilder">
            <summary>
            Provides a cached reusable instance of StringBuilder per thread. It's an optimisation that reduces the number of instances constructed and collected.
            Used like <c>using(new Au.Util.LibStringBuilder(out var b)) { b.Append("example"); var s = b.ToString(); }</c>.
            </summary>
            <remarks>
            This is a modified copy of the .NET internal StringBuilderCache class.
            The cache uses 2 [ThreadLocal] StringBuilder instances, which allows 1 nesting level. Not error to use deeper nesting level, but then gets new StringBuilder, not from the cache.
            </remarks>
        </member>
        <member name="F:Au.Util.LibStringBuilder.MAX_BUILDER_SIZE">
            <summary>
            2000. The cache is not used if capacity is bigger.
            </summary>
        </member>
        <member name="M:Au.Util.LibStringBuilder.#ctor(System.Text.StringBuilder@,System.Int32)">
            <summary>
            Gets a new or cached/cleared StringBuilder of the specified capacity, min 200.
            </summary>
        </member>
        <member name="M:Au.Util.LibStringBuilder.Dispose">
            <summary>
            Releases the StringBuilder to the cache.
            </summary>
        </member>
        <member name="T:Au.Util.GC_">
            <summary>
            <see cref="T:System.GC"/> extensions.
            </summary>
        </member>
        <member name="M:Au.Util.GC_.AddObjectMemoryPressure(System.Object,System.Int32)">
            <summary>
            Calls <see cref="M:System.GC.AddMemoryPressure(System.Int64)"/>. Later, when object <paramref name="obj"/> is garbage-collected, will call <see cref="M:System.GC.RemoveMemoryPressure(System.Int64)"/>.
            </summary>
            <param name="obj">An object of any type.</param>
            <param name="size">Unmanaged memory size. It is passed to <b>GC.AddMemoryPressure</b> and <b>GC.RemoveMemoryPressure</b>.</param>
        </member>
        <member name="T:Au.Util.MessageLoop">
            <summary>
            A message loop, alternative to Application.Run which does not support nested loops.
            </summary>
        </member>
        <member name="M:Au.Util.MessageLoop.Loop">
            <summary>
            Runs a message loop.
            </summary>
        </member>
        <member name="M:Au.Util.MessageLoop.Stop">
            <summary>
            Ends the message loop, causing Loop() to return.
            </summary>
        </member>
        <member name="T:Au.Util.LibEnsureWindowsFormsSynchronizationContext">
            <summary>
            Constructor ensures that current SynchronizationContext of this thread is WindowsFormsSynchronizationContext.
            Also sets WindowsFormsSynchronizationContext.AutoInstall=false to prevent Application.DoEvents etc setting wrong context.
            Dispose() restores both if need. Does not restore context if was null.
            Example: using(new Util.LibEnsureWindowsFormsSynchronizationContext()) { ... }
            </summary>
        </member>
        <member name="M:Au.Util.LibEnsureWindowsFormsSynchronizationContext.#ctor(System.Boolean)">
            <summary>
            See class help.
            </summary>
            <param name="onlyIfAutoInstall">Do nothing if WindowsFormsSynchronizationContext.AutoInstall==false. Normally WindowsFormsSynchronizationContext.AutoInstall is true (default).</param>
        </member>
        <member name="M:Au.Util.LibEnsureWindowsFormsSynchronizationContext.EnsurePermanently">
            <summary>
            If synchronization context of this thread is null or not WindowsFormsSynchronizationContext, makes it WindowsFormsSynchronizationContext.
            Use this instead of creating instance when will not need to restore previous synchronization context.
            </summary>
            <exception cref="T:System.InvalidOperationException">This thread has a synchronization context other than WindowsFormsSynchronizationContext or null. Or it is null and thread's GetApartmentState is not STA.</exception>
        </member>
        <member name="T:Au.Util.DragDrop">
            <summary>
            Drag-drop functions.
            </summary>
        </member>
        <member name="M:Au.Util.DragDrop.SimpleDragDrop(Au.Types.AnyWnd,Au.Types.MButtons,System.Action{Au.Util.DragDrop.MsgArgs})">
            <summary>
            Simple non-OLE drag operation.
            Returns true if dropped, false if cancelled.
            </summary>
            <param name="window">Window or control that owns the drag operation.</param>
            <param name="mouseButton">Mouse button that is used for the drag operation: Left, Right.</param>
            <param name="onMouseKeyMessage">Callback function, called on each received mouse/key message. Optional.</param>
        </member>
        <member name="T:Au.Util.DragDrop.MsgArgs">
            <tocexclude />
            <summary>
            <see cref="M:Au.Util.DragDrop.SimpleDragDrop(Au.Types.AnyWnd,Au.Types.MButtons,System.Action{Au.Util.DragDrop.MsgArgs})"/> callback function arguments.
            </summary>
        </member>
        <member name="F:Au.Util.DragDrop.MsgArgs.Msg">
            <summary>
            Current message retrieved by API <msdn>GetMessage</msdn>.
            </summary>
        </member>
        <member name="F:Au.Util.DragDrop.MsgArgs.Cursor">
            <summary>
            The callback function can set this to temporarily set cursor.
            </summary>
        </member>
        <member name="M:Au.Util.DragDrop.MsgArgs.Stop">
            <summary>
            The callback function can call this to end the operation.
            </summary>
        </member>
        <member name="T:Au.Util.ThreadPoolSTA">
            <summary>
            Thread pool where COM can be used. Initializes thread COM as single-thread-apartment.
            </summary>
        </member>
        <member name="T:Au.Util.ThreadPoolSTA.WorkCallbackData">
            <summary>
            Work callback function parameter type.
            More info: <see cref="T:Au.Util.ThreadPoolSTA.WorkCallback"/>.
            </summary>
        </member>
        <member name="F:Au.Util.ThreadPoolSTA.WorkCallbackData.state">
            
        </member>
        <member name="F:Au.Util.ThreadPoolSTA.WorkCallbackData.completionCallback">
            
        </member>
        <member name="T:Au.Util.ThreadPoolSTA.WorkCallback">
            <summary>
            Work callback function type.
            </summary>
            <param name="d">
            Contains state and completionCallback that were passed to the submit function.
            Your work callback function can change completionCallback and/or state. For example it can set completionCallback = null to prevent calling it (the call is expensive); or change state, if want to pass another object to the completion function.
            Note that the completion function is never called if initially it was null.
            </param>
        </member>
        <member name="M:Au.Util.ThreadPoolSTA.SubmitCallback(System.Object,Au.Util.ThreadPoolSTA.WorkCallback,System.Threading.SendOrPostCallback)">
            <summary>
            Requests that a thread pool thread call the callback function.
            </summary>
            <param name="state">Something to pass to the callback functions.</param>
            <param name="workCallback">Callback function to call in a thread pool thread.</param>
            <param name="completionCallback">Optional callback function to call in this thread after workCallback.</param>
            <exception cref="T:System.ComponentModel.Win32Exception"/>
            <exception cref="T:System.InvalidOperationException">(only when completionCallback is used) This thread has a synchronization context other than WindowsFormsSynchronizationContext or null; or it is null and thread's GetApartmentState is not STA.</exception>
        </member>
        <member name="M:Au.Util.ThreadPoolSTA.CreateWork(System.Object,Au.Util.ThreadPoolSTA.WorkCallback,System.Threading.SendOrPostCallback)">
            <summary>
            Creates a <see cref="T:Au.Util.ThreadPoolSTA.Work"/> object that can be used when need more options than <see cref="M:Au.Util.ThreadPoolSTA.SubmitCallback(System.Object,Au.Util.ThreadPoolSTA.WorkCallback,System.Threading.SendOrPostCallback)"/> has.
            </summary>
            <param name="state">Something to pass to the callback functions.</param>
            <param name="workCallback">Callback function to call in a thread pool thread.</param>
            <param name="completionCallback">Optional callback function to call in this thread after workCallback.</param>
            <remarks>
            Call Dispose() to avoid memory leaks. If not called, the object and related OS object remain in memory until this appdomain ends.
            </remarks>
            <exception cref="T:System.ComponentModel.Win32Exception"/>
            <exception cref="T:System.InvalidOperationException">(only when completionCallback is used) This thread has a synchronization context other than WindowsFormsSynchronizationContext or null; or it is null and thread's GetApartmentState is not STA.</exception>
        </member>
        <member name="T:Au.Util.ThreadPoolSTA.Work">
            <summary>
            Allows to submit a callback function (one or more times) to be called in thread pool threads, then optionally wait and cancel.
            Can be used when need more options than <see cref="M:Au.Util.ThreadPoolSTA.SubmitCallback(System.Object,Au.Util.ThreadPoolSTA.WorkCallback,System.Threading.SendOrPostCallback)"/> has.
            </summary>
            <example><code>
            using(var work = Util.ThreadPoolSTA.CreateWork(null, o =&gt; { Thread.Sleep(100); })) {
            	work.Submit();
            	work.Wait();
            }
            </code></example>
        </member>
        <member name="M:Au.Util.ThreadPoolSTA.Work.#ctor(System.Object,Au.Util.ThreadPoolSTA.WorkCallback,System.Threading.SendOrPostCallback,System.Boolean)">
            <exception cref="T:System.ComponentModel.Win32Exception"/>
            <exception cref="T:System.InvalidOperationException">(only when completionCallback is used) This thread has a synchronization context other than WindowsFormsSynchronizationContext or null; or it is null and thread's GetApartmentState is not STA.</exception>
        </member>
        <member name="M:Au.Util.ThreadPoolSTA.Work.Submit">
            <summary>
            Requests that a thread pool thread call the callback function.
            This function can be called multiple times.
            </summary>
        </member>
        <member name="M:Au.Util.ThreadPoolSTA.Work.Wait">
            <summary>
            Waits until all submitted instances of the callback function finish their work.
            While waiting, this thread cannot dispatch events and Windows messages.
            </summary>
        </member>
        <member name="M:Au.Util.ThreadPoolSTA.Work.Cancel">
            <summary>
            Waits until all running instances of the callback function finish their work, and cancels pending (still not running) instances.
            While waiting, this thread cannot dispatch events and Windows messages.
            </summary>
        </member>
        <member name="M:Au.Util.ThreadPoolSTA.Work.Dispose">
            <summary>
            Calls <see cref="M:Au.Util.ThreadPoolSTA.Work.Cancel"/>, releases all resources used by this object and allows this object to be garbage-collected.
            Call this to avoid memory leaks. If not called, the object and related OS object remain in memory until this appdomain ends.
            </summary>
        </member>
        <member name="T:Au.Util.NamespaceDoc">
            <summary>
            Miscellaneous classes and functions, used in this library as utility/helper.
            Some classes are public, and can be used not only in this library.
            </summary>
        </member>
        <member name="T:Au.Util.ModuleHandle">
            <summary>
            Gets native module handle.
            </summary>
        </member>
        <member name="M:Au.Util.ModuleHandle.OfType(System.Type)">
            <summary>
            Gets native module handle of type's assembly.
            </summary>
        </member>
        <member name="M:Au.Util.ModuleHandle.OfAssembly(System.Reflection.Assembly)">
            <summary>
            Gets native module handle of an assembly.
            If the assembly consists of multiple modules, gets its first loaded module.
            </summary>
        </member>
        <member name="M:Au.Util.ModuleHandle.OfAppDomainEntryAssembly">
            <summary>
            Gets native module handle of the entry assembly of this appdomain.
            If the assembly consists of multiple modules, gets its first loaded module.
            </summary>
        </member>
        <member name="M:Au.Util.ModuleHandle.OfAuDll">
            <summary>
            Gets native module handle of Au.dll.
            </summary>
        </member>
        <member name="M:Au.Util.ModuleHandle.OfProcessExe">
            <summary>
            Gets native module handle of the program file of this process.
            </summary>
        </member>
        <member name="M:Au.Util.ModuleHandle.OfAppIcon">
            <summary>
            Gets native module handle of the assembly containing native icon that can be displayed as icon of this app.
            Some API functions need it when you use <msdn>IDI_APPLICATION</msdn>.
            If the entry assembly of this appdomain is dll with icon, gets dll handle; else gets exe handle.
            Returns default(IntPtr) if there are no native icons.
            </summary>
        </member>
        <member name="T:Au.Util.Assembly_">
            <summary>
            Assembly functions.
            </summary>
        </member>
        <member name="P:Au.Util.Assembly_.EntryAssembly">
            <summary>
            Gets the entry assembly of this appdomain.
            Normally instead can be used <see cref="M:System.Reflection.Assembly.GetEntryAssembly"/>, but it returns null if appdomain launched through <see cref="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)"/>.
            </summary>
        </member>
        <member name="P:Au.Util.Assembly_.LibIsAuInGAC">
            <summary>
            Returns true if Au.dll is installed in the global assembly cache.
            </summary>
        </member>
        <member name="P:Au.Util.Assembly_.LibIsAuNgened">
            <summary>
            Returns true if Au.dll is compiled to native code using ngen.exe.
            It means - no JIT-compiling delay when its functions are called first time in process or appdomain.
            </summary>
        </member>
        <member name="M:Au.Util.Assembly_.IsAssemblyNgened(System.Reflection.Assembly)">
            <summary>
            Returns true if assembly asm is compiled to native code using ngen.exe.
            It means - no JIT-compiling delay when its functions are called first time in process or appdomain.
            </summary>
        </member>
        <member name="T:Au.Util.Resources_">
            <summary>
            Functions to work with managed resources.
            </summary>
        </member>
        <member name="M:Au.Util.Resources_.GetAppResource(System.String)">
            <summary>
            Gets an Image or other object from managed resources of appdomain's entry assembly.
            Returns null if not found.
            </summary>
            <param name="name">Resource name, like "example", not like "Project.Properties.Resources.example".</param>
            <remarks>
            Uses <see cref="M:System.Resources.ResourceManager.GetObject(System.String,System.Globalization.CultureInfo)"/>.
            The Image is not cached. Will need to Dispose.
            </remarks>
        </member>
        <member name="M:Au.Util.Resources_.LibGetAppResourceManager(System.Globalization.CultureInfo@)">
            <summary>
            Gets ResourceManager of appdomain's entry assembly.
            Returns null if fails or if the assembly does not have resources.
            Prefers resources where name ends with ".Resources.resources". If there is no such resources, gets the first.
            </summary>
        </member>
        <member name="T:Au.Util.Dpi">
            <summary>
            Functions for high-DPI screen support.
            High DPI means when in Control Panel is set screen text size other than 100%.
            </summary>
        </member>
        <member name="P:Au.Util.Dpi.BaseDPI">
            <summary>
            Gets DPI of the primary screen.
            On newer Windows versions, users can change DPI without logoff-logon. This function gets the setting that was after logon.
            </summary>
        </member>
        <member name="P:Au.Util.Dpi.SmallIconSize">
            <summary>
            Gets small icon size that depends on DPI of the primary screen.
            Width and Height are <see cref="P:Au.Util.Dpi.BaseDPI"/>/6, which is 16 if DPI is 96 (100%).
            </summary>
        </member>
        <member name="M:Au.Util.Dpi.ScaleInt(System.Int32)">
            <summary>
            If <see cref="P:Au.Util.Dpi.BaseDPI"/> is more than 96, returns stretched i.
            Else returns i.
            </summary>
            <param name="i"></param>
        </member>
        <member name="M:Au.Util.Dpi.ScaleSize(Au.Types.SIZE)">
            <summary>
            If <see cref="P:Au.Util.Dpi.BaseDPI"/> is more than 96, returns scaled (stretched) z.
            Else returns z.
            Note: for images use <see cref="M:Au.Util.Dpi.ImageSize(System.Drawing.Image)"/>.
            </summary>
            <param name="z"></param>
        </member>
        <member name="M:Au.Util.Dpi.ImageSize(System.Drawing.Image)">
            <summary>
            If <see cref="P:Au.Util.Dpi.BaseDPI"/> is more than 96 and image resolution is different, returns scaled (stretched) image.Size.
            Else returns image.Size.
            </summary>
            <param name="image"></param>
        </member>
        <member name="T:Au.Util.WaitableTimer">
            <summary>
            Wraps a waitable timer handle. Allows to create, open, set and wait.
            More info: API <msdn>CreateWaitableTimer</msdn>.
            Note: will need to dispose.
            </summary>
        </member>
        <member name="M:Au.Util.WaitableTimer.Create(System.Boolean,System.String)">
            <summary>
            Calls API <msdn>CreateWaitableTimer</msdn> and creates a WaitableTimer object that wraps the timer handle.
            </summary>
            <param name="manualReset"></param>
            <param name="timerName">Timer name. If a timer with this name already exists, opens it if possible. If null, creates unnamed timer.</param>
            <exception cref="T:Au.Types.AuException">Failed. For example, a non-timer kernel object with this name already exists.</exception>
        </member>
        <member name="M:Au.Util.WaitableTimer.Open(System.String,System.UInt32,System.Boolean,System.Boolean)">
            <summary>
            Calls API <msdn>OpenWaitableTimer</msdn> and creates a WaitableTimer object that wraps the timer handle.
            </summary>
            <param name="timerName">Timer name. Fails if it does not exist; to open-or-create use <see cref="M:Au.Util.WaitableTimer.Create(System.Boolean,System.String)"/>.</param>
            <param name="access">.See <msdn>Synchronization Object Security and Access Rights</msdn>. The default value TIMER_MODIFY_STATE|SYNCHRONIZE allows to set and wait.</param>
            <exception cref="T:Au.Types.AuException">Failed. For example, a non-timer kernel object with this name already exists.</exception>
            <param name="inheritHandle"></param>
            <param name="noException">If fails, return null, don't throw exception. Supports <see cref="M:Au.Types.Native.GetError"/>.</param>
            <exception cref="T:Au.Types.AuException">Failed. For example, the timer does not exist.</exception>
        </member>
        <member name="M:Au.Util.WaitableTimer.Set(System.Int64,System.Int32)">
            <summary>
            Calls API <msdn>SetWaitableTimer</msdn>.
            Returns false if fails. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <param name="dueTime">
            The time after which the state of the timer is to be set to signaled. It is relative time (from now).
            If positive, in milliseconds. If negative, in 100 nanosecond intervals (microseconds*10), see <msdn>FILETIME</msdn>.
            Also can be 0, to set minimal time.</param>
            <param name="period">The period of the timer, in milliseconds. If 0, the timer is signaled once. If greater than 0, the timer is periodic.</param>
            <exception cref="T:System.OverflowException">dueTime*10000 is greater than long.MaxValue.</exception>
        </member>
        <member name="M:Au.Util.WaitableTimer.SetAbsolute(System.DateTime,System.Int32)">
            <summary>
            Calls API <msdn>SetWaitableTimer</msdn>.
            Returns false if fails. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <param name="dueTime">The UTC date/time at which the state of the timer is to be set to signaled.</param>
            <param name="period">The period of the timer, in milliseconds. If 0, the timer is signaled once. If greater than 0, the timer is periodic.</param>
        </member>
        <member name="T:Au.Util.Help">
            <summary>
            Static functions to open a help topic etc.
            </summary>
        </member>
        <member name="M:Au.Util.Help.AuHelp(System.String)">
            <summary>
            Opens file "Au Help.chm" and a help topic in it.
            The file must be in <see cref="P:Au.Folders.ThisApp"/>.
            </summary>
            <param name="topic">Topic file name, like "M_Au_Acc_Find" or "0248143b-a0dd-4fa1-84f9-76831db6714a".</param>
        </member>
        <member name="T:Au.Util.LibAttachThreadInput">
            <summary>
            Calls API <msdn>AttachThreadInput</msdn> to attach/detach thread input.
            Constructor attaches thread input of this thread to that of the specified thread. <b>Dispose</b> detaches.
            </summary>
        </member>
        <member name="M:Au.Util.LibAttachThreadInput.#ctor(System.Int32,System.Boolean@)">
            <summary>
            Attaches thread input of this thread to that of the specified thread.
            </summary>
        </member>
        <member name="M:Au.Util.LibAttachThreadInput.Dispose">
            <summary>
            Detaches thread input.
            </summary>
        </member>
        <member name="P:Au.Util.LibAttachThreadInput.IsAttached">
            <summary>
            Returns true if AttachThreadInput succeeded and this variable is not disposed.
            </summary>
        </member>
        <member name="M:Au.Util.LibWorkarounds.WaitCursorWhenShowingMenuEtc">
            <summary>
            A workaround for:
            	When showing a ContextMenuStrip menu or a submenu, something briefly sets the AppStarting cursor.
            	Only if this process does/did not have active windows.
            	Only if current cursor is arrow. Works well if eg I or hand.
            	Starts before first WM_NCPAINT (after WM_SHOWWINDOW+WM_WINDOWPOSCHANGING) and stops before WM_PAINT.
            Call this before showing a menu. Possibly also will need for some other windows.
            </summary>
        </member>
        <member name="T:Au.Util.LibActCtx">
            <summary>
            Activates our manifest which tells to use comctl32.dll version 6.
            The manifest is embedded in this dll, resource id 2.
            </summary>
        </member>
        <member name="T:Au.Thread_">
            <summary>
            Thread functions. Extends <see cref="T:System.Threading.Thread"/>.
            </summary>
        </member>
        <member name="P:Au.Thread_.NativeId">
            <summary>
            Gets native thread id of this thread.
            Calls API <msdn>GetCurrentThreadId</msdn>.
            </summary>
            <remarks>
            It is not the same as <see cref="P:System.Threading.Thread.ManagedThreadId"/>.
            </remarks>
            <seealso cref="P:Au.Wnd.ThreadId"/>
        </member>
        <member name="P:Au.Thread_.Handle">
            <summary>
            Returns native thread handle of this thread.
            Calls API <msdn>GetCurrentThread</msdn>.
            </summary>
            <remarks>
            Don't need to close the handle.
            </remarks>
        </member>
        <member name="P:Au.Thread_.IsUI">
            <summary>
            Returns true if this thread has a .NET message loop (Forms or WPF).
            </summary>
            <seealso cref="M:Au.Wnd.GetWnd.ThreadWindows(System.Int32,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:Au.BlockUserInput">
            <summary>
            Blocks keyboard and/or mouse input events from reaching applications.
            </summary>
            <remarks>
            Uses keyboard and/or mouse hooks. Does not use API <b>BlockInput</b>, it does not work on current Windows versions.
            Blocks hardware-generated events and software-generated events, except if generated by functions of this library.
            Functions of this library that send keys or text use this class internally, to block user-pressed keys and resend them afterwards (see <see cref="P:Au.BlockUserInput.ResendBlockedKeys"/>).
            Does not block:
            <list type="bullet">
            <item>In windows of the same thread that started blocking. For example, if your script shows a message box, the user can click its buttons.</item>
            <item>In windows of higher <see cref="T:Au.Process_.UacInfo">UAC</see> integrity level (IL) processes, unless this process has uiAccess IL.</item>
            <item>In special screens such as when you press Ctrl+Alt+Delete or when you launch and admin program. See also <see cref="P:Au.BlockUserInput.ResumeAfterCtrlAltDelete"/>.</item>
            <item>Some Windows hotkeys, such as Ctrl+Alt+Delete and Win+L.</item>
            <item><see cref="P:Au.BlockUserInput.DoNotBlockKeys"/> keys.</item>
            <item>Keyboard hooks don't work in windows of this process if this process uses direct input or raw input API.</item>
            </list>
            
            To stop blocking, can be used the 'using' pattern, like in the example. Or the 'try/finally' pattern, where the finally block calls <see cref="M:Au.BlockUserInput.Dispose"/> or <see cref="M:Au.BlockUserInput.Stop(System.Boolean)"/>. Also automatically stops when this thread ends. Users can stop with Ctrl+Alt+Delete.
            </remarks>
            <example>
            <code><![CDATA[
            using(new BlockUserInput(BIEvents.All)) {
            	Print("blocked");
            	5.s();
            }
            Print("unblocked");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.BlockUserInput.#ctor">
            <summary>
            This constructor does nothing (does not call <see cref="M:Au.BlockUserInput.Start(Au.Types.BIEvents)"/>).
            </summary>
        </member>
        <member name="M:Au.BlockUserInput.#ctor(Au.Types.BIEvents)">
            <summary>
            This constructor calls <see cref="M:Au.BlockUserInput.Start(Au.Types.BIEvents)"/>.
            </summary>
            <exception cref="T:System.ArgumentException"><paramref name="what"/> is 0.</exception>
        </member>
        <member name="M:Au.BlockUserInput.Start(Au.Types.BIEvents)">
            <summary>
            Starts blocking.
            </summary>
            <exception cref="T:System.ArgumentException"><paramref name="what"/> is 0.</exception>
            <exception cref="T:System.InvalidOperationException">Already started.</exception>
        </member>
        <member name="M:Au.BlockUserInput.Dispose">
            <summary>
            Calls <see cref="M:Au.BlockUserInput.Stop(System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Au.BlockUserInput.Finalize">
            
        </member>
        <member name="M:Au.BlockUserInput.Stop(System.Boolean)">
            <summary>
            Stops blocking.
            Plays back blocked keys if need. See <see cref="P:Au.BlockUserInput.ResendBlockedKeys"/>.
            Does nothing if currently is not blocking.
            </summary>
            <param name="discardBlockedKeys">Do not play back blocked keys recorded because of <see cref="P:Au.BlockUserInput.ResendBlockedKeys"/>.</param>
        </member>
        <member name="P:Au.BlockUserInput.ResumeAfterCtrlAltDelete">
            <summary>
            Continue blocking when returned from a special screen where blocking is disabled: Ctrl+Alt+Delete, <see cref="T:Au.Process_.UacInfo">UAC</see> consent, etc.
            </summary>
        </member>
        <member name="P:Au.BlockUserInput.ResendBlockedKeys">
            <summary>
            Record blocked keys, and play back when stopped blocking.
            </summary>
            <remarks>
            Will not play back if: 1. The blocking time is &gt;= 10 seconds. 2. Detected Ctrl+Alt+Delete, <see cref="T:Au.Process_.UacInfo">UAC</see> consent or some other special screen. 3. Called <see cref="P:Au.BlockUserInput.Pause"/>.
            </remarks>
        </member>
        <member name="P:Au.BlockUserInput.DoNotBlockInjectedExtraInfo">
            <summary>
            Do not block software-generated key/mouse events if this extra info value was set when calling API <msdn>SendInput</msdn>.
            The default value is the value used by functions of this library, that is why their events are not blocked. If changed, their events are blocked, unless <see cref="P:Au.BlockUserInput.DoNotBlockInjected"/> is true.
            </summary>
        </member>
        <member name="P:Au.BlockUserInput.DoNotBlockInjected">
            <summary>
            Do not block software-generated key/mouse events.
            If false (default), only events generated by functions of this library are not blocked, unless <see cref="P:Au.BlockUserInput.DoNotBlockInjectedExtraInfo"/> is changed.
            </summary>
        </member>
        <member name="P:Au.BlockUserInput.DoNotBlockKeys">
            <summary>
            Do not block these keys.
            Default: { KKey.Pause, KKey.PrintScreen, KKey.F1 }.
            </summary>
            <remarks>
            The array should contain keys without modifier key flags.
            </remarks>
        </member>
        <member name="P:Au.BlockUserInput.Pause">
            <summary>
            Gets or sets whether the blocking is paused.
            </summary>
            <remarks>
            The 'set' function is much faster than <see cref="M:Au.BlockUserInput.Stop(System.Boolean)"/>/<see cref="M:Au.BlockUserInput.Start(Au.Types.BIEvents)"/>. Does not remove hooks etc. Discards blocked keys.
            </remarks>
        </member>
        <member name="T:Au.Clipb">
            <summary>
            Clipboard functions: copy, paste, get and set clipboard text and other data.
            </summary>
            <remarks>
            This class is similar to the .NET <see cref="T:System.Windows.Forms.Clipboard"/> class, which uses OLE API, works only in STA threads and does not work well in automation scripts. This class uses non-OLE API and works well in automation scripts and any threads.
            
            To set/get clipboard data of non-text formats, use class <see cref="T:Au.Clipb.Data"/>; to paste, use it with <see cref="M:Au.Clipb.PasteData(Au.Clipb.Data,Au.Types.OptKey)"/>; to copy (get from the active app), use it with <see cref="M:Au.Clipb.CopyData(System.Action,System.Boolean,Au.Types.OptKey)"/>.
            
            Should not be used to copy/paste in windows of own thread. In most cases it works, but strange problems are possible, because it waits until the window processes the copy/paste request, and while waiting it gets/dispatches all messages/events/etc. It's better to call it from another thread. Example in <see cref="M:Au.Keyb.Key(System.Object[])"/>.
            </remarks>
        </member>
        <member name="M:Au.Clipb.Clear">
            <summary>
            Clears the clipboard.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry).</exception>
        </member>
        <member name="P:Au.Clipb.Text">
            <summary>
            Gets or sets clipboard text.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry) or set clipboard data.</exception>
            <exception cref="T:System.OutOfMemoryException">The 'set' function failed to allocate memory.</exception>
            <remarks>
            The 'get' function calls <see cref="M:Au.Clipb.Data.GetText(System.Int32)"/>. Also can get file paths, as multiline text. Returns null if there is no text/files.
            </remarks>
            <seealso cref="T:Au.Clipb.Data"/>
        </member>
        <member name="M:Au.Clipb._SetClipboardData_ClipboardViewerIgnore">
            <summary>
            Calls API SetClipboardData("Clipboard Viewer Ignore"). Clipboard must be open.
            Then clipboard manager/viewer/etc programs that are aware of this convention don't try to get our clipboard data while we are pasting.
            Tested apps that support it: Ditto, Clipdiary. Other 5 tested apps don't.
            </summary>
        </member>
        <member name="M:Au.Clipb.CopyText(System.Boolean,Au.Types.OptKey)">
            <summary>
            Gets the selected text from the focused app using the clipboard.
            </summary>
            <param name="cut">Use Ctrl+X.</param>
            <param name="options">
            Options. If null (default), uses <see cref="P:Au.Opt.Key"/>.
            Uses <see cref="P:Au.Types.OptKey.RestoreClipboard" r=""/>, <see cref="P:Au.Types.OptKey.NoBlockInput" r=""/>, <see cref="P:Au.Types.OptKey.KeySpeedClipboard" r=""/>. Does not use <see cref="P:Au.Types.OptKey.Hook" r=""/>.
            </param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Also can get file paths, as multiline text.
            Sends keys Ctrl+C, waits until the focused app sets clipboard data, gets it, finally restores clipboard data.
            Fails (exception) if the focused app does not set clipboard text or file paths, for example if there is no selected text/files.
            Works with console windows too, even if they don't support Ctrl+C.
            </remarks>
        </member>
        <member name="M:Au.Clipb.CopyData(System.Action,System.Boolean,Au.Types.OptKey)">
            <summary>
            Gets data of any formats from the focused app using the clipboard and a callback function.
            </summary>
            <param name="callback">Callback function. It can get clipboard data of any formats. It can use any clipboard functions, for example the <see cref="T:Au.Clipb.Data"/> class or the .NET <see cref="T:System.Windows.Forms.Clipboard"/> class. Don't call copy/paste functions.</param>
            <param name="cut">Use Ctrl+X.</param>
            <param name="options"><inheritdoc cref="M:Au.Clipb.CopyText(System.Boolean,Au.Types.OptKey)"/></param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <exception cref="T:System.Exception">Exceptions thrown by the callback function.</exception>
            <remarks>
            Sends keys Ctrl+C, waits until the focused app sets clipboard data, calls callback function that gets it, finally restores clipboard data.
            Fails (exception) if the focused app does not set clipboard data.
            Works with console windows too, even if they don't support Ctrl+C.
            </remarks>
            <example>
            <code><![CDATA[
            string text = null; Bitmap image = null; string[] files = null;
            Clipb.CopyData(() => { text = Clipb.Data.GetText(); image = Clipb.Data.GetImage(); files = Clipb.Data.GetFiles(); });
            if(text == null) Print("no text in clipboard"); else Print(text);
            if(image == null) Print("no image in clipboard"); else Print(image.Size);
            if(files == null) Print("no files in clipboard"); else Print(files);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Clipb.PasteText(System.String,Au.Types.OptKey)">
            <summary>
            Pastes text into the focused app using the clipboard.
            </summary>
            <param name="text">Text.</param>
            <param name="options">
            Options. If null (default), uses <see cref="P:Au.Opt.Key"/>.
            Uses <see cref="P:Au.Types.OptKey.RestoreClipboard" r=""/>, <see cref="P:Au.Types.OptKey.PasteEnter" r=""/>, <see cref="P:Au.Types.OptKey.NoBlockInput" r=""/>, <see cref="P:Au.Types.OptKey.SleepFinally" r=""/>, <see cref="P:Au.Types.OptKey.Hook" r=""/>, <see cref="P:Au.Types.OptKey.KeySpeedClipboard" r=""/>.
            </param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Adds to the clipboard, sends keys Ctrl+V, waits until the focused app gets clipboard data, finally restores clipboard data.
            Fails (exception) if nothing gets clipboard data in several seconds.
            Works with console windows too, even if they don't support Ctrl+V.
            A clipboard viewer/manager program can make this function slower and less reliable, unless it supports <see cref="P:Au.Types.ClipFormats.ClipboardViewerIgnore"/> or gets clipboard data with a delay.
            Possible problems with some virtual PC programs. Either pasting does not work in their windows, or they use a hidden clipboard viewer that makes this function slower and less reliable.
            </remarks>
            <seealso cref="M:Au.Keyb.Text(System.String,System.Object[])"/>
            <example>
            <code><![CDATA[
            Clipb.PasteText("Example\r\n");
            Paste("Example\r\n"); //the same as above
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Clipb.PasteData(Au.Clipb.Data,Au.Types.OptKey)">
            <summary>
            Pastes data added to a <see cref="T:Au.Clipb.Data"/> variable into the focused app using the clipboard.
            </summary>
            <inheritdoc cref="M:Au.Clipb.PasteText(System.String,Au.Types.OptKey)"/>
            <example>
            Paste data of two formats: HTML and text.
            <code><![CDATA[
            Clipb.PasteData(new Clipb.Data().AddHtml("<b>text</b>").AddText("text"));
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Clipb.LibPaste(System.Object,Au.Types.OptKey,Au.Wnd)">
            <summary>
            Used by Clipb and Keyb.
            The caller should block user input (if need), release modifier keys, get opt/wFocus, sleep finally (if need).
            </summary>
            <param name="data">string or Data.</param>
            <param name="opt"></param>
            <param name="wFocus"></param>
        </member>
        <member name="T:Au.Clipb._ClipboardListener">
            <summary>
            Waits until the target app gets (Paste) or sets (Copy) clipboard text.
            For it subclasses our clipboard owner window and uses clipboard messages. Does not unsubclass.
            </summary>
        </member>
        <member name="P:Au.Clipb._ClipboardListener.Success">
            <summary>
            The clipboard message has been received. Probably the target window responded to the Ctrl+C or Ctrl+V.
            On Paste it is unreliable because of clipboard viewers/managers/etc. The caller also must check IsBadWindow.
            </summary>
        </member>
        <member name="F:Au.Clipb._ClipboardListener.IsBadWindow">
            <summary>
            On Paste, true if probably not the target process retrieved clipboard data. Probably a clipboard viewer/manager/etc.
            Not used on Copy.
            </summary>
        </member>
        <member name="F:Au.Clipb._ClipboardListener.FailedToSetData">
            <summary>
            Exception thrown/catched when failed to set clipboard data.
            </summary>
        </member>
        <member name="M:Au.Clipb._ClipboardListener.#ctor(System.Boolean,System.Object,Au.Wnd,Au.Wnd)">
            <summary>
            Subclasses clipOwner.
            </summary>
            <param name="paste">true if used for paste, false if for copy.</param>
            <param name="data">If used for paste, can be string containing Unicode text or int/string dictionary containing clipboard format/data.</param>
            <param name="clipOwner">Our clipboard owner window.</param>
            <param name="wFocus">The target control or window.</param>
        </member>
        <member name="M:Au.Clipb._ClipboardListener.Wait(Au.Keyb.Lib.SendCopyPaste@)">
            <summary>
            Waits until the target app gets (Paste) or sets (Copy) clipboard text.
            Throws AuException on timeout (3 s normally, 28 s if the target window is hung).
            </summary>
            <param name="ctrlKey">The variable that was used to send Ctrl+V or Ctrl+C. This function may call Release to avoid too long Ctrl down.</param>
        </member>
        <member name="T:Au.Clipb._OpenClipboard">
            <summary>
            Opens and closes clipboard using API OpenClipboard and CloseClipboard.
            Constructor tries to open for 10 s, then throws AuException.
            If the 'createOwner' parameter is true, creates temporary message-only clipboard owner window.
            If the 'noOpenNow' parameter is true, does not open, only creates owner if need.
            Dispose() closes clipboard and destroys the owner window.
            </summary>
        </member>
        <member name="M:Au.Clipb._OpenClipboard.Reopen(System.Boolean)">
            <summary>
            Opens again.
            Must be closed.
            Owner window should be not destroyed; does not create again.
            </summary>
            <param name="noThrow">If fails, return false, no exception. Also then waits 1 s instead of 10 s.</param>
            <exception cref="T:Au.Types.AuException">Failed to open.</exception>
        </member>
        <member name="T:Au.Clipb._SaveRestore">
            <summary>
            Saves and restores clipboard data.
            Clipboard must be open. Don't need to call EmptyClipboard before Restore.
            </summary>
        </member>
        <member name="T:Au.Clipb.Data">
            <summary>
            Sets or gets clipboard data in multiple formats.
            </summary>
            <remarks>
            The <b>AddX</b> functions add data to the variable (not to the clipboard). Then <see cref="M:Au.Clipb.Data.SetClipboard"/> copies the added data to the clipboard. Also you can use the variable with <see cref="M:Au.Clipb.PasteData(Au.Clipb.Data,Au.Types.OptKey)"/>.
            The static <b>GetX</b> functions get data directly from the clipboard.
            </remarks>
            <example>
            Get bitmap image from clipboard.
            <code><![CDATA[
            var image = Clipb.Data.GetImage();
            if(image == null) Print("no image in clipboard"); else Print(image.Size);
            ]]></code>
            Set clipboard data of two formats: text and image.
            <code><![CDATA[
            new Clipb.Data().AddText("text").AddImage(Image.FromFile(@"q:\file.png")).SetClipboard();
            ]]></code>
            Paste data of two formats: HTML and text.
            <code><![CDATA[
            Clipb.PasteData(new Clipb.Data().AddHtml("<b>text</b>").AddText("text"));
            ]]></code>
            Copy data of two formats: HTML and text.
            <code><![CDATA[
            string html = null, text = null;
            Clipb.CopyData(() => { html = Clipb.Data.GetHtml(); text = Clipb.Data.GetText(); });
            Print(html); Print(text);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Clipb.Data.AddText(System.String,System.Int32)">
            <summary>
            Adds text.
            Returns this.
            </summary>
            <param name="text">Text.</param>
            <param name="format">
            Clipboard format id. Default: <see cref="F:Au.Types.ClipFormats.Text"/> (CF_UNICODETEXT).
            Text encoding (UTF-16, ANSI, etc) depends on format; default UTF-16. See <see cref="M:Au.Types.ClipFormats.Register(System.String,System.Text.Encoding)"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException">Invalid format.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.Text.Encoding.GetBytes(System.String)"/>, which is called if encoding is not UTF-16.</exception>
        </member>
        <member name="M:Au.Clipb.Data.AddBinary(System.Byte[],System.Int32)">
            <summary>
            Adds data of any format as byte[].
            Returns this.
            </summary>
            <param name="data">byte[] containing data.</param>
            <param name="format">Clipboard format id. See <see cref="M:Au.Types.ClipFormats.Register(System.String,System.Text.Encoding)"/>.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException">Invalid format. Supported are all registered formats and standard formats &lt;CF_MAX except GDI handles.</exception>
        </member>
        <member name="M:Au.Clipb.Data.AddImage(System.Drawing.Image)">
            <summary>
            Adds image. Uses clipboard format <see cref="F:Au.Types.ClipFormats.Image"/> (CF_BITMAP).
            Returns this.
            </summary>
            <param name="image">Image. Must be <see cref="T:System.Drawing.Bitmap"/>, else exception.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Au.Clipb.Data.AddHtml(System.String)">
            <summary>
            Adds HTML text. Uses clipboard format <see cref="P:Au.Types.ClipFormats.Html"/> ("HTML Format").
            Returns this.
            </summary>
            <param name="html">Full HTML or HTML fragment. If full HTML, a fragment in it can be optionally specified. See examples.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <example>
            <code><![CDATA[
            d.AddHtml("<i>italy</i>");
            d.AddHtml("<html><body><i>italy</i></body></html>");
            d.AddHtml("<html><body><!--StartFragment--><i>italy</i><!--EndFragment--></body></html>");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Clipb.Data.AddRtf(System.String)">
            <summary>
            Adds rich text (RTF). Uses clipboard format <see cref="P:Au.Types.ClipFormats.Rtf"/> ("Rich Text Format").
            Returns this.
            </summary>
            <param name="rtf">Rich text. Simplest example: <c>@"{\rtf1 text\par}"</c>.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Au.Clipb.Data.AddFiles(System.String[])">
            <summary>
            Adds list of files to copy/paste. Uses clipboard format <see cref="F:Au.Types.ClipFormats.Files"/> (CF_HDROP).
            Returns this.
            </summary>
            <param name="files">One or more file paths.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Au.Clipb.Data.SetClipboard">
            <summary>
            Copies the added data of all formats to the clipboard.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry) or set clipboard data.</exception>
            <exception cref="T:System.OutOfMemoryException">Failed to allocate memory for clipboard data.</exception>
            <remarks>
            Calls API <msdn>OpenClipboard</msdn>, <msdn>EmptyClipboard</msdn>, <msdn>SetClipboardData</msdn> and <msdn>CloseClipboard</msdn>.
            </remarks>
        </member>
        <member name="M:Au.Clipb.Data.SetOpenClipboard(System.Boolean,System.Int32)">
            <summary>
            Copies the added data to the clipboard.
            </summary>
            <param name="renderLater">Call API <msdn>SetClipboardData</msdn>(format, default). When/if some app will try to get clipboard data, the first time your clipboard owner window will receive <msdn>WM_RENDERFORMAT</msdn> message and should call <c>SetOpenClipboard(false);</c>.</param>
            <param name="format">Copy data only of this format. If 0 (default), of all formats.</param>
            <exception cref="T:System.OutOfMemoryException">Failed to allocate memory for clipboard data.</exception>
            <exception cref="T:Au.Types.AuException">Failed to set clipboard data.</exception>
            <remarks>
            This function is similar to <see cref="M:Au.Clipb.Data.SetClipboard"/>. It calls API <msdn>SetClipboardData</msdn> and does not call <b>OpenClipboard</b>, <b>EmptyClipboard</b>, <b>CloseClipboard</b>. The clipboard must be open and owned by a window of this thread.
            </remarks>
        </member>
        <member name="M:Au.Clipb.Data.LibSetText(System.String)">
            <summary>
            Copies Unicode text to the clipboard without open/empty/close.
            </summary>
        </member>
        <member name="M:Au.Clipb.Data.LibCreateHtmlFormatData(System.String)">
            <summary>
            Converts HTML string to byte[] containing data in clipboard format "HTML Format".
            </summary>
            <param name="html">Full HTML or HTML fragment. If full HTML, a fragment in it can be optionally specified. See examples.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <example>
            HTML examples.
            <code><![CDATA[
            "<i>italy</i>"
            "<html><body><i>italy</i></body></html>"
            "<html><body><!--StartFragment--><i>italy</i><!--EndFragment--></body></html>"
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Clipb.Data.LibGetText(System.Int32)">
            <summary>
            Gets clipboard text without open/close.
            If format is 0, tries CF_UNICODETEXT and CF_HDROP.
            </summary>
        </member>
        <member name="M:Au.Clipb.Data.GetText(System.Int32)">
            <summary>
            Gets text from the clipboard.
            Returns null if there is no text.
            </summary>
            <param name="format">
            Clipboard format id. Default: <see cref="F:Au.Types.ClipFormats.Text"/> (CF_UNICODETEXT).
            If 0, tries to get text (<see cref="F:Au.Types.ClipFormats.Text"/>) or file paths (<see cref="F:Au.Types.ClipFormats.Files"/>; returns multiline text).
            Text encoding (UTF-16, ANSI, etc) depends on format; default UTF-16. See <see cref="M:Au.Types.ClipFormats.Register(System.String,System.Text.Encoding)"/>.
            </param>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry).</exception>
        </member>
        <member name="M:Au.Clipb.Data.GetBinary(System.Int32)">
            <summary>
            Gets clipboard data of any format as byte[].
            Returns null if there is no data of the specified format.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid format. Supported are all registered formats and standard formats &lt;CF_MAX except GDI handles.</exception>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry).</exception>
        </member>
        <member name="M:Au.Clipb.Data.GetImage">
            <summary>
            Gets image from the clipboard. Uses clipboard format <see cref="F:Au.Types.ClipFormats.Image"/> (CF_BITMAP).
            Returns null if there is no data of this format.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.Drawing.Image.FromHbitmap(System.IntPtr)"/>.</exception>
        </member>
        <member name="M:Au.Clipb.Data.GetHtml">
            <summary>
            Gets HTML text from the clipboard. Uses clipboard format <see cref="P:Au.Types.ClipFormats.Html"/> ("HTML Format").
            Returns null if there is no data of this format or if failed to parse it.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry).</exception>
        </member>
        <member name="M:Au.Clipb.Data.GetHtml(System.Int32@,System.Int32@,System.String@)">
            <summary>
            Gets HTML text from the clipboard. Uses clipboard format <see cref="P:Au.Types.ClipFormats.Html"/> ("HTML Format").
            Returns null if there is no data of this format or if failed to parse it.
            </summary>
            <param name="fragmentStart">Fragment start index in the returned string.</param>
            <param name="fragmentLength">Fragment length.</param>
            <param name="sourceURL">Source URL, or null if unavailable.</param>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry).</exception>
        </member>
        <member name="M:Au.Clipb.Data.GetRtf">
            <summary>
            Gets rich text (RTF) from the clipboard. Uses clipboard format <see cref="P:Au.Types.ClipFormats.Rtf"/> ("Rich Text Format").
            Returns null if there is no data of this format.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry).</exception>
        </member>
        <member name="M:Au.Clipb.Data.GetFiles">
            <summary>
            Gets file paths from the clipboard. Uses clipboard format <see cref="F:Au.Types.ClipFormats.Files"/> (CF_HDROP).
            Returns null if there is no data of this format.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry).</exception>
        </member>
        <member name="M:Au.Clipb.Data._HdropToFiles(System.IntPtr)">
            <summary>
            Gets file paths from HDROP.
            Returns array of 0 or more non-null elements.
            </summary>
        </member>
        <member name="M:Au.Clipb.Data.Contains(System.Int32)">
            <summary>
            Returns true if the clipboard contains data of the specified format.
            </summary>
            <param name="format">Clipboard format id. See <see cref="T:Au.Types.ClipFormats"/>.</param>
            <remarks>Calls API <msdn>IsClipboardFormatAvailable</msdn>.</remarks>
        </member>
        <member name="M:Au.Clipb.Data.Contains(System.Int32[])">
            <summary>
            Returns the first of the specified formats that is in the clipboard.
            Returns 0 if the clipboard is empty. Returns -1 if the clipboard contains data but not in any of the specified formats.
            </summary>
            <param name="formats">Clipboard format ids. See <see cref="T:Au.Types.ClipFormats"/>.</param>
            <remarks>Calls API <msdn>GetPriorityClipboardFormat</msdn>.</remarks>
        </member>
        <member name="T:Au.NoClass">
            <summary>
            This class contains aliases of some frequently used functions. You can call them without type name.
            </summary>
            <remarks>
            In C# source files add <c>using static Au.NoClass;</c>, and you can call these functions without type name.
            Examples:
            <c>Print</c> is the same as <c>Output.Write</c>;
            <c>Empty</c> is the same as <c>string.IsNullOrEmpty</c>;
            </remarks>
        </member>
        <member name="M:Au.NoClass.Paste(System.String)">
            <summary>
            Calls <see cref="M:Au.Clipb.PasteText(System.String,Au.Types.OptKey)"/>.
            </summary>
            <inheritdoc cref="M:Au.Clipb.PasteText(System.String,Au.Types.OptKey)"/>
        </member>
        <member name="M:Au.NoClass.CopyText">
            <summary>
            Calls <see cref="M:Au.Clipb.CopyText(System.Boolean,Au.Types.OptKey)"/>.
            </summary>
            <inheritdoc cref="M:Au.Clipb.CopyText(System.Boolean,Au.Types.OptKey)"/>
        </member>
        <member name="M:Au.NoClass.Key(System.Object[])">
            <summary>
            Sends virtual keystrokes to the active window. Also can send text, wait, etc.
            Calls <see cref="M:Au.Keyb.Key(System.Object[])"/>.
            </summary>
            <inheritdoc cref="M:Au.Keyb.Key(System.Object[])"/>
        </member>
        <member name="M:Au.NoClass.Text(System.String,System.Object[])">
            <summary>
            Sends text to the active window, using virtual keystrokes or the clipboard. Then also can send non-text keystrokes.
            Calls <see cref="M:Au.Keyb.Text(System.String,System.Object[])"/>.
            </summary>
            <inheritdoc cref="M:Au.Keyb.Text(System.String,System.Object[])"/>
        </member>
        <member name="M:Au.NoClass.Print(System.String)">
            <summary>
            Calls <see cref="M:Au.Output.Write(System.String)"/>. It writes string + "\r\n" to the output.
            </summary>
            <remarks>
            If "" or null, writes empty line. To write "null" if null, use code <c>Print((object)s);</c>.
            </remarks>
        </member>
        <member name="M:Au.NoClass.Print(System.Object)">
            <summary>
            Writes value of any type to the output.
            </summary>
            <param name="value">Value of any type. Can be null.</param>
            <remarks>
            Calls <see cref="M:System.Object.ToString"/> and <see cref="M:Au.Output.Write(System.String)"/>.
            If the type is unsigned integer (uint, ulong, ushort, byte), writes in hexadecimal format with prefix "0x".
            If null, prints "null".
            
            This overload is used for value types (int, RECT) etc and other types except strings, arrays and generic collections (they have own overloads; to use this function need to cast to object).
            </remarks>
        </member>
        <member name="M:Au.NoClass.LibPrintObjectToString(System.Object)">
            <summary>
            Converts object to string like <see cref="M:Au.NoClass.Print(System.Object)" r=""/> does.
            </summary>
        </member>
        <member name="M:Au.NoClass.Print``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Writes array, List, Dictionary or other generic collection to the output, as a list of items separated by "\r\n".
            </summary>
            <param name="value">Array or generic collection of any type. Can be null.</param>
            <remarks>
            Calls <see cref="M:Au.NoClass.PrintListEx``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Int32)"/>, which calls <see cref="M:Au.Output.Write(System.String)"/>.
            </remarks>
        </member>
        <member name="M:Au.NoClass.PrintListEx``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Int32)">
            <summary>
            Writes array, List, Dictionary or other generic collection to the output, as a list of items.
            </summary>
            <param name="value">Array or generic collection of any type. Can be null.</param>
            <param name="format">
            Item format string.
            
            These special substrings are replaced with:
            {s} - <c>item.ToString</c>, or "null" if null.
            {0} - item index, starting from 0.
            {1} - item index, starting from 1.
            
            Default "{s}\r\n". It works like <see cref="M:Au.NoClass.Print``1(System.Collections.Generic.IEnumerable{``0})" r=""/>.
            </param>
            <param name="trimEnd">
            How many characters to remove from the end of the result string.
            Default 2 (removes the default "\r\n" separator from the last item).
            </param>
            <remarks>
            Calls <see cref="M:System.Object.ToString"/> and <see cref="M:Au.Output.Write(System.String)"/>.
            </remarks>
        </member>
        <member name="M:Au.NoClass.Print(System.Object,System.Object,System.Object[])">
            <summary>
            Writes multiple arguments of any type to the output, using separator ", ".
            </summary>
            <remarks>
            Calls <see cref="M:System.Object.ToString"/> and <see cref="M:Au.Output.Write(System.String)"/>.
            If a value is null, writes "null".
            If a value is unsigned integer (uint, ulong, ushort, byte), writes in hexadecimal format with prefix "0x".
            </remarks>
        </member>
        <member name="M:Au.NoClass.PrintWarning(System.String,System.Int32,System.String)">
            <summary>
            Writes warning text to the output.
            By default appends the stack trace.
            </summary>
            <param name="text">Warning text.</param>
            <param name="showStackFromThisFrame">If &gt;= 0, appends the stack trace, skipping this number of frames. Default 0.</param>
            <param name="prefix">Text before <paramref name="text"/>. Default "Warning: ".</param>
            <remarks>
            Calls <see cref="M:Au.Output.Write(System.String)"/>.
            Does not show more that 1 warning/second, unless Opt.Debug.<see cref="P:Au.Types.OptDebug.Verbose" r=""/> == true.
            To disable some warnings, use Opt.Debug.<see cref="M:Au.Types.OptDebug.DisableWarnings(System.String[])" r=""/>.
            </remarks>
        </member>
        <member name="M:Au.NoClass.Empty(System.String)">
            <summary>
            Returns true if the string is null or "".
            The same as string.IsNullOrEmpty.
            </summary>
        </member>
        <member name="T:Au.Keyb">
            <summary>
            Keyboard functions: send virtual keystrokes and text to the active window, get key states.
            </summary>
            <remarks>
            The main function is <see cref="M:Au.Keyb.Key(System.Object[])"/>. Most documentation is there. See also <see cref="M:Au.Keyb.Text(System.String,System.Object[])"/>. These functions use <see cref="P:Au.Opt.Key"/>. Alternatively can be used <b>Keyb</b> variables, see <see cref="M:Au.Keyb.#ctor(Au.Types.OptKey)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            Keyb.Key("Ctrl+Shift+Left"); //press Ctrl+Shift+Left
            
            Opt.Key.KeySpeed = 300; //set options for static functions
            Keyb.Key("Ctrl+A Del Tab*3", "text", "Enter", 500); //press Ctrl+A, press Del, press Tab 3 times, send text, press Enter, wait 100 ms
            
            Keyb.Text("text\r\n"); //send text that ends with newline
            Keyb.Text("text", "Enter", 300); //send text, press Enter, wait 300 ms
            
            Text("Key and Text can be used without the \"Keyb.\" prefix.");
            Key("Enter");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Keyb.#ctor(Au.Types.OptKey)">
            <param name="cloneOptions">Options to be copied to <see cref="P:Au.Keyb.Options"/> of this variable. If null, uses default options.</param>
            <example>
            <code><![CDATA[
            var k = new Keyb(Opt.Static.Key);
            k.Options.KeySpeed = 50;
            k.AddKeys("Tab // Space").AddRepeat(3).AddText("text").AddKey(KKey.Enter).AddSleep(500);
            k.Send(); //sends and clears the variable
            k.Add("Tab // Space*3", "text", KKey.Enter, 500); //does the same as the above k.Add... line
            for(int i = 0; i < 5; i++) k.Send(true); //does not clear the variable
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Keyb.Options">
            <summary>
            Options used by this variable.
            </summary>
        </member>
        <member name="M:Au.Keyb.AddKeys(System.String)">
            <summary>
            Adds keystrokes to the internal collection. They will be sent by <see cref="M:Au.Keyb.Send(System.Boolean)"/>.
            Returns self.
            </summary>
            <param name="keys">Key names and operators. Example: <c>"Tab Ctrl+V Alt+(E P) Left*3 Space a , 5 #5 $abc"</c>. More info: <see cref="M:Au.Keyb.Key(System.Object[])"/>. Can be null or "".</param>
            <exception cref="T:System.ArgumentException">Error in <paramref name="keys"/> string, for example an unknown key name.</exception>
        </member>
        <member name="M:Au.Keyb.AddKey(Au.Types.KKey,System.Nullable{System.Boolean})">
            <summary>
            Adds single key, specified as <see cref="T:Au.Types.KKey"/>, to the internal collection. It will be sent by <see cref="M:Au.Keyb.Send(System.Boolean)"/>.
            Returns self.
            </summary>
            <param name="key">Virtual-key code, as <see cref="T:Au.Types.KKey"/> or int like <c>(KKey)200</c>. Valid values are 1-255.</param>
            <param name="down">true - key down; false - key up; null (default) - key down-up.</param>
            <exception cref="T:System.ArgumentException">Invalid <paramref name="key"/> (0).</exception>
        </member>
        <member name="M:Au.Keyb.AddKey(Au.Types.KKey,System.Int32,System.Boolean,System.Nullable{System.Boolean})">
            <summary>
            Adds single key to the internal collection. Allows to specify scan code and whether it is an extended key. It will be sent by <see cref="M:Au.Keyb.Send(System.Boolean)"/>.
            Returns self.
            </summary>
            <param name="key">Virtual-key code, as <see cref="T:Au.Types.KKey"/> or int like <c>(KKey)200</c>. Valid values are 1-255. Can be 0.</param>
            <param name="scanCode">Scan code of the physical key. Scan code values are 1-127, but this function allows 1-0xffff. Can be 0.</param>
            <param name="extendedKey">true if the key is an extended key.</param>
            <param name="down">true - key down; false - key up; null (default) - key down-up.</param>
            <exception cref="T:System.ArgumentException">Invalid scan code.</exception>
        </member>
        <member name="M:Au.Keyb.LibAddRaw(Au.Types.KKey,System.UInt16,System.Byte)">
            <summary>
            Adds key down or up event.
            </summary>
            <param name="vk"></param>
            <param name="scan"></param>
            <param name="siFlags">SendInput flags.</param>
        </member>
        <member name="M:Au.Keyb.AddText(System.String)">
            <summary>
            Adds text. It will be sent by <see cref="M:Au.Keyb.Send(System.Boolean)"/>.
            Returns self.
            </summary>
            <param name="text">Text. Can be null.</param>
            <remarks>
            To send text can be used keys or clipboard, depending on <see cref="P:Au.Opt.Key"/> and text.
            </remarks>
        </member>
        <member name="M:Au.Keyb.AddCallback(System.Action)">
            <summary>
            Adds a callback function.
            Returns self.
            </summary>
            <param name="callback"></param>
            <remarks>
            The callback function will be called by <see cref="M:Au.Keyb.Send(System.Boolean)"/> and can do anything except sending keys and copy/paste.
            </remarks>
        </member>
        <member name="M:Au.Keyb.AddRepeat(System.Int32)">
            <summary>
            Adds the repeat-key operator. Then <see cref="M:Au.Keyb.Send(System.Boolean)"/> will send the last added key the specified number of times.
            Returns self.
            </summary>
            <param name="count">Repeat count.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> &gt;10000 or &lt;0.</exception>
            <exception cref="T:System.ArgumentException">The last added item is not key. Can repeat only single key; cannot repeat text etc.</exception>
        </member>
        <member name="M:Au.Keyb.AddSleep(System.Int32)">
            <summary>
            Adds a short pause. Then <see cref="M:Au.Keyb.Send(System.Boolean)"/> will sleep (wait).
            Returns self.
            </summary>
            <param name="timeMS">Time to sleep, milliseconds.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeMS"/> &gt;10000 (1 minute) or &lt;0.</exception>
        </member>
        <member name="M:Au.Keyb.Add(System.Object[])">
            <summary>
            Adds keystrokes, text, sleep and other events to the internal collection. They will be sent/executed by <see cref="M:Au.Keyb.Send(System.Boolean)"/>.
            Returns self.
            </summary>
            <param name="keysEtc">Arguments. The same as with <see cref="M:Au.Keyb.Key(System.Object[])"/>.</param>
            <exception cref="T:System.ArgumentException">An argument is of an unsupported type or has an invalid value, for example unknown key name.</exception>
        </member>
        <member name="M:Au.Keyb.Send(System.Boolean)">
            <summary>
            Sends keys, text and executes other events added with the <b>AddX</b> functions.
            </summary>
            <param name="canSendAgain">Don't clear the internal collection. If true, this function then can be called again (eg in loop) to send/execute the same keys etc. If false (default), clears the added keys etc; then you can call <b>AddX</b> functions and <b>Send</b> again.</param>
            <exception cref="T:System.ArgumentException"><paramref name="canSendAgain"/> is true and keys end with + or (.</exception>
        </member>
        <member name="M:Au.Keyb._KeynameToKey(System.String,System.Int32,System.Int32)">
            <summary>
            Converts part of string to <see cref="T:Au.Types.KKey"/>.
            The substring should contain single key name, eg "Esc", "A", "=".
            Returns 0 if invalid key name.
            </summary>
        </member>
        <member name="T:Au.Keyb.Lib">
            <summary>
            Internal static functions.
            </summary>
        </member>
        <member name="M:Au.Keyb.Lib.Sleep(System.Int32)">
            <summary>
            Calls Time.SleepDoEvents.
            </summary>
        </member>
        <member name="M:Au.Keyb.Lib.LimitSleepTime(System.Int32)">
            <summary>
            If t &gt; 10, returns (t / 4 + 8).
            </summary>
        </member>
        <member name="M:Au.Keyb.Lib.KeyToMod(Au.Types.KKey)">
            <summary>
            If k is Shift, Ctrl, Alt or Win, returns it as modifier flag, eg KMod.Shift.
            Else returns 0.
            Also supports RShift etc.
            </summary>
        </member>
        <member name="M:Au.Keyb.Lib.VkToSc(Au.Types.KKey,Au.Types.LPARAM)">
            <summary>
            Gets scan code from virtual-key code.
            </summary>
            <param name="vk"></param>
            <param name="hkl">Keyboard layout. If default(LPARAM), uses of current thread.</param>
        </member>
        <member name="M:Au.Keyb.Lib.SendKeyEventRaw(Au.Types.KKey,System.UInt16,System.UInt32)">
            <summary>
            Sends one key event.
            Just calls API SendInput with raw parameters.
            </summary>
        </member>
        <member name="M:Au.Keyb.Lib.SendKey(Au.Types.KKey,System.Int32)">
            <summary>
            Sends key.
            Not used for keys whose scancode can depend on keyboard layout. To get scancode, uses keyboard layout of current thread.
            </summary>
            <param name="k"></param>
            <param name="downUp">1 down, 2 up, 0 down-up.</param>
        </member>
        <member name="M:Au.Keyb.Lib.ModPressRelease(System.Boolean,Au.Types.KMod)">
            <summary>
            Presses or releases one or more modifier keys.
            Sends in this order: Ctrl, Alt, Shift, Win.
            </summary>
            <param name="press"></param>
            <param name="mod">Modifier keys. Does nothing if 0.</param>
        </member>
        <member name="M:Au.Keyb.Lib.ReleaseModAndCapsLock(Au.Types.OptKey,System.Boolean)">
            <summary>
            Releases modifier keys if pressed. Optionally turns off CapsLock if toggled.
            Returns true if was CapsLock.
            Uses options NoModOff and NoCapsOff. Does not call Hook.
            </summary>
            <param name="opt"></param>
            <param name="forClipb">Used for Clipb Ctrl+V/C/X. Ignore CapsLock and always release modifiers, regardless of opt.</param>
        </member>
        <member name="T:Au.Keyb.Lib.SendCopyPaste">
            <summary>
            Sends Ctrl+V or Ctrl+C or Ctrl+X, and/or optionally Enter.
            Caller gets opt and wFocus with _GetOptionsAndWndFocused (it may want to know some options too).
            Caller calls Press, waits until the target app gets clipboard data, then calls Release.
            </summary>
        </member>
        <member name="M:Au.Keyb.Lib.SendCopyPaste.Press(Au.Types.KKey,Au.Types.OptKey,Au.Wnd,System.Boolean)">
            <summary>
            Presses Ctrl+key. Does not release.
            If enter is true, Release will press Enter.
            </summary>
        </member>
        <member name="M:Au.Keyb.Lib.SendCopyPaste.Release">
            <summary>
            Releases keys.
            Does nothing if already released.
            </summary>
        </member>
        <member name="M:Au.Keyb.Lib.SendCopyPaste.Enter(Au.Types.OptKey)">
            <summary>
            Sends Enter.
            </summary>
        </member>
        <member name="M:Au.Keyb._GetOptionsAndWndFocused(Au.Wnd@,System.Boolean)">
            <summary>
            Returns OptKey of this variable or OptKey cloned from this variable and possibly modified by Hook.
            </summary>
            <param name="wFocus">receives the focused or active window. Also the function uses it to avoid frequent calling of Hook.</param>
            <param name="getWndAlways">if false, the caller does not need wFocus. Then wFocus will be default(Wnd) if Hook is null.</param>
        </member>
        <member name="M:Au.Keyb._GetOptions(Au.Wnd)">
            <summary>
            Returns OptKey of this variable or OptKey cloned from this variable and possibly modified by Hook.
            </summary>
            <param name="wFocus">the focused or active window. The function uses it to avoid frequent calling of Hook. If you don't have it, use _GetOptionsAndWndFocused instead.</param>
        </member>
        <member name="P:Au.Keyb.IsAlt">
            <summary>
            Returns true if Alt key is pressed.
            </summary>
            <remarks>
            Uses <see cref="M:Au.Keyb.GetKeyState(Au.Types.KKey)"/>.
            </remarks>
        </member>
        <member name="P:Au.Keyb.IsCtrl">
            <summary>
            Returns true if Ctrl key is pressed.
            </summary>
            <remarks>
            Uses <see cref="M:Au.Keyb.GetKeyState(Au.Types.KKey)"/>.
            </remarks>
        </member>
        <member name="P:Au.Keyb.IsShift">
            <summary>
            Returns true if Shift key is pressed.
            </summary>
            <remarks>
            Uses <see cref="M:Au.Keyb.GetKeyState(Au.Types.KKey)"/>.
            </remarks>
        </member>
        <member name="P:Au.Keyb.IsWin">
            <summary>
            Returns true if Win key is pressed.
            </summary>
            <remarks>
            Uses <see cref="M:Au.Keyb.GetKeyState(Au.Types.KKey)"/>.
            </remarks>
        </member>
        <member name="M:Au.Keyb.IsMod(Au.Types.KMod)">
            <summary>
            Returns true if some modifier keys are pressed: Ctrl, Shift, Alt, Win.
            </summary>
            <param name="modifierKeys">Check only these keys. Default - all.</param>
            <seealso cref="M:Au.Keyb.WaitForNoModifierKeys(System.Double,Au.Types.KMod)"/>
            <remarks>
            Uses <see cref="M:Au.Keyb.GetKeyState(Au.Types.KKey)"/>.
            </remarks>
        </member>
        <member name="M:Au.Keyb.GetMod(Au.Types.KMod)">
            <summary>
            Gets flags indicating which modifier keys are pressed: Ctrl, Shift, Alt, Win.
            </summary>
            <param name="modifierKeys">Check only these keys. Default - all.</param>
            <remarks>
            Uses <see cref="M:Au.Keyb.GetKeyState(Au.Types.KKey)"/>.
            </remarks>
        </member>
        <member name="P:Au.Keyb.IsCapsLock">
            <summary>
            Returns true if the Caps Lock key is toggled.
            </summary>
            <remarks>
            Uses <see cref="M:Au.Keyb.GetKeyState(Au.Types.KKey)"/>.
            </remarks>
        </member>
        <member name="P:Au.Keyb.IsNumLock">
            <summary>
            Returns true if the Num Lock key is toggled.
            </summary>
            <remarks>
            Uses <see cref="M:Au.Keyb.GetKeyState(Au.Types.KKey)"/>.
            </remarks>
        </member>
        <member name="P:Au.Keyb.IsScrollLock">
            <summary>
            Returns true if the Scroll Lock key is toggled.
            </summary>
            <remarks>
            Uses <see cref="M:Au.Keyb.GetKeyState(Au.Types.KKey)"/>.
            </remarks>
        </member>
        <member name="M:Au.Keyb.GetKeyState(Au.Types.KKey)">
            <summary>
            Calls API <msdn>GetKeyState</msdn> and returns its return value.
            </summary>
            <remarks>
            If returns &lt; 0, the key is pressed. If the low-order bit is 1, the key is toggled; not all keys can be toggled.
            This key state changes when the active app receives the key down or up notification.
            This and other 'get key state' functions of this library except <see cref="M:Au.Keyb.GetAsyncKeyState(Au.Types.KKey)"/> use API <msdn>GetKeyState</msdn>.
            If a key is blocked by a hook, its state does not change. If it's a low-level hook, then it's impossible to detect whether the key is physically pressed.
            </remarks>
        </member>
        <member name="M:Au.Keyb.GetAsyncKeyState(Au.Types.KKey)">
            <summary>
            Calls API <msdn>GetAsyncKeyState</msdn> and returns its return value.
            </summary>
            <remarks>
            If returns &lt; 0, the key is pressed.
            This key state changes when the OS receives the key down or up notification and before the active app receives the notification.
            If a key is blocked by a low-level hook, its state does not change. Then it's impossible to detect whether the key is physically pressed.
            </remarks>
        </member>
        <member name="M:Au.Keyb.IsPressed(Au.Types.KKey)">
            <summary>
            Returns true if the specified key or mouse button is pressed.
            </summary>
            <remarks>
            Calls API <msdn>GetKeyState</msdn>.
            </remarks>
        </member>
        <member name="M:Au.Keyb.WaitForNoModifierKeys(System.Double,Au.Types.KMod)">
            <summary>
            Waits while some modifier keys (Ctrl, Shift, Alt, Win) are in pressed state (see <see cref="M:Au.Keyb.IsMod(Au.Types.KMod)"/>).
            </summary>
            <param name="secondsTimeout"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></param>
            <param name="modifierKeys">Check only these keys. Default - all.</param>
            <returns><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></returns>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
        </member>
        <member name="M:Au.Keyb.WaitForNoModifierKeysAndMouseButtons(System.Double,Au.Types.KMod,Au.Types.MButtons)">
            <summary>
            Waits while some modifier keys (Ctrl, Shift, Alt, Win) or mouse buttons are in pressed state.
            </summary>
            <param name="secondsTimeout"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></param>
            <param name="modifierKeys">Check only these keys. Default - all.</param>
            <param name="buttons">Check only these buttons. Default - all.</param>
            <returns><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></returns>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
            <seealso cref="M:Au.Keyb.IsMod(Au.Types.KMod)"/>
            <seealso cref="M:Au.Mouse.IsPressed(Au.Types.MButtons)"/>
            <seealso cref="M:Au.Mouse.WaitForNoButtonsPressed(System.Double,Au.Types.MButtons)"/>
        </member>
        <member name="M:Au.Keyb.WaitForReleased(System.Double,Au.Types.KKey[])">
            <summary>
            Waits while the specified keys or/and mouse buttons are in pressed state.
            </summary>
            <param name="secondsTimeout"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></param>
            <param name="keys">One or more keys or/and mouse buttons. Waits until all are released. Can be string like with <see cref="M:Au.Keyb.Key(System.Object[])"/>, without operators.</param>
            <returns><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></returns>
        </member>
        <member name="M:Au.Keyb.WaitForReleased(System.Double,System.String)">
            <inheritdoc cref="M:Au.Keyb.WaitForReleased(System.Double,Au.Types.KKey[])"/>
        </member>
        <member name="M:Au.Keyb.WaitForHotkey(System.Double,Au.Types.KHotkey,System.Boolean)">
            <summary>
            Registers a temporary hotkey and waits for it.
            </summary>
            <param name="secondsTimeout"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></param>
            <param name="hotkey"><inheritdoc cref="M:Au.Util.RegisterHotkey.Register(System.Int32,Au.Types.KHotkey,Au.Types.AnyWnd)"/></param>
            <param name="waitModReleased">Also wait until hotkey modifier keys released.</param>
            <returns><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></returns>
            <exception cref="T:System.ArgumentException">Error in hotkey string.</exception>
            <exception cref="T:Au.Types.AuException">Failed to register hotkey.</exception>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
            <remarks>
            Uses <see cref="T:Au.Util.RegisterHotkey"/>; it uses API <msdn>RegisterHotKey</msdn>.
            Fails if the hotkey is currently registered by this or another application or used by Windows. Also if F12.
            </remarks>
            <example>
            <code><![CDATA[
            Keyb.WaitForHotkey(0, "F11");
            Keyb.WaitForHotkey(0, KKey.F11);
            Keyb.WaitForHotkey(0, "Shift+A", true);
            Keyb.WaitForHotkey(0, (KMod.Ctrl | KMod.Shift, KKey.P)); //Ctrl+Shift+P
            Keyb.WaitForHotkey(0, Keys.Control | Keys.Alt | Keys.H); //Ctrl+Alt+H
            Keyb.WaitForHotkey(5, "Ctrl+Win+K"); //exception after 5 s
            if(!Keyb.WaitForHotkey(-5, "Left")) Print("timeout"); //returns false after 5 s
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Keyb.WaitForKey(System.Double,Au.Types.KKey,System.Boolean,System.Boolean)">
            <summary>
            Waits for key-down or key-up event of the specified key.
            </summary>
            <param name="secondsTimeout"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></param>
            <param name="key">Wait for this key. Can be a single-key string like with <see cref="M:Au.Keyb.Key(System.Object[])"/>.</param>
            <param name="up">Wait for key-up event.</param>
            <param name="block">Make the event invisible for other apps. If <paramref name="up"/> is true, makes the down event invisible too, if it comes while waiting for the up event.</param>
            <returns><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></returns>
            <exception cref="T:System.ArgumentException"><paramref name="key"/> is 0.</exception>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
            <remarks>
            Unlike <see cref="M:Au.Keyb.WaitForReleased(System.Double,Au.Types.KKey[])"/>, waits for key event, not for key state.
            Uses low-level keyboard hook. Can wait for any single key. See also <see cref="M:Au.Keyb.WaitForHotkey(System.Double,Au.Types.KHotkey,System.Boolean)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            Keyb.WaitForKey(0, KKey.Ctrl, up: false, block: true);
            Print("Ctrl");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Keyb.WaitForKey(System.Double,System.String,System.Boolean,System.Boolean)">
            <inheritdoc cref="M:Au.Keyb.WaitForKey(System.Double,Au.Types.KKey,System.Boolean,System.Boolean)"/>
            <exception cref="T:System.ArgumentException">Invalid <paramref name="key"/> string.</exception>
            <example>
            <code><![CDATA[
            Keyb.WaitForKey(0, "Ctrl", up: false, block: true);
            Print("Ctrl");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Keyb.WaitForKey(System.Double,System.Boolean,System.Boolean)">
            <summary>
            Waits for key-down or key-up event of any key, and gets the key code.
            </summary>
            <returns>
            Returns the key code. On timeout returns 0 if <paramref name="secondsTimeout"/> is negative; else exception.
            For modifier keys returns the left or right key code, for example LCtrl/RCtrl, not Ctrl.
            </returns>
            <inheritdoc cref="M:Au.Keyb.WaitForKey(System.Double,Au.Types.KKey,System.Boolean,System.Boolean)"/>
            <example>
            <code><![CDATA[
            var key = Keyb.WaitForKey(0, up: true, block: true);
            Print(key);
            ]]></code>
            </example>
        </member>
        <member name="T:Au.Keyb.Misc">
            <summary>
            Miscellaneous keyboard-related functions.
            </summary>
        </member>
        <member name="M:Au.Keyb.Misc.GetTextCursorRect(Au.Types.RECT@,Au.Wnd@,System.Boolean)">
            <summary>
            Gets text cursor (caret) position and size.
            Returns false if fails.
            </summary>
            <param name="r">Receives the rectangle, in screen coordinates.</param>
            <param name="w">Receives the control that contains the text cursor.</param>
            <param name="orMouse">If fails, get mouse pointer coodinates.</param>
            <remarks>
            Can get only standard text cursor. Many apps use non-standard cursor; then fails.
            Also fails if the text cursor currently is not displayed.
            </remarks>
        </member>
        <member name="M:Au.Keyb.Misc.ParseKeyName(System.String)">
            <summary>
            Converts key name to <see cref="T:Au.Types.KKey"/>.
            Returns 0 if unknown key name.
            </summary>
            <param name="keyName">Key name, like with <see cref="M:Au.Keyb.Key(System.Object[])"/>.</param>
        </member>
        <member name="M:Au.Keyb.Misc.LibParseKeyNameThrow(System.String)">
            <summary>
            Calls <see cref="M:Au.Keyb.Misc.ParseKeyName(System.String)"/> and throws ArgumentException if invalid key string.
            </summary>
            <param name="keyName"></param>
        </member>
        <member name="M:Au.Keyb.Misc.ParseKeyName(System.String,System.Int32,System.Int32)">
            <summary>
            Converts key name to <see cref="T:Au.Types.KKey"/>.
            Returns 0 if unknown key name.
            </summary>
            <param name="s">String containing key name, like with <see cref="M:Au.Keyb.Key(System.Object[])"/>.</param>
            <param name="startIndex">Key name start index in <paramref name="s"/>.</param>
            <param name="length">Key name length.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid start index or length.</exception>
        </member>
        <member name="M:Au.Keyb.Misc.ParseKeysString(System.String)">
            <summary>
            Converts keys string to <see cref="T:Au.Types.KKey"/> array.
            </summary>
            <param name="keys">String containing one or more key names, like with <see cref="M:Au.Keyb.Key(System.Object[])"/>. Operators are not supported.</param>
            <exception cref="T:System.ArgumentException">Error in keys string.</exception>
        </member>
        <member name="M:Au.Keyb.Misc.ParseHotkeyString(System.String,Au.Types.KMod@,Au.Types.KKey@)">
            <summary>
            Converts hotkey string to <see cref="T:Au.Types.KKey"/> and <see cref="T:Au.Types.KMod"/>.
            For example, if s is "Ctrl+Left", sets mod=KMod.Ctrl, key=KKey.Left.
            Returns false if the string is invalid.
            </summary>
            <remarks>
            Key names are like with <see cref="M:Au.Keyb.Key(System.Object[])"/>.
            Must be single non-modifier key, preceded by zero or more of modifier keys Ctrl, Shift, Alt, Win, all joined with +.
            Valid hotkey examples: "A", "a", "7", "F12", ".", "End", "Ctrl+D", "Ctrl+Alt+Shift+Win+Left", " Ctrl + U ".
            Invalid hotkey examples: null, "", "A+B", "Ctrl+A+K", "A+Ctrl", "Ctrl+Shift", "Ctrl+", "NoSuchKey", "tab".
            </remarks>
        </member>
        <member name="M:Au.Keyb.Misc.ParseHotkeyString(System.String,System.Windows.Forms.Keys@)">
            <summary>
            Converts hotkey string to <see cref="T:System.Windows.Forms.Keys"/>.
            For example, if s is "Ctrl+Left", sets hotkey=Keys.Control|Keys.Left.
            Returns false if the string is invalid.
            </summary>
            <inheritdoc cref="M:Au.Keyb.Misc.ParseHotkeyString(System.String,Au.Types.KMod@,Au.Types.KKey@)"/>
        </member>
        <member name="M:Au.Keyb.Misc.KModToKeys(Au.Types.KMod)">
            <summary>
            Converts modifier key flags from <b>KMod</b> to <b>Keys</b>.
            </summary>
            <remarks>
            For Win returns flag (Keys)0x80000.
            </remarks>
        </member>
        <member name="M:Au.Keyb.Misc.KModFromKeys(System.Windows.Forms.Keys)">
            <summary>
            Converts modifier key flags from <b>Keys</b> to <b>KMod</b>.
            </summary>
            <remarks>
            For Win can be used flag (Keys)0x80000.
            </remarks>
        </member>
        <member name="M:Au.Keyb.Key(System.Object[])">
            <summary>
            Sends virtual keystrokes to the active window. Also can send text, wait, etc.
            </summary>
            <param name="keysEtc">
            Any number of arguments of these types:
            <list type="bullet">
            <item>
            <term>string</term>
            <description>one or more key names separated by spaces or operators. More info in Remarks.
            Example: <c>Key("Enter A Ctrl+A");</c>
            See <see cref="M:Au.Keyb.AddKeys(System.String)"/>.
            </description>
            </item>
            <item>
            <term>string after 'keys' string</term>
            <description>literal text. When there are several strings in sequence, they are interpreted as keys, text, keys, text...
            Example: <c>Key("keys", "text", "keys", "text", 500, "keys", "text", "keys", KKey.Back, "keys", "text");</c>
            Function <see cref="M:Au.Keyb.Text(System.String,System.Object[])"/> is the same as <b>Key</b>, but the first parameter is text.
            To send text can be used keys or clipboard, depending on <see cref="P:Au.Opt.Key"/> and text.
            See <see cref="M:Au.Keyb.AddText(System.String)"/>.
            </description>
            </item>
            <item>
            <term><see cref="T:Au.Types.KKey"/></term>
            <description>a single key.
            Example: <c>Key("Shift+", KKey.Left, "*3");</c> is the same as <c>Key("Shift+Left*3");</c>.
            See <see cref="M:Au.Keyb.AddKey(Au.Types.KKey,System.Nullable{System.Boolean})"/>.
            </description>
            </item>
            <item>
            <term>int</term>
            <description>milliseconds to sleep. Max 10000.
            Example: <c>Key("Left", 500, "Right");</c>
            See <see cref="M:Au.Keyb.AddSleep(System.Int32)"/>.
            </description>
            </item>
            <item>
            <term><see cref="T:System.Action"/></term>
            <description>callback function.
            Example: <c>Action click = () => Mouse.Click(); Key("Shift+", click);</c>
            See <see cref="M:Au.Keyb.AddCallback(System.Action)"/>.
            </description>
            </item>
            <item>
            <term>null or ""</term>
            <description>nothing.
            Example: <c>Key("keys", 500, "", "text");</c>
            </description>
            </item>
            <item>
            <term>(int, bool)</term>
            <description>a single key, specified using scan code and extended-key flag.
            Example: <c>Key("", "key F1:", (0x3B, false));</c>
            See <see cref="M:Au.Keyb.AddKey(Au.Types.KKey,System.Int32,System.Boolean,System.Nullable{System.Boolean})"/>.
            </description>
            </item>
            <item>
            <term>(KKey, int, bool)</term>
            <description>a single key, specified using <see cref="T:Au.Types.KKey"/> and/or scan code and extended-key flag.
            Example: <c>Key("", "numpad Enter:", (KKey.Enter, 0, true));</c>
            See <see cref="M:Au.Keyb.AddKey(Au.Types.KKey,System.Int32,System.Boolean,System.Nullable{System.Boolean})"/>.
            </description>
            </item>
            </list>
            </param>
            <exception cref="T:System.ArgumentException">An argument is of an unsupported type or has an invalid value, for example an unknown key name.</exception>
            <remarks>
            Generates virtual keystrokes. Uses API <msdn>SendInput</msdn>. It works almost like real keyboard.
            
            Usually keys are specified in string, like in this example:
            <code><![CDATA[Key("A F2 Ctrl+Shift+A Enter*2"); //keys A, F2, Ctrl+Shift+A, Enter Enter
            ]]></code>
            
            Key names:
            <list type="table">
            <listheader>
            <term>Group</term>
            <term>Keys</term>
            <term>Info</term>
            </listheader>
            <item>
            <description>Named keys</description>
            <description>
            <b>Modifier:</b> Alt, Ctrl, Shift, Win
            <b>Right side:</b> RAlt, RCtrl, RShift, RWin
            <b>Lock:</b> CapsLock, NumLock, ScrollLock
            <b>Function:</b> F1-F24
            <b>Arrow:</b> Down, Left, Right, Up
            <b>Other:</b> Back, Del, End, Enter, Esc, Home, Ins, Menu, PgDown, PgUp, PrtSc, Space, Tab
            </description>
            <description>Start with an uppercase character. Only the first 3 characters are significant; others can be any ASCII letters. For example, can be <c>"Back"</c>, <c>"Bac"</c>, <c>"Backspace"</c> or <c>"BACK"</c>, but not <c>"back"</c> or <c>"Ba"</c> or <c>"Back5"</c>.
            
            Alternative key names: AltGr (RAlt), App (Menu), PageDown, PageUp, PrintScreen (PrtSc).
            </description>
            </item>
            <item>
            <description>Text keys</description>
            <description>
            <b>Alphabetic:</b> A-Z (or a-z)
            <b>Number:</b> 0-9
            <b>Numeric keypad:</b> #/ #* #- #+ #. #0-#9
            <b>Other:</b> =, ` - [ ] \ ; ' , . /
            </description>
            <description>Spaces between keys are optional, except for uppercase A-Z. For example, can be <c>"A B"</c>, <c>"a b"</c>, <c>"A b"</c> or <c>"ab"</c>, but not <c>"AB"</c> or <c>"Ab"</c>.
            
            For ` - [ ] \ ; ' , . / also can be used ~ _ { } | : " &lt; &gt; ?.
            </description>
            </item>
            <item>
            <description>Other keys</description>
            <description>Names of enum <see cref="T:Au.Types.KKey"/> or <see cref="T:System.Windows.Forms.Keys"/> members.</description>
            <description>Start with an uppercase character.
            Example: <c>Key("BrowserBack", KKey.BrowserBack);</c>
            </description>
            </item>
            <item>
            <description>Forbidden</description>
            <description>Fn, Ctrl+Alt+Del, Win+L, some other</description>
            <description>Programs cannot press these keys.</description>
            </item>
            <item>
            <description>Special characters</description>
            <description><b>Operator:</b> + * ( ) $
            <b>Numpad key prefix:</b> #
            <b>Reserved:</b> ! @ % ^ &amp;
            </description>
            <description>These characters cannot be used as keys. Use = 8 9 0 4 3 1 2 5 6 7.</description>
            </item>
            </list>
            
            Operators:
            <list type="table">
            <listheader>
            <term>Operator</term>
            <term>Examples</term>
            <term>Description</term>
            </listheader>
            <item>
            <description>+</description>
            <description><c>"Ctrl+Shift+A"</c><br/><c>"Alt+E+P"</c></description>
            <description>The same as <c>"Ctrl*down Shift*down A Shift*up Ctrl*up"</c> and <c>"Alt*down E*down P E*up Alt*up"</c>.</description>
            </item>
            <item>
            <description>+()</description>
            <description><c>"Alt+(E P)"</c></description>
            <description>The same as <c>"Alt*down E P Alt*up"</c>.
            Inside () cannot be used + or another +().
            </description>
            </item>
            <item>
            <description>*down</description>
            <description><c>"Ctrl*down"</c></description>
            <description>Press key and don't release.</description>
            </item>
            <item>
            <description>*up</description>
            <description><c>"Ctrl*up"</c></description>
            <description>Release key.</description>
            </item>
            <item>
            <description>*number</description>
            <description><c>"Left*3"</c></description>
            <description>Press key repeatedly, like <c>"Left Left Left"</c>.
            See <see cref="M:Au.Keyb.AddRepeat(System.Int32)"/>.
            </description>
            </item>
            <item>
            <description>$</description>
            <description><c>"$text"</c></description>
            <description>$ is the same as Shift+.</description>
            </item>
            </list>
            Operators and related keys can be in separate arguments. Examples: <c>Key("Shift+", KKey.A); Key(KKey.A, "*3");</c>.
            
            Uses <see cref="P:Au.Opt.Key"/>:
            <list type="table">
            <listheader>
            <term>Option</term>
            <term>Default</term>
            <term>Changed</term>
            </listheader>
            <item>
            <description><see cref="P:Au.Types.OptKey.NoBlockInput" r=""/></description>
            <description>false.
            Blocks user-pressed keys. Sends them afterwards.
            If the last argument is 'sleep', stops blocking before executing it; else stops blocking after executing all arguments.</description>
            <description>true.
            Does not block user-pressed keys. It can be dangerous.</description>
            </item>
            <item>
            <description><see cref="P:Au.Types.OptKey.NoCapsOff" r=""/></description>
            <description>false.
            If the CapsLock key is toggled, untoggles it temporarily (presses it before and after).</description>
            <description>true.
            Does not touch the CapsLock key.
            Alphabetic keys of 'keys' arguments can depend on CapsLock. Text of 'text' arguments doesn't depend on CapsLock, unless <see cref="P:Au.Types.OptKey.TextOption" r=""/> is <see cref="F:Au.Types.KTextOption.Keys"/>.</description>
            </item>
            <item>
            <description><see cref="P:Au.Types.OptKey.NoModOff" r=""/></description>
            <description>false.
            Releases modifier keys (Alt, Ctrl, Shift, Win) if pressed.
            Does it only at the start; later they cannot interfere, unless <see cref="P:Au.Types.OptKey.NoBlockInput" r=""/> is true.</description>
            <description>true.
            Does not touch modifier keys. It can be dangerous.</description>
            </item>
            <item>
            <description><see cref="P:Au.Types.OptKey.TextSpeed" r=""/></description>
            <description>0 ms.</description>
            <description>0 - 1000.
            Changes the speed for 'text' arguments (makes slower).</description>
            </item>
            <item>
            <description><see cref="P:Au.Types.OptKey.KeySpeed" r=""/></description>
            <description>1 ms.</description>
            <description>0 - 1000.
            Changes the speed for 'keys' arguments (makes slower if &gt;1).</description>
            </item>
            <item>
            <description><see cref="P:Au.Types.OptKey.KeySpeedClipboard" r=""/></description>
            <description>5 ms.</description>
            <description>0 - 1000.
            Changes the speed of Ctrl+V keys when text is pasted using the clipboard.</description>
            </item>
            <item>
            <description><see cref="P:Au.Types.OptKey.SleepFinally" r=""/></description>
            <description>10 ms.</description>
            <description>0 - 10000.
            Tip: to sleep finally, also can be used code like this: <c>Key("keys", 1000);</c>.</description>
            </item>
            <item>
            <description><see cref="P:Au.Types.OptKey.TextOption" r=""/></description>
            <description><see cref="F:Au.Types.KTextOption.Characters"/></description>
            <description><b>Keys</b> (send keys and Shift) or <b>Paste</b> (use clipboard).</description>
            </item>
            <item>
            <description><see cref="P:Au.Types.OptKey.PasteLength" r=""/></description>
            <description>300.
            This option is used for 'text' arguments. If text length &gt;= this value, uses the clipboard.</description>
            <description>&gt;=0.</description>
            </item>
            <item>
            <description><see cref="P:Au.Types.OptKey.PasteEnter" r=""/></description>
            <description>false.</description>
            <description>true.
            This option is used for 'text' arguments when using the clipboard.</description>
            </item>
            <item>
            <description><see cref="P:Au.Types.OptKey.RestoreClipboard" r=""/></description>
            <description>true.
            Restore clipboard data (by default only text).
            This option is used for 'text' arguments when using the clipboard.</description>
            <description>false.
            Don't restore clipboard data.</description>
            </item>
            <item>
            <description><see cref="P:Au.Types.OptKey.Hook" r=""/></description>
            <description>null.</description>
            <description>Callback function that can modify options depending on active window etc.</description>
            </item>
            </list>
            When you don't want to use or modify <see cref="P:Au.Opt.Key"/>, use a <see cref="T:Au.Keyb"/> variable instead of this function. Example: <c>new Keyb(null).Add("keys", "text").Send();</c>. More examples in <see cref="M:Au.Keyb.#ctor(Au.Types.OptKey)"/> topic.
            
            This function does not wait until the target app receives and processes sent keystrokes and text; there is no reliable way to know it. It just adds small delays depending on options (<see cref="P:Au.Types.OptKey.SleepFinally" r=""/> etc). If need, change options or add 'sleep' arguments or wait after calling this function. Sending text through the clipboard normally does not have these problems.
            
            This function should not be used to automate windows of own thread. In most cases it works, but strange problems are possible, because while waiting it gets/dispatches all messages/events/etc. It's better to call it from another thread. See the last example.
            
            Administrator and uiAccess processes don't receive keystrokes sent by standard user processes. See <see cref="T:Au.Process_.UacInfo">UAC</see>.
            
            The mouse button codes/names (eg <see cref="F:Au.Types.KKey.MouseLeft"/>) cannot be used to click. For it can be used callback, like in the "Ctrl+click" example.
            </remarks>
            <example>
            <code><![CDATA[
            //Press key Enter.
            Keyb.Key("Enter");
            
            //The same as above. The "Keyb." prefix is optional.
            Key("Enter");
            
            //Press keys Ctrl+A.
            Key("Ctrl+A");
            
            //Ctrl+Alt+Shift+Win+A.
            Key("Ctrl+Alt+Shift+Win+A");
            
            //Alt down, E, P, Alt up.
            Key("Alt+(E P)");
            
            //Alt down, E, P, Alt up.
            Key("Alt*down E P Alt*up");
            
            //Press key End, key Backspace 3 times, send text "Text".
            Key("End Back*3", "Text");
            
            //Press Tab n times, send text "user", press Tab, send text "password", press Enter.
            int n = 5;
            Key($"Tab*{n}", "user", "Tab", "password", "Enter");
            
            //Send text "Text".
            Text("Text");
            
            //Send text "user", press Tab, send text "password", press Enter.
            Text("user", "Tab", "password", "Enter");
            
            //Press Ctrl+V, wait 500 ms, press Enter.
            Key("Ctrl+V", 500, "Enter");
            
            //Press Ctrl+V, wait 500 ms, send text "Text".
            Key("Ctrl+V", 500, "", "Text");
            
            //F2, Ctrl+K, Left 3 times, Space, A, comma, 5, numpad 5, Shift+A, B, C, BrowserBack.
            Key("F2 Ctrl+K Left*3 Space a , 5 #5 $abc", KKey.BrowserBack);
            
            //Shift down, A 3 times, Shift up.
            Key("Shift+A*3");
            
            //Shift down, A 3 times, Shift up.
            Key("Shift+", KKey.A, "*3");
            
            //Shift down, A, wait 500 ms, B, Shift up.
            Key("Shift+(", KKey.A, 500, KKey.B, ")");
            
            //Send keys and text slowly.
            Opt.Key.KeySpeed = Opt.Key.TextSpeed = 50;
            Key("keys$:Space 123456789 Space 123456789 ,Space", "text: 123456789 123456789\n");
            
            //Ctrl+click
            Action click = () => Mouse.Click();
            Key("Ctrl+", click);
            
            //Ctrl+drag
            Action drag = () => { using(Mouse.LeftDown()) Mouse.MoveRelative(0, 50); };
            Key("Ctrl+", drag);
            
            //Ctrl+drag, poor man's version
            Key("Ctrl*down");
            using(Mouse.LeftDown()) Mouse.MoveRelative(0, 50);
            Key("Ctrl*up");
            ]]></code>
            Show form and send keys/text to it when button clicked.
            <code><![CDATA[
            static void TestKeyOwnThread()
            {
            	var f = new Form();
            	var b = new Button() { Text = "Key" };
            	var t = new TextBox() { Top = 100 };
            	var c = new Button() { Text = "Close", Left = 100 };
            	f.Controls.Add(b);
            	f.Controls.Add(t);
            	f.Controls.Add(c); f.CancelButton = c;
            
            	b.Click += async (unu, sed) =>
            	{
            		//Key("Tab", "text", 2000, "Esc"); //possible problems
            		await Task.Run(() => { Key("Tab", "text", 2000, "Esc"); }); //use other thread
            	};
            
            	f.ShowDialog();
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Keyb.Text(System.String,System.Object[])">
            <summary>
            Sends text to the active window, using virtual keystrokes or the clipboard. Also can send non-text keystrokes.
            </summary>
            <param name="text">Text to send.</param>
            <param name="keysEtc">Optional more parameters. The same as with <see cref="M:Au.Keyb.Key(System.Object[])"/>. Can be used for example to press non-text keys, wait, send more text.</param>
            <exception cref="T:System.ArgumentException">An argument in <paramref name="keysEtc"/> is of an unsupported type or has an invalid value, for example an unknown key name.</exception>
            <remarks>
            This function is identical to <see cref="M:Au.Keyb.Key(System.Object[])"/>, except: the first parameter is literal text (not keys). This example shows the difference: <c>Key("keys", "text", "keys", "text"); Text("text", "keys", "text", "keys");</c>.
            To send text can be used keys or clipboard, depending on <see cref="P:Au.Opt.Key"/> and text.
            More info in <see cref="M:Au.Keyb.Key(System.Object[])"/> topic.
            </remarks>
            <seealso cref="M:Au.Clipb.PasteText(System.String,Au.Types.OptKey)"/>
            <example>
            <code><![CDATA[
            Keyb.Text("Text where key names like Enter are interpreted as text.\r\n");
            Keyb.Text("Send this text, press key", "Enter", "and wait", 500, "milliseconds. Enter");
            Text("Can be used without the \"Keyb.\" prefix.\n");
            ]]></code>
            </example>
        </member>
        <member name="T:Au.OsdWindow">
            <summary>
            Transparent window that can be used for on-screen display. Derived classes on it can draw non-transparent text, rectangle, image, anything.
            </summary>
        </member>
        <member name="M:Au.OsdWindow.#ctor">
            
        </member>
        <member name="M:Au.OsdWindow.Dispose(System.Boolean)">
            <summary>Destroys the OSD window.</summary>
        </member>
        <member name="M:Au.OsdWindow.Dispose">
            <summary>Destroys the OSD window.</summary>
        </member>
        <member name="M:Au.OsdWindow.Close">
            <summary>Destroys the OSD window.</summary>
        </member>
        <member name="P:Au.OsdWindow.Handle">
            <summary>OSD window handle or default(Wnd).</summary>
        </member>
        <member name="P:Au.OsdWindow.IsHandleCreated">
            <summary>
            Returns true if the OSD window is created.
            </summary>
        </member>
        <member name="M:Au.OsdWindow.Redraw">
            <summary>
            Redraws the OSD window immediately.
            Does nothing it is not created or not visible.
            </summary>
        </member>
        <member name="M:Au.OsdWindow.Invalidate">
            <summary>
            Sets to redraw the OSD window later.
            Does nothing it is not created or not visible.
            </summary>
        </member>
        <member name="P:Au.OsdWindow.Opacity">
            <summary>
            Gets or sets the opacity of the OSD window, from 0 to 1.
            If 1 (default), completely opaque. If 0, pixels of <see cref="P:Au.OsdWindow.TransparentColor"/> are transparent, others opaque. If between 0 and 1, partially transparent.
            </summary>
            <remarks>
            This property can be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.OsdWindow.TransparentColor">
            <summary>
            Gets or sets transparent color, default 0xF5F4F5. Pixels of this color will be transparent, unless <see cref="P:Au.OsdWindow.Opacity"/> is not 0.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            Note: when used for transparent text, text edges are blended with this color, and it can become visible if the color is not chosen carefully.
            </remarks>
        </member>
        <member name="P:Au.OsdWindow.Rect">
            <summary>
            Gets or sets OSD window size and position in screen.
            </summary>
            <remarks>
            This property can be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.OsdWindow.Visible">
            <summary>
            Gets or sets whether the OSD window is visible.
            The 'set' function calls <see cref="M:Au.OsdWindow.Show"/> (it creates OSD window if need) or <see cref="M:Au.OsdWindow.Hide"/> (it does not destroy the OSD window).
            </summary>
        </member>
        <member name="M:Au.OsdWindow.Show">
            <summary>
            Shows the OSD window. Creates if need.
            </summary>
            <remarks>
            In any case, also moves the window to the top of the Z order.
            </remarks>
        </member>
        <member name="M:Au.OsdWindow.Hide">
            <summary>
            Hides the OSD window. Does not destroy; use <see cref="M:Au.OsdWindow.Close"/> or <see cref="M:Au.OsdWindow.Dispose(System.Boolean)"/> for it.
            Does nothing if not created or not visible.
            </summary>
        </member>
        <member name="M:Au.OsdWindow.WndProc(Au.Wnd,System.Int32,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>
            Called when the OSD window receives a message.
            If your derived class overrides this function, it must call base.WndProc and return its return value, except when don't need default processing.
            </summary>
        </member>
        <member name="M:Au.OsdWindow.OnPaint(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Called when the OSD window must be drawn or redrawn.
            Derived classes should override this function and draw anything. Don't need to call base.OnPaint of <see cref="T:Au.OsdWindow"/>, it does nothing.
            </summary>
            <remarks>
            If <see cref="P:Au.OsdWindow.Opacity"/> is 0 (default), <paramref name="g"/> is filled with <see cref="P:Au.OsdWindow.TransparentColor"/>. Pixels of this color will be transparent. The base class draws only non-transparent areas.
            </remarks>
        </member>
        <member name="P:Au.OsdWindow.Shadow">
            <summary>
            If true, the OSD window will have shadow.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.OsdWindow.ClickToClose">
            <summary>
            If true, the OSD window receive mouse messages. Only completely transparent areas don't. The user can click to close the OSD (left, right or middle button).
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.OsdWindow.Name">
            <summary>
            OSD window name. Optional, default null.
            </summary>
            <remarks>
            This text is invisible. Can be used to find OSD window. The class name is "Au.OSD"; if with shadow - "Au.OSD2".
            </remarks>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="M:Au.OsdWindow.CloseAll(System.String)">
            <summary>
            Closes all OSD windows of this process.
            </summary>
            <param name="name">If not null, closes only OSD windows whose <see cref="P:Au.OsdWindow.Name"/> matches this <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">wildcard expression</conceptualLink>.</param>
        </member>
        <member name="T:Au.OsdRect">
            <summary>
            Shows mouse-transparent rectangle on screen. Its interior can be visually transparent or opaque.
            </summary>
            <remarks>
            Creates a temporary partially transparent window, and draws rectangle in it.
            </remarks>
            <example>
            <code><![CDATA[
            using(var x = new OsdRect()) {
            	x.Rect = (300, 300, 100, 100);
            	x.Color = Color.SlateBlue;
            	x.Thickness = 4;
            	x.Show();
            	for(int i = 0; i < 5; i++) {
            		250.ms();
            		x.Visible = !x.Visible;
            	}
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.OsdRect.#ctor">
            
        </member>
        <member name="P:Au.OsdRect.Color">
            <summary>
            Gets or sets rectangle color.
            </summary>
            <remarks>
            This property can be changed after creating OSD window.
            </remarks>
            <example>
            <code><![CDATA[
            x.Color = 0xFF0000; //red
            x.Color = Color.Orange;
            ]]></code>
            </example>
        </member>
        <member name="P:Au.OsdRect.Thickness">
            <summary>
            Gets or sets rectangle frame width.
            Used only if <see cref="P:Au.OsdWindow.Opacity"/> is 0 (default).
            </summary>
            <remarks>
            This property can be changed after creating OSD window.
            </remarks>
        </member>
        <member name="M:Au.OsdRect.OnPaint(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Called when the OSD window must be drawn or redrawn. Draws rectangle. More info: <see cref="M:Au.OsdWindow.OnPaint(System.Drawing.Graphics,System.Drawing.Rectangle)"/>.
            </summary>
        </member>
        <member name="T:Au.Osd">
            <summary>
            Shows mouse-transparent text on screen. Its background can be visually transparent or opaque.
            </summary>
            <remarks>
            Creates a temporary partially transparent window, and draws text in it.
            Most properties cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.Osd.XY">
            <summary>
            Coordinates.
            Default: null - screen center.
            </summary>
            <remarks>
            Not used if <see cref="P:Au.Osd.Rect"/> is set.
            This property can be changed after creating OSD window.
            </remarks>
            <example>
            <code><![CDATA[
            var m = new Osd { Text = "Text", ShowMode = OsdShowMode.StrongThread };
            m.XY = (Coord.Center, Coord.Max); //bottom-center of the work area of the primary screen
            m.Show();
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Osd.Rect">
            <summary>
            Gets or sets OSD window size and position in screen.
            </summary>
            <remarks>
            Normally don't need to use this property. If not used, the OSD window size depends on text etc, and position on <see cref="P:Au.Osd.XY"/>.
            This property can be changed after creating OSD window.
            </remarks>
            <seealso cref="M:Au.Osd.Measure"/>
        </member>
        <member name="P:Au.Osd.ResizeWhenContentChanged">
            <summary>
            When changing text, resize/move the OSD window if need.
            Default: false.
            </summary>
        </member>
        <member name="P:Au.Osd.Text">
            <summary>
            Text in OSD window.
            </summary>
            <remarks>
            This property can be changed after creating OSD window; then the window is not moved/resized, unless <see cref="P:Au.Osd.ResizeWhenContentChanged"/> is true.
            </remarks>
        </member>
        <member name="P:Au.Osd.Font">
            <summary>
            Font.
            Default: <see cref="P:Au.Osd.DefaultFont"/>.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.Osd.TextColor">
            <summary>
            Text color.
            Default: <see cref="P:Au.Osd.DefaultTextColor"/>.
            </summary>
            <remarks>
            This property can be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.Osd.BackColor">
            <summary>
            Background color.
            Default: <see cref="P:Au.Osd.DefaultBackColor"/>.
            </summary>
            <remarks>
            This property can be changed after creating OSD window.
            Not used for completely transparent OSD.
            </remarks>
        </member>
        <member name="P:Au.Osd.BorderColor">
            <summary>
            Border color.
            Default: <see cref="P:Au.Osd.DefaultBorderColor"/>.
            </summary>
            <remarks>
            This property can be changed after creating OSD window.
            No border if <see cref="P:Au.OsdWindow.Opacity"/>==0 or <b>BorderColor</b>==<see cref="P:Au.Osd.BackColor"/>.
            </remarks>
        </member>
        <member name="P:Au.Osd.BackgroundImage">
            <summary>
            Background image.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.Osd.IsOfImageSize">
            <summary>
            When used <see cref="P:Au.Osd.BackgroundImage"/>, the OSD window has the same size as the image, plus borders.
            Else OSD window size is calculated from sizes of text and icon. Then image is displayed scaled or clipped if need.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.Osd.WrapWidth">
            <summary>
            Maximal text width.
            Default: 0 - no limit (depends on screen width etc).
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.Osd.TextFormatFlags">
            <summary>
            Gets or sets text format flags.
            Default: TextFormatFlags.NoPrefix | TextFormatFlags.WordBreak | TextFormatFlags.ExpandTabs.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.Osd.Icon">
            <summary>
            Icon at the left of text.
            For example SystemIcons.Information.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.Osd.Shadow">
            <summary>
            If true, the OSD window will have shadow.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            Window shadows can be disabled. See <msdn>SPI_SETDROPSHADOW</msdn>.
            </remarks>
        </member>
        <member name="P:Au.Osd.ClickToClose">
            <summary>
            If true, the OSD window receive mouse messages. Only completely transparent areas don't. The user can click to close the OSD (left, right or middle button).
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.Osd.SecondsTimeout">
            <summary>
            Close the OSD window after this time, seconds.
            If 0 (default), depends on text length. Can be <see cref="F:System.Threading.Timeout.Infinite"/> (-1).
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.Osd.ShowMode">
            <inheritdoc cref="T:Au.Types.OsdShowMode"/>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="M:Au.Osd.#ctor">
            
        </member>
        <member name="M:Au.Osd.Show">
            <summary>
            Shows the OSD window. Creates if need.
            By default does not wait; the window will be closed after <see cref="P:Au.Osd.SecondsTimeout"/>.
            </summary>
            <remarks>
            Depending on <see cref="P:Au.Osd.ShowMode"/>, creates the OSD window in this or new thread.
            If the OSD window is already created, just shows it if hidden. Many properties can be changed only before creating OSD window; call <see cref="M:Au.OsdWindow.Close"/> if need.
            </remarks>
        </member>
        <member name="M:Au.Osd.OnPaint(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draws OSD text etc.
            </summary>
        </member>
        <member name="M:Au.Osd.Measure">
            <summary>
            Calculates OSD window size and position.
            Can be called before showing OSD.
            </summary>
        </member>
        <member name="M:Au.Osd.ShowText(System.String,System.Int32,Au.Types.PopupXY,System.Drawing.Icon,Au.Types.ColorInt,Au.Types.ColorInt,System.String,Au.Types.OsdShowMode,System.Boolean)">
            <summary>
            Shows a tooltip-like OSD window with text and optionally icon.
            </summary>
            <param name="text"><see cref="P:Au.Osd.Text"/></param>
            <param name="secondsTimeout"><see cref="P:Au.Osd.SecondsTimeout"/></param>
            <param name="xy"><see cref="P:Au.Osd.XY"/></param>
            <param name="icon"><see cref="P:Au.Osd.Icon"/></param>
            <param name="textColor"><see cref="P:Au.Osd.TextColor"/></param>
            <param name="backColor"><see cref="P:Au.Osd.BackColor"/></param>
            <param name="name"><see cref="P:Au.OsdWindow.Name"/></param>
            <param name="showMode"><see cref="P:Au.Osd.ShowMode"/></param>
            <param name="doNotShow">Don't call <see cref="M:Au.Osd.Show"/>. The caller can use the return value to set some other properties and call <b>Show</b>.</param>
            <returns>Returns an <see cref="T:Au.Osd"/> object that can be used to change properties or close the OSD window.</returns>
            <remarks>
            Also sets these properties: <see cref="P:Au.Osd.ClickToClose"/>=true, <see cref="P:Au.Osd.Shadow"/>=true.
            </remarks>
        </member>
        <member name="M:Au.Osd.ShowTransparentText(System.String,System.Int32,Au.Types.PopupXY,Au.Types.ColorInt,System.String,Au.Types.OsdShowMode,System.Boolean)">
            <summary>
            Shows a big-font text with transparent background.
            </summary>
            <param name="text"><see cref="P:Au.Osd.Text"/></param>
            <param name="secondsTimeout"><see cref="P:Au.Osd.SecondsTimeout"/></param>
            <param name="xy"><see cref="P:Au.Osd.XY"/></param>
            <param name="color"><see cref="P:Au.Osd.TextColor"/>. Default: <see cref="P:Au.Osd.DefaultTransparentTextColor"/>.</param>
            <param name="name"><see cref="P:Au.OsdWindow.Name"/></param>
            <param name="showMode"><see cref="P:Au.Osd.ShowMode"/></param>
            <param name="doNotShow"><inheritdoc cref="M:Au.Osd.ShowText(System.String,System.Int32,Au.Types.PopupXY,System.Drawing.Icon,Au.Types.ColorInt,Au.Types.ColorInt,System.String,Au.Types.OsdShowMode,System.Boolean)"/></param>
            <returns><inheritdoc cref="M:Au.Osd.ShowText(System.String,System.Int32,Au.Types.PopupXY,System.Drawing.Icon,Au.Types.ColorInt,Au.Types.ColorInt,System.String,Au.Types.OsdShowMode,System.Boolean)"/></returns>
            <remarks>
            Also sets these properties: <see cref="P:Au.Osd.Font"/>=<see cref="P:Au.Osd.DefaultTransparentTextFont"/>, <see cref="P:Au.OsdWindow.Opacity"/>=0.
            </remarks>
        </member>
        <member name="M:Au.Osd.ShowImage(System.Drawing.Image,System.Int32,Au.Types.PopupXY,System.String,Au.Types.OsdShowMode,System.Boolean)">
            <summary>
            Shows on-screen image.
            </summary>
            <param name="image"><see cref="P:Au.Osd.BackgroundImage"/></param>
            <param name="secondsTimeout"><see cref="P:Au.Osd.SecondsTimeout"/></param>
            <param name="xy"><see cref="P:Au.Osd.XY"/></param>
            <param name="name"><see cref="P:Au.OsdWindow.Name"/></param>
            <param name="showMode"><see cref="P:Au.Osd.ShowMode"/></param>
            <param name="doNotShow"><inheritdoc cref="M:Au.Osd.ShowText(System.String,System.Int32,Au.Types.PopupXY,System.Drawing.Icon,Au.Types.ColorInt,Au.Types.ColorInt,System.String,Au.Types.OsdShowMode,System.Boolean)"/></param>
            <returns><inheritdoc cref="M:Au.Osd.ShowText(System.String,System.Int32,Au.Types.PopupXY,System.Drawing.Icon,Au.Types.ColorInt,Au.Types.ColorInt,System.String,Au.Types.OsdShowMode,System.Boolean)"/></returns>
            <remarks>
            Also sets these properties: <see cref="P:Au.Osd.IsOfImageSize"/>=true, <see cref="P:Au.OsdWindow.Opacity"/>=0, <see cref="P:Au.Osd.ClickToClose"/>=true.
            </remarks>
        </member>
        <member name="P:Au.Osd.DefaultFont">
            <summary>Default font for <see cref="M:Au.Osd.ShowText(System.String,System.Int32,Au.Types.PopupXY,System.Drawing.Icon,Au.Types.ColorInt,Au.Types.ColorInt,System.String,Au.Types.OsdShowMode,System.Boolean)"/> and <b>Osd</b>. Default: <b>SystemFonts.MessageBoxFont</b> of size 12.</summary>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="P:Au.Osd.DefaultTextColor">
            <summary>Default text color for <see cref="M:Au.Osd.ShowText(System.String,System.Int32,Au.Types.PopupXY,System.Drawing.Icon,Au.Types.ColorInt,Au.Types.ColorInt,System.String,Au.Types.OsdShowMode,System.Boolean)"/> and <b>Osd</b>. Default: 0xFF404040 (dark gray).</summary>
        </member>
        <member name="P:Au.Osd.DefaultBorderColor">
            <summary>Default border color for <see cref="M:Au.Osd.ShowText(System.String,System.Int32,Au.Types.PopupXY,System.Drawing.Icon,Au.Types.ColorInt,Au.Types.ColorInt,System.String,Au.Types.OsdShowMode,System.Boolean)"/> and <b>Osd</b>. Default: 0xFF404040 (dark gray).</summary>
        </member>
        <member name="P:Au.Osd.DefaultBackColor">
            <summary>Default background color for <see cref="M:Au.Osd.ShowText(System.String,System.Int32,Au.Types.PopupXY,System.Drawing.Icon,Au.Types.ColorInt,Au.Types.ColorInt,System.String,Au.Types.OsdShowMode,System.Boolean)"/> and <b>Osd</b>. Default: 0xFFFFFFF0 (light yellow).</summary>
        </member>
        <member name="P:Au.Osd.DefaultTransparentTextFont">
            <summary>Default font for <see cref="M:Au.Osd.ShowTransparentText(System.String,System.Int32,Au.Types.PopupXY,Au.Types.ColorInt,System.String,Au.Types.OsdShowMode,System.Boolean)"/>. Default: "Tahoma" of size 18.</summary>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="P:Au.Osd.DefaultTransparentTextColor">
            <summary>Default text color for <see cref="M:Au.Osd.ShowTransparentText(System.String,System.Int32,Au.Types.PopupXY,Au.Types.ColorInt,System.String,Au.Types.OsdShowMode,System.Boolean)"/>. Default: 0xFF8A2BE2 (Color.BlueViolet).</summary>
        </member>
        <member name="P:Au.Osd.DefaultScreen">
            <summary>
            Default screen when <see cref="P:Au.Osd.XY"/> is not set.
            Each thread has its own instance of this property.
            </summary>
        </member>
        <member name="T:Au.WinImage">
            <summary>
            Captures, finds and clicks images and colors in windows.
            </summary>
            <remarks>
            An image is any visible rectangular part of a window. A color is any visible pixel (the same as image of size 1x1).
            A <b>WinImage</b> variable holds results of <see cref="M:Au.WinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,Au.Types.WIAlso})"/> and similar functions (rectangle etc).
            </remarks>
        </member>
        <member name="M:Au.WinImage.LoadImage(System.String)">
            <summary>
            Loads image from file, string or resource.
            </summary>
            <param name="image"><inheritdoc cref="M:Au.WinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,Au.Types.WIAlso})"/></param>
            <exception cref="T:System.IO.FileNotFoundException">The specified file does not exist.</exception>
            <exception cref="T:System.Exception">Depending on <paramref name="image"/> string format, exceptions of <see cref="M:System.Drawing.Image.FromFile(System.String)"/>, <see cref="M:System.Drawing.Bitmap.#ctor(System.IO.Stream)"/>, <see cref="M:Au.Convert_.Decompress(System.Byte[],System.Int32,System.Int32)"/>.</exception>
            <exception cref="T:System.ArgumentException">Bad image format (the image cannot be loaded as Bitmap).</exception>
            <remarks>
            <see cref="M:Au.WinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,Au.Types.WIAlso})"/> uses this function when <i>image</i> argument type is string. More info there.
            </remarks>
        </member>
        <member name="P:Au.WinImage.Rect">
            <summary>
            Gets location of the found image, relative to the search area.
            </summary>
            <remarks>
            Relative to the window/control client area (if area type is Wnd), accessible object (if Acc), image (if Bitmap) or screen (if RECT).
            More info: <see cref="M:Au.WinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,Au.Types.WIAlso})"/>.
            </remarks>
        </member>
        <member name="P:Au.WinImage.RectInScreen">
            <summary>
            Gets location of the found image in screen coordinates.
            </summary>
            <remarks>
            Slower than <see cref="P:Au.WinImage.Rect"/>.
            </remarks>
        </member>
        <member name="P:Au.WinImage.MatchIndex">
            <summary>
            Gets 0-based index of current matching image instance.
            </summary>
            <remarks>
            Can be useful in <i>also</i> callback functions.
            When the <i>image</i> argument is a list of images, <b>MatchIndex</b> starts from 0 for each list image.
            </remarks>
        </member>
        <member name="P:Au.WinImage.ListIndex">
            <summary>
            When the <i>image</i> argument is a list of images, gets 0-based index of the list image.
            </summary>
        </member>
        <member name="M:Au.WinImage.Skip(System.Int32)">
            <summary>
            Can be used in <i>also</i> callback function to skip n matching images. Example: <c>also: o => o.Skip(n)</c>.
            </summary>
            <param name="n">How many matching images to skip.</param>
        </member>
        <member name="M:Au.WinImage.ToString">
            
        </member>
        <member name="M:Au.WinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,Au.Types.WIAlso})">
            <summary>
            Finds image(s) or color(s) displayed in window or other area.
            </summary>
            <returns>
            Returns <see cref="T:Au.WinImage"/> object containing the rectangle of the found image.
            Returns null if not found. See example.
            </returns>
            <param name="area">
            Where to search. Can be a window/control, accessible object, another image or a rectangle in screen.
            <list type="bullet">
            <item><see cref="T:Au.Wnd"/> - window or control. The search area is its client area.</item>
            <item><see cref="T:Au.Acc"/> - accessible object.</item>
            <item><see cref="T:System.Drawing.Bitmap"/> - another image. These flags are invalid: <see cref="F:Au.Types.WIFlags.WindowDC"/>.</item>
            <item><see cref="T:Au.Types.RECT"/> - a rectangle area in screen. These flags are invalid: <see cref="F:Au.Types.WIFlags.WindowDC"/>.</item>
            <item><see cref="T:Au.Types.WIArea"/> - can contain Wnd, Acc or Bitmap. Also allows to specify a rectangle in it, which makes the search area smaller and the function faster. Example: <c>WinImage.Find((w, (left, top, width, height)), "image.png");</c>.</item>
            </list>
            </param>
            <param name="image">
            Image or color to find. Can be of type:
            <list type="bullet">
            <item>
            string - path of .png or .bmp file.
            If not full path, uses <see cref="P:Au.Folders.ThisAppImages"/>.
            If the file does not exist, looks in resources of apdomain's entry assembly. For example, looks for Project.Properties.Resources.X if file @"C:\X.png" not found. Alternatively you can use code like <c>using(var b = Project.Properties.Resources.X) WinImage.Find(w, b);</c>.
            </item>
            <item>
            string that starts with "image:" or "~:" - Base64-encoded .png or .bmp image embedded in script.
            If "image:", it is .png file data, else it is compressed .bmp file data.
            Can be created with function Au.Controls.ImageUtil.ImageToString (in Au.Controls.dll).
            </item>
            <item>int, ColorInt or Color - color. Int must be in 0xRRGGBB format. Alpha is not used.</item>
            <item>Bitmap - image object in memory.</item>
            <item>IEnumerable of string, int/ColorInt/Color, Bitmap or object - multiple images or colors. Action - find any. To create a different action can be used callback function (parameter <paramref name="also"/>).</item>
            </list>
            Icons are not supported directly, but you can use <see cref="M:Au.Icons.GetFileIconImage(System.String,System.Int32,Au.Types.GIFlags)"/> or <see cref="M:Au.Icons.HandleToImage(System.IntPtr,System.Boolean)"/>.
            Transparent and partially transparent pixels are not compared. For example, when you capture a non-rectangular area image, the image actually is rectangular, but pixels outside of its captured area are transparent and therefore not compared. Also you can draw transparent areas with an image editor that supports it, for example Paint.NET.
            </param>
            <param name="flags"></param>
            <param name="colorDiff">Maximal allowed color difference. Use to to find images that have slightly different colors than the specified image. Can be 0 - 250, but should be as small as possible. Applied to each color component (red, green, blue) of each pixel.</param>
            <param name="also">
            Callback function. Called for each found image instance and receives its rectangle, match index and list index. Can return one of <see cref="T:Au.Types.WIAlso"/> values.
            Callback functions can be used to get rectangles of multiple found images, create custom behaviors/actions, etc. Examples:
            <list type="bullet">
            <item>Skip some matching images if some condition if false: <c>also: o => condition ? WIAlso.OkReturn : WIAlso.FindOther</c></item>
            <item>Skip n matching images: <c>also: o => o.Skip(n)</c></item>
            <item>Get rectangles etc of all matching images: <c>also: o => { list.Add(o); return false; }</c>. Don't use this code in 'wait' functions.</item>
            <item>Get rectangles etc of all matching images and stop waiting: <c>also: o => { list.Add(o); o.Found = true; return false; }</c></item>
            <item>Do different actions depending on which list images found: <c>var found = new BitArray(images.Length); WinImage.Find(w, images, also: o => { found[o.ListIndex] = true; return WIAlso.OkFindMoreOfList; }); if(found[0]) Print(0); if(found[1]) Print(1);</c></item>
            </list>
            </param>
            <exception cref="T:Au.Types.WndException">Invalid window handle (the <paramref name="area"/> argument).</exception>
            <exception cref="T:System.ArgumentException">
            An argument is of unsupported type or is/contains a null/invalid value.
            Image or area is a bottom-up Bitmap object (see <see cref="P:System.Drawing.Imaging.BitmapData.Stride"/>). Such bitmaps are unusual in .NET (GDI+), but can be created by <b>Image.FromHbitmap</b> (instead use <see cref="M:Au.WinImage.BitmapFromHbitmap(System.IntPtr)"/>).
            </exception>
            <exception cref="T:System.IO.FileNotFoundException">The specified file does not exist.</exception>
            <exception cref="T:System.Exception">Depending on <paramref name="image"/> string format, exceptions of <see cref="M:System.Drawing.Image.FromFile(System.String)"/>, <see cref="M:System.Drawing.Bitmap.#ctor(System.IO.Stream)"/>, <see cref="M:Au.Convert_.Decompress(System.Byte[],System.Int32,System.Int32)"/>.</exception>
            <exception cref="T:Au.Types.AuException">Something failed.</exception>
            <remarks>
            To create code for this function, use dialog "Find image or color in window". It is form <b>Au.Tools.Form_WinImage</b> in Au.Tools.dll.
            
            The speed mostly depends on:
            1. The size of the search area. Use the smallest possible area (control or accessible object or rectangle in window like <c>(w, rectangle)</c>).
            2. Flag <see cref="F:Au.Types.WIFlags.WindowDC"/>. Usually makes several times faster. With this flag the speed depends on window.
            3. Video driver. Can be much slower if incorrect, generic or virtual PC driver is used. Flag <see cref="F:Au.Types.WIFlags.WindowDC"/> should help.
            4. <paramref name="colorDiff"/>. Should be as small as possible.
            
            If flag <see cref="F:Au.Types.WIFlags.WindowDC"/> is not used, the search area must be visible on the screen. If it is covered by other windows, the function will search in these windows.
            
            The function can only find images that exactly match the specified image. With <paramref name="colorDiff"/> it can find images with slightly different colors and brightness. It cannot find images with different shapes.
            
            This function is not the best way to find objects when the script is intended for long use or for use on multiple computers or must be very reliable. Because it may fail to find the image after are changed some settings - system theme, application theme, text size (DPI), font smoothing (if the image contains text), etc. Also are possible various unexpected temporary conditions that may distort or hide the image, for example adjacent window shadow, a tooltip or some temporary window. If possible, in such scripts instead use other functions, eg find control or accessible object.
            </remarks>
            <example>
            Code created with dialog "Find image or color in window".
            <code><![CDATA[
            var w = Wnd.Find("Window Name").OrThrow();
            string image = "image:iVBORw0KGgoAAAANSUhEUgAAABYAAAANCAYAAACtpZ5jAAAAAXNSR0IArs4c...";
            var wi = WinImage.Find(w, image).OrThrow();
            wi.Click();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.WinImage.Wait(System.Double,Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,Au.Types.WIAlso})">
            <inheritdoc cref="M:Au.WinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,Au.Types.WIAlso})"/>
            <summary>
            Finds image(s) or color(s) displayed in window or other area. Waits until found.
            </summary>
            <returns>Returns <see cref="T:Au.WinImage"/> object containing the rectangle of the found image. On timeout returns null if <paramref name="secondsTimeout"/> is negative; else exception.</returns>
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits infinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, after that time interval returns null.
            </param>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
            <exception cref="T:Au.Types.WndException">Invalid window handle (the area argument), or the window closed while waiting.</exception>
        </member>
        <member name="M:Au.WinImage.WaitNot(System.Double,Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,Au.Types.WIAlso})">
            <inheritdoc cref="M:Au.WinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,Au.Types.WIAlso})"/>
            <summary>
            Waits until image(s) or color(s) is not displayed in window or other area.
            </summary>
            <param name="secondsTimeout"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></param>
            <returns><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></returns>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
            <exception cref="T:Au.Types.WndException">Invalid window handle (the area argument), or the window closed while waiting.</exception>
        </member>
        <member name="M:Au.WinImage.WaitChanged(System.Double,Au.Types.WIArea,Au.Types.WIFlags,System.Int32)">
            <inheritdoc cref="M:Au.WinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,Au.Types.WIAlso})"/>
            <summary>
            Waits until something visually changes in window or other area.
            </summary>
            <param name="secondsTimeout"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></param>
            <returns><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></returns>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
            <exception cref="T:Au.Types.WndException">Invalid window handle (the area argument), or the window closed while waiting.</exception>
            <remarks>
            The same as <see cref="M:Au.WinImage.WaitNot(System.Double,Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,Au.Types.WIAlso})"/>, but instead of <i>image</i> parameter this function captures the area image at the beginning.
            </remarks>
        </member>
        <member name="M:Au.WinImage.Capture(Au.Types.RECT)">
            <summary>
            Creates image from a rectangle of screen pixels.
            </summary>
            <param name="rect">A rectangle in screen coordinates.</param>
            <exception cref="T:System.ArgumentException">Empty rectangle.</exception>
            <exception cref="T:Au.Types.AuException">Failed. Probably there is not enough memory for bitmap of this size (with*height*4 bytes).</exception>
            <remarks>
            PixelFormat is always Format32bppRgb.
            </remarks>
            <example>
            <code><![CDATA[
            var file = Folders.Temp + "notepad.png";
            Wnd w = Wnd.Find("* Notepad");
            w.Activate();
            using(var b = WinImage.Capture(w.Rect)) { b.Save(file); }
            Shell.Run(file);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.WinImage.Capture(Au.Wnd,Au.Types.RECT)">
            <summary>
            Creates image from a rectangle of window client area pixels.
            </summary>
            <param name="w">Window or control.</param>
            <param name="rect">A rectangle in w client area coordinates. Use <c>w.ClientRect</c> to get whole client area.</param>
            <exception cref="T:Au.Types.WndException">Invalid w.</exception>
            <exception cref="T:System.ArgumentException">Empty rectangle.</exception>
            <exception cref="T:Au.Types.AuException">Failed. Probably there is not enough memory for bitmap of this size (with*height*4 bytes).</exception>
            <remarks>
            How this is different from <see cref="M:Au.WinImage.Capture(Au.Types.RECT)"/>:
            1. Gets pixels from window's device context (DC), not from screen DC, unless the Aero theme is turned off (on Windows 7). The window can be under other windows. The image can be different.
            2. If the window is partially or completely transparent, gets non-transparent image.
            3. Does not work with Windows Store app windows, Chrome and some other windows. Creates black image.
            4. If the window is DPI-scaled, captures its non-scaled view. And <paramref name="rect"/> must contain non-scaled coordinates.
            </remarks>
        </member>
        <member name="M:Au.WinImage.Capture(System.Collections.Generic.List{Au.Types.POINT})">
            <summary>
            Creates image from a non-rectangular area of screen pixels.
            </summary>
            <param name="outline">The outline (shape) of the area in screen. If single element, captures single pixel.</param>
            <exception cref="T:System.ArgumentException"><paramref name="outline"/> is null or has 0 elements.</exception>
            <exception cref="T:Au.Types.AuException">Failed. Probably there is not enough memory for bitmap of this size.</exception>
            <remarks>
            PixelFormat is always Format32bppRgb.
            </remarks>
        </member>
        <member name="M:Au.WinImage.Capture(Au.Wnd,System.Collections.Generic.List{Au.Types.POINT})">
            <summary>
            Creates image from a non-rectangular area of window client area pixels.
            </summary>
            <param name="w">Window or control.</param>
            <param name="outline">The outline (shape) of the area in w client area coordinates. If single element, captures single pixel.</param>
            <exception cref="T:Au.Types.WndException">Invalid <paramref name="w"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="outline"/> is null or has 0 elements.</exception>
            <exception cref="T:Au.Types.AuException">Failed. Probably there is not enough memory for bitmap of this size.</exception>
            <remarks>More info: <see cref="M:Au.WinImage.Capture(Au.Wnd,Au.Types.RECT)"/>.</remarks>
        </member>
        <member name="M:Au.WinImage.BitmapFromHbitmap(System.IntPtr)">
            <summary>
            Creates Bitmap from a GDI bitmap.
            </summary>
            <param name="hbitmap">GDI bitmap handle. This function makes its copy.</param>
            <remarks>
            How this function is different from <see cref="M:System.Drawing.Image.FromHbitmap(System.IntPtr)"/>:
            1. Image.FromHbitmap usually creates bottom-up bitmap, which is incompatible with <see cref="M:Au.WinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,Au.Types.WIAlso})"/>. This function creates normal top-down bitmap, like <c>new Bitmap(...)</c>, <c>Bitmap.FromFile(...)</c> etc do.
            2. This function always creates bitmap of PixelFormat Format32bppRgb.
            </remarks>
            <exception cref="T:Au.Types.AuException">Failed. For example hbitmap is default(IntPtr).</exception>
            <exception cref="T:System.Exception">Exceptions of Bitmap(int, int, PixelFormat) constructor.</exception>
        </member>
        <member name="M:Au.WinImage.CaptureUI(Au.Types.WICResult@,Au.Types.WICFlags,Au.Types.AnyWnd)">
            <summary>
            Creates image from a user-selected area of screen pixels. Or gets single pixel color, or just rectangle.
            Returns false if cancelled.
            </summary>
            <param name="result">Receives results.</param>
            <param name="flags"></param>
            <param name="toolWindow">Owner window. Temporarily hides it and its owner windows.</param>
            <remarks>
            Gets all screen pixels and shows in a full-screen topmost window, where the user can select an area.
            </remarks>
        </member>
        <member name="T:Au.Opt">
            <summary>
            Options used by some functions of this library.
            </summary>
            <remarks>
            Some frequently used static functions of this library have some options (settings). For example <see cref="M:Au.Keyb.Key(System.Object[])"/> allows to change speed, text sending method, etc. Passing options as parameters in each call usually isn't what you want to do in automation scripts. Instead you can set options using static properties. This class contains several groups of options for functions of various classes. See examples.
            
            There are two sets of identical or similar options - in class <b>Opt</b> and in its nested class <see cref="T:Au.Opt.Static"/>:
            <list type="bullet">
            <item><b>Opt</b> - thread-static options (each thread has its own instance). Functions of this library use them. You can change or change-restore them anywhere in script. Initial options are automatically copied from <b>Opt.Static</b> when that group of options (<b>Key</b>, <b>Mouse</b>, etc) is used first time in that thread (explicitly or by library functions).</item>
            <item><b>Opt.Static</b> - static options. Contains initial property values for <b>Opt</b>. Normally you change them in your script template (in script initialization code) or at the very start of script. Don't change later, it's not thread-safe.</item>
            </list>
            </remarks>
            <example><inheritdoc cref="P:Au.Opt.Static.Mouse"/></example>
        </member>
        <member name="P:Au.Opt.Key">
            <summary>
            Options for keyboard and clipboard functions (classes <see cref="T:Au.Keyb"/>, <see cref="T:Au.Clipb"/> and functions that use them).
            </summary>
            <remarks>
            Each thread has its own <b>Opt.Key</b> instance. It inherits options from <see cref="P:Au.Opt.Static.Key"/>.
            Also can be used when creating <see cref="T:Au.Keyb"/> instances. See the second example.
            </remarks>
            <example>
            <code><![CDATA[
            Opt.Key.KeySpeed = 20;
            Key("Tab Ctrl+V");
            ]]></code>
            Use a Keyb instance.
            <code><![CDATA[
            var k = new Keyb(Opt.Key); //create new Keyb instance and copy options from Opt.Key to it
            k.Options.KeySpeed = 100; //changes option of k but not of Opt.Key
            k.Add("Tab Ctrl+V").Send(); //uses options of k
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Opt.Mouse">
            <summary>
            Options for mouse functions (class <see cref="P:Au.Opt.Mouse"/> and functions that use it).
            </summary>
            <remarks>
            Each thread has its own <b>Opt.Mouse</b> instance. It inherits options from <see cref="P:Au.Opt.Static.Mouse"/>.
            </remarks>
            <example>
            <code><![CDATA[
            Opt.Mouse.ClickSpeed = 100;
            Mouse.Click();
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Opt.Debug">
            <summary>
            Options for showing run-time warnings and other info that can be useful to find problems in code at run time.
            </summary>
            <remarks>
            Each thread has its own <b>Opt.Debug</b> instance. It inherits options from <see cref="P:Au.Opt.Static.Debug"/>.
            </remarks>
            <example>
            <code><![CDATA[
            Opt.Debug.Verbose = false;
            PrintWarning("Example");
            PrintWarning("Example");
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Opt.WaitFor">
            <summary>
            Options for 'wait for' functions.
            </summary>
            <remarks>
            Each thread has its own <b>Opt.WaitFor</b> instance. There is no <b>Opt.Static.WaitFor</b>.
            Most 'wait for' functions of this library use these options. Functions of .NET classes don't.
            </remarks>
        </member>
        <member name="T:Au.Opt.Static">
            <summary>
            Default <see cref="T:Au.Opt"/> properties of each thread.
            </summary>
            <remarks>
            You can change these options at the start of your script or in the static constructor of script's class. Don't change later.
            </remarks>
        </member>
        <member name="P:Au.Opt.Static.Key">
            <summary>
            Default option values for <see cref="P:Au.Opt.Key"/> of each thread.
            </summary>
            <remarks>
            Also can be used when creating <see cref="T:Au.Keyb"/> instances. See the second example.
            </remarks>
            <example>
            <code><![CDATA[
            static MyScriptClass() { Opt.Static.Key.KeySpeed = 10; } //static constructor
            ...
            Key("Tab Ctrl+V"); //uses Opt.Key, which is implicitly copied from Opt.Static.Key
            ]]></code>
            Use a Keyb instance.
            <code><![CDATA[
            var k = new Keyb(Opt.Static.Key); //create new Keyb instance and copy options from Opt.Static.Key to it
            k.Options.KeySpeed = 100; //changes option of k but not of Opt.Static.Key
            k.Add("Tab Ctrl+V").Send(); //uses options of k
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Opt.Static.Mouse">
            <summary>
            Default option values for <see cref="P:Au.Opt.Mouse"/> of each thread.
            </summary>
            <example>
            <code><![CDATA[
            static MyScriptClass() { Opt.Static.Mouse.ClickSpeed = 10; } //static constructor, for example in script template
            ...
            Mouse.Click(); //uses Opt.Mouse, which is implicitly copied from Opt.Static.Mouse
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Opt.Static.Debug">
            <summary>
            Default option values for <see cref="P:Au.Opt.Debug"/> of each thread.
            </summary>
            <example>
            <code><![CDATA[
            Opt.Static.Debug.Verbose = false;
            ]]></code>
            </example>
        </member>
        <member name="T:Au.Opt.Temp">
            <summary>
            Makes easy to restore current options of this thread. See example.
            </summary>
            <example><inheritdoc cref="P:Au.Opt.Temp.Mouse"/></example>
        </member>
        <member name="P:Au.Opt.Temp.Mouse">
            <summary>
            Makes easy to restore current <see cref="P:Au.Opt.Mouse"/> of this thread. See example.
            </summary>
            <example>
            <code><![CDATA[
            Print(Opt.Mouse.ClickSpeed);
            using(Opt.Temp.Mouse) {
            	Opt.Mouse.ClickSpeed = 100;
            	Print(Opt.Mouse.ClickSpeed);
            } //here restored automatically
            Print(Opt.Mouse.ClickSpeed);
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Opt.Temp.Key">
            <summary>
            Makes easy to restore current <see cref="P:Au.Opt.Key"/> of this thread. See example.
            </summary>
            <example>
            <code><![CDATA[
            Print(Opt.Key.KeySpeed);
            using(Opt.Temp.Key) {
            	Opt.Key.KeySpeed = 5;
            	Print(Opt.Key.KeySpeed);
            } //here restored automatically
            Print(Opt.Key.KeySpeed);
            ]]></code>
            </example>
        </member>
        <member name="T:Au.Opt.Temp.RestoreMouse">
            <summary>Infrastructure.</summary>
            <tocexclude />
        </member>
        <member name="M:Au.Opt.Temp.RestoreMouse.Dispose">
            <summary>Restores options.</summary>
        </member>
        <member name="T:Au.Opt.Temp.RestoreKey">
            <summary>Infrastructure.</summary>
            <tocexclude />
        </member>
        <member name="M:Au.Opt.Temp.RestoreKey.Dispose">
            <summary>Restores options.</summary>
        </member>
        <member name="T:Au.Output">
            <summary>
            Writes text to the output window, console or log file.
            </summary>
            <remarks>
            When <see cref="M:Au.Output.Write(System.String)"/>, <b>Print</b>, etc is called, where the text goes:
            <list type="bullet">
            <item>If redirected, to wherever it is redirected. See <see cref="P:Au.Output.Writer"/>.</item>
            <item>Else if using log file (<see cref="P:Au.Output.LogFile"/> not null), writes to the file.</item>
            <item>Else if using console (<see cref="P:Au.Output.IsWritingToConsole"/> returns true), writes to console.</item>
            <item>Else if using local <see cref="T:Au.Util.OutputServer"/> (in this appdomain), writes to it.</item>
            <item>Else if exists global <see cref="T:Au.Util.OutputServer"/> (in any process/appdomain), writes to it.</item>
            <item>Else nowhere.</item>
            </list>
            </remarks>
        </member>
        <member name="P:Au.Output.IsConsoleProcess">
            <summary>
            Returns true if this is a console process.
            </summary>
        </member>
        <member name="P:Au.Output.IsWritingToConsole">
            <summary>
            Returns true if is writing to console, false if to the output window or log file. Assuming that <see cref="P:Au.Output.Writer"/> is not changed.
            </summary>
            <remarks>
            Does not write to console in these cases:
            <list type="bullet">
            <item><see cref="P:Au.Output.IsConsoleProcess"/> is false.</item>
            <item><see cref="P:Au.Output.IgnoreConsole"/> is true.</item>
            <item><see cref="P:Au.Output.LogFile"/> is not null.</item>
            <item>The startup info of this process tells to not show console window and to not redirect the standard output.</item>
            </list>
            </remarks>
        </member>
        <member name="P:Au.Output.IgnoreConsole">
            <summary>
            If true, Write and related functions in console process don't not use the console window. Then everything is like in non-console process.
            </summary>
            <seealso cref="P:Au.Output.RedirectConsoleOutput"/>
            <seealso cref="P:Au.Output.RedirectDebugOutput"/>
        </member>
        <member name="M:Au.Output.Clear">
            <summary>
            Clears the output window or console text (if <see cref="P:Au.Output.IsWritingToConsole"/>) or log file (if <see cref="P:Au.Output.LogFile"/> not null).
            </summary>
        </member>
        <member name="M:Au.Output.Write(System.String)">
            <summary>
            Writes string + "\r\n" to the output window or console (if <see cref="P:Au.Output.IsWritingToConsole"/>) or log file (if <see cref="P:Au.Output.LogFile"/> not null).
            </summary>
            <seealso cref="M:Au.NoClass.Print(System.String)"/>
            <seealso cref="M:Au.NoClass.Print(System.Object)"/>
            <seealso cref="M:Au.NoClass.Print``1(System.Collections.Generic.IEnumerable{``0})"/>
            <seealso cref="M:Au.NoClass.Print(System.Object,System.Object,System.Object[])"/>
            <seealso cref="M:Au.NoClass.PrintListEx``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Int32)"/>
        </member>
        <member name="P:Au.Output.Writer">
            <summary>
            Gets or sets object that actually writes text when is called Output.Write, Print and similar functions.
            </summary>
            <remarks>
            If you want to redirect, modify or just monitor output text, use code like in the example. It is known as "output redirection".
            Redirection is applied to whole appdomain, and does not affect other appdomains.
            Redirection affects Output.Write, Print and similar functions, also Output.RedirectConsoleOutput and Output.RedirectDebugOutput. It does not affect Output.WriteDirectly and Output.Clear.
            Don't call Output.Write, Print etc in method WriteLine(string) of your writer class. It would call itself and create stack overflow. But you can call Output.WriteDirectly.
            </remarks>
            <example>
            <code><![CDATA[
            [STAThread]
            static void Main()
            {
            	Output.Writer = new TestOutputWriter();
            
            	Print("test");
            }
            
            class TestOutputWriter :TextWriter
            {
            	public override void WriteLine(string value) { Output.WriteDirectly("redir: " + value); }
            	public override Encoding Encoding => Encoding.Unicode;
            }
            ]]></code>
            </example>
        </member>
        <member name="T:Au.Output._OutputWriter">
            <summary>
            Our default writer class for the Writer property.
            </summary>
        </member>
        <member name="M:Au.Output.WriteDirectly(System.String)">
            <summary>
            Writes string value + "\r\n" to the output window or console (if <see cref="P:Au.Output.IsWritingToConsole"/>) or log file (if <see cref="P:Au.Output.LogFile"/> not null).
            Unlike Output.Write, Print etc, the string is not passed to <see cref="P:Au.Output.Writer"/>.
            </summary>
        </member>
        <member name="P:Au.Output.RedirectConsoleOutput">
            <summary>
            Let Console.WriteX methods in non-console process write to the same destination as Output.Write etc.
            </summary>
            <remarks>
            Console.Write will write line, like Console.WriteLine.
            Console.Clear will not clear output; it will throw exception.
            </remarks>
        </member>
        <member name="P:Au.Output.RedirectDebugOutput">
            <summary>
            Let Debug.WriteX and Trace.WriteX methods write to the same destination as Output.Write etc.
            </summary>
            <remarks>
            Tip: To write to the output window even in console process, set <c>Output.IgnoreConsole=true;</c> before calling this method first time.
            </remarks>
        </member>
        <member name="P:Au.Output.LogFile">
            <summary>
            Sets log file path.
            When set (not null), text passed to Output.Write, Print and similar functions will be written to the file. Assuming that <see cref="P:Au.Output.Writer"/> is not changed.
            If value is null - restores default behavior.
            </summary>
            <remarks>
            The first Write etc call (in this appdomain) creates or opens the file and deletes old content if the file already exists.
            Multiple appdomains cannot use the same file. If the file is open for writing, Write makes unique filename and changes LogFile value.
            
            Also supports mailslots. For LogFile use mailslot name, as documented in <msdn>CreateMailslot</msdn>. Multiple appdomains and processes can use the same mailslot.
            </remarks>
            <exception cref="T:System.ArgumentException">The 'set' function throws this exception if the value is not full path and not null.</exception>
        </member>
        <member name="P:Au.Output.LogFileTimestamp">
            <summary>
            Let Write etc also add current time when using log file (see <see cref="P:Au.Output.LogFile"/>).
            The time is local, not UTC.
            </summary>
        </member>
        <member name="M:Au.Output._LogFile.Open">
            <summary>
            Opens LogFile file handle for writing.
            Uses CREATE_ALWAYS, GENERIC_WRITE, FILE_SHARE_READ.
            </summary>
            <remarks>
            Multiple appdomains cannot use the same file. Each appdomain overwrites it when opens first time.
            </remarks>
        </member>
        <member name="M:Au.Output._LogFile.WriteLine(System.String)">
            <summary>
            Writes s + "\r\n" and optionally timestamp.
            </summary>
            <remarks>
            If fails to write to file: Sets LogFile=null, which closes file handle. Writes a warning and s to the output window or console.
            </remarks>
        </member>
        <member name="M:Au.Output._LogFile.Clear">
            <summary>
            Sets file size = 0.
            </summary>
        </member>
        <member name="M:Au.Output._LogFile.Close">
            <summary>
            Closes file handle.
            </summary>
        </member>
        <member name="M:Au.Output.LibCreateFile(System.String,System.Boolean)">
            <summary>
            Calls Api.CreateFile to open file or mailslot.
            </summary>
            <param name="name">File path or mailslot name.</param>
            <param name="openExisting">Use OPEN_EXISTING. If false, uses CREATE_ALWAYS.</param>
        </member>
        <member name="P:Au.Output.LibUseQM2">
            <summary>
            Sets to use QM2 as the output server.
            </summary>
        </member>
        <member name="M:Au.Output._WriteToQM2(System.String)">
            <param name="s">If null, clears output.</param>
        </member>
        <member name="T:Au.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Au.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Au.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Au.Properties.Resources.red_cross_cursor">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="T:Au.Regex_">
            <summary>
            PCRE regular expression.
            </summary>
            <remarks>
            PCRE is a regular expression library: <see href="https://www.pcre.org/"/>.
            PCRE regular expression syntax: <see href="https://www.pcre.org/current/doc/html/pcre2pattern.html">full</see>, <see href="https://www.pcre.org/current/doc/html/pcre2syntax.html">short</see>.
            Some websites with tutorials and info: <see href="http://www.rexegg.com/">rexegg</see>, <see href="https://www.regular-expressions.info/">regular-expressions.info</see>.
            
            This class is an alternative to the .NET <see cref="T:System.Text.RegularExpressions.Regex"/> class. The regular expression syntax is similar. PCRE has some features unavailable in .NET, and vice versa. In most cases PCRE is about 2 times faster. You can use any of these classes. Functions of <see cref="T:Au.Acc"/> class support only PCRE.
            
            Terms used in this documentation and in names of functions and types:
            <list type="bullet">
              <item> <term>regular expression</term> <description>Regular expression string. Also known as <i>pattern</i>.</description> </item>
              <item> <term>subject string</term> <description>The string in which to search for the regular expression. Also known as <i>input string</i>.</description> </item>
              <item> <term>match</term> <description>The part (substring) of the subject string that matches the regular expression.</description> </item>
              <item> <term>groups</term> <description>Regular expression parts enclosed in (). Except non-capturing parts, like (?:...) and (?options). Also known as <i>capturing group</i>, <i>capturing subpattern</i>. Often term <i>group</i> also is used for group matches.</description> </item>
              <item> <term>group match</term> <description>The part (substring) of the subject string that matches the group. Also known as <i>captured substring</i>.</description> </item>
            </list>
            
            This library uses an unmanaged code dll AuCpp.dll that contains PCRE code. This class is a managed wrapper for it. The main PCRE API functions used by this class are <see href="https://www.pcre.org/current/doc/html/pcre2api.html">pcre2_compile and pcre2_match</see>. The Regex_ constructor calls pcre2_compile and stores the compiled code in the variable. Other Regex_ functions call pcre2_match. Compiling to native code (JIT) is not supported.
            
            A Regex_ variable can be used by multiple threads simultaneously.
            
            Also there are several String extension methods that use this class. The string variable is the subject string. These methods create and use cached Regex_ instances for speed. The Regex_ constructor does not use caching.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22, three333,four"; //subject string
            var x = new Regex_(@"\b(\w+?)(\d+)\b"); //regular expression
             
             Print("//IsMatch:");
            Print(x.IsMatch(s));
             
             Print("//Match:");
            if(x.Match(s, out var m)) Print(m.Value, m[1].Value, m[2].Value);
             
             Print("//FindAll with foreach:");
            foreach(var v in x.FindAll(s)) Print(v.Value, v[1].Value, v[2].Value);
             Print("//FindAllS, get only strings of group 2:");
            Print(x.FindAllS(s, 2));
             
             Print("//Replace:");
            Print(x.Replace(s, "'$2$1'"));
             Print("//Replace with callback:");
            Print(x.Replace(s, o => o.Value.ToUpper_()));
             Print("//Replace with callback and ExpandReplacement:");
            Print(x.Replace(s, o => { if(o.Length > 5) return o.ExpandReplacement("'$2$1'"); else return o[1].Value; }));
             
             Print("//Split:");
            Print(new Regex_(@" *, *").Split(s));
            ]]></code>
             Examples with String extension methods. 
            <code><![CDATA[
            var s = "one two22, three333,four"; //subject string
            var rx = @"\b(\w+?)(\d+)\b"; //regular expression
             
             Print("//RegexIsMatch_:");
            Print(s.RegexIsMatch_(rx));
             
             Print("//RegexMatch_:");
            if(s.RegexMatch_(rx, out var m)) Print(m.Value, m[1].Value, m[2].Value);
             
             Print("//RegexMatch_, get only string:");
            if(s.RegexMatch_(rx, 0, out var s0)) Print(s0);
             Print("//RegexMatch_, get only string of group 1:");
            if(s.RegexMatch_(rx, 1, out var s1)) Print(s1);
             
             Print("//RegexFindAll_ with foreach:");
            foreach(var v in s.RegexFindAll_(rx)) Print(v.Value, v[1].Value, v[2].Value);
             
             Print("//RegexFindAll_ with foreach, get only strings:");
            foreach(var v in s.RegexFindAll_(rx, 0)) Print(v);
             Print("//RegexFindAll_ with foreach, get only strings of group 2:");
            foreach(var v in s.RegexFindAll_(rx, 2)) Print(v);
             
             Print("//RegexFindAll_, get array:");
            if(s.RegexFindAll_(rx, out var am)) foreach(var k in am) Print(k.Value, k[1].Value, k[2].Value);
             
             Print("//RegexFindAll_, get array of strings:");
            if(s.RegexFindAll_(rx, 0, out var av)) Print(av);
             Print("//RegexFindAll_, get array of group 2 strings:");
            if(s.RegexFindAll_(rx, 2, out var ag)) Print(ag);
             
             Print("//RegexReplace_:");
            Print(s.RegexReplace_(rx, "'$2$1'"));
             
             Print("//RegexReplace_ with callback:");
            Print(s.RegexReplace_(rx, o => o.Value.ToUpper_()));
             Print("//RegexReplace_ with callback and ExpandReplacement:");
            Print(s.RegexReplace_(rx, o => { if(o.Length > 5) return o.ExpandReplacement("'$2$1'"); else return o[1].Value; }));
             
             Print("//RegexReplace_, get replacement count:");
            if(0 != s.RegexReplace_(rx, "'$2$1'", out var s2)) Print(s2);
             
             Print("//RegexReplace_ with callback, get replacement count:");
            if(0 != s.RegexReplace_(rx, o => o.Value.ToUpper_(), out var s3)) Print(s3);
             
             Print("//RegexSplit_:");
            Print(s.RegexSplit_(@" *, *"));
            ]]></code></example>
        </member>
        <member name="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)">
            <summary>
            Compiles regular expression string.
            
            PCRE regular expression syntax: <see href="https://www.pcre.org/current/doc/html/pcre2pattern.html">full</see>, <see href="https://www.pcre.org/current/doc/html/pcre2syntax.html">short</see>.
            </summary>
            <param name="rx">
            Regular expression. Cannot be null.
            </param>
            <param name="flags">
            Options.
            Default 0. Flag UTF is implicitly added if <paramref name="rx"/> contains non-ASCII characters and there is no flag NEVER_UTF.
            </param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or failed to compile it for some other reason (unlikely).</exception>
            <remarks>
            Calls PCRE API function <see href="https://www.pcre.org/current/doc/html/pcre2api.html">pcre2_compile</see>.
            
            Examples in class help: <see cref="T:Au.Regex_"/>.
            </remarks>
        </member>
        <member name="M:Au.Regex_.Finalize">
            
        </member>
        <member name="P:Au.Regex_.Callout">
            <summary>
            Sets callout callback function.
            </summary>
            <value>Callback delegate (eg lambda) or null.</value>
            <remarks>
            Callouts can be used to: 1. Track the matching progress. 2. Get all instances of a group that can match multiple times. 3. Evaluate and reject some matches or match parts. 4. Etc.
            The callback function is called by <see cref="M:Au.Regex_.IsMatch(System.String,Au.Types.RXMore)"/>, <see cref="M:Au.Regex_.Match(System.String,Au.Types.RXMatch@,Au.Types.RXMore)"/>, <see cref="M:Au.Regex_.FindAll(System.String,Au.Types.RXMore)"/>, <see cref="M:Au.Regex_.Replace(System.String,System.String,System.Int32,Au.Types.RXMore)"/>, <see cref="M:Au.Regex_.Split(System.String,System.Int32,Au.Types.RXMore)"/> and similar functions, when they reach callout points in regular expression. To insert callout points use (?C), (?C1), (?C2), (?C'name') etc or pass flag AUTO_CALLOUT to the constructor.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            See also: <see href="http://www.rexegg.com/pcre-callouts.html"/>
            </remarks>
            <example>
            Track the matching progress.
            <code><![CDATA[
            var s = "text <a href='url'>link</a> text";
            var rx = @"(?C1)<a (?C2)href='.+?'>(?C3)[^<]*(?C4)</a>";
            var x = new Regex_(rx);
            x.Callout = o => { Print(o.callout_number, o.current_position, s.Substring(o.start_match, o.current_position), rx.Substring(o.pattern_position, o.next_item_length)); };
            Print(x.IsMatch(s));
            ]]></code>
            Track the matching progress with flag AUTO_CALLOUT.
            <code><![CDATA[
            var s = "one 'two' three";
            var rx = @"'(.+?)'";
            var x = new Regex_(rx, RXFlags.AUTO_CALLOUT);
            x.Callout = o => Print(o.current_position, o.pattern_position, rx.Substring(o.pattern_position, o.next_item_length));
            Print(x.IsMatch(s));
            ]]></code>
            Get all instances of a group that can match multiple times.
            <code><![CDATA[
            var s = "BEGIN 111 2222 333 END";
            var x = new Regex_(@"^(\w+) (?:(\d+) (?C1))+(\w+)$");
            var a = new List<string>();
            x.Callout = o => a.Add(o.LastGroupValue);
            if(!x.Match(s, out var m)) { Print("no match"); return; }
            Print(m[1]);
            Print(a); //all numbers. m[2] contains only the last number.
            Print(m[3]);
            ]]></code>
            Evaluate and reject some matches or match parts. This code rejects matches longer than 5.
            <code><![CDATA[
            var s = "one 123-5 two 12-456 three 1-34 four";
            var x = new Regex_(@"\b\d+-\d+\b(?C1)");
            x.Callout = o => { int len = o.current_position - o.start_match; /*Print(len);*/ if(len > 5) o.Result = 1; };
            Print(x.FindAllS(s));
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.GroupNumberFromName(System.String)">
            <summary>
            Finds a named group and returns its 1-based index.
            Returns -1 if not found.
            </summary>
            <param name="groupName">
            Group name.
            In regular expression, to set name of group <c>(text)</c>, use <c>(?&lt;NAME&gt;text)</c>.
            </param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException">More than 1 group have this name.</exception>
            <seealso cref="M:Au.Types.RXMatch.GroupNumberFromName(System.String)"/>
            <seealso cref="M:Au.Types.RXMatch.GroupNumberFromName(System.String,System.Boolean@)"/>
        </member>
        <member name="M:Au.Regex_.IsMatch(System.String,Au.Types.RXMore)">
            <summary>
            Returns true if string <paramref name="s"/> matches this regular expression.
            </summary>
            <param name="s">
            Subject string.
            If null, always returns false, even if the regular expression matches empty string.
            </param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            If partial match, returns true too. Partial match is possible if used a PARTIAL_ flag.
            
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new Regex_(@"\b(\w+?)(\d+)\b");
            Print(x.IsMatch(s));
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.Match(System.String,Au.Types.RXMatch@,Au.Types.RXMore)">
            <summary>
            Returns true if string <paramref name="s"/> matches this regular expression.
            Gets match info as <see cref="T:Au.Types.RXMatch"/>.
            </summary>
            <param name="s">
            Subject string.
            If null, always returns false, even if the regular expression matches empty string.
            </param>
            <param name="result">Receives match info. Read more in Remarks.</param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            If full match, returns true, and <paramref name="result"/> contains the match and all groups that exist in the regular expressions.
            If partial match, returns true, and <paramref name="result"/> contains the match without groups. Partial match is possible if used a PARTIAL_ flag.
            If no match, returns false, and <paramref name="result"/> normally is null. But if a mark is available, <paramref name="result"/> is an object with two valid properties - <see cref="P:Au.Types.RXMatch.Exists"/> (false) and <see cref="P:Au.Types.RXMatch.Mark"/>; other properties have undefined values or throw exception.
            
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new Regex_(@"\b(\w+?)(\d+)\b");
            if(x.Match(s, out var m)) Print(m.Value, m[1].Value, m[2].Value);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.MatchG(System.String,Au.Types.RXGroup@,System.Int32,Au.Types.RXMore)">
            <summary>
            Returns true if string <paramref name="s"/> matches this regular expression.
            Gets whole match or some group, as <see cref="T:Au.Types.RXGroup"/> (index, length, value).
            </summary>
            <param name="s">
            Subject string.
            If null, always returns false, even if the regular expression matches empty string.
            </param>
            <param name="result">Receives match info.</param>
            <param name="group">
            Group number (1-based index) of result. If 0 (default) - whole match.
            See also <see cref="M:Au.Regex_.GroupNumberFromName(System.String)"/>.
            </param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="group"/> or from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            This function is a simplified version of <see cref="M:Au.Regex_.Match(System.String,Au.Types.RXMatch@,Au.Types.RXMore)"/>.
            If full match, returns true, and <paramref name="result"/> contains the match or the specifed group.
            If partial match, returns true too. Partial match is possible if used a PARTIAL_ flag. Then cannot get groups, therefore <paramref name="group"/> should be 0.
            If no match, returns false, and <paramref name="result"/> is empty.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new Regex_(@"\b(\w+?)(\d+)\b");
            if(x.MatchG(s, out var g)) Print(g.Value, g.Index);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.MatchS(System.String,System.String@,System.Int32,Au.Types.RXMore)">
            <summary>
            Returns true if string <paramref name="s"/> matches this regular expression.
            Gets whole match or some group, as string.
            </summary>
            <param name="s">
            Subject string.
            If null, always returns false, even if the regular expression matches empty string.
            </param>
            <param name="result">Receives the match value.</param>
            <param name="group">
            Group number (1-based index) of result. If 0 (default) - whole match.
            See also <see cref="M:Au.Regex_.GroupNumberFromName(System.String)"/>.
            </param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="group"/> or from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            This function is a simplified version of <see cref="M:Au.Regex_.Match(System.String,Au.Types.RXMatch@,Au.Types.RXMore)"/> and <see cref="M:Au.Regex_.MatchG(System.String,Au.Types.RXGroup@,System.Int32,Au.Types.RXMore)"/>.
            If full match, returns true, and <paramref name="result"/> contains the value of the match or of the specifed group.
            If partial match, returns true too. Partial match is possible if used a PARTIAL_ flag. Then cannot get groups, therefore <paramref name="group"/> should be 0.
            If no match, returns false, and <paramref name="result"/> is null.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new Regex_(@"\b(\w+?)(\d+)\b");
            if(x.MatchS(s, out var v)) Print(v);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.FindAll(System.String,Au.Types.RXMore)">
            <summary>
            Finds all match instances of the regular expression.
            Returns a lazy IEnumerable&lt;<see cref="T:Au.Types.RXMatch"/>&gt; object that can be used with foreach.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new Regex_(@"\b(\w+?)(\d+)\b");
            foreach(var m in x.FindAll(s)) Print(m.Value, m[1].Value, m[2].Value);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.FindAll(System.String,Au.Types.RXMatch[]@,Au.Types.RXMore)">
            <summary>
            Finds all match instances of the regular expression. Gets array of <see cref="T:Au.Types.RXMatch"/>.
            Returns true if found 1 or more matches.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="result">Receives all found matches.</param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new Regex_(@"\b(\w+?)(\d+)\b");
            if(!x.FindAll(s, out var a)) { Print("not found"); return; }
            foreach(var m in a) Print(m.Value, m[1].Value, m[2].Value);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.FindAllG(System.String,System.Int32,Au.Types.RXMore)">
            <summary>
            Finds all match instances of the regular expression.
            Returns a lazy IEnumerable&lt;<see cref="T:Au.Types.RXGroup"/>&gt; object that can be used with foreach.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="group">
            Group number (1-based index) of results. If 0 (default) - whole match.
            See also <see cref="M:Au.Regex_.GroupNumberFromName(System.String)"/>.
            </param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="group"/> or from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            This function is a simplified version of <see cref="M:Au.Regex_.FindAll(System.String,Au.Types.RXMore)"/>. Also it is similar to <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two three";
            var x = new Regex_(@"\b\w+\b");
            foreach(var g in x.FindAllG(s)) Print(g.Index, g.Value);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.FindAllG(System.String,Au.Types.RXGroup[]@,System.Int32,Au.Types.RXMore)">
            <summary>
            Finds all match instances of the regular expression. Gets array of <see cref="T:Au.Types.RXGroup"/> (index, length, value).
            Returns true if found 1 or more matches.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="result">Receives all found matches.</param>
            <param name="group">
            Group number (1-based index) of results. If 0 (default) - whole match.
            See also <see cref="M:Au.Regex_.GroupNumberFromName(System.String)"/>.
            </param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="group"/> or from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            This function is a simplified version of <see cref="M:Au.Regex_.FindAll(System.String,Au.Types.RXMatch[]@,Au.Types.RXMore)"/>. Also it is similar to <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two three";
            var x = new Regex_(@"\b\w+\b");
            if(!x.FindAllG(s, out var a)) { Print("not found"); return; }
            foreach(var g in a) Print(g.Index, g.Value);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.FindAllS(System.String,System.Int32,Au.Types.RXMore)">
            <summary>
            Finds all match instances of the regular expression.
            Returns a lazy IEnumerable&lt;string&gt; object that can be used with foreach.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="group">
            Group number (1-based index) of results. If 0 (default) - whole match.
            See also <see cref="M:Au.Regex_.GroupNumberFromName(System.String)"/>.
            </param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="group"/> or from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            This function is a simplified version of <see cref="M:Au.Regex_.FindAll(System.String,Au.Types.RXMore)"/> and <see cref="M:Au.Regex_.FindAllG(System.String,System.Int32,Au.Types.RXMore)"/>. Also it is similar to <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two three";
            var x = new Regex_(@"\b\w+\b");
            foreach(var v in x.FindAllS(s)) Print(v);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.FindAllS(System.String,System.String[]@,System.Int32,Au.Types.RXMore)">
            <summary>
            Finds all match instances of the regular expression. Gets array of strings.
            Returns true if found 1 or more matches.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="result">Receives all found matches.</param>
            <param name="group">
            Group number (1-based index) of results. If 0 (default) - whole match.
            See also <see cref="M:Au.Regex_.GroupNumberFromName(System.String)"/>.
            </param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="group"/> or from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            This function is a simplified version of <see cref="M:Au.Regex_.FindAll(System.String,Au.Types.RXMatch[]@,Au.Types.RXMore)"/> and <see cref="M:Au.Regex_.FindAllG(System.String,Au.Types.RXGroup[]@,System.Int32,Au.Types.RXMore)"/>. Also it is similar to <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two three";
            var x = new Regex_(@"\b\w+\b");
            if(!x.FindAllS(s, out var a)) { Print("not found"); return; }
            foreach(var v in a) Print(v);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.Replace(System.String,System.String,System.Int32,Au.Types.RXMore)">
            <summary>
            Finds and replaces all match instances of the regular expression.
            Returns the result string.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="repl">
            Replacement pattern.
            Can consist of any combination of literal text and substitutions like $1.
            Supports .NET regular expression substitution syntax. See <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)"/>. Also replaces $* with the name of the last encountered mark.
            </param>
            <param name="maxCount">The maximal count of replacements to make. If -1 (default), replaces all.</param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new Regex_(@"\b(\w+?)(\d+)\b");
            s = x.Replace(s, "'$2$1'");
            Print(s);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.Replace(System.String,System.String,System.String@,System.Int32,Au.Types.RXMore)">
            <summary>
            Finds and replaces all match instances of the regular expression.
            Returns the number of replacements made. Returns the result string through an out parameter.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="repl">
            Replacement pattern.
            Can consist of any combination of literal text and substitutions like $1.
            Supports .NET regular expression substitution syntax. See <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)"/>. Also replaces $* with the name of the last encountered mark.
            </param>
            <param name="result">The result string. Can be <paramref name="s"/>.</param>
            <param name="maxCount">The maximal count of replacements to make. If -1 (default), replaces all.</param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new Regex_(@"\b(\w+?)(\d+)\b");
            if(0 == x.Replace(s, "'$2$1'", out s)) Print("not found");
            else Print(s);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.Replace(System.String,System.Func{Au.Types.RXMatch,System.String},System.Int32,Au.Types.RXMore)">
            <summary>
            Finds and replaces all match instances of the regular expression. Uses a callback function.
            Returns the result string.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="replFunc">
            Callback function's delegate, eg lambda. Called for each found match. Returns the replacement.
            In the callback function you can use <see cref="M:Au.Types.RXMatch.ExpandReplacement(System.String)"/>.
            </param>
            <param name="maxCount">The maximal count of replacements to make. If -1 (default), replaces all.</param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new Regex_(@"\b(\w+?)(\d+)\b");
            s = x.Replace(s, o => o.Value.ToUpper_());
            Print(s);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.Replace(System.String,System.Func{Au.Types.RXMatch,System.String},System.String@,System.Int32,Au.Types.RXMore)">
            <summary>
            Finds and replaces all match instances of the regular expression. Uses a callback function.
            Returns the number of replacements made. Returns the result string through an out parameter.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="replFunc">
            Callback function's delegate, eg lambda. Called for each found match. Returns the replacement.
            In the callback function you can use <see cref="M:Au.Types.RXMatch.ExpandReplacement(System.String)"/>.
            </param>
            <param name="result">The result string. Can be <paramref name="s"/>.</param>
            <param name="maxCount">The maximal count of replacements to make. If -1 (default), replaces all.</param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new Regex_(@"\b(\w+?)(\d+)\b");
            if(0 == x.Replace(s, o => o.Value.ToUpper_(), out s)) Print("not found");
            else Print(s);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.Split(System.String,System.Int32,Au.Types.RXMore)">
            <summary>
            Returns array of substrings delimited by regular expression matches.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="maxCount">The maximal count of substrings to get. The last substring contains the unsplit remainder of the subject string. If 0 (default) or negative, gets all.</param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            Element 0 of the returned array is <paramref name="s"/> substring until the first match of the regular expression, element 1 is substring between the first and second match, and so on. If no matches, the array contains single element and it is <paramref name="s"/>.
            
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one, two,three , four";
            var x = new Regex_(@" *, *");
            var a = x.Split(s);
            for(int i = 0; i < a.Length; i++) Print(i, a[i]);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.SplitG(System.String,System.Int32,Au.Types.RXMore)">
            <summary>
            Returns <see cref="T:Au.Types.RXGroup"/> array of substrings delimited by regular expression matches.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="maxCount">The maximal count of substrings to get. The last substring contains the unsplit remainder of the subject string. If 0 (default) or negative, gets all.</param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            Element 0 of the returned array is <paramref name="s"/> substring until the first match of the regular expression, element 1 is substring between the first and second match, and so on. If no matches, the array contains single element and it is <paramref name="s"/>.
            
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one, two,three , four";
            var x = new Regex_(@" *, *");
            var a = x.SplitG(s);
            foreach(var v in a) Print(v.Index, v.Value);
            ]]></code>
            </example>
        </member>
        <member name="T:Au.String_">
            <summary>
            Adds extension methods to <see cref="T:System.String"/>.
            </summary>
            <remarks>
            Also adds StringComparison.Ordinal[IgnoreCase] versions of .NET String methods that use StringComparison.CurrentCulture by default. See https://msdn.microsoft.com/en-us/library/ms973919.aspx
            Extension method names have suffix _.
            Most of these extension methods throw <b>NullReferenceException</b> if called for a string variable that is null.
            </remarks>
        </member>
        <member name="M:Au.String_.RegexIsMatch_(System.String,System.String,Au.Types.RXFlags)">
            <summary>
            Returns true if this string matches PCRE regular expression <paramref name="rx"/>.
            Parameters etc are of <see cref="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.Regex_.IsMatch(System.String,Au.Types.RXMore)"/>.
            Examples in <see cref="T:Au.Regex_"/> class help.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid regular expression.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.String_.RegexMatch_(System.String,System.String,Au.Types.RXMatch@,Au.Types.RXFlags)">
            <summary>
            Returns true if this string matches PCRE regular expression <paramref name="rx"/>.
            Gets match info as <see cref="T:Au.Types.RXMatch"/>.
            Parameters etc are of <see cref="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.Regex_.Match(System.String,Au.Types.RXMatch@,Au.Types.RXMore)"/>.
            Examples in <see cref="T:Au.Regex_"/> class help.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid regular expression.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.String_.RegexMatch_(System.String,System.String,System.Int32,System.String@,Au.Types.RXFlags)">
            <summary>
            Returns true if this string matches PCRE regular expression <paramref name="rx"/>.
            Gets whole match or some group, as string.
            Parameters etc are of <see cref="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.Regex_.MatchS(System.String,System.String@,System.Int32,Au.Types.RXMore)"/>.
            Examples in <see cref="T:Au.Regex_"/> class help.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid regular expression.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="group"/>.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.String_.RegexFindAll_(System.String,System.String,Au.Types.RXFlags)">
            <summary>
            Finds all match instances of PCRE regular expression <paramref name="rx"/>.
            Returns a lazy IEnumerable&lt;<see cref="T:Au.Types.RXMatch"/>&gt; object that can be used with foreach.
            Parameters etc are of <see cref="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.Regex_.FindAll(System.String,Au.Types.RXMore)"/>.
            Examples in <see cref="T:Au.Regex_"/> class help.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.String_.RegexFindAll_(System.String,System.String,Au.Types.RXMatch[]@,Au.Types.RXFlags)">
            <summary>
            Finds all match instances of PCRE regular expression <paramref name="rx"/>. Gets array of <see cref="T:Au.Types.RXMatch"/>.
            Returns true if found 1 or more matches.
            Parameters etc are of <see cref="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.Regex_.FindAll(System.String,Au.Types.RXMatch[]@,Au.Types.RXMore)"/>.
            Examples in <see cref="T:Au.Regex_"/> class help.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.String_.RegexFindAll_(System.String,System.String,System.Int32,Au.Types.RXFlags)">
            <summary>
            Finds all match instances of PCRE regular expression <paramref name="rx"/>.
            Returns a lazy IEnumerable&lt;<see cref="T:Au.Types.RXGroup"/>&gt; object that can be used with foreach.
            Parameters etc are of <see cref="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.Regex_.FindAllS(System.String,System.Int32,Au.Types.RXMore)"/>.
            Examples in <see cref="T:Au.Regex_"/> class help.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="group"/>.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.String_.RegexFindAll_(System.String,System.String,System.Int32,System.String[]@,Au.Types.RXFlags)">
            <summary>
            Finds all match instances of PCRE regular expression <paramref name="rx"/>. Gets array of strings.
            Returns true if found 1 or more matches.
            Parameters etc are of <see cref="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.Regex_.FindAllS(System.String,System.String[]@,System.Int32,Au.Types.RXMore)"/>.
            Examples in <see cref="T:Au.Regex_"/> class help.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="group"/>.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.String_.RegexReplace_(System.String,System.String,System.String,System.Int32,Au.Types.RXFlags)">
            <summary>
            Finds and replaces all match instances of PCRE regular expression <paramref name="rx"/>.
            Returns the result string.
            Parameters etc are of <see cref="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.Regex_.Replace(System.String,System.String,System.Int32,Au.Types.RXMore)"/>.
            Examples in <see cref="T:Au.Regex_"/> class help.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.String_.RegexReplace_(System.String,System.String,System.String,System.String@,System.Int32,Au.Types.RXFlags)">
            <summary>
            Finds and replaces all match instances of PCRE regular expression <paramref name="rx"/>.
            Returns the number of replacements made.
            Parameters etc are of <see cref="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.Regex_.Replace(System.String,System.String,System.String@,System.Int32,Au.Types.RXMore)"/>.
            Examples in <see cref="T:Au.Regex_"/> class help.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.String_.RegexReplace_(System.String,System.String,System.Func{Au.Types.RXMatch,System.String},System.Int32,Au.Types.RXFlags)">
            <summary>
            Finds and replaces all match instances of PCRE regular expression <paramref name="rx"/>. Uses a callback function.
            Returns the result string.
            Parameters etc are of <see cref="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.Regex_.Replace(System.String,System.Func{Au.Types.RXMatch,System.String},System.Int32,Au.Types.RXMore)"/>.
            Examples in <see cref="T:Au.Regex_"/> class help.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.String_.RegexReplace_(System.String,System.String,System.Func{Au.Types.RXMatch,System.String},System.String@,System.Int32,Au.Types.RXFlags)">
            <summary>
            Finds and replaces all match instances of PCRE regular expression <paramref name="rx"/>. Uses a callback function.
            Returns the number of replacements made.
            Parameters etc are of <see cref="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.Regex_.Replace(System.String,System.Func{Au.Types.RXMatch,System.String},System.String@,System.Int32,Au.Types.RXMore)"/>.
            Examples in <see cref="T:Au.Regex_"/> class help.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.String_.RegexSplit_(System.String,System.String,System.Int32,Au.Types.RXFlags)">
            <summary>
            Returns array of substrings delimited by PCRE regular expression <paramref name="rx"/> matches.
            Parameters etc are of <see cref="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.Regex_.Split(System.String,System.Int32,Au.Types.RXMore)"/>.
            Examples in <see cref="T:Au.Regex_"/> class help.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.String_._RegexCache.AddOrGet(System.String,Au.Types.RXFlags)">
            <summary>
            If rx/flags is in the cache, returns the cached code.
            Else compiles rx/flags, adds to the cache and returns the code.
            </summary>
            <param name="rx"></param>
            <param name="flags"></param>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or failed to compile it for some other reason.</exception>
        </member>
        <member name="M:Au.String_.Segments_(System.String,System.String,Au.Types.SegFlags)">
            <summary>
            This function can be used with foreach to split this string into substrings as <see cref="T:Au.StringSegment"/> variables.
            </summary>
            <param name="t"></param>
            <param name="separators">Characters that delimit the substrings. Or one of <see cref="T:Au.Types.Separators"/> constants.</param>
            <param name="flags"></param>
            <example>
            <code><![CDATA[
            string s = "one * two three ";
            foreach(var t in s.Segments_(" ")) Print(t);
            foreach(var t in s.Segments_(Separators.Word, SegFlags.NoEmpty)) Print(t);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.String_.Segments_(System.String,System.Int32,System.Int32,System.String,Au.Types.SegFlags)">
            <summary>
            This function can be used with foreach to split the specified part of this string into substrings as <see cref="T:Au.StringSegment"/> variables.
            </summary>
            <param name="t"></param>
            <param name="startIndex">The start of the part of this string.</param>
            <param name="length">The length of the part of this string.</param>
            <param name="separators">Characters that delimit the substrings. Or one of <see cref="T:Au.Types.Separators"/> constants.</param>
            <param name="flags"></param>
        </member>
        <member name="M:Au.String_.Like_(System.String,System.String,System.Boolean)">
            <summary>
            Compares this string with a string that possibly contains wildcard characters.
            Returns true if the strings match.
            
            Wildcard characters:
            * - zero or more of any characters.
            ? - any character.
            </summary>
            <param name="t">This string. If null, returns false. If "", returns true if pattern is "" or "*".</param>
            <param name="pattern">String that possibly contains wildcard characters. Cannot be null. If "", returns true if this string is "". If "*", always returns true except when this string is null.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <remarks>
            Like all String_ functions, performs ordinal comparison, ie does not depend on current culture.
            Much faster than Regex.IsMatch and not much slower than Equals_, EndsWith_, IndexOf_ etc.
            </remarks>
            <example>
            <code><![CDATA[
            string s = @"C:\abc\mno.xyz";
            if(s.Like_(@"C:\abc\mno.xyz")) Print("matches whole text (no wildcard characters)");
            if(s.Like_(@"C:\abc\*")) Print("starts with");
            if(s.Like_(@"*.xyz")) Print("ends with");
            if(s.Like_(@"*mno*")) Print("contains");
            if(s.Like_(@"C:\*.xyz")) Print("starts and ends with");
            if(s.Like_(@"?:*")) Print("any character, : and possibly more text");
            ]]></code>
            </example>
            <seealso cref="T:Au.Types.Wildex"/>
            <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">Wildcard expression</conceptualLink>
        </member>
        <member name="M:Au.String_.Like_(System.String,System.Boolean,System.String[])">
            <summary>
            Calls <see cref="M:Au.String_.Like_(System.String,System.String,System.Boolean)"/> for each wildcard pattern specified in the argument list until it returns true.
            Returns 1-based index of matching pattern, or 0 if none.
            </summary>
            <param name="t"></param>
            <param name="ignoreCase">Case-insensitive.</param>
            <param name="patterns">One or more wildcard strings. The array and strings cannot be null.</param>
        </member>
        <member name="M:Au.String_.Equals_(System.String,System.String,System.Boolean)">
            <summary>
            Compares this and other string. Returns true if equal. Uses ordinal comparison.
            </summary>
        </member>
        <member name="M:Au.String_.Equals_(System.String,System.Boolean,System.String[])">
            <summary>
            Calls <see cref="M:Au.String_.Equals_(System.String,System.String,System.Boolean)"/> for each string specified in the argument list until it returns true.
            Returns 1-based index of matching string, or 0 if none.
            </summary>
        </member>
        <member name="M:Au.String_.EqualsAt_(System.String,System.Int32,System.String,System.Boolean)">
            <summary>
            Compares part of this string with other string. Returns true if equal. Uses ordinal comparison.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="startIndex"/>.</exception>
        </member>
        <member name="M:Au.String_.EqualsAt_(System.String,System.Int32,System.Boolean,System.String[])">
            <summary>
            Calls <see cref="M:Au.String_.EqualsAt_(System.String,System.Int32,System.String,System.Boolean)"/> for each string specified in the argument list until it returns true.
            Returns 1-based index of matching string, or 0 if none.
            </summary>
            <exception cref="T:System.ArgumentNullException">A string in <paramref name="strings"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="startIndex"/>.</exception>
        </member>
        <member name="M:Au.String_.EndsWith_(System.String,System.String,System.Boolean)">
            <summary>
            Compares the end of this string with other string. Returns true if equal. Uses ordinal comparison.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:Au.String_.EndsWith_(System.String,System.Boolean,System.String[])">
            <summary>
            Calls <see cref="M:Au.String_.EndsWith_(System.String,System.String,System.Boolean)"/> for each string specified in the argument list until it returns true.
            Returns 1-based index of matching string, or 0 if none.
            </summary>
            <exception cref="T:System.ArgumentNullException">A string in <paramref name="strings"/> is null.</exception>
        </member>
        <member name="M:Au.String_.EndsWith_(System.String,System.Char)">
            <summary>
            Returns true if this string ends with the specified character.
            Fast, case-sensitive.
            </summary>
        </member>
        <member name="M:Au.String_.StartsWith_(System.String,System.String,System.Boolean)">
            <summary>
            Compares the beginning of this string with other string. Returns true if equal. Uses ordinal comparison.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:Au.String_.StartsWith_(System.String,System.Boolean,System.String[])">
            <summary>
            Calls <see cref="M:Au.String_.StartsWith_(System.String,System.String,System.Boolean)"/> for each string specified in the argument list until it returns true.
            Returns 1-based index of matching string, or 0 if none.
            </summary>
            <exception cref="T:System.ArgumentNullException">A string in <paramref name="strings"/> is null.</exception>
        </member>
        <member name="M:Au.String_.StartsWith_(System.String,System.Char)">
            <summary>
            Returns true if this string starts with the specified character.
            Fast, case-sensitive.
            </summary>
        </member>
        <member name="M:Au.String_.IndexOf_(System.String,System.String,System.Boolean)">
            <summary>
            Calls <see cref="M:System.String.IndexOf(System.String,System.StringComparison)"/>. Uses ordinal comparison.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
        </member>
        <member name="M:Au.String_.IndexOf_(System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            Calls <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)"/>. Uses ordinal comparison.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="startIndex"/>.</exception>
        </member>
        <member name="M:Au.String_.IndexOf_(System.String,System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Calls <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)"/>. Uses ordinal comparison.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="startIndex"/> or <paramref name="count"/>.</exception>
        </member>
        <member name="M:Au.String_.Length_(System.String)">
            <summary>
            Returns <see cref="P:System.String.Length"/>. If this string is null, returns 0.
            </summary>
        </member>
        <member name="M:Au.String_.Split_(System.String,System.String,System.Int32,Au.Types.SegFlags)">
            <summary>
            Splits this string into substrings using the specified separators.
            </summary>
            <param name="t"></param>
            <param name="separators">A string containing characters that delimit substrings. Or one of <see cref="T:Au.Types.Separators"/> constants.</param>
            <param name="maxCount">The maximum number of substrings to get. If negative, gets all.</param>
            <param name="flags"></param>
            <seealso cref="M:Au.String_.Segments_(System.String,System.String,Au.Types.SegFlags)"/>
            <seealso cref="M:Au.String_.SplitLines_(System.String,System.Boolean)"/>
        </member>
        <member name="M:Au.String_.Split_(System.String,System.String,Au.Types.SegFlags)">
            <summary>
            Splits this string into substrings using the specified separators.
            </summary>
            <param name="t"></param>
            <param name="separators">A string containing characters that delimit substrings. Or one of <see cref="T:Au.Types.Separators"/> constants.</param>
            <param name="flags"></param>
            <seealso cref="M:Au.String_.Segments_(System.String,System.String,Au.Types.SegFlags)"/>
            <seealso cref="M:Au.String_.SplitLines_(System.String,System.Boolean)"/>
        </member>
        <member name="M:Au.String_.SplitLines_(System.String,System.Boolean)">
            <summary>
            Splits this string into lines using separators "\r\n", "\n", "\r".
            </summary>
            <param name="t"></param>
            <param name="noEmptyLines">Don't get empty lines.</param>
            <remarks>
            Calls <see cref="M:Au.String_.Split_(System.String,System.String,System.Int32,Au.Types.SegFlags)"/> with separators = Separators.Line, maxCount = -1 (all lines), flags = noEmptyLines ? SegFlags.NoEmpty : 0.
            </remarks>
            <seealso cref="M:Au.String_.Segments_(System.String,System.String,Au.Types.SegFlags)"/>
        </member>
        <member name="M:Au.String_.CountLines_(System.String,System.Boolean)">
            <summary>
            Returns the number of lines.
            Counts line separators "\r\n", "\n", "\r".
            </summary>
            <param name="t"></param>
            <param name="preferMore">Add 1 if the string ends with a line separator or its length is 0.</param>
        </member>
        <member name="M:Au.String_.ToLower_(System.String)">
            <summary>
            Calls <see cref="M:System.String.ToLowerInvariant"/>.
            </summary>
        </member>
        <member name="M:Au.String_.ToUpper_(System.String)">
            <summary>
            Calls <see cref="M:System.String.ToUpperInvariant"/>.
            </summary>
        </member>
        <member name="M:Au.String_.ToInt_(System.String,System.Int32,System.Int32@,Au.Types.STIFlags)">
            <summary>
            Converts part of string to int.
            Returns the int value, or 0 if fails to convert.
            </summary>
            <param name="t"></param>
            <param name="startIndex">Offset in this string where to start parsing.</param>
            <param name="numberEndIndex">Receives offset in string where the number part ends. If fails to convert, receives 0.</param>
            <param name="flags"></param>
            <remarks>
            Fails to convert when string is null, "", does not begin with a number or the number is too big.
            
            Unlike int.Parse and Convert.ToInt32:
            	The number in string can be followed by more text, like "123text".
            	Has startIndex parameter that allows to get number from middle, like "text123text".
            	Gets the end of the number part.
            	No exception when cannot convert.
            	Supports hexadecimal format, like "0x1A", case-insensitive.
            	Much faster.
            
            The number in string can begin with ASCII spaces, tabs or newlines, like " 5".
            The number in string can be with "-" or "+", like "-5", but not like "- 5".
            Fails if the number is greater than +- uint.MaxValue (0xffffffff).
            The return value becomes negative if the number is greater than int.MaxValue, for example "0xffffffff" is -1, but it becomes correct if assigned to uint (need cast).
            Does not support non-integer numbers; for example, for "3.5E4" returns 3 and sets numberEndIndex=startIndex+1.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">startIndex is less than 0 or greater than string length.</exception>
        </member>
        <member name="M:Au.String_.ToInt_(System.String,System.Int32,Au.Types.STIFlags)">
            <summary>
            This <see cref="M:Au.String_.ToInt_(System.String,System.Int32,System.Int32@,Au.Types.STIFlags)"/> overload does not have parameter numberEndIndex.
            </summary>
        </member>
        <member name="M:Au.String_.ToInt_(System.String)">
            <summary>
            This <see cref="M:Au.String_.ToInt_(System.String,System.Int32,System.Int32@,Au.Types.STIFlags)"/> overload does not have parameters.
            </summary>
        </member>
        <member name="M:Au.String_.ToLong_(System.String,System.Int32,System.Int32@,Au.Types.STIFlags)">
            <summary>
            Converts part of string to long.
            Returns the long value, or 0 if fails to convert.
            </summary>
            <param name="t"></param>
            <param name="startIndex">Offset in this string where to start parsing.</param>
            <param name="numberEndIndex">Receives offset in string where the number part ends. If fails to convert, receives 0.</param>
            <param name="flags"></param>
            <remarks>
            Fails to convert when string is null, "", does not begin with a number or the number is too big.
            
            Unlike long.Parse and Convert.ToInt64:
            	The number in string can be followed by more text, like "123text".
            	Has startIndex parameter that allows to get number from middle, like "text123text".
            	Gets the end of the number part.
            	No exception when cannot convert.
            	Supports hexadecimal format, like "0x1A", case-insensitive.
            	Much faster.
            
            The number in string can begin with ASCII spaces, tabs or newlines, like " 5".
            The number in string can be with "-" or "+", like "-5", but not like "- 5".
            Fails if the number is greater than +- ulong.MaxValue (0xffffffffffffffff).
            The return value becomes negative if the number is greater than long.MaxValue, for example "0xffffffffffffffff" is -1, but it becomes correct if assigned to ulong (need cast).
            Does not support non-integer numbers; for example, for "3.5E4" returns 3 and sets numberEndIndex=startIndex+1.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">startIndex is less than 0 or greater than string length.</exception>
        </member>
        <member name="M:Au.String_.ToLong_(System.String,System.Int32,Au.Types.STIFlags)">
            <summary>
            This <see cref="M:Au.String_.ToLong_(System.String,System.Int32,System.Int32@,Au.Types.STIFlags)"/> overload does not have parameter numberEndIndex.
            </summary>
        </member>
        <member name="M:Au.String_.ToLong_(System.String)">
            <summary>
            This <see cref="M:Au.String_.ToLong_(System.String,System.Int32,System.Int32@,Au.Types.STIFlags)"/> overload does not have parameters.
            </summary>
        </member>
        <member name="M:Au.String_.ToIntAndString_(System.String,System.Int32@,System.String@,System.Int32,Au.Types.STIFlags)">
            <summary>
            If this string contains a number at startIndex, gets that number as int, also gets the string part that follows it, and returns true.
            For example, for string "25text" or "25 text" gets num = 25, tail = "text".
            Everything else is the same as with <see cref="M:Au.String_.ToInt_(System.String,System.Int32,System.Int32@,Au.Types.STIFlags)"/>.
            </summary>
            <param name="t"></param>
            <param name="num">Receives the number. Receives 0 if no number.</param>
            <param name="tail">Receives the string part that follows the number, or "". Receives null if no number. Can be this variable.</param>
            <param name="startIndex">Offset in this string where to start parsing.</param>
            <param name="flags"></param>
        </member>
        <member name="M:Au.String_.ToDouble_(System.String,System.Boolean)">
            <summary>
            Converts string to double.
            Calls <see cref="M:System.Double.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)"/> with CultureInfo.InvariantCulture and NumberStyles.Float|NumberStyles.AllowThousands.
            </summary>
            <param name="t"></param>
            <param name="canThrow">If true, exception if the string is not a valid number or is null. If false, then returns 0.</param>
        </member>
        <member name="M:Au.String_.ToFloat_(System.String,System.Boolean)">
            <summary>
            Converts string to float.
            Calls <see cref="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)"/> with CultureInfo.InvariantCulture and NumberStyles.Float|NumberStyles.AllowThousands.
            </summary>
            <param name="t"></param>
            <param name="canThrow">If true, exception if the string is not a valid number or is null. If false, then returns 0.</param>
        </member>
        <member name="M:Au.String_.ReplaceAt_(System.String,System.Int32,System.Int32,System.String)">
            <summary>
            Returns a new string in which a specified string replaces a specified count of characters at a specified position in this instance.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="startIndex"/> or <paramref name="count"/>.</exception>
        </member>
        <member name="M:Au.String_.Limit_(System.String,System.Int32)">
            <summary>
            If this string is longer than <paramref name="limit"/>, returns its substring 0 to <paramref name="limit"/>-3 with appended "...".
            Else returns this string.
            </summary>
        </member>
        <member name="M:Au.String_.Escape_(System.String,System.Int32,System.Boolean)">
            <summary>
            Replaces some characters with C# escape sequences.
            Replaces these characters: '\\', '\"', '\t', '\n', '\r' and all in range 0-31.
            If the string contains these characters, replaces and returns new string. Else returns this string.
            </summary>
            <param name="t">This string.</param>
            <param name="limit">If the final string is longer than <paramref name="limit"/>, get its substring 0 to <paramref name="limit"/>-3 with appended "...". The enclosing "" are not counted.</param>
            <param name="quote">Enclose in "".</param>
        </member>
        <member name="M:Au.String_.IsAscii_(System.String)">
            <summary>
            Returns true if this string is "" or contains only ASCII characters.
            </summary>
        </member>
        <member name="F:Au.String_.Lib.lineSep">
            <summary>{ '\r', '\n' }</summary>
        </member>
        <member name="F:Au.String_.Lib.pathSep">
            <summary>{ '\\', '/' }</summary>
        </member>
        <member name="T:Au.StringSegment">
            <summary>
            An optimized representation of a substring (any part of a string).
            </summary>
            <remarks>
            The main properties are: <see cref="P:Au.StringSegment.Buffer"/> - the string containing the substring; <see cref="P:Au.StringSegment.Offset"/> - the start index of the substring in the string; <see cref="P:Au.StringSegment.Length"/> substring length. There is no string object for the substring itself; however <see cref="P:Au.StringSegment.Value"/> and some other functions allocate and return a new string object.
            
            One of ways to create <b>StringSegment</b> instances is to split a string with <see cref="M:Au.String_.Segments_(System.String,System.String,Au.Types.SegFlags)"/>.
            
            Don't use the default constructor (parameterless). Then <b>Buffer</b> is null and the behavior of functions is undefined. Other constructors throw exception if the string is null.
            
            Functions throw <b>ArgumentOutOfRangeException</b>, <b>ArgumentNullException</b>, <b>NullReferenceException</b> or <b>IndexOutOfRangeException</b> exception when an argument is invalid.
            </remarks>
        </member>
        <member name="M:Au.StringSegment.#ctor(System.String)">
            <summary>
            Sets the substring = whole <paramref name="buffer"/>.
            </summary>
            <param name="buffer">The string that contains this substring. Cannot be null.</param>
        </member>
        <member name="M:Au.StringSegment.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Sets the substring = part of <paramref name="buffer"/> that starts at index <paramref name="offset"/> and has length <paramref name="length"/>.
            </summary>
            <param name="buffer">The string that contains this substring. Cannot be null.</param>
            <param name="offset">The offset of the substring in <paramref name="buffer"/>.</param>
            <param name="length">The length of the substring.</param>
        </member>
        <member name="M:Au.StringSegment.#ctor(System.String,System.Int32)">
            <summary>
            Sets the substring = part of <paramref name="buffer"/> that starts at index <paramref name="offset"/>.
            </summary>
            <param name="buffer">The string that contains this substring. Cannot be null.</param>
            <param name="offset">The offset of the substring in <paramref name="buffer"/>.</param>
        </member>
        <member name="P:Au.StringSegment.Buffer">
            <summary>
            Gets the string that contains this substring.
            </summary>
        </member>
        <member name="P:Au.StringSegment.Offset">
            <summary>
            Gets or sets the start index of this substring within <see cref="P:Au.StringSegment.Buffer"/>.
            The setter also changes <see cref="P:Au.StringSegment.Length"/>, but not <see cref="P:Au.StringSegment.EndOffset"/>.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">The setter throws if value is less than 0 or greater than <see cref="P:Au.StringSegment.EndOffset"/>.</exception>
        </member>
        <member name="M:Au.StringSegment.OffsetAdd(System.Int32)">
            <summary>
            Increments <see cref="P:Au.StringSegment.Offset"/>.
            Also changes <see cref="P:Au.StringSegment.Length"/>, but not <see cref="P:Au.StringSegment.EndOffset"/>.
            </summary>
            <param name="n">How much to increment. Can be negative.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">New <see cref="P:Au.StringSegment.Offset"/> would be less than 0 or greater than <see cref="P:Au.StringSegment.EndOffset"/>.</exception>
            <remarks>
            This method can be used instead of the <see cref="P:Au.StringSegment.Offset"/> setter when C# does not allow to call a property setter, for example with foreach variables.
            </remarks>
        </member>
        <member name="M:Au.StringSegment.OffsetSub(System.Int32)">
            <summary>
            Decrements <see cref="P:Au.StringSegment.Offset"/>.
            Also changes <see cref="P:Au.StringSegment.Length"/>, but not <see cref="P:Au.StringSegment.EndOffset"/>.
            </summary>
            <param name="n">How much to decrement. Can be negative.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">New <see cref="P:Au.StringSegment.Offset"/> would be less than 0 or greater than <see cref="P:Au.StringSegment.EndOffset"/>.</exception>
            <remarks>
            This method can be used instead of the <see cref="P:Au.StringSegment.Offset"/> setter when C# does not allow to call a property setter, for example with foreach variables.
            </remarks>
        </member>
        <member name="M:Au.StringSegment.OffsetSet(System.Int32)">
            <summary>
            Changes <see cref="P:Au.StringSegment.Offset"/>.
            Also changes <see cref="P:Au.StringSegment.Length"/>, but not <see cref="P:Au.StringSegment.EndOffset"/>.
            </summary>
            <param name="n">New value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">n is less than 0 or greater than <see cref="P:Au.StringSegment.EndOffset"/>.</exception>
            <remarks>
            This method can be used instead of the <see cref="P:Au.StringSegment.Offset"/> setter when C# does not allow to call a property setter, for example with foreach variables.
            </remarks>
        </member>
        <member name="P:Au.StringSegment.Length">
            <summary>
            Gets or sets the length of the substring.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">The setter throws if value is less than 0 or new <see cref="P:Au.StringSegment.EndOffset"/> would be greater than buffer length.</exception>
        </member>
        <member name="M:Au.StringSegment.LengthAdd(System.Int32)">
            <summary>
            Increments <see cref="P:Au.StringSegment.Length"/>.
            </summary>
            <param name="n">How much to increment. Can be negative.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">New <see cref="P:Au.StringSegment.Length"/> would be less than 0 or new <see cref="P:Au.StringSegment.EndOffset"/> would be greater than buffer length.</exception>
            <remarks>
            This method can be used instead of the <see cref="P:Au.StringSegment.Length"/> setter when C# does not allow to call a property setter, for example with foreach variables.
            </remarks>
        </member>
        <member name="M:Au.StringSegment.LengthSub(System.Int32)">
            <summary>
            Decrements <see cref="P:Au.StringSegment.Length"/>.
            </summary>
            <param name="n">How much to decrement. Can be negative.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">New <see cref="P:Au.StringSegment.Length"/> would be less than 0 or new <see cref="P:Au.StringSegment.EndOffset"/> would be greater than buffer length.</exception>
            <remarks>
            This method can be used instead of the <see cref="P:Au.StringSegment.Length"/> setter when C# does not allow to call a property setter, for example with foreach variables.
            </remarks>
        </member>
        <member name="M:Au.StringSegment.LengthSet(System.Int32)">
            <summary>
            Changes <see cref="P:Au.StringSegment.Length"/>.
            </summary>
            <param name="n">New value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">n is less than 0 or new <see cref="P:Au.StringSegment.EndOffset"/> would be greater than buffer length.</exception>
            <remarks>
            This method can be used instead of the <see cref="P:Au.StringSegment.Length"/> setter when C# does not allow to call a property setter, for example with foreach variables.
            </remarks>
        </member>
        <member name="P:Au.StringSegment.EndOffset">
            <summary>
            Gets or sets the end index of this substring within <see cref="P:Au.StringSegment.Buffer"/>. It's <see cref="P:Au.StringSegment.Offset"/> + <see cref="P:Au.StringSegment.Length"/>.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">The setter throws if value is less than <see cref="P:Au.StringSegment.Offset"/> or greater than buffer length.</exception>
        </member>
        <member name="M:Au.StringSegment.EndAdd(System.Int32)">
            <summary>
            Increments <see cref="P:Au.StringSegment.EndOffset"/>.
            </summary>
            <param name="n">How much to increment. Can be negative.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">New <see cref="P:Au.StringSegment.EndOffset"/> would be less than <see cref="P:Au.StringSegment.Offset"/> or greater than buffer length.</exception>
            <remarks>
            This method can be used instead of the <see cref="P:Au.StringSegment.EndOffset"/> setter when C# does not allow to call a property setter, for example with foreach variables.
            </remarks>
        </member>
        <member name="M:Au.StringSegment.EndSub(System.Int32)">
            <summary>
            Decrements <see cref="P:Au.StringSegment.EndOffset"/>.
            </summary>
            <param name="n">How much to decrement. Can be negative.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">New <see cref="P:Au.StringSegment.EndOffset"/> would be less than <see cref="P:Au.StringSegment.Offset"/> or greater than buffer length.</exception>
            <remarks>
            This method can be used instead of the <see cref="P:Au.StringSegment.EndOffset"/> setter when C# does not allow to call a property setter, for example with foreach variables.
            </remarks>
        </member>
        <member name="M:Au.StringSegment.EndSet(System.Int32)">
            <summary>
            Changes <see cref="P:Au.StringSegment.EndOffset"/>.
            </summary>
            <param name="n">New value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">n is less than <see cref="P:Au.StringSegment.Offset"/> or greater than buffer length.</exception>
            <remarks>
            This method can be used instead of the <see cref="P:Au.StringSegment.EndOffset"/> setter when C# does not allow to call a property setter, for example with foreach variables.
            </remarks>
        </member>
        <member name="M:Au.StringSegment.IsEmpty">
            <summary>
            Returns true if <b>Length</b> == 0.
            </summary>
        </member>
        <member name="P:Au.StringSegment.Value">
            <summary>
            Gets the value of this substring as a new string.
            </summary>
            <remarks>
            <note type="note">Always creates new string object (substring of <see cref="P:Au.StringSegment.Buffer"/>). See also <see cref="P:Au.StringSegment.ValueCached"/>.</note>
            </remarks>
        </member>
        <member name="P:Au.StringSegment.ValueCached">
            <summary>
            Gets the value of this substring as a cached string.
            </summary>
            <remarks>
            Can be used instead of <see cref="P:Au.StringSegment.Value"/> to avoid much garbage when identical substring values are frequent.
            Uses a <see cref="T:Au.Util.StringCache"/>.
            </remarks>
        </member>
        <member name="M:Au.StringSegment.ToString">
            <summary>
            Returns <see cref="P:Au.StringSegment.Value"/>.
            </summary>
        </member>
        <member name="M:Au.StringSegment.GetHashCode">
            
        </member>
        <member name="P:Au.StringSegment.Item(System.Int32)">
            <summary>
            Gets the character at a specified position in this substring.
            </summary>
            <param name="index">Character index in this substring.</param>
            <exception cref="T:System.IndexOutOfRangeException">index is not in this substring, even if it is in <see cref="P:Au.StringSegment.Buffer"/>.</exception>
        </member>
        <member name="M:Au.StringSegment.Equals(System.Object)">
            <summary>
            Returns true if <paramref name="obj"/> is <b>StringSegment</b> and its value is equal to that of this variable.
            Compares only substrigs, not offsets.
            </summary>
        </member>
        <member name="M:Au.StringSegment.Equals(Au.StringSegment)">
            <summary>
            Returns true if values of this and other variable are equal.
            Compares only substrigs, not offsets.
            </summary>
            <param name="other">A variable to compare with this variable.</param>
        </member>
        <member name="M:Au.StringSegment.EqualsI(Au.StringSegment)">
            <summary>
            Returns true if values of this and other variable are equal, case insensitive.
            Compares only substrigs, not offsets.
            </summary>
            <param name="other">A variable to compare with this variable.</param>
        </member>
        <member name="M:Au.StringSegment.Equals(System.String)">
            <summary>
            Returns true if the specified string is equal to this substring.
            </summary>
            <param name="text">The string. Cannot be null.</param>
        </member>
        <member name="M:Au.StringSegment.EqualsI(System.String)">
            <summary>
            Returns true if the specified string is equal to this substring, case-insensitive.
            </summary>
            <param name="text">The string. Cannot be null.</param>
        </member>
        <member name="M:Au.StringSegment.op_Equality(Au.StringSegment,Au.StringSegment)">
            <summary>
            Compares two substrings and returns true if their values are equal.
            Compares only substrigs, not offsets.
            </summary>
        </member>
        <member name="M:Au.StringSegment.op_Inequality(Au.StringSegment,Au.StringSegment)">
            <summary>
            Compares two substrings and returns true if their values are not equal.
            Compares only substrigs, not offsets.
            </summary>
        </member>
        <member name="M:Au.StringSegment.op_Implicit(System.String)~Au.StringSegment">
            <summary>
            Creates a new <b>StringSegment</b> from the given string.
            </summary>
            <param name="value">The string. Cannot be null.</param>
        </member>
        <member name="M:Au.StringSegment.StartsWith(System.String,System.Boolean)">
            <summary>
            Returns true if the beginning of this substring matches the specified string.
            </summary>
            <param name="text">The string. Cannot be null.</param>
            <param name="ignoreCase">Case-insensitive.</param>
        </member>
        <member name="M:Au.StringSegment.EndsWith(System.String,System.Boolean)">
            <summary>
            Returns true if the end of this substring matches the specified string.
            </summary>
            <param name="text">The string. Cannot be null.</param>
            <param name="ignoreCase">Case-insensitive.</param>
        </member>
        <member name="M:Au.StringSegment.Substring(System.Int32,System.Boolean)">
            <summary>
            Gets a substring of this substring, as string.
            </summary>
            <param name="offset">The start index in this substring.</param>
            <param name="cached">Use a <see cref="T:Au.Util.StringCache"/>, to avoid much garbage when identical substring values are frequent.</param>
        </member>
        <member name="M:Au.StringSegment.Substring(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Gets a substring of this substring, as string.
            </summary>
            <param name="offset">The start index in this substring.</param>
            <param name="length">The number of characters.</param>
            <param name="cached">Use a <see cref="T:Au.Util.StringCache"/>, to avoid much garbage when identical substring values are frequent.</param>
        </member>
        <member name="M:Au.StringSegment.Subsegment(System.Int32)">
            <summary>
            Gets a substring of this substring, as <b>StringSegment</b>.
            </summary>
            <param name="offset">The start index in this substring.</param>
        </member>
        <member name="M:Au.StringSegment.Subsegment(System.Int32,System.Int32)">
            <summary>
            Gets a substring of this substring, as <b>StringSegment</b>.
            </summary>
            <param name="offset">The start index in this substring.</param>
            <param name="length">The number of characters.</param>
        </member>
        <member name="M:Au.StringSegment.IndexOf(System.Char,System.Int32,System.Int32)">
            <summary>
            Finds a character and returns its index in this substring.
            Returns -1 if not found.
            </summary>
            <param name="c">The character.</param>
            <param name="startIndex">The search starting position.</param>
            <param name="count">The number of characters to examine.</param>
        </member>
        <member name="M:Au.StringSegment.IndexOf(System.Char,System.Int32)">
            <summary>
            Finds a character and returns its index in this substring.
            Returns -1 if not found.
            </summary>
            <param name="c">The character.</param>
            <param name="startIndex">The search starting position.</param>
        </member>
        <member name="M:Au.StringSegment.IndexOf(System.Char)">
            <summary>
            Finds a character and returns its index in this substring.
            Returns -1 if not found.
            </summary>
            <param name="c">The character.</param>
        </member>
        <member name="M:Au.StringSegment.IndexOfAny(System.Char[],System.Int32,System.Int32)">
            <summary>
            Finds a character and returns its index in this substring.
            Returns -1 if not found.
            </summary>
            <param name="anyOf">One or more characters to seek.</param>
            <param name="startIndex">The search starting position.</param>
            <param name="count">The number of character positions to examine.</param>
        </member>
        <member name="M:Au.StringSegment.IndexOfAny(System.Char[],System.Int32)">
            <summary>
            Finds a character and returns its index in this substring.
            Returns -1 if not found.
            </summary>
            <param name="anyOf">One or more characters to seek.</param>
            <param name="startIndex">The search starting position.</param>
        </member>
        <member name="M:Au.StringSegment.IndexOfAny(System.Char[])">
            <summary>
            Finds a character and returns its index in this substring.
            Returns -1 if not found.
            </summary>
            <param name="anyOf">One or more characters to seek.</param>
        </member>
        <member name="M:Au.StringSegment.LastIndexOf(System.Char)">
            <summary>
            Finds a character and returns its index in this substring. Searches right-to-left.
            Returns -1 if not found.
            </summary>
            <param name="c">The character.</param>
        </member>
        <member name="M:Au.StringSegment.Trim">
            <summary>
            Removes all leading and trailing whitespaces (see <see cref="M:System.Char.IsWhiteSpace(System.Char)"/>).
            </summary>
        </member>
        <member name="M:Au.StringSegment.TrimStart">
            <summary>
            Removes all leading whitespaces (see <see cref="M:System.Char.IsWhiteSpace(System.Char)"/>).
            </summary>
        </member>
        <member name="M:Au.StringSegment.TrimEnd">
            <summary>
            Removes all trailing whitespaces (see <see cref="M:System.Char.IsWhiteSpace(System.Char)"/>).
            </summary>
        </member>
        <member name="M:Au.StringSegment.Split(System.String,Au.Types.SegFlags)">
            <summary>
            Returns a <see cref="T:Au.Types.SegParser"/> that will split this substring into substrings as <b>StringSegment</b> variables when used with foreach.
            </summary>
            <param name="separators">Characters that delimit the substrings. Or one of <see cref="T:Au.Types.Separators"/> constants.</param>
            <param name="flags"></param>
            <seealso cref="M:Au.String_.Segments_(System.String,System.String,Au.Types.SegFlags)"/>
        </member>
        <member name="T:Au.InterDomainVariables">
            <summary>
            Inter-domain variables. Allows to share values by all app domains of this process.
            </summary>
            <remarks>
            Similar to environment variables, but supports more types and does not inherit parent process variables; the speed is similar.
            Supports not all types. The type must have one of these properties:
            1. Derived from MarshalByRefObject. The stored value is a virtual reference (proxy), not a copy. The owner domain must be still alive when other domains access (call methods etc) the retrieved value, else AppDomainUnloadedException.
            2. Has [Serializable] attribute. The stored value is a copy, not reference. For example int, IntPtr, string, arrays, List, Dictionary.
            </remarks>
        </member>
        <member name="M:Au.InterDomainVariables.SetVariable(System.String,System.Object)">
            <summary>
            Adds or modifies an inter-domain variable.
            </summary>
            <param name="name">Name. Can be any unique string, for example a GUID string. Case-sensitive.</param>
            <param name="value">Value.</param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The type is not supported because is neither serializable nor MarshalByRefObject-derived.</exception>
        </member>
        <member name="M:Au.InterDomainVariables.GetVariable(System.String)">
            <summary>
            Gets the value of an inter-domain variable.
            Returns null if the variable does not exist. Else returns the value as object; need a cast.
            </summary>
            <param name="name">Name. Case-sensitive.</param>
        </member>
        <member name="M:Au.InterDomainVariables.GetVariable``1(System.String,``0@)">
            <summary>
            Gets the value of an inter-domain variable.
            Returns true if the variable exists and is not null.
            </summary>
            <param name="name">Name. Case-sensitive.</param>
            <param name="value">Receives the value. If the variable does not exist, receives the default value of that type (for reference types it is null).</param>
            <exception cref="T:System.InvalidCastException">Bad value type.</exception>
        </member>
        <member name="M:Au.InterDomainVariables.GetVariable``1(System.String,System.Func{``0})">
            <summary>
            Gets the value of an inter-domain variable.
            If the variable does not exist or is null, calls a callback function that provides an initial value; then sets the variable = the initial value.
            Thread-safe.
            </summary>
            <param name="name">Name. Case-sensitive.</param>
            <param name="initValue">A callback function delegate (eg lambda) that is called when the variable does not exist or is null. It must return an initial value.</param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The type is not supported because is neither serializable nor MarshalByRefObject-derived.</exception>
            <exception cref="T:System.InvalidCastException">Bad value type.</exception>
            <remarks>
            Be careful with types derived from MarshalByRefObject. If the object does not exist, your callback function creates it in this appdomain. Maybe this appdomain is not where you want it to live. Instead use SetVariable and another overload of GetVariable.
            </remarks>
            <example><code>int test = InterDomainVariables.GetVariable("test", () => 10);</code></example>
        </member>
        <member name="M:Au.InterDomainVariables.DefaultDomainVariable``1(System.String,System.Boolean@)">
            <summary>
            Gets a reference to an object that lives in default appdomain. Auto-creates new object there if does not exist.
            The object can be used in any appdomain. When a non-default domain calls its methods, the call is marshaled to the default domain and executed there.
            </summary>
            <typeparam name="T">The type must be derived from MarshalByRefObject and have default constructor.</typeparam>
            <param name="name">Inter-domain variable name. Any unique string. Case-sensitive.</param>
            <param name="createdNew">Receives true if now created new object, false if the object alrady existed.</param>
            <remarks>
            Thread-safe.
            </remarks>
            <example>
            <code><![CDATA[
            static DefDomainVar s_idvTest = InterDomainVariables.DefaultDomainVariable<DefDomainVar>(nameof(s_idvTest));
            
            static void Main()
            {
            	s_idvTest.Method(7);
            }
            
            class DefDomainVar :MarshalByRefObject
            {
            	public void Method(int param)
            	{
            		Print(param, AppDomain.CurrentDomain.FriendlyName);
            	}
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.InterDomainVariables.DefaultDomainVariable``1(System.String)">
            <summary>
            The same as <see cref="M:Au.InterDomainVariables.DefaultDomainVariable``1(System.String,System.Boolean@)"/>, just does not have the bool parameter.
            </summary>
        </member>
        <member name="T:Au.Files">
            <summary>
            File system functions.
            </summary>
            <remarks>
            Works with files and directories. Disk drives like @"C:\" or "C:" are directories too.
            Extends .NET file system classes such as <see cref="T:System.IO.File"/> and <see cref="T:System.IO.Directory"/>.
            Many functions of this class can be used instead of existing similar .NET functions that are slow, limited or unreliable.
            Most functions support only full path. Most of them throw <b>ArgumentException</b> if passed a filename or relative path, ie in "current directory". Using current directory is unsafe; it was relevant only in DOS era.
            Most functions support extended-length paths (longer than 259). Such local paths should have @"\\?\" prefix, like @"\\?\C:\...". Such network path should be like @"\\?\UNC\server\share\...". See <see cref="M:Au.Path_.PrefixLongPath(System.String)"/>, <see cref="M:Au.Path_.PrefixLongPathIfNeed(System.String)"/>. Many functions support long paths even without prefix.
            </remarks>
        </member>
        <member name="T:Au.Files.Misc">
            <summary>
            Miscellaneous file/directory functions.
            </summary>
        </member>
        <member name="T:Au.Files.Misc.FileId">
            <summary>
            Contains file properties that can be used to uniquely identify the file on a single computer.
            </summary>
            <remarks>
            Can be used with files and directories.
            To get it, use <see cref="M:Au.Files.Misc.GetFileId(System.String,Au.Files.Misc.FileId@)"/>.
            There are many different ways to specify path to the same file or directory. To determine whether two paths represent the same file, get and compare their <b>FileId</b>.
            </remarks>
            <tocexclude />
        </member>
        <member name="F:Au.Files.Misc.FileId.VolumeSerialNumber">
            <summary>The serial number of the volume (aka disk drive) that contains the file.</summary>
        </member>
        <member name="F:Au.Files.Misc.FileId.FileIndex">
            <summary>An identifier that is associated with the file. It is unique in that volume.</summary>
        </member>
        <member name="M:Au.Files.Misc.FileId.op_Equality(Au.Files.Misc.FileId,Au.Files.Misc.FileId)">
            
        </member>
        <member name="M:Au.Files.Misc.FileId.op_Inequality(Au.Files.Misc.FileId,Au.Files.Misc.FileId)">
            
        </member>
        <member name="M:Au.Files.Misc.GetFileId(System.String,Au.Files.Misc.FileId@)">
            <summary>
            Gets <see cref="T:Au.Files.Misc.FileId"/> of a file or directory.
            Returns false if fails. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <param name="path">Full path. Supports environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>).</param>
            <param name="fileId"></param>
        </member>
        <member name="M:Au.Files.Misc.LibIsSameFile(System.String,System.String)">
            <summary>
            Calls <see cref="M:Au.Files.Misc.GetFileId(System.String,Au.Files.Misc.FileId@)"/> for two paths and returns true if both calls succeed and the ids are equal.
            Paths should be normalized. They are passed to API unmodified.
            </summary>
            <param name="path1"></param>
            <param name="path2"></param>
        </member>
        <member name="T:Au.Files.Misc.DisableRedirection">
            <summary>
            Temporarily disables file system redirection, to allow this 32-bit process access the 64-bit System32 directory.
            </summary>
        </member>
        <member name="M:Au.Files.Misc.DisableRedirection.Disable">
            <summary>
            If Ver.Is32BitProcessOn64BitOS, calls API <msdn>Wow64DisableWow64FsRedirection</msdn>, which disables file system redirection.
            The caller can call this without checking OS and process bitness. This function checks it and it is fast.
            Always call <see cref="M:Au.Files.Misc.DisableRedirection.Revert"/> or Dispose, for example in finally{}, or use using (this struct implements IDisposable). Not calling it is more dangerous than a memory leak. It is not called by GC.
            </summary>
        </member>
        <member name="M:Au.Files.Misc.DisableRedirection.Revert">
            <summary>
            If redirected, calls API <msdn>Wow64RevertWow64FsRedirection</msdn>.
            </summary>
        </member>
        <member name="M:Au.Files.Misc.DisableRedirection.IsSystem64PathIn32BitProcess(System.String)">
            <summary>
            Returns true if Ver.Is32BitProcessOn64BitOS is true and path starts with Folders.System.
            Most such paths are redirected, therefore you may want to disable redirection with this class.
            </summary>
            <param name="path">Normalized path. This function does not normalize. Also it is unaware of @"\\?\".</param>
        </member>
        <member name="M:Au.Files.Misc.DisableRedirection.GetNonRedirectedSystemPath(System.String,System.Boolean)">
            <summary>
            If Ver.Is32BitProcessOn64BitOS is true and path starts with Folders.System, replaces that path part with <see cref="P:Au.Folders.SystemX64"/>.
            It disables redirection to Folders.SystemX32 for that path.
            </summary>
            <param name="path">Normalized path. This function does not normalize. Also it is unaware of @"\\?\".</param>
            <param name="ifExistsOnlyThere">Don't replace path if the file or directory exists in the redirected folder or does not exist in the non-redirected folder.</param>
        </member>
        <member name="M:Au.Files.Misc.DisableRedirection.Dispose">
            <summary>
            Calls <see cref="M:Au.Files.Misc.DisableRedirection.Revert"/>.
            </summary>
        </member>
        <member name="M:Au.Files._DisableDeviceNotReadyMessageBox">
            <summary>
            Adds SEM_FAILCRITICALERRORS to the error mode of this process, as MSDN recommends. Does this once in appdomain.
            It is to avoid unnecessary message boxes when an API tries to access an ejected CD/DVD etc.
            </summary>
        </member>
        <member name="M:Au.Files.GetProperties(System.String,Au.Types.FileProperties@,Au.Types.FAFlags)">
            <summary>
            Gets file or directory attributes, size and times.
            Returns false if the file/directory does not exist.
            Calls API <msdn>GetFileAttributesEx</msdn>.
            </summary>
            <param name="path">Full path. Supports @"\.." etc. If flag UseRawPath not used, supports environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>).</param>
            <param name="properties">Receives properties.</param>
            <param name="flags"></param>
            <exception cref="T:System.ArgumentException">Not full path (when not used flag UseRawPath).</exception>
            <exception cref="T:Au.Types.AuException">The file/directory exist but failed to get its properties. Not thrown if used flag DoNotThrow.</exception>
            <remarks>
            For symbolic links etc, gets properties of the link, not of its target.
            You can also get most of these properties with <see cref="M:Au.Files.EnumDirectory(System.String,Au.Types.FEFlags,System.Func{Au.Types.FEFile,System.Boolean},System.Action{System.String})"/>.
            </remarks>
        </member>
        <member name="M:Au.Files.GetAttributes(System.String,System.IO.FileAttributes@,Au.Types.FAFlags)">
            <summary>
            Gets file or directory attributes.
            Returns false if the file/directory does not exist.
            Calls API <msdn>GetFileAttributes</msdn>.
            </summary>
            <param name="path">Full path. Supports @"\.." etc. If flag UseRawPath not used, supports environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>).</param>
            <param name="attributes">Receives attributes, or 0 if failed.</param>
            <param name="flags"></param>
            <exception cref="T:System.ArgumentException">Not full path (when not used flag UseRawPath).</exception>
            <exception cref="T:Au.Types.AuException">Failed. Not thrown if used flag DoNotThrow.</exception>
            <remarks>
            For symbolic links etc, gets properties of the link, not of its target.
            </remarks>
        </member>
        <member name="M:Au.Files._GetAttributes(System.String,System.IO.FileAttributes@,System.Boolean)">
            <summary>
            Gets attributes.
            Returns false if INVALID_FILE_ATTRIBUTES or if relative path. No exceptions.
            </summary>
        </member>
        <member name="M:Au.Files.ExistsAs(System.String,System.Boolean)">
            <summary>
            Gets file system entry type - file, directory, and whether it exists.
            Returns NotFound (0) if does not exist or if fails to get attributes.
            Calls API <msdn>GetFileAttributes</msdn>.
            </summary>
            <param name="path">Full path. Supports @"\.." etc. If useRawPath is false (default), supports environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>). Can be null.</param>
            <param name="useRawPath">Pass path to the API as it is, without any normalizing and full-path checking.</param>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>. If you need exception when fails, instead call <see cref="M:Au.Files.GetAttributes(System.String,System.IO.FileAttributes@,Au.Types.FAFlags)"/> and check attribute Directory.
            Always use full path. If path is not full: if useRawPath is false (default) returns NotFound; if useRawPath is true, searches in "current directory".
            </remarks>
        </member>
        <member name="M:Au.Files.ExistsAs2(System.String,System.Boolean)">
            <summary>
            Gets file system entry type - file, directory, symbolic link, whether it exists and is accessible.
            Returns NotFound (0) if does not exist. Returns AccessDenied (&lt; 0) if exists but this process cannot access it and get attributes.
            Calls API <msdn>GetFileAttributes</msdn>.
            The same as <see cref="M:Au.Files.ExistsAs(System.String,System.Boolean)"/> but provides more complete result. In most cases you can use ExistsAs, it's simpler.
            </summary>
            <param name="path">Full path. Supports @"\.." etc. If useRawPath is false (default), supports environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>). Can be null.</param>
            <param name="useRawPath">Pass path to the API as it is, without any normalizing and full-path checking.</param>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>. If you need exception when fails, instead call <see cref="M:Au.Files.GetAttributes(System.String,System.IO.FileAttributes@,Au.Types.FAFlags)"/> and check attributes Directory and ReparsePoint.
            Always use full path. If path is not full: if useRawPath is false (default) returns NotFound; if useRawPath is true, searches in "current directory".
            </remarks>
        </member>
        <member name="M:Au.Files.ExistsAsAny(System.String,System.Boolean)">
            <summary>
            Returns true if file or directory exists.
            Calls <see cref="M:Au.Files.ExistsAs2(System.String,System.Boolean)"/>, which calls API <msdn>GetFileAttributes</msdn>.
            </summary>
            <param name="path">Full path. Supports @"\.." etc. If useRawPath is false (default), supports environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>). Can be null.</param>
            <param name="useRawPath">Pass path to the API as it is, without any normalizing and full-path checking.</param>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>. If you need exception when fails, instead call <see cref="M:Au.Files.GetAttributes(System.String,System.IO.FileAttributes@,Au.Types.FAFlags)"/>.
            Always use full path. If path is not full: if useRawPath is false (default) returns NotFound; if useRawPath is true, searches in "current directory".
            For symbolic links etc, returns true if the link exists. Does not care whether its target exists.
            Unlike <see cref="M:Au.Files.ExistsAsFile(System.String,System.Boolean)"/> and <see cref="M:Au.Files.ExistsAsDirectory(System.String,System.Boolean)"/>, this function returns true when the file exists but cannot get its attributes. Then <c>ExistsAsAny(path)</c> is not the same as <c>ExistsAsFile(path) || ExistsAsDirectory(path)</c>.
            </remarks>
        </member>
        <member name="M:Au.Files.ExistsAsFile(System.String,System.Boolean)">
            <summary>
            Returns true if file exists and is not a directory.
            Returns false if does not exist or if fails to get its attributes.
            Calls <see cref="M:Au.Files.ExistsAs(System.String,System.Boolean)"/>, which calls API <msdn>GetFileAttributes</msdn>.
            </summary>
            <param name="path">Full path. Supports @"\.." etc. If useRawPath is false (default), supports environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>). Can be null.</param>
            <param name="useRawPath">Pass path to the API as it is, without any normalizing and full-path checking.</param>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>. If you need exception when fails, instead call <see cref="M:Au.Files.GetAttributes(System.String,System.IO.FileAttributes@,Au.Types.FAFlags)"/> and check attribute Directory.
            Always use full path. If path is not full: if useRawPath is false (default) returns NotFound; if useRawPath is true, searches in "current directory".
            For symbolic links etc, returns true if the link exists and its target is not a directory. Does not care whether its target exists.
            </remarks>
        </member>
        <member name="M:Au.Files.ExistsAsDirectory(System.String,System.Boolean)">
            <summary>
            Returns true if directory (folder or drive) exists.
            Returns false if does not exist or if fails to get its attributes.
            Calls <see cref="M:Au.Files.ExistsAs(System.String,System.Boolean)"/>, which calls API <msdn>GetFileAttributes</msdn>.
            </summary>
            <param name="path">Full path. Supports @"\.." etc. If useRawPath is false (default), supports environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>). Can be null.</param>
            <param name="useRawPath">Pass path to the API as it is, without any normalizing and full-path checking.</param>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>. If you need exception when fails, instead call <see cref="M:Au.Files.GetAttributes(System.String,System.IO.FileAttributes@,Au.Types.FAFlags)"/> and check attribute Directory.
            Always use full path. If path is not full: if useRawPath is false (default) returns NotFound; if useRawPath is true, searches in "current directory".
            For symbolic links etc, returns true if the link exists and its target is a directory. Does not care whether its target exists.
            </remarks>
        </member>
        <member name="M:Au.Files.SearchPath(System.String,System.String[])">
            <summary>
            Finds file or directory and returns full path.
            Returns null if cannot be found.
            If the path argument is full path, calls <see cref="M:Au.Files.ExistsAsAny(System.String,System.Boolean)"/> and returns normalized path if exists, null if not.
            Else searches in these places:
            1. dirs, if used.
            2. <see cref="P:Au.Folders.ThisApp"/>.
            3. Calls API <msdn>SearchPath</msdn>, which searches in process directory, Windows system directories, current directory, PATH environment variable. The search order depends on API <msdn>SetSearchPathMode</msdn> or registry settings.
            4. If path ends with ".exe", tries to get path from registry "App Paths" keys.
            </summary>
            <param name="path">Full or relative path or just filename with extension. Supports network paths too.</param>
            <param name="dirs">0 or more directories where to search.</param>
        </member>
        <member name="M:Au.Files.EnumDirectory(System.String,Au.Types.FEFlags,System.Func{Au.Types.FEFile,System.Boolean},System.Action{System.String})">
            <summary>
            Gets names and other info of files and subdirectories in the specified directory.
            Returns an enumerable collection of <see cref="T:Au.Types.FEFile"/> objects containing the info.
            By default gets only direct children. Use flag <see cref="F:Au.Types.FEFlags.AndSubdirectories"/> to get all descendants.
            </summary>
            <param name="directoryPath">Full path of the directory.</param>
            <param name="flags"></param>
            <param name="filter">
            Callback function. Called for each file and subdirectory.
            If it returns false, the file/subdirectory is not included in results.
            This can be useful when EnumDirectory is called indirectly, for example by the Copy method. If you call it directly, you can instead skip processing the file in your foreach loop.
            </param>
            <param name="errorHandler">
            Callback function. Called when fails to get children of a subdirectory, when using flag <see cref="F:Au.Types.FEFlags.AndSubdirectories"/>.
            It receives the subdirectory path. It can call <see cref="M:Au.Types.Native.GetError"/> and throw an exception.
            If it does not throw an exception, the enumeration continues as if the directory is empty.
            If errorHandler not used, then throws exception.
            Read more in Remarks.
            </param>
            <exception cref="T:System.ArgumentException">directoryPath is invalid path or not full path.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">directoryPath directory does not exist.</exception>
            <exception cref="T:Au.Types.AuException">Failed to get children of directoryPath or of a subdirectory. Read more in Remarks.</exception>
            <remarks>
            Uses API <msdn>FindFirstFile</msdn>.
            
            The paths that this function gets are normalized, ie may not start with exact directoryPath string. Expanded environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>), "..", DOS path etc.
            Paths longer than <see cref="F:Au.Path_.MaxDirectoryPathLength"/> have @"\\?\" prefix (see <see cref="M:Au.Path_.PrefixLongPathIfNeed(System.String)"/>).
            For symbolic links and mounted folders, gets info of the link/folder and not of its target.
            
            These errors are ignored:
            1. Access denied (usually because of security permissions), unless used flag FailIfAccessDenied.
            2. Missing target directory of a symbolic link or mounted folder.
            When an error is ignored, the function works as if that [sub]directory is empty; does not throw exception and does not call errorHandler.
            
            Enumeration of a subdirectory starts immediately after the subdirectory itself is retrieved.
            </remarks>
        </member>
        <member name="M:Au.Files._SafeDeleteExistingDirectory.Rename(System.String,System.Boolean)">
            <summary>
            note: path must be normalized.
            </summary>
        </member>
        <member name="M:Au.Files.Rename(System.String,System.String,Au.Types.IfExists)">
            <summary>
            Renames file or directory.
            </summary>
            <param name="path">Full path.</param>
            <param name="newName">New name without path. Example: "name.txt".</param>
            <param name="ifExists"></param>
            <exception cref="T:System.ArgumentException">
            path is not full path (see <see cref="M:Au.Path_.IsFullPath(System.String)"/>).
            newName is invalid filename.
            </exception>
            <exception cref="T:System.IO.FileNotFoundException">The file (path) does not exist or cannot be found.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Uses API <msdn>MoveFileEx</msdn>.
            </remarks>
        </member>
        <member name="M:Au.Files.Move(System.String,System.String,Au.Types.IfExists)">
            <summary>
            Moves (changes path of) file or directory.
            </summary>
            <param name="path">Full path.</param>
            <param name="newPath">
            New full path.
            <note type="note">It is not the new parent directory. Use <see cref="M:Au.Files.MoveTo(System.String,System.String,Au.Types.IfExists)"/> for it.</note>
            </param>
            <param name="ifExists"></param>
            <exception cref="T:System.ArgumentException">path or newPath is not full path (see <see cref="M:Au.Path_.IsFullPath(System.String)"/>).</exception>
            <exception cref="T:System.IO.FileNotFoundException">The source file (path) does not exist or cannot be found.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            In most cases uses API <msdn>MoveFileEx</msdn>. It's fast, because don't need to copy files.
            In these cases copies/deletes: destination is on another drive; need to merge directories.
            When need to copy, does not copy the security properties; sets default security properties.
            
            Creates the destination directory if does not exist (see <see cref="M:Au.Files.CreateDirectory(System.String,System.String)"/>).
            If path and newPath share the same parent directory, just renames the file.
            </remarks>
        </member>
        <member name="M:Au.Files.MoveTo(System.String,System.String,Au.Types.IfExists)">
            <summary>
            Moves file or directory into another directory.
            </summary>
            <param name="path">Full path.</param>
            <param name="newDirectory">New parent directory.</param>
            <param name="ifExists"></param>
            <exception cref="T:System.ArgumentException">
            path or newDirectory is not full path (see <see cref="M:Au.Path_.IsFullPath(System.String)"/>).
            path is drive. To move drive content, use <see cref="M:Au.Files.Move(System.String,System.String,Au.Types.IfExists)"/>.
            </exception>
            <exception cref="T:System.IO.FileNotFoundException">The source file (path) does not exist or cannot be found.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            In most cases uses API <msdn>MoveFileEx</msdn>. It's fast, because don't need to copy files.
            In these cases copies/deletes: destination is on another drive; need to merge directories.
            When need to copy, does not copy the security properties; sets default security properties.
            
            Creates the destination directory if does not exist (see <see cref="M:Au.Files.CreateDirectory(System.String,System.String)"/>).
            </remarks>
        </member>
        <member name="M:Au.Files.Copy(System.String,System.String,Au.Types.IfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})">
            <summary>
            Copies file or directory.
            </summary>
            <param name="path">Full path.</param>
            <param name="newPath">
            New full path.
            <note type="note">It is not the new parent directory. Use <see cref="M:Au.Files.CopyTo(System.String,System.String,Au.Types.IfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})"/> for it.</note>
            </param>
            <param name="ifExists"></param>
            <param name="copyFlags">Options used when copying directory.</param>
            <param name="filter">
            This callback function can be used when copying directory. Called for each descendant file and subdirectory.
            If it returns false, the file/subdirectory is not copied.
            </param>
            <exception cref="T:System.ArgumentException">path or newPath is not full path (see <see cref="M:Au.Path_.IsFullPath(System.String)"/>).</exception>
            <exception cref="T:System.IO.FileNotFoundException">The source file (path) does not exist or cannot be found.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Uses API <msdn>CopyFileEx</msdn>.
            On Windows 7 does not copy the security properties; sets default security properties.
            Does not copy symbolic links (silently skips, no exception) if this process is not running as administrator.
            Creates the destination directory if does not exist (see <see cref="M:Au.Files.CreateDirectory(System.String,System.String)"/>).
            </remarks>
        </member>
        <member name="M:Au.Files.CopyTo(System.String,System.String,Au.Types.IfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})">
            <summary>
            Copies file or directory into another directory.
            </summary>
            <param name="path">Full path.</param>
            <param name="newDirectory">New parent directory.</param>
            <param name="ifExists"></param>
            <param name="copyFlags">Options used when copying directory.</param>
            <param name="filter"><inheritdoc cref="M:Au.Files.Copy(System.String,System.String,Au.Types.IfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})"/></param>
            <exception cref="T:System.ArgumentException">
            path or newDirectory is not full path (see <see cref="M:Au.Path_.IsFullPath(System.String)"/>).
            path is drive. To copy drive content, use <see cref="M:Au.Files.Copy(System.String,System.String,Au.Types.IfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})"/>.
            </exception>
            <exception cref="T:System.IO.FileNotFoundException">The source file (path) does not exist or cannot be found.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Uses API <msdn>CopyFileEx</msdn>.
            On Windows 7 does not copy the security properties; sets default security properties.
            Does not copy symbolic links (silently skips, no exception) if this process is not running as administrator.
            Creates the destination directory if does not exist (see <see cref="M:Au.Files.CreateDirectory(System.String,System.String)"/>).
            </remarks>
        </member>
        <member name="M:Au.Files.Delete(System.String,System.Boolean)">
            <summary>
            Deletes file or directory.
            Does nothing if it does not exist (no exception).
            </summary>
            <param name="path">Full path.</param>
            <param name="tryRecycleBin">
            Send to the Recycle Bin. If not possible, delete anyway.
            Why could be not possible: 1. The file is in a removable drive (most removables don't have a recycle bin). 2. The file is too large. 3. The path is too long. 4. The Recycle Bin is not used on that drive (it can be set in the Recycle Bin Properties dialog). 5. This process is non-UI-interactive, eg a service. 6. Unknown reasons.
            Note: it is much slower. To delete multiple, use <see cref="M:Au.Files.Delete(System.Collections.Generic.IEnumerable{System.String},System.Boolean)"/>.
            </param>
            <exception cref="T:System.ArgumentException">path is not full path (see <see cref="M:Au.Path_.IsFullPath(System.String)"/>).</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            If directory, also deletes all its files and subdirectories. If fails to delete some, tries to delete as many as possible.
            Deletes read-only files too.
            Does not show any message boxes etc (confirmation, error, UAC consent, progress).
            
            Some reasons why this function can fail:
            1. The file is open (in any process). Or a file in the directory is open.
            2. This process does not have security permissions to access or delete the file or directory or some of its descendants.
            3. The directory is (or contains) the "current directory" (in any process).
            </remarks>
        </member>
        <member name="M:Au.Files.Delete(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Deletes multiple files or/and directories.
            The same as <see cref="M:Au.Files.Delete(System.String,System.Boolean)"/>, but faster when using Recycle Bin.
            </summary>
            <param name="paths">string array, List or other collection. Full paths.</param>
            <param name="tryRecycleBin"></param>
        </member>
        <member name="M:Au.Files._Delete(System.String,System.Boolean)">
            <summary>
            note: path must be normalized.
            </summary>
        </member>
        <member name="M:Au.Files.CalculateDirectorySize(System.String,Au.Types.FEFlags)">
            <summary>
            Calls <see cref="M:Au.Files.EnumDirectory(System.String,Au.Types.FEFlags,System.Func{Au.Types.FEFile,System.Boolean},System.Action{System.String})"/> and returns sum of all file sizes.
            With default flags, it includes sizes of all descendant files, in this directory and all subdirectories except in inaccessible [sub]directories.
            </summary>
            <param name="path">Full path.</param>
            <param name="flags">EnumDirectory flags.</param>
            <exception cref="T:System.Exception"><see cref="M:Au.Files.EnumDirectory(System.String,Au.Types.FEFlags,System.Func{Au.Types.FEFile,System.Boolean},System.Action{System.String})"/> exceptions. By default, no exceptions if used full path and the directory exists.</exception>
            <remarks>
            This function is slow if the directory is large.
            Don't use this function for files (throws exception) and drives (instead use <see cref="T:System.IO.DriveInfo"/>, it's fast and includes sizes of Recycle Bin and other protected hidden system directories).
            </remarks>
        </member>
        <member name="M:Au.Files.CreateDirectory(System.String,System.String)">
            <summary>
            Creates new directory if does not exists.
            If need, creates missing parent/ancestor directories.
            Returns true if created new directory, false if the directory already exists. Throws exception if fails.
            </summary>
            <param name="path">Path of new directory.</param>
            <param name="templateDirectory">Optional path of a template directory from which to copy some properties. See API <msdn>CreateDirectoryEx</msdn>.</param>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            If the directory already exists, this function does nothing, and returns false.
            Else, at first it creates missing parent/ancestor directories, then creates the specified (path) directory.
            To create the specified directory, calls API <msdn>CreateDirectory</msdn> or <msdn>CreateDirectoryEx</msdn> (if templateDirectory is not null).
            </remarks>
        </member>
        <member name="M:Au.Files.CreateDirectoryFor(System.String)">
            <summary>
            Creates parent directory for a new file, if does not exist.
            The same as <see cref="M:Au.Files.CreateDirectory(System.String,System.String)"/>, just removes filename from filePath.
            </summary>
            <param name="filePath">Path of new file.</param>
            <exception cref="T:System.ArgumentException">Not full path. No filename.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            string path = @"D:\Test\new\test.txt";
            Files.CreateDirectoryFor(path);
            File.WriteAllText(path, "text"); //would fail if directory @"D:\Test\new" does not exist
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Files._PreparePath(System.String)">
            <summary>
            Expands environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>). Throws ArgumentException if not full path. Normalizes. Removes or adds '\\' at the end.
            </summary>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
        </member>
        <member name="M:Au.Files._FindFilename(System.String,System.Boolean)">
            <summary>
            Finds filename, eg @"b.txt" in @"c:\a\b.txt".
            </summary>
            <exception cref="T:System.ArgumentException">'\\' not found or is at the end. If noException, instead returns -1.</exception>
        </member>
        <member name="M:Au.Files._RemoveFilename(System.String,System.Boolean)">
            <summary>
            Removes filename, eg @"c:\a\b.txt" -> @"c:\a".
            </summary>
            <exception cref="T:System.ArgumentException">'\\' not found or is at the end. If noException, instead returns null.</exception>
        </member>
        <member name="M:Au.Files._GetFilename(System.String,System.Boolean)">
            <summary>
            Gets filename, eg @"c:\a\b.txt" -> @"b.txt".
            </summary>
            <exception cref="T:System.ArgumentException">'\\' not found or is at the end. If noException, instead returns null.</exception>
        </member>
        <member name="M:Au.Files._IsSepChar(System.Char)">
            <summary>
            Returns true if character c == '\\' || c == '/'.
            </summary>
        </member>
        <member name="T:Au.Shell">
            <summary>
            Windows shell functions.
            Windows shell manages files, folders (directories), shortcuts and virtual objects such as Control Panel.
            </summary>
        </member>
        <member name="T:Au.Shell.Pidl">
            <summary>
            Manages an ITEMIDLIST structure that is used with shell API to identify files and other shell objects. Like a file-system path, but not string.
            </summary>
            <remarks>
            When calling shell API, virtual objects can be identified only by ITEMIDLIST. Some API also support "parsing name", which usually looks like "::{CLSID-1}\::{CLSID-2}". File-system objects can be identified by path as well as by ITEMIDLIST. URLs can be identified by URL as well as by ITEMIDLIST.
            
            The ITEMIDLIST structure is in unmanaged memory, therefore this class implements IDisposable.
            </remarks>
        </member>
        <member name="P:Au.Shell.Pidl.UnsafePtr">
            <summary>
            Gets the ITEMIDLIST pointer (PIDL).
            </summary>
            <remarks>
            The ITEMIDLIST memory is managed by this variable and will be freed when disposing or GC-collecting it. Use <see cref="M:System.GC.KeepAlive(System.Object)"/> where need.
            </remarks>
        </member>
        <member name="P:Au.Shell.Pidl.HandleRef">
            <summary>
            Gets the ITEMIDLIST pointer (PIDL).
            </summary>
            <remarks>
            Use to pass to API where the parameter type is HandlePtr. It is safer than <see cref="P:Au.Shell.Pidl.UnsafePtr"/> because ensures that this variable will not be GC-collected during API call even if not referenced after the call.
            </remarks>
        </member>
        <member name="P:Au.Shell.Pidl.IsNull">
            <summary>
            Returns true if the PIDL is default(IntPtr).
            </summary>
        </member>
        <member name="M:Au.Shell.Pidl.#ctor(System.IntPtr)">
            <summary>
            Assigns an ITEMIDLIST to this variable.
            </summary>
            <param name="pidl">
            ITEMIDLIST pointer (PIDL).
            It can be created by any API that creates ITEMIDLIST. They allocate the memory with API CoTaskMemAlloc.
            This variable will finally free it with Marshal.FreeCoTaskMem.
            </param>
        </member>
        <member name="M:Au.Shell.Pidl.Dispose">
            <summary>
            Frees the ITEMIDLIST with Marshal.FreeCoTaskMem and clears this variable.
            </summary>
        </member>
        <member name="M:Au.Shell.Pidl.Finalize">
            
        </member>
        <member name="M:Au.Shell.Pidl.Detach">
            <summary>
            Gets the ITEMIDLIST and clears this variable so that it cannot be used and will not free the ITEMIDLIST memory. To free it use Marshal.FreeCoTaskMem.
            </summary>
        </member>
        <member name="M:Au.Shell.Pidl.FromString(System.String,System.Boolean)">
            <summary>
            Converts string to ITEMIDLIST and creates new Pidl variable that holds it.
            Returns null if failed.
            Note: Pidl is disposable.
            </summary>
            <param name="s">A file-system path or URL or shell object parsing name (see <see cref="M:Au.Shell.Pidl.ToShellString(Au.Types.Native.SIGDN,System.Boolean)"/>) or ":: HexEncodedITEMIDLIST" (see <see cref="M:Au.Shell.Pidl.ToHexString"/>). Supports environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>).</param>
            <param name="throwIfFailed">If failed, throw AuException.</param>
            <exception cref="T:Au.Types.AuException">Failed, and throwIfFailed is true. Probably invalid s.</exception>
            <remarks>
            Calls <msdn>SHParseDisplayName</msdn>, except when string is ":: HexEncodedITEMIDLIST".
            Never fails if s is ":: HexEncodedITEMIDLIST", even if it creates an invalid ITEMIDLIST.
            </remarks>
        </member>
        <member name="M:Au.Shell.Pidl.LibFromString(System.String,System.Boolean)">
            <summary>
            The same as <see cref="M:Au.Shell.Pidl.FromString(System.String,System.Boolean)"/>, just returns unmanaged ITEMIDLIST pointer (PIDL).
            Later need to free it with Marshal.FreeCoTaskMem.
            </summary>
            <param name="s"></param>
            <param name="throwIfFailed"></param>
        </member>
        <member name="M:Au.Shell.Pidl.ToShellString(Au.Types.Native.SIGDN,System.Boolean)">
            <summary>
            Converts the ITEMIDLIST to file path or URL or shell object parsing name or display name, depending on stringType argument.
            Returns null if this variable does not have an ITEMIDLIST (eg disposed or detached).
            If failed, returns null or throws exception.
            </summary>
            <param name="stringType">
            String format.
            Often used:
            Native.SIGDN.NORMALDISPLAY - returns object name without path. It is best to display in UI but cannot be parsed to create ITEMIDLIST again.
            Native.SIGDN.FILESYSPATH - returns path if the ITEMIDLIST identifies a file system object (file or directory). Else returns null.
            Native.SIGDN.URL - if URL, returns URL. If file system object, returns its path like "file:///C:/a/b.txt". Else returns null.
            Native.SIGDN.DESKTOPABSOLUTEPARSING - returns path (if file system object) or URL (if URL) or shell object parsing name (if virtual object eg Control Panel). Note: not all returned parsing names can actually be parsed to create ITEMIDLIST again, therefore usually it's better to use <see cref="M:Au.Shell.Pidl.ToString"/> instead.
            </param>
            <param name="throwIfFailed">If failed, throw AuException.</param>
            <exception cref="T:Au.Types.AuException">Failed, and throwIfFailed is true.</exception>
            <remarks>
            Calls <msdn>SHGetNameFromIDList</msdn>.
            </remarks>
        </member>
        <member name="M:Au.Shell.Pidl.LibToShellString(System.IntPtr,Au.Types.Native.SIGDN,System.Boolean)">
            <summary>
            The same as <see cref="M:Au.Shell.Pidl.ToShellString(Au.Types.Native.SIGDN,System.Boolean)"/>, just uses an ITEMIDLIST pointer that is not stored in a Pidl variable.
            </summary>
        </member>
        <member name="M:Au.Shell.Pidl.ToString">
            <summary>
            Converts the ITEMIDLIST to string.
            If it identifies an existing file-system object (file or directory), returns path. If URL, returns URL. Else returns ":: HexEncodedITEMIDLIST" (see <see cref="M:Au.Shell.Pidl.ToHexString"/>).
            Returns null if this variable does not have an ITEMIDLIST (eg disposed or detached).
            </summary>
        </member>
        <member name="M:Au.Shell.Pidl.LibToString(System.IntPtr)">
            <summary>
            The same as <see cref="M:Au.Shell.Pidl.ToString"/>, just uses an ITEMIDLIST pointer that is not stored in a Pidl variable.
            </summary>
        </member>
        <member name="M:Au.Shell.Pidl.ToHexString">
            <summary>
            Returns string ":: HexEncodedITEMIDLIST".
            It can be used with some functions of this library, mostly of classes Shell, Shell.Pidl and Icons. Cannot be used with native and .NET functions.
            Returns null if this variable does not have an ITEMIDLIST (eg disposed or detached).
            </summary>
        </member>
        <member name="M:Au.Shell.Pidl.LibToHexString(System.IntPtr)">
            <summary>
            The same as <see cref="M:Au.Shell.Pidl.ToHexString"/>, just uses an ITEMIDLIST pointer that is not stored in a Pidl variable.
            </summary>
        </member>
        <member name="T:Au.Shell.Shortcut">
            <summary>
            Creates shell shortcuts (.lnk files) and gets shortcut properties.
            </summary>
        </member>
        <member name="M:Au.Shell.Shortcut.Dispose">
            <summary>
            Releases internally used COM objects (IShellLink, IPersistFile).
            </summary>
        </member>
        <member name="P:Au.Shell.Shortcut.IShellLink">
            <summary>
            Returns the internally used IShellLink COM interface.
            </summary>
        </member>
        <member name="M:Au.Shell.Shortcut.Open(System.String)">
            <summary>
            Creates a new instance of the Shortcut class that can be used to get shortcut properties.
            Exception if shortcut file does not exist or cannot open it for read access.
            </summary>
            <param name="lnkPath">Shortcut file (.lnk) path.</param>
            <exception cref="T:Au.Types.AuException">Failed to open .lnk file.</exception>
        </member>
        <member name="M:Au.Shell.Shortcut.Create(System.String)">
            <summary>
            Creates a new instance of the Shortcut class that can be used to create or replace a shortcut file.
            You can set properties and finally call <see cref="M:Au.Shell.Shortcut.Save"/>.
            If the shortcut file already exists, Save replaces it.
            </summary>
            <param name="lnkPath">Shortcut file (.lnk) path.</param>
        </member>
        <member name="M:Au.Shell.Shortcut.OpenOrCreate(System.String)">
            <summary>
            Creates a new instance of the Shortcut class that can be used to create or modify a shortcut file.
            Exception if file exists but cannot open it for read-write access.
            You can get and set properties and finally call <see cref="M:Au.Shell.Shortcut.Save"/>.
            If the shortcut file already exists, Save updates it.
            </summary>
            <param name="lnkPath">Shortcut file (.lnk) path.</param>
            <exception cref="T:Au.Types.AuException">Failed to open existing .lnk file.</exception>
        </member>
        <member name="M:Au.Shell.Shortcut.Save">
            <summary>
            Saves the Shortcut variable properties to the shortcut file.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to save .lnk file.</exception>
            <remarks>
            Creates parent folder if need.
            </remarks>
        </member>
        <member name="P:Au.Shell.Shortcut.TargetPath">
            <summary>
            Gets or sets shortcut target path.
            This property is null if target isn't a file system object, eg Control Panel or URL.
            </summary>
            <remarks>The 'get' function gets path with expanded environment variables. If possible, it corrects the target of MSI shortcuts and 64-bit Program Files shortcuts where IShellLink.GetPath() lies.</remarks>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.Shell.Shortcut.TargetPathRawMSI">
            <summary>
            Gets shortcut target path and does not correct wrong MSI shortcut target.
            </summary>
        </member>
        <member name="P:Au.Shell.Shortcut.TargetPidl">
            <summary>
            Gets or sets a non-file-system target (eg Control Panel) through its ITEMIDLIST.
            </summary>
            <remarks>
            Also can be used for any target type, but gets raw value, for example MSI shortcut target is incorrect.
            Most but not all shortcuts have this property; the 'get' function returns null if the shortcut does not have it.
            </remarks>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.Shell.Shortcut.TargetURL">
            <summary>
            Gets or sets a URL target.
            Note: it is a .lnk shortcut, not a .url shortcut.
            The 'get' function returns string "file:///..." if target is a file.
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.Shell.Shortcut.TargetAnyType">
            <summary>
            Gets or sets target of any type - file/folder, URL, virtual shell object (see <see cref="T:Au.Shell.Pidl"/>).
            The string can be used with <see cref="M:Au.Shell.Run(System.String,System.String,Au.Types.SRFlags,Au.Types.SRMore)"/>.
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="M:Au.Shell.Shortcut.GetIconLocation(System.Int32@)">
            <summary>
            Gets custom icon file path and icon index.
            Returns null if the shortcut does not have a custom icon (then you see its target icon).
            </summary>
            <param name="iconIndex">Receives 0 or icon index or negative icon resource id.</param>
        </member>
        <member name="M:Au.Shell.Shortcut.SetIconLocation(System.String,System.Int32)">
            <summary>
            Sets icon file path and icon index.
            </summary>
            <param name="path"></param>
            <param name="iconIndex">0 or icon index or negative icon resource id.</param>
            <exception cref="T:Au.Types.AuException"/>
        </member>
        <member name="P:Au.Shell.Shortcut.WorkingDirectory">
            <summary>
            Gets or sets the working directory path (Start in).
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.Shell.Shortcut.Arguments">
            <summary>
            Gets or sets the command-line arguments.
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.Shell.Shortcut.Description">
            <summary>
            Gets or sets the description text (Comment).
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.Shell.Shortcut.Hotkey">
            <summary>
            Gets or sets hotkey.
            Example: <c>x.Hotkey = Keys.Control | Keys.Alt | Keys.E;</c>
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.Shell.Shortcut.ShowState">
            <summary>
            Gets or sets the window show state.
            The value can be 1 (normal, default), 2 (minimized) or 3 (maximized).
            Most programs ignore it.
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="M:Au.Shell.Shortcut.GetTarget(System.String)">
            <summary>
            Gets shortcut target path or URL or virtual shell object ITEMIDLIST.
            Uses <see cref="M:Au.Shell.Shortcut.Open(System.String)"/> and <see cref="P:Au.Shell.Shortcut.TargetAnyType"/>.
            </summary>
            <param name="lnkPath">Shortcut file (.lnk) path.</param>
            <exception cref="T:Au.Types.AuException">Failed to open.</exception>
        </member>
        <member name="M:Au.Shell.Shortcut.Delete(System.String)">
            <summary>
            If shortcut file exists, unregisters its hotkey and deletes it.
            </summary>
            <param name="lnkPath">.lnk file path.</param>
            <exception cref="T:Au.Types.AuException">Failed to unregister hotkey.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Files.Delete(System.String,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.Shell.Shortcut._UnregisterHotkey(System.String)">
            <exception cref="T:Au.Types.AuException">Failed to open or save.</exception>
        </member>
        <member name="M:Au.Shell._Normalize(System.String)">
            <summary>
            The same as <see cref="M:Au.Path_.Normalize(System.String,System.String,Au.Types.PNFlags)"/>(CanBeUrlOrShell|DoNotPrefixLongPath), but ignores non-full path (returns s).
            </summary>
            <param name="s">File-system path or URL or "::...".</param>
        </member>
        <member name="M:Au.Shell.Run(System.String,System.String,Au.Types.SRFlags,Au.Types.SRMore)">
            <summary>
            Runs/opens a program, document, directory (folder), URL, new email, Control Panel item etc.
            The returned <see cref="T:Au.Types.SRResult"/> variable contains some process info - process id etc.
            </summary>
            <param name="file">
            What to run. Can be:
            Full path of a file or directory. Examples: <c>@"C:\file.txt"</c>, <c>Folders.System + "notepad.exe"</c>, <c>@"%Folders.System%\notepad.exe"</c>.
            Filename of a file or directory, like <c>"notepad.exe"</c>. The function calls <see cref="M:Au.Files.SearchPath(System.String,System.String[])"/>.
            Path relative to <see cref="P:Au.Folders.ThisApp"/>. Examples: <c>"x.exe"</c>, <c>@"subfolder\x.exe"</c>, <c>@".\subfolder\x.exe"</c>, <c>@"..\another folder\x.exe"</c>.
            URL. Examples: <c>"http://a.b.c/d"</c>, <c>"file:///path"</c>.
            Email, like <c>"mailto:a@b.c"</c>. Subject, body etc also can be specified, and Google knows how.
            Shell object's ITEMIDLIST like <c>":: HexEncodedITEMIDLIST"</c>. See <see cref="M:Au.Shell.Pidl.ToHexString"/>, <see cref="T:Au.Folders.Virtual"/>. Can be used to open virtual folders and items like Control Panel.
            Shell object's parsing name, like <c>@"::{CLSID}"</c>. See <see cref="M:Au.Shell.Pidl.ToShellString(Au.Types.Native.SIGDN,System.Boolean)"/>, <see cref="T:Au.Folders.VirtualPidl"/>. Can be used to open virtual folders and items like Control Panel.
            To run a Windows Store App, use <c>@"shell:AppsFolder\WinStoreAppId"</c> format. Examples: <c>@"shell:AppsFolder\Microsoft.WindowsCalculator_8wekyb3d8bbwe!App"</c>, <c>@"shell:AppsFolder\windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel"</c>. To discover the string use <see cref="M:Au.Wnd.Misc.GetWindowsStoreAppId(Au.Wnd,System.Boolean,System.Boolean)"/> or Google.
            Supports environment variables, like <c>@"%TMP%\file.txt"</c>. See <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>.
            </param>
            <param name="args">
            Command line arguments.
            This function expands environment variables if starts with "%" or "\"%".
            </param>
            <param name="flags"></param>
            <param name="more">Allows to specify more parameters.</param>
            <exception cref="T:Au.Types.AuException">Failed. For example, the file does not exist.</exception>
            <remarks>
            It works like when you double-click a file icon. It may start new process or not. For example it may just activate window if the program is already running.
            Uses API <msdn>ShellExecuteEx</msdn>.
            Similar to <see cref="M:System.Diagnostics.Process.Start(System.String,System.String)"/>.
            </remarks>
            <seealso cref="M:Au.Wnd.FindOrRun(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object,System.Action,System.Double,System.Boolean)"/>
            <example>
            Run notepad and wait for its window.
            <code><![CDATA[
            Shell.Run("notepad.exe");
            Wnd w = Wnd.Wait(10, true, "*- Notepad", "Notepad");
            ]]></code>
            Run notepad or activate its window.
            <code><![CDATA[
            Wnd w = Wnd.FindOrRun("*- Notepad", run: () => Shell.Run("notepad.exe"));
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Shell.TryRun(System.String,System.String,Au.Types.SRFlags,Au.Types.SRMore)">
            <summary>
            Calls <see cref="M:Au.Shell.Run(System.String,System.String,Au.Types.SRFlags,Au.Types.SRMore)"/> and handles exceptions. All parameters are the same.
            If <b>Run</b> throws exception, prints it as warning and returns null.
            </summary>
            <remarks>
            This is useful when you don't care whether <b>Run</b> succeeded and don't want to use try/catch.
            Handles only exception of type AuException. It is thrown when fails, usually when the file does not exist.
            </remarks>
            <seealso cref="M:Au.NoClass.PrintWarning(System.String,System.Int32,System.String)"/>
            <seealso cref="M:Au.Types.OptDebug.DisableWarnings(System.String[])"/>
            <seealso cref="M:Au.Wnd.FindOrRun(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object,System.Action,System.Double,System.Boolean)"/>
        </member>
        <member name="M:Au.Shell.RunConsole(System.String@,System.String,System.String,System.String,System.Text.Encoding)">
            <summary>
            Runs a console program, waits until its process ends, and gets its output text.
            Returns the process exit code. Usually a non-0 value means error.
            </summary>
            <param name="output">
            Receives the output text.
            Console programs have two output text streams - standard output and standard error. This function gets both, and the error text is always after the output text.
            </param>
            <param name="file">
            Path or name of an .exe or .bat file. Can be:
            Full path. Examples: <c>@"C:\folder\x.exe"</c>, <c>Folders.System + "x.exe"</c>, <c>@"%Folders.System%\x.exe"</c>.
            Filename, like <c>"x.exe"</c>. The function calls <see cref="M:Au.Files.SearchPath(System.String,System.String[])"/>.
            Path relative to <see cref="P:Au.Folders.ThisApp"/>. Examples: <c>"x.exe"</c>, <c>@"subfolder\x.exe"</c>, <c>@".\subfolder\x.exe"</c>, <c>@"..\another folder\x.exe"</c>.
            Supports environment variables, like <c>@"%TMP%\x.bat"</c>. See <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>.
            </param>
            <param name="args">
            Command line arguments.
            This function expands environment variables if starts with "%" or "\"%".
            </param>
            <param name="directory">Working directory. Default - <see cref="M:System.IO.Directory.GetCurrentDirectory"/> of this process.</param>
            <param name="textEncoding">Text encoding used to convert console's ANSI text to C# Unicode text.</param>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed, for example file not found.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.Diagnostics.Process.Start"/>, <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)"/>, <see cref="M:System.IO.StreamReader.ReadToEnd"/>.</exception>
            <remarks>
            Does not show the console window.
            Uses <see cref="M:System.Diagnostics.Process.Start"/>. Does not use Windows shell API.
            See also <see cref="M:Au.Shell.Run(System.String,System.String,Au.Types.SRFlags,Au.Types.SRMore)"/>.
            </remarks>
        </member>
        <member name="M:Au.Shell.RunConsole(System.String,System.String,System.String,System.Text.Encoding)">
            <summary>
            Runs a console program (hidden), waits until its process ends, and prints its output text.
            Calls <see cref="M:Au.Shell.RunConsole(System.String@,System.String,System.String,System.String,System.Text.Encoding)"/> and <see cref="M:Au.NoClass.Print(System.String)" r=""/>.
            </summary>
            <param name="file"></param>
            <param name="args"></param>
            <param name="directory"></param>
            <param name="textEncoding"></param>
        </member>
        <member name="M:Au.Shell.SelectFileInExplorer(System.String)">
            <summary>
            Opens parent folder in Explorer and selects the file.
            Returns null if fails, for example if the file does not exist.
            </summary>
            <param name="path">
            Full path of a file or directory or other shell object.
            Supports @"%environmentVariable%\..." (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>) and "::..." (see <see cref="M:Au.Shell.Pidl.ToHexString"/>).
            </param>
        </member>
        <member name="T:Au.Path_">
            <summary>
            Extends <see cref="T:System.IO.Path"/>.
            </summary>
        </member>
        <member name="M:Au.Path_.ExpandEnvVar(System.String)">
             <summary>
             If path starts with "%" or "\"%", expands environment variables enclosed in %, else just returns path.
             Also supports known folder names, like "%Folders.Documents%". More info in Remarks.
             </summary>
             <param name="path">Any string. Can be null.</param>
             <remarks>
             Supports known folder names as you can get with <see cref="T:Au.Folders"/> class properties.
             Example: @"%Folders.Documents%\file.txt".
             Example: @"%Folders.Virtual.ControlPanel%" //gets ":: HexEncodedITEMIDLIST".
             Usually known folders are used like <c>string path = Folders.Documents + "file.txt"</c>. It's easier and faster. However it cannot be used when you want to store paths in text files, registry, etc. Then this feature is useful.
             To get known folder path, this function calls <see cref="M:Au.Folders.GetFolder(System.String)"/>.
            
             This function is called by many functions of classes Path_, Files, Shell, Icons, some others, therefore all they support environment variables and known folders in path string.
             </remarks>
        </member>
        <member name="M:Au.Path_.LibGetEnvVar(System.String)">
            <summary>
            Gets environment variable's value.
            Returns "" if variable not found.
            Does not support Folders.X.
            </summary>
            <param name="name">Case-insensitive name. Without %.</param>
            <remarks>
            Environment variable values cannot be "" or null. Setting empty value removes the variable.
            </remarks>
        </member>
        <member name="M:Au.Path_.LibEnvVarExists(System.String)">
            <summary>
            Returns true if environment variable exists.
            </summary>
            <param name="name">Case-insensitive name.</param>
            <returns></returns>
        </member>
        <member name="M:Au.Path_.IsFullPath(System.String)">
            <summary>
            Returns true if the string is full path, like @"C:\a\b.txt" or @"C:" or @"\\server\share\...":
            </summary>
            <param name="path">Any string. Can be null.</param>
            <remarks>
            Returns true if <paramref name="path"/> matches one of these wildcard patterns:
            <list type="bullet">
            <item>@"?:\*" - local path, like @"C:\a\b.txt". Here ? is A-Z, a-z.</item>
            <item>@"?:" - drive name, like @"C:". Here ? is A-Z, a-z.</item>
            <item>@"\\*" - network path, like @"\\server\share\...". Or has prefix @"\\?\".</item>
            </list>
            Supports '/' characters too.
            Supports only file-system paths. Returns false if path is URL (<see cref="M:Au.Path_.IsUrl(System.String)"/>) or starts with "::".
            If path starts with "%environmentVariable%", shows warning and returns false. You should at first expand environment variables with <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/> or instead use <see cref="M:Au.Path_.IsFullPathExpandEnvVar(System.String@)"/>.
            </remarks>
        </member>
        <member name="M:Au.Path_.IsFullPathExpandEnvVar(System.String@)">
            <summary>
            Expands environment variables and calls <see cref="M:Au.Path_.IsFullPath(System.String)"/>.
            Returns true if the string is full path, like @"C:\a\b.txt" or @"C:" or @"\\server\share\...":
            </summary>
            <param name="path">
            Any string. Can be null.
            If starts with '%' character, calls <see cref="M:Au.Path_.IsFullPath(System.String)"/> with expanded environment variables (<see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>). If it returns true, replaces the passed variable with the expanded path string.
            </param>
            <remarks>
            Returns true if <paramref name="path"/> matches one of these wildcard patterns:
            <list type="bullet">
            <item>@"?:\*" - local path, like @"C:\a\b.txt". Here ? is A-Z, a-z.</item>
            <item>@"?:" - drive name, like @"C:". Here ? is A-Z, a-z.</item>
            <item>@"\\*" - network path, like @"\\server\share\...". Or has prefix @"\\?\".</item>
            </list>
            Supports '/' characters too.
            Supports only file-system paths. Returns false if path is URL (<see cref="M:Au.Path_.IsUrl(System.String)"/>) or starts with "::".
            </remarks>
        </member>
        <member name="M:Au.Path_.GetRootLength(System.String)">
            <summary>
            Gets the length of the drive or network folder part in path, including its separator if any.
            If the string does not start with a drive or network folder path, returns 0 or prefix length (@"\\?\" or @"\\?\UNC\").
            </summary>
            <param name="path">Full path or any string. Can be null. Should not be "%environmentVariable%\...".</param>
            <remarks>
            Supports prefixes @"\\?\" and @"\\?\UNC\".
            Supports separators '\\' and '/'.
            </remarks>
        </member>
        <member name="M:Au.Path_.GetUrlProtocolLength(System.String)">
            <summary>
            Gets the length of the URL protocol name (also known as URI scheme) in string, including ':'.
            If the string does not start with a protocol name, returns 0.
            URL examples: "http:" (returns 5), "http://www.x.com" (returns 5), "file:///path" (returns 5), "shell:etc" (returns 6).
            The protocol can be unknown, the function just checks string format, which is an ASCII alpha character followed by one or more ASCII alpha-numeric, '.', '-', '+' characters, followed by ':' character.
            </summary>
            <param name="s">A URL or path or any string. Can be null.</param>
        </member>
        <member name="M:Au.Path_.IsUrl(System.String)">
            <summary>
            Returns true if the string starts with a URL protocol name (existing or not) and ':' character.
            URL examples: "http:", "http://www.x.com", "file:///path", "shell:etc".
            Calls <see cref="M:Au.Path_.GetUrlProtocolLength(System.String)"/> and returns true if it's not 0.
            </summary>
            <param name="s">A URL or path or any string. Can be null.</param>
        </member>
        <member name="M:Au.Path_.Combine(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Combines two path parts using character '\\'. For example directory path and file name.
            </summary>
            <param name="s1">First part. Usually a directory.</param>
            <param name="s2">Second part. Usually a filename or relative path.</param>
            <param name="s2CanBeFullPath">s2 can be full path. If it is, ignore s1 and return s2 with expanded environment variables. If false (default), simply combines s1 and s2.</param>
            <param name="prefixLongPath">Call <see cref="M:Au.Path_.PrefixLongPathIfNeed(System.String)"/> which may prepend @"\\?\" if the result path is very long. Default true.</param>
            <remarks>
            If s1 and s2 are null or "", returns "". Else if s1 is null or "", returns s2. Else if s2 is null or "", returns s1.
            Similar to System.IO.Path.Combine. Main differences: does not throw exceptions; has some options.
            Does not expand environment variables. For it use <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/> before, or <see cref="M:Au.Path_.Normalize(System.String,System.String,Au.Types.PNFlags)"/> instead. Path that starts with an environment variable is considerd not full path.
            </remarks>
            <seealso cref="M:Au.Path_.Normalize(System.String,System.String,Au.Types.PNFlags)"/>
        </member>
        <member name="M:Au.Path_.LibCombine(System.String,System.String,System.Boolean)">
            <summary>
            Combines two path parts.
            Unlike <see cref="M:Au.Path_.Combine(System.String,System.String,System.Boolean,System.Boolean)"/>, fails if some part is empty or @"\" or if s2 is @"\\". Also does not check s2 full path.
            If fails, throws exception or returns null (if noException).
            </summary>
        </member>
        <member name="M:Au.Path_.LibIsSepChar(System.Char)">
            <summary>
            Returns true if character c == '\\' || c == '/'.
            </summary>
        </member>
        <member name="M:Au.Path_._EndsWithDriveWithoutSep(System.String,System.Int32)">
            <summary>
            Returns true if ends with ':' preceded by a drive letter, like "C:" or "more\C:", but not like "moreC:".
            </summary>
            <param name="s">Can be null.</param>
            <param name="length">Use when want to check drive at a middle, not at the end. Eg returns true if s is @"C:\more" and length is 2.</param>
        </member>
        <member name="M:Au.Path_._AddRemoveSep(System.String)">
            <summary>
            Ensures that s either ends with a valid drive path (eg @"C:\" but not "C:") or does not end with '\\' or '/' (unless would become empty if removed).
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="M:Au.Path_.Normalize(System.String,System.String,Au.Types.PNFlags)">
            <summary>
            Makes normal full path from path that can contain special substrings etc.
            The sequence of actions:
            1. If path starts with '%' character, expands environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>).
            2. If path is not full path but looks like URL, and used flag CanBeUrl, returns path.
            3. If path is not full path, and defaultParentDirectory is not null/"", combines path with ExpandEnvVar(defaultParentDirectory).
            4. If path is not full path, throws exception.
            5. Calls API <msdn>GetFullPathName</msdn>. It replaces '/' with '\\', replaces multiple '\\' to single (where need), processes @"\.." etc, trims spaces, etc.
            6. If no flag DoNotExpandDosPath, if looks like a DOS path (contains '~' etc), calls API <msdn>GetLongPathName</msdn>. It converts short DOS path to normal path, if possible, for example @"c:\progra~1" to @"c:\program files". It is slow. It converts path only if the file exists.
            7. If no flag DoNotRemoveEndSeparator, removes '\\' character at the end, unless it is a drive path (eg @"C:\").
            8. Appends '\\' character if ends with a drive name (eg "C:" -> @"C:\").
            9. If no flag DoNotPrefixLongPath, calls <see cref="M:Au.Path_.PrefixLongPathIfNeed(System.String)"/>, which adds @"\\?\" etc prefix if path is very long.
            </summary>
            <param name="path">Any path.</param>
            <param name="defaultParentDirectory">If path is not full path, combine it with defaultParentDirectory to make full path.</param>
            <param name="flags"></param>
            <exception cref="T:System.ArgumentException">path is not full path, and <paramref name="defaultParentDirectory"/> is not used or does not make it full path.</exception>
            <remarks>
            Similar to <see cref="M:System.IO.Path.GetFullPath(System.String)"/>. Main differences: this function expands environment variables, does not support relative paths, supports @"\\?\very long path", trims '\\' at the end if need, does not throw exceptions when [it thinks that] path is invalid (except when path is not full).
            </remarks>
        </member>
        <member name="M:Au.Path_.LibNormalize(System.String,Au.Types.PNFlags,System.Boolean)">
            <summary>
            Same as <see cref="M:Au.Path_.Normalize(System.String,System.String,Au.Types.PNFlags)"/>, but skips full-path checking.
            s should be full path. If not full and not null/"", combines with current directory.
            </summary>
        </member>
        <member name="M:Au.Path_.LibExpandDosPath(System.String)">
            <summary>
            Calls API GetLongPathName.
            Does not check whether s contains '~' character etc. Note: the API is slow.
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="M:Au.Path_.LibIsPossiblyDos(System.String)">
            <summary>
            Returns true if pathOrFilename looks like a DOS filename or path.
            Examples: "abcde~12", "abcde~12.txt", @"c:\path\abcde~12.txt", "c:\abcde~12\path".
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="M:Au.Path_.LibNormalizeMinimally(System.String,System.Boolean)">
            <summary>
            Prepares path for passing to API that support "..", DOS path etc.
            Calls ExpandEnvVar, _AddRemoveSep, PrefixLongPathIfNeed. Optionally throws if !IsFullPath(path).
            </summary>
            <exception cref="T:System.ArgumentException">Not full path (only if throwIfNotFullPath is true).</exception>
        </member>
        <member name="M:Au.Path_.LibIsShellPath(System.String)">
            <summary>
            Returns true if starts with "::".
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="M:Au.Path_.PrefixLongPath(System.String)">
            <summary>
            If path is full path (see <see cref="M:Au.Path_.IsFullPath(System.String)"/>) and does not start with @"\\?\", prepends @"\\?\".
            If path is network path (like @"\\computer\folder\..."), makes like @"\\?\UNC\computer\folder\...".
            </summary>
            <param name="path">
            Path. Can be null.
            Must not start with "%environmentVariable%", this function does not expand it. See <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>.
            </param>
            <remarks>
            Windows API kernel functions support extended-length paths, ie longer than 259 characters. But the path must have this prefix. Windows API shell functions don't support it.
            </remarks>
        </member>
        <member name="M:Au.Path_.PrefixLongPathIfNeed(System.String)">
            <summary>
            Calls <see cref="M:Au.Path_.PrefixLongPath(System.String)"/> if path is longer than <see cref="F:Au.Path_.MaxDirectoryPathLength"/> (247).
            </summary>
            <param name="path">
            Path. Can be null.
            Must not start with "%environmentVariable%", this function does not expand it. See <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>.
            </param>
        </member>
        <member name="M:Au.Path_.UnprefixLongPath(System.String)">
            <summary>
            If path starts with @"\\?\" prefix, removes it.
            If path starts with @"\\?\UNC\" prefix, removes @"?\UNC\".
            </summary>
            <param name="path">
            Path. Can be null.
            Must not start with "%environmentVariable%", this function does not expand it. See <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>.
            </param>
        </member>
        <member name="M:Au.Path_._GetPrefixLength(System.String)">
            <summary>
            If s starts with @"\\?\UNC\", returns 8.
            Else if starts with @"\\?\", returns 4.
            Else returns 0.
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="F:Au.Path_.MaxFilePathLength">
            <summary>
            Maximal file (not directory) path length supported by all functions (native, .NET and this library).
            For longer paths need @"\\?\" prefix. It is supported by most native kernel API (but not shell API) and by most functions of this library.
            </summary>
        </member>
        <member name="F:Au.Path_.MaxDirectoryPathLength">
            <summary>
            Maximal directory path length supported by all functions (native, .NET and this library).
            For longer paths need @"\\?\" prefix. It is supported by most native kernel API (but not shell API) and by most functions of this library.
            </summary>
        </member>
        <member name="M:Au.Path_.CorrectFileName(System.String,System.String)">
            <summary>
            Replaces characters that cannot be used in file names.
            Also corrects other forms of invalid or problematic filename: trims spaces and other blank characters; replaces "." at the end; prepends "@" if a reserved name like "CON" or "CON.txt"; returns "-" if name is null/empty/whitespace.
            Returns valid filename. However it can be too long (itself or when combined with a directory path).
            </summary>
            <param name="name">Initial filename.</param>
            <param name="invalidCharReplacement">A string that will replace each invalid character. Default "-".</param>
        </member>
        <member name="M:Au.Path_.IsInvalidFileName(System.String)">
            <summary>
            Returns true if name cannot be used for a file name, eg contains '\\' etc characters or is empty.
            More info: <see cref="M:Au.Path_.CorrectFileName(System.String,System.String)"/>.
            </summary>
            <param name="name">Any string. Example: "name.txt". Can be null.</param>
        </member>
        <member name="M:Au.Path_.GetFileName(System.String)">
            <summary>
            Gets filename with extension.
            Returns "" if there is no filename.
            Returns null if path is null.
            </summary>
            <param name="path">Path or filename. Can be null.</param>
            <remarks>
            Similar to <see cref="M:System.IO.Path.GetFileName(System.String)"/>. Some diferences: does not throw exceptions; if ends with '\\' or '/', gets part before it, eg "B" from @"C:\A\B\".
            Supports separators '\\' and '/'.
            Also supports URL and shell parsing names like @"::{CLSID-1}\0\::{CLSID-2}".
            Example paths and results:
            <code>
            @"C:\A\B\file.txt" -> "file.txt".
            "file.txt" -> "file.txt".
            "file" -> "file".
            @"C:\A\B" -> "B".
            @"C:\A\B\" -> "B".
            @"C:\A\/B\/" -> "B".
            @"C:\" -> "".
            @"C:" -> "".
            @"\\network\share" -> "share".
            @"C:\aa\file.txt:alt.stream" -> "file.txt:alt.stream".
            "http://a.b.c" -> "a.b.c".
            "::{A}\::{B}" -> "::{B}".
            "" -> "".
            null -> null.
            </code>
            </remarks>
        </member>
        <member name="M:Au.Path_.GetFileNameWithoutExtension(System.String)">
            <summary>
            Gets filename without extension.
            Returns "" if there is no filename.
            Returns null if path is null.
            </summary>
            <param name="path">Path or filename. Can be null.</param>
            <remarks>
            Similar to <see cref="M:System.IO.Path.GetFileNameWithoutExtension(System.String)"/> Some diferences: does not throw exceptions; if ends with '\\' or '/', gets part before it, eg "B" from @"C:\A\B\" (then does not remove extension from it because it is a directory name).
            Supports separators '\\' and '/'.
            Also supports URL and shell parsing names like @"::{CLSID-1}\0\::{CLSID-2}".
            Example paths and results:
            <code>
            @"C:\A\B\file.txt" -> "file".
            "file.txt" -> "file".
            "file" -> "file".
            @"C:\A\B" -> "B".
            @"C:\A\B\" -> "B".
            @"C:\A\B.B\" -> "B.B".
            @"C:\" -> "".
            @"C:" -> "".
            @"\\network\share" -> "share".
            @"C:\aa\file.txt:alt.stream" -> "file.txt:alt".
            "http://a.b.c" -> "a.b".
            "::{A}\::{B}" -> "::{B}".
            "" -> "".
            null -> null.
            </code>
            </remarks>
        </member>
        <member name="M:Au.Path_.GetExtension(System.String)">
            <summary>
            Gets filename extension, like ".txt".
            Returns "" if there is no extension.
            Returns null if path is null.
            </summary>
            <param name="path">Path or filename. Can be null.</param>
            <remarks>
            Supports separators '\\' and '/'.
            Like <see cref="M:System.IO.Path.GetExtension(System.String)"/>, but does not throw exceptions.
            </remarks>
        </member>
        <member name="M:Au.Path_.GetExtension(System.String,System.String@)">
            <summary>
            Gets filename extension and path part without the extension.
            More info: <see cref="M:Au.Path_.GetExtension(System.String)"/>.
            </summary>
            <param name="path">Path or filename. Can be null.</param>
            <param name="pathWithoutExtension">Receives path part without the extension. Can be the same variable as path.</param>
        </member>
        <member name="M:Au.Path_.FindExtension(System.String)">
            <summary>
            Finds filename extension, like ".txt".
            Returns '.' character index, or -1 if there is no extension.
            </summary>
            <param name="path">Path or filename. Can be null.</param>
            <remarks>
            Returns -1 if '.' is before '\\' or '/'.
            </remarks>
        </member>
        <member name="M:Au.Path_.GetDirectoryPath(System.String,System.Boolean)">
            <summary>
            Removes filename part from path. By default also removes separator ('\\' or '/') if it is not after drive name (eg "C:").
            Returns "" if the string is a filename.
            Returns null if the string is null or a root (like @"C:\" or "C:" or @"\\server\share" or "http:").
            </summary>
            <param name="path">Path or filename. Can be null.</param>
            <param name="withSeparator">
            Don't remove the separator character(s) ('\\' or '/').
            Examples: from @"C:\A\B" gets @"C:\A\", not @"C:\A"; from "http://x.y" gets "http://", not "http:".</param>
            <remarks>
            Similar to <see cref="M:System.IO.Path.GetDirectoryName(System.String)"/>. Some diferences: does not throw exceptions; skips '\\' or '/' at the end (eg from @"C:\A\B\" gets @"C:\A", not @"C:\A\B"); does not expand DOS path; much faster.
            Parses raw string. You may want to <see cref="M:Au.Path_.Normalize(System.String,System.String,Au.Types.PNFlags)"/> it at first.
            Supports separators '\\' and '/'.
            Also supports URL and shell parsing names like @"::{CLSID-1}\0\::{CLSID-2}".
            Example paths and results (withSeparator=false):
            <code>
            @"C:\A\B\file.txt" -> @"C:\A\B".
            "file.txt" -> "".
            @"C:\A\B\" -> @"C:\A".
            @"C:\A\/B\/" -> @"C:\A".
            @"C:\" -> null.
            @"\\network\share" -> null.
            "http:" -> null.
            @"C:\aa\file.txt:alt.stream" -> "C:\aa".
            "http://a.b.c" -> "http:".
            "::{A}\::{B}" -> "::{A}".
            "" -> "".
            null -> null.
            </code>
            </remarks>
        </member>
        <member name="M:Au.Path_.LibIsExtension(System.String)">
            <summary>
            Returns true if s is like ".ext" and the ext part does not contain characters ".\\/:".
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="M:Au.Path_.LibIsProtocol(System.String)">
            <summary>
            Returns true if s is like "protocol:" and not like "c:" or "protocol:more".
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="M:Au.Path_.MakeUnique(System.String,System.Boolean)">
            <summary>
            Gets path with unique filename for a new file or directory. 
            If the specified path is of an existing file or directory, returns path where the filename part is modified like "file 2.txt", "file 3.txt" etc. Else returns unchanged path.
            </summary>
            <param name="path">Suggested full path.</param>
            <param name="isDirectory">The path is for a directory. The number is always appended at the very end, not before .extension.</param>
        </member>
        <member name="T:Au.Ver">
            <summary>
            Provides various version info, for example the true Windows OS version.
            </summary>
            <remarks>
            The Windows version properties return true Windows version. If you need version that depends on manifest and debugger, instead use <see cref="P:System.Environment.OSVersion"/>.
            </remarks>
        </member>
        <member name="P:Au.Ver.WinVer">
            <summary>
            Gets classic Windows major+minor version value:
            Win7 (0x601), Win8 (0x602), Win8_1 (0x603), Win10 (0xA00).
            Example: <c>if(Ver.WinVer >= Ver.Win8) ...</c>
            </summary>
        </member>
        <member name="F:Au.Ver.Win7">
            <summary>
            Classic Windows version major+minor values that can be used with <see cref="P:Au.Ver.WinVer"/>.
            Example: <c>if(Ver.WinVer >= Ver.Win8) ...</c>
            </summary>
        </member>
        <member name="F:Au.Ver.Win8">
            <summary>
            Classic Windows version major+minor values that can be used with <see cref="P:Au.Ver.WinVer"/>.
            Example: <c>if(Ver.WinVer >= Ver.Win8) ...</c>
            </summary>
        </member>
        <member name="F:Au.Ver.Win8_1">
            <summary>
            Classic Windows version major+minor values that can be used with <see cref="P:Au.Ver.WinVer"/>.
            Example: <c>if(Ver.WinVer >= Ver.Win8) ...</c>
            </summary>
        </member>
        <member name="F:Au.Ver.Win10">
            <summary>
            Classic Windows version major+minor values that can be used with <see cref="P:Au.Ver.WinVer"/>.
            Example: <c>if(Ver.WinVer >= Ver.Win8) ...</c>
            </summary>
        </member>
        <member name="P:Au.Ver.MinWin8">
            <summary>
            true if Windows 8.0 or later.
            </summary>
        </member>
        <member name="P:Au.Ver.MinWin8_1">
            <summary>
            true if Windows 8.1 or later.
            </summary>
        </member>
        <member name="P:Au.Ver.MinWin10">
            <summary>
            true if Windows 10 or later.
            </summary>
        </member>
        <member name="P:Au.Ver.Is64BitProcess">
            <summary>
            true if this process is 64-bit, false if 32-bit.
            The same as <see cref="P:System.Environment.Is64BitProcess"/>.
            </summary>
        </member>
        <member name="P:Au.Ver.Is64BitOS">
            <summary>
            true if Windows is 64-bit, false if 32-bit.
            The same as <see cref="P:System.Environment.Is64BitOperatingSystem"/>, but fast. The .NET function is slow in 32-bit process; they forgot to optimize it.
            </summary>
        </member>
        <member name="P:Au.Ver.Is32BitProcessOn64BitOS">
            <summary>
            Returns true if this process is a 32-bit process running on 64-bit Windows. Also known as WOW64 process.
            </summary>
        </member>
        <member name="T:Au.Math_">
            <summary>
            Simple calculation functions.
            </summary>
        </member>
        <member name="M:Au.Math_.MakeUint(System.UInt32,System.UInt32)">
            <summary>
            Creates uint by placing (ushort)loWord in bits 1-16 and (ushort)hiWord in bits 17-32.
            Like C macro MAKELONG, MAKEWPARAM, MAKELPARAM, MAKELRESULT.
            </summary>
        </member>
        <member name="M:Au.Math_.MakeUint(System.Int32,System.Int32)">
            <summary>
            Creates uint by placing (ushort)loWord in bits 1-16 and (ushort)hiWord in bits 17-32.
            Like C macro MAKELONG, MAKEWPARAM, MAKELPARAM, MAKELRESULT.
            </summary>
        </member>
        <member name="M:Au.Math_.MakeUshort(System.UInt32,System.UInt32)">
            <summary>
            Creates ushort by placing (byte)loByte in bits 1-8 and (byte)hiByte in bits 9-16.
            Like C macro MAKEWORD.
            </summary>
        </member>
        <member name="M:Au.Math_.MakeUshort(System.Int32,System.Int32)">
            <summary>
            Creates ushort by placing (byte)loByte in bits 1-8 and (byte)hiByte in bits 9-16.
            Like C macro MAKEWORD.
            </summary>
        </member>
        <member name="M:Au.Math_.LoUshort(Au.Types.LPARAM)">
            <summary>
            Gets bits 1-16 as ushort.
            Like C macro LOWORD.
            </summary>
            <remarks>
            The parameter is interpreted as uint. Its declared type is LPARAM because it allows to avoid explicit casting from other integer types and IntPtr (casting from IntPtr to uint could throw OverflowException).
            </remarks>
        </member>
        <member name="M:Au.Math_.HiUshort(Au.Types.LPARAM)">
            <summary>
            Gets bits 17-32 as ushort.
            Like C macro HIWORD.
            </summary>
            <remarks>
            The parameter is interpreted as uint. Its declared type is LPARAM because it allows to avoid explicit casting from other integer types and IntPtr (casting from IntPtr to uint could throw OverflowException).
            </remarks>
        </member>
        <member name="M:Au.Math_.LoShort(Au.Types.LPARAM)">
            <summary>
            Gets bits 1-16 as short.
            Like C macro GET_X_LPARAM.
            </summary>
            <remarks>
            The parameter is interpreted as uint. Its declared type is LPARAM because it allows to avoid explicit casting from other integer types and IntPtr (casting from IntPtr to uint could throw OverflowException).
            </remarks>
        </member>
        <member name="M:Au.Math_.HiShort(Au.Types.LPARAM)">
            <summary>
            Gets bits 17-32 as short.
            Like C macro GET_Y_LPARAM.
            </summary>
            <remarks>
            The parameter is interpreted as uint. Its declared type is LPARAM because it allows to avoid explicit casting from other integer types and IntPtr (casting from IntPtr to uint could throw OverflowException).
            </remarks>
        </member>
        <member name="M:Au.Math_.LoByte(System.UInt16)">
            <summary>
            Gets bits 1-8 as byte.
            Like C macro LOBYTE.
            </summary>
        </member>
        <member name="M:Au.Math_.HiByte(System.UInt16)">
            <summary>
            Gets bits 9-16 as byte.
            Like C macro HIBYTE.
            </summary>
        </member>
        <member name="M:Au.Math_.MulDiv(System.Int32,System.Int32,System.Int32)">
            <summary>
            Multiplies number and numerator without overflow, and divides by denominator.
            The return value is rounded up or down to the nearest integer.
            If either an overflow occurred or denominator was 0, the return value is –1.
            </summary>
        </member>
        <member name="M:Au.Math_.Percent(System.Int32,System.Int32)">
            <summary>
            Returns percent of part in whole.
            </summary>
        </member>
        <member name="M:Au.Math_.Percent(System.Double,System.Double)">
            <summary>
            Returns percent of part in whole.
            </summary>
        </member>
        <member name="M:Au.Math_.AlignUp(System.UInt32,System.UInt32)">
            <summary>
            If value is divisible by alignment, returns value. Else returns nearest bigger number that is divisible by alignment.
            </summary>
            <param name="value">An integer value.</param>
            <param name="alignment">Alignment. Must be a power of two (2, 4, 8, 16...).</param>
            <remarks>For example if alignment is 4, returns 4 if value is 1-4, returns 8 if value is 5-8, returns 12 if value is 9-10, and so on.</remarks>
        </member>
        <member name="M:Au.Math_.AlignUp(System.Int32,System.UInt32)">
            <summary>
            If value is divisible by alignment, returns value. Else returns nearest bigger number that is divisible by alignment.
            </summary>
            <param name="value">An integer value.</param>
            <param name="alignment">Alignment. Must be a power of two (2, 4, 8, 16...).</param>
            <remarks>For example if alignment is 4, returns 4 if value is 1-4, returns 8 if value is 5-8, returns 12 if value is 9-10, and so on.</remarks>
        </member>
        <member name="M:Au.Math_.MinMax(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns value but not less than min and not greater than max.
            If value is less than min, returns min.
            If value is greater than max, returns max.
            </summary>
        </member>
        <member name="M:Au.Math_.Swap``1(``0@,``0@)">
            <summary>
            Swaps values of variables a and b: <c>T t = a; a = b; b = t;</c>
            </summary>
        </member>
        <member name="M:Au.Math_.AngleFromXY(System.Int32,System.Int32)">
            <summary>
            Calculates angle degrees from coordinates x and y.
            </summary>
        </member>
        <member name="M:Au.Math_.SetFlag``1(``0@,``0,System.Boolean)">
            <summary>
            Adds or removes an enum flag.
            </summary>
            <typeparam name="T">enum. Must be of size 4 (default).</typeparam>
            <param name="enumVariable">Enum variable to modify.</param>
            <param name="flag">One or more flags to add or remove.</param>
            <param name="add">If true, adds flag to enumVariable, else removes flag from enumVariable.</param>
        </member>
        <member name="T:Au.NamespaceDoc">
            <summary>
            This namespace contains main classes of this library.
            </summary>
        </member>
        <member name="T:Au.Folders">
             <summary>
             Gets known/special folder paths (Desktop, Temp, etc).
             </summary>
             <remarks>
             For return values is used type <see cref="T:Au.Folders.FolderPath"/>, not string. It is implicitly convertible to string. Its operator + appends a filename or relative path string, with @"\" separator if need. Example: <c>string s = Folders.Desktop + "file.txt"; //C:\Users\Name\Desktop\file.txt</c>
             If a function cannot get folder path, the return value contains null string. Then the + operator would throw AuException.
            
             Some folders are known only on newer Windows versions or only on some computers. Some property-get functions have a suffix like "_Win8" which means that the folder is unavailable on older Windows.
             Some known folders, although supported and registerd, may be still not created.
             
             Some folders are virtual, for example Control Panel. They don't have a file system path, but can be identified by an unmanaged array called "ITEMIDLIST" or "PIDL". Functions of the nested class <see cref="T:Au.Folders.VirtualPidl"/> return it as <see cref="T:Au.Shell.Pidl"/>. Functions of the nested class <see cref="T:Au.Folders.Virtual"/> return it as string <c>":: HexEncodedITEMIDLIST"</c> that can be used with some functions of this library (of classes Shell, Shell.Pidl, Icons) but not with .NET or native functions.
            
             Most functions use Windows "Known Folders" API, such as <msdn>SHGetKnownFolderPath</msdn>.
             The list of Windows predefined known folders: <msdn>KNOWNFOLDERID</msdn>.
             Names of folders specific to this application have "This" prefix, like ThisApp.
             
             Some paths depend on the bitness (32 or 64 bit) of the OS and this process.
             The example paths below are for English versions of Windows on most computers.
             <list type="definition">
             <item>
             <term>32-bit Windows</term>
             <description>
             System, SystemX86, SystemX64: <c>@"C:\WINDOWS\system32"</c>
             ProgramFiles, ProgramFilesX86, ProgramFilesX64: <c>@"C:\Program Files"</c>
             ProgramFilesCommon, ProgramFilesCommonX86, ProgramFilesCommonX64: <c>@"C:\Program Files\Common Files"</c>
             </description>
             </item>
             <item>
             <term>64-bit Windows, 64-bit process</term>
             <description>
             System, SystemX64: <c>@"C:\WINDOWS\system32"</c>
             SystemX86: <c>@"C:\WINDOWS\SysWOW64"</c>
             ProgramFiles, ProgramFilesX64: <c>@"C:\Program Files"</c>
             ProgramFilesX86: <c>@"C:\Program Files (x86)"</c>
             ProgramFilesCommon, ProgramFilesCommonX64: <c>@"C:\Program Files\Common Files"</c>
             ProgramFilesCommonX86: <c>@"C:\Program Files (x86)\Common Files"</c>
             </description>
             </item>
             <item>
             <term>64-bit Windows, 32-bit process</term>
             <description>
             System: <c>@"C:\WINDOWS\system32"</c>. However the OS in most cases redirects this path to <c>@"C:\WINDOWS\SysWOW64"</c>.
             SystemX86: <c>@"C:\WINDOWS\SysWOW64"</c>
             SystemX64: <c>@"C:\WINDOWS\Sysnative"</c>. The OS redirects it to the true <c>@"C:\WINDOWS\system32"</c>. It is a special path that you don't see in Explorer.
             ProgramFiles, ProgramFilesX86: <c>@"C:\Program Files (x86)"</c>
             ProgramFilesX64: <c>@"C:\Program Files"</c>
             ProgramFilesCommon, ProgramFilesCommonX86: <c>@"C:\Program Files (x86)\Common Files"</c>
             ProgramFilesCommonX64: <c>@"C:\Program Files\Common Files"</c>
             </description>
             </item>
             </list>
             </remarks>
        </member>
        <member name="P:Au.Folders.ProgramFiles">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.Folders.ProgramFilesX86">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.Folders.ProgramFilesCommon">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.Folders.ProgramFilesCommonX86">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.Folders.System">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.Folders.SystemX86">
            <summary>More info in class help.</summary>
        </member>
        <member name="T:Au.Folders.Virtual">
            <summary>
            Gets ITEMIDLIST of known/special virtual folders (eg Control Panel), as string like ":: 12345678...". 
            </summary>
        </member>
        <member name="T:Au.Folders.VirtualPidl">
            <summary>
            Gets ITEMIDLIST of known/special virtual folders (eg Control Panel), as <see cref="T:Au.Shell.Pidl"/>. 
            </summary>
        </member>
        <member name="P:Au.Folders.Temp">
            <summary>
            Temp folder (temporary files) of this user account.
            </summary>
        </member>
        <member name="P:Au.Folders.ThisApp">
            <summary>
            Folder containing assemblies of this appdomain.
            Calls <see cref="P:System.AppDomain.BaseDirectory"/>.
            </summary>
            <remarks>
            Unlike <see cref="P:Au.Folders.ThisProcess"/>, this path can be different for each appdomain; it is set when creating the AppDomain.
            See also <see cref="P:System.Windows.Forms.Application.ExecutablePath"/>, it gets full path (with file name) of appdomain's entry assembly.
            </remarks>
        </member>
        <member name="P:Au.Folders.ThisAppTemp">
            <summary>
            Gets or sets path of the temporary files folder of this application.
            Default is Folders.Temp + Application.ProductName.
            The 'set' function does not change system settings, it just remembers a string that will be later returned by the 'get' function in this appdomain.
            The 'get' function creates the folder if does not exist.
            </summary>
        </member>
        <member name="P:Au.Folders.ThisAppDocuments">
            <summary>
            Gets or sets path of user document files folder of this application.
            Default is Folders.Documents + Application.ProductName.
            The 'set' function does not change system settings, it just remembers a string that will be later returned by the 'get' function in this appdomain.
            The 'get' function creates the folder if does not exist.
            </summary>
        </member>
        <member name="P:Au.Folders.ThisAppData">
            <summary>
            Gets or sets path of private files folder of this application on this user account.
            Default is Folders.RoamingAppData + Application.ProductName.
            The 'set' function does not change system settings, it just remembers a string that will be later returned by the 'get' function in this appdomain.
            The 'get' function creates the folder if does not exist.
            </summary>
        </member>
        <member name="P:Au.Folders.ThisAppDataLocal">
            <summary>
            Gets or sets path of local (non-roaming) private files folder of this application on this user account.
            Default is Folders.LocalAppData + Application.ProductName.
            The 'set' function does not change system settings, it just remembers a string that will be later returned by the 'get' function in this appdomain.
            The 'get' function creates the folder if does not exist.
            </summary>
        </member>
        <member name="P:Au.Folders.ThisAppDataCommon">
            <summary>
            Gets or sets path of common (all users) private files folder of this application.
            Default is Folders.ProgramData + Application.ProductName.
            The 'set' function does not change system settings, it just remembers a string that will be later returned by the 'get' function in this appdomain.
            Note: the ProgramData folder has special permissions. Programs running not as administrator usually cannot write there.
            This function does not auto-create the folder; usually it is created when installing the application.
            </summary>
        </member>
        <member name="P:Au.Folders.ThisProcess">
            <summary>
            Folder containing the program file of this process.
            Calls <see cref="P:System.Windows.Forms.Application.StartupPath"/>.
            Unlike <see cref="P:Au.Folders.ThisApp"/>, this path is the same for all app domains of this process.
            </summary>
        </member>
        <member name="P:Au.Folders.ThisAppImages">
            <summary>
            Gets or sets path of images (icons etc) folder of this application.
            Default is ThisApp + "Images".
            Functions of these classes will look for image there: Icons, AuMenu, AuToolbar, WinImage, possibly some other.
            </summary>
        </member>
        <member name="P:Au.Folders.SystemX64">
            <summary>
            Gets non-redirected path of the System32 folder.
            </summary>
            <remarks>
            If this process is 32-bit and OS is 64-bit, when it uses the <see cref="P:Au.Folders.System"/> folder path (@"C:\WINDOWS\system32"), the OS in most cases redirects it to @"C:\Windows\SysWOW64", which contains 32-bit versions of program files. Use SystemX64 when you want to avoid the redirection and access the true System32 folder which on 64-bit OS contains 64-bit program files.
            More info in class help.
            </remarks>
            <seealso cref="T:Au.Files.Misc.DisableRedirection"/>
            <seealso cref="P:Au.Ver.Is32BitProcessOn64BitOS"/>
        </member>
        <member name="P:Au.Folders.ProgramFilesX64">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.Folders.ProgramFilesCommonX64">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.Folders.NetFrameworkRuntime">
            <summary>
            Returns <see cref="M:System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory"/>.
            </summary>
        </member>
        <member name="P:Au.Folders.CdDvdDrive">
            <summary>
            Gets CD/DVD drive path, like @"D:\".
            Returns null if unavailable.
            </summary>
        </member>
        <member name="P:Au.Folders.RemovableDrive0">
            <summary>Calls <see cref="M:Au.Folders.RemovableDrive(System.Int32)"/>(0).</summary>
        </member>
        <member name="P:Au.Folders.RemovableDrive1">
            <summary>Calls <see cref="M:Au.Folders.RemovableDrive(System.Int32)"/>(1).</summary>
        </member>
        <member name="P:Au.Folders.RemovableDrive2">
            <summary>Calls <see cref="M:Au.Folders.RemovableDrive(System.Int32)"/>(2).</summary>
        </member>
        <member name="P:Au.Folders.RemovableDrive3">
            <summary>Calls <see cref="M:Au.Folders.RemovableDrive(System.Int32)"/>(3).</summary>
        </member>
        <member name="M:Au.Folders.RemovableDrive(System.Int32)">
            <summary>
            Gets removable/external/USB drive path, like @"F:\".
            Returns null if unavailable.
            </summary>
            <param name="driveIndex">0-based removable drive index.</param>
            <remarks>Uses <see cref="M:System.IO.DriveInfo.GetDrives"/> and counts only drives of type DriveType.Removable.</remarks>
        </member>
        <member name="M:Au.Folders.RemovableDrive(System.String)">
            <summary>
            Gets removable/external/USB drive name (like @"F:\") by its volume label.
            Returns null if unavailable.
            </summary>
            <param name="volumeLabel">Volume label. You can see it in drive Properties dialog; it is not the drive name that is displayed in File Explorer.</param>
        </member>
        <member name="M:Au.Folders.EnvVar(System.String)">
            <summary>
            Gets the value of an environment variable.
            Returns null if unavailable.
            </summary>
        </member>
        <member name="M:Au.Folders.GetKnownFolders">
            <summary>
            Gets canonical names and paths of all known folders, including custom known folders registerd by applications.
            Can be useful for information. These names then can be used with <see cref="M:Au.Folders.GetFolder(System.String)"/>.
            Example: <c>Print(Folders.GetKnownFolders());</c>
            </summary>
        </member>
        <member name="M:Au.Folders.GetFolder(System.String)">
            <summary>
            Gets path of a known folder by its name as string.
            Returns null if unavailable.
            </summary>
            <param name="folderName">
            A property name of this class. Examples: "Documents", "Temp", "ThisApp".
            Or a property name of the nested class Virtual, like "Virtual.ControlPanel". Gets ":: HexEncodedITEMIDLIST".
            Or known folder canonical name. See <see cref="M:Au.Folders.GetKnownFolders"/>. If has prefix "Virtual.", gets ":: HexEncodedITEMIDLIST". Much slower, but allows to get paths of folders registered by applications.
            </param>
        </member>
        <member name="M:Au.Folders.FolderPath.op_Addition(Au.Folders.FolderPath,System.String)">
            <summary>
            Calls <see cref="M:Au.Path_.Combine(System.String,System.String,System.Boolean,System.Boolean)"/>(fp, append).
            Example: <c>string s = Folders.Desktop + "file.txt";</c>
            </summary>
            <exception cref="T:Au.Types.AuException">f is empty. Most likely, used code <c>Folders.X + "append"</c> and failed to get X.</exception>
        </member>
        <member name="T:Au.AuToolbar">
            <summary>
            TODO
            </summary>
        </member>
        <member name="P:Au.AuToolbar.Ex">
            <summary>
            Gets ToolStrip.
            </summary>
        </member>
        <member name="P:Au.AuToolbar.MainToolStrip">
            <summary>Infrastructure.</summary>
        </member>
        <member name="P:Au.AuToolbar.Item(System.String,System.Object)">
            <inheritdoc cref="M:Au.AuToolbar.Add(System.String,System.Action{Au.Types.MTClickArgs},System.Object)"/>
            <example><code>
            var t = new AuToolbar();
            t["One"] = o => Print(o);
            t["Two", @"icon file path"] = o => { Print(o); AuDialog.Show(o.ToString()); };
            t.LastItem.ToolTipText = "tooltip";
            </code></example>
        </member>
        <member name="M:Au.AuToolbar.Add(System.String,System.Action{Au.Types.MTClickArgs},System.Object)">
            <summary>
            Adds new button as <see cref="T:System.Windows.Forms.ToolStripButton"/>.
            Sets its text, icon and Click event handler. Other properties can be specified later. See example.
            Code <c>t.Add("text", o => Print(o));</c> is the same as <c>t["text"] = o => Print(o);</c> .
            </summary>
            <param name="text">Text.</param>
            <param name="onClick">Callback function. Called when the button clicked.</param>
            <param name="icon"><inheritdoc cref="M:Au.AuMenu.Add(System.String,System.Action{Au.Types.MTClickArgs},System.Object)"/></param>
            <example><code>
            var m = new AuToolbar();
            t.Add("One", o => Print(o), @"icon file path");
            t.LastItem.ToolTipText = "tooltip";
            t.Add("Two", o => { Print(o.MenuItem.Checked); });
            </code></example>
        </member>
        <member name="M:Au.AuToolbar.Add(System.Windows.Forms.ToolStripItem,System.Object,System.Action{Au.Types.MTClickArgs})">
            <summary>
            Adds item of any supported type, for example ToolStripLabel, ToolStripTextBox, ToolStripComboBox, ToolStripProgressBar.
            Supports types derived from ToolStripItem.
            </summary>
            <param name="item">An already created item of any supported type.</param>
            <param name="icon"><inheritdoc cref="M:Au.AuMenu.Add(System.String,System.Action{Au.Types.MTClickArgs},System.Object)"/></param>
            <param name="onClick">Callback function. Called when the item clicked. Not useful for most item types.</param>
        </member>
        <member name="M:Au.AuToolbar.Separator">
            <summary>
            Adds separator.
            </summary>
        </member>
        <member name="P:Au.AuToolbar.LastButton">
            <summary>
            Gets the last added item as ToolStripButton.
            Returns null if it is not a ToolStripButton.
            The item can be added with m.Add(...) and m[...]=.
            </summary>
            <remarks>
            You can instead use LastItem, which gets ToolStripItem, which is the base class of all supported item types; cast it to a derived type if need.
            </remarks>
        </member>
        <member name="P:Au.AuToolbar.MainWnd">
            <summary>
            Gets the main toolbar window.
            </summary>
        </member>
        <member name="T:Au.AuMenu">
            <summary>
            TODO
            </summary>
        </member>
        <member name="P:Au.AuMenu.CMS">
            <summary>
            Gets ContextMenuStrip that is used to show the main drop-down menu.
            You can use all its properties, methods and events. You can assign it to a control or toolstrip's drop-down button etc.
            </summary>
        </member>
        <member name="P:Au.AuMenu.MainToolStrip">
            <summary>Infrastructure.</summary>
        </member>
        <member name="M:Au.AuMenu.#ctor">
            
        </member>
        <member name="M:Au.AuMenu.Dispose">
            
        </member>
        <member name="P:Au.AuMenu.IsDisposed">
            
        </member>
        <member name="P:Au.AuMenu.Item(System.String,System.Object)">
            <inheritdoc cref="M:Au.AuMenu.Add(System.String,System.Action{Au.Types.MTClickArgs},System.Object)"/>
            <example><code>
            var m = new AuMenu();
            m["One"] = o => Print(o);
            m["Two", @"icon file path"] = o => { Print(o); AuDialog.Show(o.ToString()); };
            m.LastItem.ToolTipText = "tooltip";
            m["Three"] = o => { Print(o.MenuItem.Checked); };
            m.LastMenuItem.Checked = true;
            m.ExtractIconPathFromCode = true;
            m["notepad"] = o => Shell.TryRun(Folders.System + "notepad.exe"));
            m.Show();
            </code></example>
        </member>
        <member name="M:Au.AuMenu.Add(System.String,System.Action{Au.Types.MTClickArgs},System.Object)">
            <summary>
            Adds new item as <see cref="T:System.Windows.Forms.ToolStripMenuItem"/>.
            Sets its text, icon and <b>Click</b> event handler. Other properties can be specified later. See example.
            Code <c>m.Add("text", o => Print(o));</c> is the same as <c>m["text"] = o => Print(o);</c> .
            </summary>
            <param name="text">Text. If contains a tab character, like "Open\tCtrl+O", displays text after it as shortcut keys (right-aligned).</param>
            <param name="onClick">Callback function. Called when clicked the menu item.</param>
            <param name="icon">Can be:
            string - path of .ico or any other file or folder or non-file object. See <see cref="M:Au.Icons.GetFileIcon(System.String,System.Int32,Au.Types.GIFlags)"/>. If not full path, searches in <see cref="P:Au.Folders.ThisAppImages"/>; see also <see cref="P:Au.Types.BaseMT.IconFlags" r=""/>.
            string - image name (key) in the ImageList (<see cref="P:System.Windows.Forms.ToolStripItem.ImageKey"/>).
            int - image index in the ImageList (<see cref="P:System.Windows.Forms.ToolStripItem.ImageIndex"/>).
            Icon, Image, Folders.FolderPath.
            null (default) - no icon. If <see cref="P:Au.Types.BaseMT.ExtractIconPathFromCode" r=""/> == true, extracts icon path from <paramref name="onClick"/> code like <c>Shell.TryRun(@"c:\path\file.exe")</c> or <c>Shell.TryRun(Folders.System + "file.exe")</c>.
            "" - no icon.
            </param>
            <example><code>
            var m = new AuMenu();
            m.Add("One", o => Print(o), @"icon file path");
            m.Add("Two", o => { Print(o.MenuItem.Checked); AuDialog.Show(o.ToString()); });
            m.LastMenuItem.Checked = true;
            m.ExtractIconPathFromCode = true;
            m.Add("notepad", o => Shell.TryRun(Folders.System + "notepad.exe"));
            m.Show();
            </code></example>
        </member>
        <member name="M:Au.AuMenu.Add(System.Windows.Forms.ToolStripItem,System.Object,System.Action{Au.Types.MTClickArgs})">
            <summary>
            Adds item of any supported type, for example ToolStripLabel, ToolStripTextBox, ToolStripComboBox, ToolStripProgressBar, ToolStripButton.
            Supports types derived from ToolStripItem.
            </summary>
            <param name="item">An already created item of any supported type.</param>
            <param name="icon"><inheritdoc cref="M:Au.AuMenu.Add(System.String,System.Action{Au.Types.MTClickArgs},System.Object)"/></param>
            <param name="onClick">Callback function. Called when the item clicked. Not useful for most item types.</param>
        </member>
        <member name="M:Au.AuMenu.Separator">
            <summary>
            Adds separator.
            </summary>
        </member>
        <member name="M:Au.AuMenu.Submenu(System.String,System.Object,System.Action{Au.Types.MTClickArgs})">
            <summary>
            Adds new item (<see cref="T:System.Windows.Forms.ToolStripMenuItem"/>) that will open a submenu.
            Then the add-item functions will add items to the submenu.
            Can be used in 2 ways:
            1. <c>using(m.Submenu(...)) { add items; }</c>. See example.
            2. <c>m.Submenu(...); add items; m.EndSubmenu();</c>. See <see cref="M:Au.AuMenu.EndSubmenu"/>.
            </summary>
            <param name="text">Text.</param>
            <param name="icon"><inheritdoc cref="M:Au.AuMenu.Add(System.String,System.Action{Au.Types.MTClickArgs},System.Object)"/></param>
            <param name="onClick">Callback function. Called when the item clicked. Rarely used.</param>
            <remarks>
            Submenus inherit these properties of the main menu, set before adding submenus (see example):
            <b>BackgroundImage</b>, <b>BackgroundImageLayout</b>, <b>ContextMenu</b>, <b>Cursor</b>, <b>Font</b>, <b>ForeColor</b>, <b>ImageList</b>, <b>ImageScalingSize</b>, <b>Renderer</b>, <b>ShowCheckMargin</b>, <b>ShowImageMargin</b>.
            </remarks>
            <example><code>
            var m = new AuMenu();
            m.CMS.BackColor = Color.PaleGoldenrod;
            m["One"] = o => Print(o);
            m["Two"] = o => Print(o);
            using(m.Submenu("Submenu")) {
            	m["Three"] = o => Print(o);
            	m["Four"] = o => Print(o);
            	using(m.Submenu("Submenu")) {
            		m["Five"] = o => Print(o);
            		m["Six"] = o => Print(o);
            	}
            	m["Seven"] = o => Print(o);
            }
            m["Eight"] = o => Print(o);
            m.Show();
            </code></example>
        </member>
        <member name="M:Au.AuMenu.EndSubmenu">
            <summary>
            Call this to end adding items to the current submenu if <see cref="M:Au.AuMenu.Submenu(System.String,System.Object,System.Action{Au.Types.MTClickArgs})"/> was called without 'using' and without a callback function that adds submenu items.
            </summary>
            <example><code>
            var m = new AuMenu();
            m["One"] = o => Print(o);
            m["Two"] = o => Print(o);
            m.Submenu("Submenu");
            	m["Three"] = o => Print(o);
            	m["Four"] = o => Print(o);
            	m.EndSubmenu();
            m["Five"] = o => Print(o);
            m.Show();
            </code></example>
        </member>
        <member name="T:Au.AuMenu.UsingSubmenu">
            <summary>
            Allows to use code: <c>using(m.Submenu("Name")) { add items; }</c> .
            </summary>
            <tocexclude />
        </member>
        <member name="P:Au.AuMenu.UsingSubmenu.MenuItem">
            <summary>
            Gets ToolStripMenuItem of the submenu-item.
            </summary>
        </member>
        <member name="M:Au.AuMenu.UsingSubmenu.Dispose">
            <summary>
            Calls m.EndSubmenu().
            </summary>
        </member>
        <member name="M:Au.AuMenu.Submenu(System.String,System.Action{Au.AuMenu},System.Object,System.Action{Au.Types.MTClickArgs})">
            <summary>
            Adds new item (<see cref="T:System.Windows.Forms.ToolStripMenuItem"/>) that will open a submenu.
            When showing the submenu first time, your callback function will be called and can add submenu items.
            </summary>
            <param name="text">Text.</param>
            <param name="onOpening">Callback function that should add submenu items.</param>
            <param name="icon"><inheritdoc cref="M:Au.AuMenu.Add(System.String,System.Action{Au.Types.MTClickArgs},System.Object)"/></param>
            <param name="onClick">Callback function. Called when the item clicked. Rarely used.</param>
            <example><code>
            var m = new AuMenu();
            m["One"] = o => Print(o);
            m["Two"] = o => Print(o);
            m.Submenu("Submenu 1", m1 =>
            {
            	Print("adding items of " + m.CurrentAddMenu.OwnerItem);
            	m["Three"] = o => Print(o);
            	m["Four"] = o => Print(o);
            	m.Submenu("Submenu 2", m2 =>
            	{
            		Print("adding items of " + m.CurrentAddMenu.OwnerItem);
            		m["Five"] = o => Print(o);
            		m["Six"] = o => Print(o);
            	});
            	m["Seven"] = o => Print(o);
            });
            m["Eight"] = o => Print(o);
            m.Show();
            </code></example>
        </member>
        <member name="P:Au.AuMenu.CurrentAddMenu">
            <summary>
            Gets <see cref="T:System.Windows.Forms.ToolStripDropDownMenu"/> of the main menu or submenu where new items currently are added.
            </summary>
        </member>
        <member name="P:Au.AuMenu.LastMenuItem">
            <summary>
            Gets the last added item as <see cref="T:System.Windows.Forms.ToolStripMenuItem"/>.
            Returns null if it is not a <b>ToolStripMenuItem</b>, for example a button or separator.
            </summary>
            <remarks>
            You can instead use <see cref="P:Au.Types.BaseMT.LastItem" r=""/>, which gets <see cref="T:System.Windows.Forms.ToolStripItem"/>, which is the base class of all supported item types.
            </remarks>
        </member>
        <member name="M:Au.AuMenu.Show">
            <summary>
            Shows the menu at the mouse cursor position.
            </summary>
        </member>
        <member name="M:Au.AuMenu.Show(System.Int32,System.Int32,System.Windows.Forms.ToolStripDropDownDirection)">
            <summary>
            Shows the menu at the specified position.
            </summary>
            <param name="x">X position in screen.</param>
            <param name="y">Y position in screen.</param>
            <param name="direction">Menu drop direction.</param>
        </member>
        <member name="M:Au.AuMenu.Show(System.Windows.Forms.Control,System.Int32,System.Int32,System.Windows.Forms.ToolStripDropDownDirection)">
            <summary>
            Shows the menu on a form or control.
            </summary>
            <param name="owner">A control or form that will own the menu.</param>
            <param name="x">X position in control's client area.</param>
            <param name="y">Y position in control's client area.</param>
            <param name="direction">Menu drop direction.</param>
            <remarks>
            Alternatively you can assign the context menu to a control or toolstrip's drop-down button etc, then don't need to call <b>Show</b>. Use the <see cref="P:Au.AuMenu.CMS"/> property, which gets <see cref="T:System.Windows.Forms.ContextMenuStrip"/>.
            </remarks>
        </member>
        <member name="M:Au.AuMenu.Show(System.Windows.Forms.Control,System.Windows.Forms.ToolStripDropDownDirection)">
            <summary>
            Shows the menu at the mouse cursor position.
            </summary>
            <param name="owner">A control or form that will own the menu.</param>
            <param name="direction">Menu drop direction.</param>
            <remarks>
            Alternatively you can assign the context menu to a control or toolstrip's drop-down button etc, then don't need to call <b>Show</b>. Use the <see cref="P:Au.AuMenu.CMS"/> property, which gets <see cref="T:System.Windows.Forms.ContextMenuStrip"/>.
            </remarks>
        </member>
        <member name="P:Au.AuMenu.MultiShow">
            <summary>
            If false, disposes the menu when it is closed.
            If true, does not dispose. Then you can call <b>Show</b> multiple times for the same object.
            Default is false, but is automatically set to true when showing the menu not with <b>Show</b>, eg when assigned to a control.
            </summary>
            <seealso cref="P:Au.AuMenu.DefaultMultiShow"/>
        </member>
        <member name="P:Au.AuMenu.DefaultMultiShow">
            <summary>
            Default <see cref="P:Au.AuMenu.MultiShow"/> value for new <b>AuMenu</b> instances.
            </summary>
        </member>
        <member name="P:Au.AuMenu.ModalAlways">
            <summary>
            If true, <b>Show</b> always waits until the menu is closed.
            If false, does not wait if the thread has a .NET message loop (<see cref="P:Au.Thread_.IsUI"/>==true).
            </summary>
        </member>
        <member name="P:Au.AuMenu.ActivateMenuWindow">
            <summary>
            Activate the menu window.
            It enables selecting menu items with the keyboard (arrows, Tab, Enter, etc).
            If false, only Esc works, it closes the menu.
            If the menu is owned by a control or toolbar button, keyboard navigation works in any case, don't need this property to enable it.
            </summary>
            <seealso cref="P:Au.AuMenu.DefaultActivateMenuWindow"/>
        </member>
        <member name="P:Au.AuMenu.DefaultActivateMenuWindow">
            <summary>
            Default <see cref="P:Au.AuMenu.ActivateMenuWindow"/> value for new <b>AuMenu</b> instances.
            </summary>
        </member>
        <member name="P:Au.AuMenu.MouseClosingDistance">
            <summary>
            Close the menu when the mouse cursor moves away from it to this distance, pixels.
            At first the mouse must be or move at less than half of the distance.
            Default is equal to AuMenu.DefaultMouseClosingDistance, default 200.
            </summary>
            <seealso cref="P:Au.AuMenu.DefaultMouseClosingDistance"/>
        </member>
        <member name="P:Au.AuMenu.DefaultMouseClosingDistance">
            <summary>
            Default MouseClosingDistance value of AuMenu instances.
            A AuMenu instance inherits this at the moment it is created.
            </summary>
        </member>
        <member name="M:Au.AuMenu.Close">
            <summary>
            Closes the menu and its submenus.
            Also closes its context menu (CMS.ContextMenu).
            </summary>
        </member>
        <member name="T:Au.Mouse">
            <summary>
            Mouse functions.
            </summary>
            <remarks>
            Should not be used to click windows of own thread. It may work or not. If need, use another thread. Example in <see cref="M:Au.Keyb.Key(System.Object[])"/>.
            </remarks>
        </member>
        <member name="P:Au.Mouse.XY">
            <summary>
            Gets cursor (mouse pointer) position.
            </summary>
        </member>
        <member name="P:Au.Mouse.X">
            <summary>
            Gets cursor (mouse pointer) X coordinate (Mouse.XY.x).
            </summary>
        </member>
        <member name="P:Au.Mouse.Y">
            <summary>
            Gets cursor (mouse pointer) Y coordinate (Mouse.XY.y).
            </summary>
        </member>
        <member name="M:Au.Mouse.Move(Au.Types.POINT)">
            <summary>
            Moves the cursor (mouse pointer) to the specified position in screen.
            </summary>
            <param name="p">
            Coordinates relative to the primary screen.
            Tip: When need coordinates relative to another screen or/and the work area, use <see cref="M:Au.Types.Coord.Normalize(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.Types.Screen_,System.Boolean,System.Boolean)"/> or tuple (x, y, workArea) etc. Example: <c>Mouse.Move((x, y, true));</c>.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">The specified x y is not in screen. No exception if option <b>Relaxed</b> is true (then moves to a screen edge).</exception>
            <exception cref="T:Au.Types.AuException">Failed to move the cursor to the specified x y. Some reasons: 1. Another thread blocks or modifies mouse input (API BlockInput, mouse hooks, frequent API SendInput etc); 2. The active window belongs to a process of higher <see cref="T:Au.Process_.UacInfo">UAC</see> integrity level; 3. Some application called API ClipCursor. No exception if option <b>Relaxed</b> is true (then final cursor position is undefined).</exception>
            <remarks>
            Uses <see cref="P:Au.Opt.Mouse"/>: <see cref="P:Au.Types.OptMouse.MoveSpeed" r=""/>, <see cref="P:Au.Types.OptMouse.MoveSleepFinally" r=""/>, <see cref="P:Au.Types.OptMouse.Relaxed" r=""/>.
            </remarks>
            <example>
            Save-restore mouse position.
            <code><![CDATA[
            var p = Mouse.XY;
            //...;
            Mouse.Move(p);
            ]]></code>
            Use coodinates in the first non-primary screen.
            <code><![CDATA[
            Mouse.Move(Coord.Normalize(10, 10, screen: 1));
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Mouse.Move(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Moves the cursor (mouse pointer) to the position x y in screen.
            Returns normalized cursor position.
            </summary>
            <param name="x">X coordinate.</param>
            <param name="y">Y coordinate.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            1. The specified x y is not in the screen (any screen). No exception if option <b>Relaxed</b> is true (then moves to a screen edge).
            2. Invalid screen index.
            </exception>
            <exception cref="T:Au.Types.AuException"><inheritdoc cref="M:Au.Mouse.Move(Au.Types.POINT)"/></exception>
            <remarks>
            Uses <see cref="P:Au.Opt.Mouse"/>: <see cref="P:Au.Types.OptMouse.MoveSpeed" r=""/>, <see cref="P:Au.Types.OptMouse.MoveSleepFinally" r=""/>, <see cref="P:Au.Types.OptMouse.Relaxed" r=""/>.
            </remarks>
        </member>
        <member name="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Moves the cursor (mouse pointer) to the position x y relative to window w.
            Returns cursor position in primary screen coordinates.
            </summary>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle. If false (default), they are relative to the client area.</param>
            <exception cref="T:Au.Types.WndException">
            Invalid window.
            The top-level window is hidden. No exception if just cloaked, for example in another desktop; then on click will activate, which usually uncloaks.
            Other window-related failures.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The specified x y is not in screen. No exception if option <b>Relaxed</b> is true (then moves to a screen edge).</exception>
            <exception cref="T:Au.Types.AuException"><inheritdoc cref="M:Au.Mouse.Move(Au.Types.POINT)"/></exception>
            <remarks>
            Uses <see cref="P:Au.Opt.Mouse"/>: <see cref="P:Au.Types.OptMouse.MoveSpeed" r=""/>, <see cref="P:Au.Types.OptMouse.MoveSleepFinally" r=""/>, <see cref="P:Au.Types.OptMouse.Relaxed" r=""/>.
            </remarks>
        </member>
        <member name="M:Au.Mouse.Save">
            <summary>
            Remembers current mouse cursor position to be later restored with <see cref="M:Au.Mouse.Restore"/>.
            </summary>
        </member>
        <member name="M:Au.Mouse.Restore">
            <summary>
            Moves the mouse cursor where it was at the time of the last <see cref="M:Au.Mouse.Save"/> call in this thread. If it was not called - of the first 'mouse move' or 'mouse move and click' function call in this thread. Does nothing if these functions were not called.
            </summary>
            <remarks>
            Uses <see cref="P:Au.Opt.Mouse"/>: <see cref="P:Au.Types.OptMouse.MoveSleepFinally" r=""/>, <see cref="P:Au.Types.OptMouse.Relaxed" r=""/>.
            </remarks>
        </member>
        <member name="P:Au.Mouse.LastMoveXY">
            <summary>
            Mouse cursor position of the most recent successful 'mouse move' or 'mouse move and click' function call in this thread.
            If such functions are still not called in this thread, returns <see cref="P:Au.Mouse.XY"/>.
            </summary>
        </member>
        <member name="M:Au.Mouse.MoveRelative(System.Int32,System.Int32)">
            <summary>
            Moves the cursor (mouse pointer) relative to <see cref="P:Au.Mouse.LastMoveXY"/>.
            Returns the final cursor position in primary screen coordinates.
            </summary>
            <param name="dx">X offset from LastMoveXY.x.</param>
            <param name="dy">Y offset from LastMoveXY.y.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The calculated x y is not in screen. No exception if option <b>Relaxed</b> is true (then moves to a screen edge).</exception>
            <exception cref="T:Au.Types.AuException">Failed to move the cursor to the calculated x y. Some reasons: 1. Another thread blocks or modifies mouse input (API BlockInput, mouse hooks, frequent API SendInput etc); 2. The active window belongs to a process of higher <see cref="T:Au.Process_.UacInfo">UAC</see> integrity level; 3. Some application called API ClipCursor. No exception option <b>Relaxed</b> is true (then final cursor position is undefined).</exception>
            <remarks>
            Uses <see cref="P:Au.Opt.Mouse"/>: <see cref="P:Au.Types.OptMouse.MoveSpeed" r=""/>, <see cref="P:Au.Types.OptMouse.MoveSleepFinally" r=""/>, <see cref="P:Au.Types.OptMouse.Relaxed" r=""/>.
            </remarks>
        </member>
        <member name="M:Au.Mouse.MoveRecorded(System.String,System.Double)">
            <summary>
            Plays recorded mouse movements, relative to <see cref="P:Au.Mouse.LastMoveXY"/>.
            Returns the final cursor position in primary screen coordinates.
            </summary>
            <param name="recordedString">String containing mouse movement data recorded by a recorder tool that uses <see cref="M:Au.Util.Recording.MouseToString(System.Collections.Generic.IEnumerable{System.UInt32},System.Boolean)"/>.</param>
            <param name="speedFactor">Speed factor. For example, 0.5 makes 2 times faster.</param>
            <exception cref="T:System.ArgumentException">The string is not compatible with this library version (recorded with a newer version and has additional options).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The last x y is not in screen. No exception option <b>Relaxed</b> is true (then moves to a screen edge).</exception>
            <exception cref="T:Au.Types.AuException">Failed to move to the last x y. Some reasons: 1. Another thread blocks or modifies mouse input (API BlockInput, mouse hooks, frequent API SendInput etc); 2. The active window belongs to a process of higher <see cref="T:Au.Process_.UacInfo">UAC</see> integrity level; 3. Some application called API ClipCursor. No exception option <b>Relaxed</b> is true (then final cursor position is undefined).</exception>
            <remarks>
            Uses <see cref="P:Au.Opt.Mouse"/>: <see cref="P:Au.Types.OptMouse.Relaxed" r=""/> (only for the last movement; always relaxed in intermediate movements).
            </remarks>
        </member>
        <member name="M:Au.Mouse._SendMove(Au.Types.POINT)">
            <summary>
            Sends single mouse movement event.
            x y are normal absolute coordinates.
            </summary>
        </member>
        <member name="M:Au.Mouse._SendButton(Au.Types.MButton,System.Boolean,System.Nullable{Au.Types.POINT})">
            <summary>
            Sends single mouse button down or up event.
            Does not use the action flags of button.
            Applies SM_SWAPBUTTON.
            If pMoved!=null, also moves to pMoved in the same API SendInput call.
            </summary>
        </member>
        <member name="M:Au.Mouse._SendRaw(Au.Types.Api.IMFlags,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calls Api.SendInput to send single mouse movement or/and button down or up or wheel event.
            Converts x, y and wheelTicks as need for MOUSEINPUT.
            For X buttons use Api.IMFlag.XDown|Api.IMFlag.X1 etc.
            If Api.IMFlag.Move, adds Api.IMFlag.Absolute.
            </summary>
        </member>
        <member name="M:Au.Mouse.ClickEx(Au.Types.MButton,System.Boolean)">
            <summary>
            Clicks, double-clicks, presses or releases a mouse button.
            By default does not move the mouse cursor.
            </summary>
            <returns><inheritdoc cref="M:Au.Mouse.LeftDown(System.Boolean)"/></returns>
            <param name="button">Button and action. Default: left click.</param>
            <param name="useLastMoveXY">
            Use <see cref="P:Au.Mouse.LastMoveXY"/>. It is the mouse cursor position set by the most recent 'mouse move' or 'mouse move and click' function called in this thread. Use this option for reliability.
            Example: <c>Mouse.Move(100, 100); Mouse.ClickEx(..., true);</c>. The click is always at 100 100, even if somebody changes cursor position between <c>Mouse.Move</c> sets it and <c>Mouse.ClickEx</c> uses it. In such case this option atomically moves the cursor to <b>LastMoveXY</b>. This movement is instant and does not use <see cref="T:Au.Opt"/>.
            If false (default), clicks at the current cursor position (does not move it).
            </param>
            <exception cref="T:System.ArgumentException">Invalid button flags (multiple buttons or actions specified).</exception>
            <remarks>
            Uses <see cref="P:Au.Opt.Mouse"/>: <see cref="P:Au.Types.OptMouse.ClickSpeed" r=""/>, <see cref="P:Au.Types.OptMouse.ClickSleepFinally" r=""/>.
            </remarks>
        </member>
        <member name="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Clicks, double-clicks, presses or releases a mouse button at the specified position in screen.
            </summary>
            <returns><inheritdoc cref="M:Au.Mouse.LeftDown(System.Boolean)"/></returns>
            <param name="button">Button and action.</param>
            <param name="x">X coordinate.</param>
            <param name="y">Y coordinate.</param>
            <exception cref="T:System.ArgumentException">Invalid button flags (multiple buttons or actions specified).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
            <remarks>
            To move the mouse cursor, calls <see cref="M:Au.Mouse.Move(Au.Types.Coord,Au.Types.Coord)"/>.
            Uses <see cref="P:Au.Opt.Mouse"/>: <see cref="P:Au.Types.OptMouse.MoveSpeed" r=""/>, <see cref="P:Au.Types.OptMouse.MoveSleepFinally" r=""/> (between moving and clicking), <see cref="P:Au.Types.OptMouse.ClickSpeed" r=""/>, <see cref="P:Au.Types.OptMouse.ClickSleepFinally" r=""/>, <see cref="P:Au.Types.OptMouse.Relaxed" r=""/>.
            </remarks>
        </member>
        <member name="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Types.POINT)">
            <inheritdoc cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord)"/>
            <param name="button">Button and action.</param>
            <param name="p">
            Coordinates relative to the primary screen.
            Tip: When need coordinates relative to another screen or/and the work area, use <see cref="M:Au.Types.Coord.Normalize(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.Types.Screen_,System.Boolean,System.Boolean)"/> or tuple (x, y, workArea) etc. Example: <c>Mouse.ClickEx(MButton.Right, (x, y, true));</c>.
            </param>
        </member>
        <member name="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Clicks, double-clicks, presses or releases a mouse button at position x y relative to window w.
            </summary>
            <returns><inheritdoc cref="M:Au.Mouse.LeftDown(System.Boolean)"/></returns>
            <param name="button">Button and action.</param>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle. If false (default), they are relative to the client area.</param>
            <exception cref="T:System.ArgumentException">Invalid button flags (multiple buttons or actions specified).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <exception cref="T:Au.Types.WndException">x y is not in the window (read more in Remarks).</exception>
            <remarks>
            To move the mouse cursor, calls <see cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            Uses <see cref="P:Au.Opt.Mouse"/>: <see cref="P:Au.Types.OptMouse.MoveSpeed" r=""/>, <see cref="P:Au.Types.OptMouse.MoveSleepFinally" r=""/> (between moving and clicking), <see cref="P:Au.Types.OptMouse.ClickSpeed" r=""/>, <see cref="P:Au.Types.OptMouse.ClickSleepFinally" r=""/>, <see cref="P:Au.Types.OptMouse.Relaxed" r=""/>.
            If after moving the cursor it is not in the window (or a window of its thread), activates the window (or its top-level parent window). Throws exception if then x y is still not in the window. Skips all this when just releasing button or if option <b>Relaxed</b> is true. Also, if it is a control, x y can be somewhere else in its top-level parent window.
            </remarks>
        </member>
        <member name="M:Au.Mouse.Click(System.Boolean)">
            <summary>
            Left button click.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <param name="useLastMoveXY">Use <see cref="P:Au.Mouse.LastMoveXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.Mouse.Click(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Left button click at position x y.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord)"/>. More info there.
            </summary>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
        </member>
        <member name="M:Au.Mouse.Click(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Left button click at position x y relative to window w.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle. If false (default), they are relative to the client area.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <exception cref="T:Au.Types.AuException">x y is not in the window. More info: <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.Mouse.RightClick(System.Boolean)">
            <summary>
            Right button click.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <param name="useLastMoveXY">Use <see cref="P:Au.Mouse.LastMoveXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.Mouse.RightClick(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Right button click at position x y.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord)"/>. More info there.
            </summary>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
        </member>
        <member name="M:Au.Mouse.RightClick(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Right button click at position x y relative to window w.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle. If false (default), they are relative to the client area.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <exception cref="T:Au.Types.AuException">x y is not in the window. More info: <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.Mouse.DoubleClick(System.Boolean)">
            <summary>
            Left button double click.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <param name="useLastMoveXY">Use <see cref="P:Au.Mouse.LastMoveXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.Mouse.DoubleClick(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Left button double click at position x y.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord)"/>. More info there.
            </summary>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
        </member>
        <member name="M:Au.Mouse.DoubleClick(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Left button double click at position x y relative to window w.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle. If false (default), they are relative to the client area.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <exception cref="T:Au.Types.AuException">x y is not in the window. More info: <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.Mouse.LeftDown(System.Boolean)">
            <summary>
            Left button down (press and don't release).
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <returns>The return value can be used to auto-release pressed button. See example with <see cref="M:Au.Mouse.LeftDown(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</returns>
            <param name="useLastMoveXY">Use <see cref="P:Au.Mouse.LastMoveXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.Mouse.LeftDown(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Left button down (press and don't release) at position x y.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord)"/>. More info there.
            </summary>
            <returns><inheritdoc cref="M:Au.Mouse.LeftDown(System.Boolean)"/></returns>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
        </member>
        <member name="M:Au.Mouse.LeftDown(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Left down (press and don't release) at position x y relative to window w.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <returns>The return value can be used to auto-release pressed button. See example.</returns>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle. If false (default), they are relative to the client area.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <exception cref="T:Au.Types.AuException">x y is not in the window. More info: <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <example>
            <code><![CDATA[
            //drag and drop: start at x=8 y=8, move 20 pixels down, drop
            using(Mouse.LeftDown(w, 8, 8)) Mouse.MoveRelative(0, 20); //the button is auto-released when the 'using' code block ends
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Mouse.LeftUp(System.Boolean)">
            <summary>
            Left button up (release pressed button).
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <param name="useLastMoveXY">Use <see cref="P:Au.Mouse.LastMoveXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.Mouse.LeftUp(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Left button up (release pressed button) at position x y.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord)"/>. More info there.
            </summary>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
        </member>
        <member name="M:Au.Mouse.LeftUp(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Left button up (release pressed button) at position x y relative to window w.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle. If false (default), they are relative to the client area.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.Mouse.RightDown(System.Boolean)">
            <summary>
            Right button down (press and don't release).
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <returns><inheritdoc cref="M:Au.Mouse.LeftDown(System.Boolean)"/></returns>
            <param name="useLastMoveXY">Use <see cref="P:Au.Mouse.LastMoveXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.Mouse.RightDown(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Right button down (press and don't release) at position x y.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord)"/>. More info there.
            </summary>
            <returns><inheritdoc cref="M:Au.Mouse.LeftDown(System.Boolean)"/></returns>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
        </member>
        <member name="M:Au.Mouse.RightDown(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Right button down (press and don't release) at position x y relative to window w.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <returns><inheritdoc cref="M:Au.Mouse.LeftDown(System.Boolean)"/></returns>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle. If false (default), they are relative to the client area.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <exception cref="T:Au.Types.AuException">x y is not in the window. More info: <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.Mouse.RightUp(System.Boolean)">
            <summary>
            Right button up (release pressed button).
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <param name="useLastMoveXY">Use <see cref="P:Au.Mouse.LastMoveXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.Mouse.RightUp(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Right button up (release pressed button) at position x y.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord)"/>. More info there.
            </summary>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
        </member>
        <member name="M:Au.Mouse.RightUp(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Right button up (release pressed button) at position x y relative to window w.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle. If false (default), they are relative to the client area.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.Mouse.Wheel(System.Int32,System.Boolean)">
            <summary>
            Mouse wheel forward or backward.
            </summary>
            <param name="ticks">Number of wheel ticks forward (positive) or backward (negative).</param>
            <param name="horizontal">Horizontal wheel.</param>
            <remarks>
            Uses <see cref="P:Au.Opt.Mouse"/>: <see cref="P:Au.Types.OptMouse.ClickSleepFinally" r=""/>.
            </remarks>
        </member>
        <member name="M:Au.Mouse.IsPressed(Au.Types.MButtons)">
            <summary>
            Returns true if some mouse buttons are pressed.
            </summary>
            <param name="buttons">Check only these buttons. Default - all.</param>
            <seealso cref="M:Au.Mouse.WaitForNoButtonsPressed(System.Double,Au.Types.MButtons)"/>
        </member>
        <member name="M:Au.Mouse.PressedButtons(Au.Types.MButtons)">
            <summary>
            Returns a value indicating which mouse buttons are in pressed state.
            </summary>
            <param name="buttons">Check only these buttons. Default - all.</param>
        </member>
        <member name="M:Au.Mouse.WaitForNoButtonsPressed(System.Double,Au.Types.MButtons)">
            <summary>
            Waits while some mouse buttons are in pressed state (see <see cref="M:Au.Mouse.IsPressed(Au.Types.MButtons)"/>).
            </summary>
            <param name="secondsTimeout"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></param>
            <param name="buttons">Wait only for these buttons. Default - all.</param>
            <returns><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></returns>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
            <seealso cref="M:Au.Keyb.WaitForNoModifierKeysAndMouseButtons(System.Double,Au.Types.KMod,Au.Types.MButtons)"/>
        </member>
        <member name="M:Au.Mouse.LibWaitForNoButtonsPressed">
            <summary>
            Waits while some buttons are in pressed state, except those pressed by a <see cref="T:Au.Mouse"/> class function in this thread.
            Does nothing option <b>Relaxed</b> is true.
            </summary>
        </member>
        <member name="M:Au.Mouse.WaitForClick(System.Double,Au.Types.MButtons,System.Boolean,System.Boolean)">
            <summary>
            Waits for button-down or button-up event of the specified mouse button or buttons.
            </summary>
            <param name="secondsTimeout"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></param>
            <param name="button">Mouse button. If several buttons specified, waits for any of them.</param>
            <param name="up">Wait for button-up event.</param>
            <param name="block">Make the event invisible for other apps. If <paramref name="up"/> is true, makes the down event invisible too, if it comes while waiting for the up event.</param>
            <returns><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></returns>
            <exception cref="T:System.ArgumentException"><paramref name="button"/> is 0.</exception>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
            <remarks>
            Unlike <see cref="M:Au.Mouse.WaitForNoButtonsPressed(System.Double,Au.Types.MButtons)"/>, waits for down or up event, not for button state.
            Uses low-level mouse hook.
            </remarks>
            <example>
            <code><![CDATA[
            Mouse.WaitForClick(0, MButtons.Left, up: true, block: false);
            Print("click");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Mouse.WaitForClick(System.Double,System.Boolean,System.Boolean)">
            <summary>
            Waits for button-down or button-up event of any mouse button, and gets the button code.
            </summary>
            <returns>Returns the button code. On timeout returns 0 if <paramref name="secondsTimeout"/> is negative; else exception.</returns>
            <inheritdoc cref="M:Au.Mouse.WaitForClick(System.Double,Au.Types.MButtons,System.Boolean,System.Boolean)"/>
            <example>
            <code><![CDATA[
            var button = Mouse.WaitForClick(0, up: true, block: true);
            Print(button);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Mouse.WaitForCursor(System.Double,Au.Types.MCursor,System.Boolean)">
            <summary>
            Waits for a standard mouse cursor (pointer) visible.
            </summary>
            <param name="secondsTimeout"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></param>
            <param name="cursor">Id of a standard cursor.</param>
            <param name="not">Wait until this cursor disappears.</param>
            <returns><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></returns>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
        </member>
        <member name="M:Au.Mouse.WaitForCursor(System.Double,System.Int64,System.Boolean)">
            <summary>
            Waits for a nonstandard mouse cursor (pointer) visible.
            </summary>
            <param name="secondsTimeout"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></param>
            <param name="cursorHash">Cursor hash, as returned by <see cref="M:Au.Util.Cursors_.HashCursor(System.IntPtr)"/>.</param>
            <param name="not">Wait until this cursor disappears.</param>
            <returns><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></returns>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
        </member>
        <member name="T:Au.Char_">
            <summary>
            Provides function to get ASCII character type (is digit etc) etc.
            </summary>
            <remarks>
            Unlike <see cref="M:System.Char.IsDigit(System.Char)"/> etc, these functions never return true for non-ASCII characters. Also they are faster.
            </remarks>
        </member>
        <member name="M:Au.Char_.IsAsciiDigit(System.Char)">
            <summary>
            Returns true if character is '0' to '9'.
            </summary>
        </member>
        <member name="M:Au.Char_.IsAsciiDigit(System.Byte)">
            <summary>
            Returns true if character is '0' to '9'.
            </summary>
        </member>
        <member name="M:Au.Char_.IsAsciiAlpha(System.Char)">
            <summary>
            Returns true if character is 'A' to 'Z' or 'a' to 'z'.
            </summary>
        </member>
        <member name="M:Au.Char_.IsAsciiAlpha(System.Byte)">
            <summary>
            Returns true if character is 'A' to 'Z' or 'a' to 'z'.
            </summary>
        </member>
        <member name="M:Au.Char_.IsAsciiAlphaDigit(System.Char)">
            <summary>
            Returns true if character is 'A' to 'Z' or 'a' to 'z' or '0' to '9'.
            </summary>
        </member>
        <member name="M:Au.Char_.IsAsciiAlphaDigit(System.Byte)">
            <summary>
            Returns true if character is 'A' to 'Z' or 'a' to 'z' or '0' to '9'.
            </summary>
        </member>
        <member name="T:Au.Convert_">
            <summary>
            Data conversion functions - hash, compress, hex-encode, Base64, UTF8.
            </summary>
        </member>
        <member name="M:Au.Convert_.HashFnv1(System.String)">
            <summary>
            32-bit FNV-1 hash.
            Useful for fast hash table and checksum use, not cryptography. Similar to CRC32; faster but creates more collisions.
            </summary>
        </member>
        <member name="M:Au.Convert_.HashFnv1(System.Char*,System.Int32)">
            <summary>
            32-bit FNV-1 hash.
            Useful for fast hash table and checksum use, not cryptography. Similar to CRC32; faster but creates more collisions.
            </summary>
        </member>
        <member name="M:Au.Convert_.HashFnv1(System.Byte[])">
            <summary>
            32-bit FNV-1 hash.
            Useful for fast hash table and checksum use, not cryptography. Similar to CRC32; faster but creates more collisions.
            </summary>
        </member>
        <member name="M:Au.Convert_.HashFnv1(System.Byte*,System.Int32)">
            <summary>
            32-bit FNV-1 hash.
            Useful for fast hash table and checksum use, not cryptography. Similar to CRC32; faster but creates more collisions.
            </summary>
        </member>
        <member name="M:Au.Convert_.HashFnv1_64(System.String)">
            <summary>
            64-bit FNV-1 hash.
            </summary>
        </member>
        <member name="M:Au.Convert_.HashFnv1_64(System.Char*,System.Int32)">
            <summary>
            64-bit FNV-1 hash.
            </summary>
        </member>
        <member name="M:Au.Convert_.HashFnv1_64(System.Byte[])">
            <summary>
            64-bit FNV-1 hash.
            </summary>
        </member>
        <member name="M:Au.Convert_.HashFnv1_64(System.Byte*,System.Int32)">
            <summary>
            64-bit FNV-1 hash.
            </summary>
        </member>
        <member name="M:Au.Convert_.HashFast(System.Char*,System.Int32)">
            <summary>
            FNV-1 hash, modified to make faster with long strings (then takes every n-th character).
            </summary>
        </member>
        <member name="M:Au.Convert_.HashFast(System.String)">
            <summary>
            FNV-1 hash, modified to make faster with long strings (then takes every n-th character).
            </summary>
            <param name="s">The string to hash. Can be null.</param>
        </member>
        <member name="M:Au.Convert_.HashFast(System.String,System.Int32,System.Int32)">
            <summary>
            FNV-1 hash, modified to make faster with long strings (then takes every n-th character).
            This overload hashes a substring.
            </summary>
            <param name="s">The string containing the substring. Can be null/"" if other parameters are 0.</param>
            <param name="startIndex">Start of substring in s.</param>
            <param name="count">Length of substring.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.Convert_.HashMD5(System.Byte[])">
            <summary>
            Computes MD5 hash of binary data.
            The same as Hash(..., "MD5") but much faster.
            </summary>
        </member>
        <member name="M:Au.Convert_.HashMD5(System.String)">
            <summary>
            Computes MD5 hash of string.
            The same as Hash(..., "MD5") but much faster.
            </summary>
            <remarks>The hash is of UTF8 bytes, not of UTF16 bytes.</remarks>
        </member>
        <member name="M:Au.Convert_.HashMD5Hex(System.Byte[],System.Boolean)">
            <summary>
            Computes MD5 hash of binary data and converts to hex string.
            The same as Hash(..., "MD5") but much faster.
            </summary>
        </member>
        <member name="M:Au.Convert_.HashMD5Hex(System.String,System.Boolean)">
            <summary>
            Computes MD5 hash of string and converts to hex string.
            The same as Hash(..., "MD5") but much faster.
            </summary>
            <remarks>The hash is of UTF8 bytes, not of UTF16 bytes.</remarks>
        </member>
        <member name="M:Au.Convert_.Hash(System.Byte[],System.String)">
            <summary>
            Computes binary data hash using a specified cryptographic algorithm.
            </summary>
            <param name="a"></param>
            <param name="algorithm">Algorithm name, eg "SHA256". <see cref="T:System.Security.Cryptography.CryptoConfig"/></param>
        </member>
        <member name="M:Au.Convert_.Hash(System.String,System.String)">
            <summary>
            Computes string hash using a specified cryptographic algorithm.
            </summary>
            <param name="s"></param>
            <param name="algorithm">Algorithm name, eg "SHA256". <see cref="T:System.Security.Cryptography.CryptoConfig"/></param>
            <remarks>The hash is of UTF8 bytes, not of UTF16 bytes.</remarks>
        </member>
        <member name="M:Au.Convert_.HashHex(System.Byte[],System.String,System.Boolean)">
            <summary>
            Computes binary data hash using a specified cryptographic algorithm and converts to hex string.
            </summary>
            <param name="a"></param>
            <param name="algorithm">Algorithm name, eg "SHA256". <see cref="T:System.Security.Cryptography.CryptoConfig"/></param>
            <param name="upperCase">Let the hex string contain A-F, not a-f.</param>
        </member>
        <member name="M:Au.Convert_.HashHex(System.String,System.String,System.Boolean)">
            <summary>
            Computes string hash using a specified cryptographic algorithm and converts to hex string.
            </summary>
            <param name="s"></param>
            <param name="algorithm">Algorithm name, eg "SHA256". <see cref="T:System.Security.Cryptography.CryptoConfig"/></param>
            <param name="upperCase">Let the hex string contain A-F, not a-f.</param>
            <remarks>The hash is of UTF8 bytes, not of UTF16 bytes.</remarks>
        </member>
        <member name="M:Au.Convert_.HexEncode(System.Byte[],System.Boolean)">
            <summary>
            Converts binary data stored in byte[] to hex-encoded string.
            </summary>
            <param name="a">The data. Can be null, then returns null.</param>
            <param name="upperCase">Let the hex string contain A-F, not a-f.</param>
            <remarks>
            The result string length is 2 * array length.
            In most cases it's better to use <see cref="M:System.Convert.ToBase64String(System.Byte[])"/>, then result is 4/3 of array length. Both functions are fast.
            </remarks>
        </member>
        <member name="M:Au.Convert_.HexEncode(System.Void*,System.Int32,System.Boolean)">
            <summary>
            Converts binary data stored in any memory to hex-encoded string.
            </summary>
            <param name="data">The data. Can be any valid memory of specified size, for example a struct address. Can be null, then returns null.</param>
            <param name="size">data memory size (bytes).</param>
            <param name="upperCase">Let the hex string contain A-F, not a-f.</param>
        </member>
        <member name="M:Au.Convert_.HexDecode(System.String)">
            <summary>
            Converts hex-encoded string to binary data. Stores it in byte[].
            </summary>
            <param name="s">Hex-encoded string. Can be null, then returns null.</param>
            <remarks>
            Skips spaces and other non-hex-digit characters. Example: "01 23 46 67" is the same as "01234667".
            The number of hex-digit characters should be divisible by 2, else the last character is ignored.
            </remarks>
            <seealso cref="M:Au.Convert_.Base64Decode(System.String)"/>
        </member>
        <member name="M:Au.Convert_.HexDecode(System.String,System.Void*,System.Int32,System.Int32)">
            <summary>
            Converts hex-encoded string to binary data. Stores it in caller's memory buffer.
            Returns the number of bytes stored in resultBuffer memory. It is equal or less than Math.Min(bufferSize, (s.Length - stringStartIndex) / 2).
            </summary>
            <param name="s">Hex-encoded string. Can be null.</param>
            <param name="resultBuffer">Where to write the data. Can be any valid memory of specified size, for example a struct address.</param>
            <param name="bufferSize">resultBuffer memory size. Note: this function will damage process memory if using bad resultBuffer or bufferSize.</param>
            <param name="stringStartIndex">0 or index of first character of hex-encoded substring in s.</param>
            <remarks>
            Skips spaces and other non-hex-digit characters. Example: "01 23 46 67" is the same as "01234667".
            The number of hex-digit characters should be divisible by 2, else the last character is ignored.
            </remarks>
        </member>
        <member name="M:Au.Convert_.HexDecode(System.Char*,System.Int32,System.Void*,System.Int32)">
            <summary>
            The same as <see cref="M:Au.Convert_.HexDecode(System.String,System.Void*,System.Int32,System.Int32)"/> but the string can be an unmanaged UTF-16 string.
            </summary>
            <param name="s">UTF-16 string.</param>
            <param name="length">s length (characters).</param>
            <param name="resultBuffer"></param>
            <param name="bufferSize"></param>
        </member>
        <member name="M:Au.Convert_.Base64Decode(System.Char*,System.Int32,System.Void*,System.Int32)">
            <summary>
            Converts Base64 UTF-16 string to binary data (bytes). Stores it in caller's memory buffer.
            Returns the number of bytes stored in resultBuffer.
            </summary>
            <param name="s">Base64 string. Can be null if len is 0.</param>
            <param name="len">s length (characters).</param>
            <param name="resultBuffer">A memory buffer for the result bytes. Must be of at least bufferSize size, else this function will damage process memory.</param>
            <param name="bufferSize">resultBuffer buffer size (bytes). Must be at least (int)(len * 3L / 4), else exception.</param>
            <exception cref="T:System.ArgumentException">bufferSize too small.</exception>
            <remarks><inheritdoc cref="M:Au.Convert_.Base64Decode(System.String)"/></remarks>
        </member>
        <member name="M:Au.Convert_.Base64Decode(System.String)">
            <summary>
            Converts Base64 string to binary data (bytes).
            Returns byte[] containing the data.
            </summary>
            <param name="s">Base64 string. Can be null, then returns null.</param>
            <remarks>
            How this function is different than <see cref="M:System.Convert.FromBase64String(System.String)"/>:
            1. Allows (discards) non-base64 characters.
            2. Supports URL-safe characters: '-' for '+' and '_' for '/'.
            3. No exception when string length is not multiple of 4, eg if does not contain '=' characters for padding. 
            
            This library does not have Base64-encode functions. Use <see cref="M:System.Convert.ToBase64String(System.Byte[])"/>.
            </remarks>
        </member>
        <member name="M:Au.Convert_.GuidToBase64Filename(System.Guid)">
            <summary>
            Converts GUID to string that can be used in file paths and URLs.
            </summary>
            <param name="guid"></param>
            <remarks>
            Standard Base64 strings cannot be used in file paths and URLs, because can contain characters '/' and '+'. This function replaces them with '_' and '-'. Also trims "==" at the end.
            Such string can be parsed with <b>Convert_</b> class functions, not with <b>Convert</b> class functions.
            </remarks>
        </member>
        <member name="M:Au.Convert_.Compress(System.Byte[])">
            <summary>
            Compresses data using <see cref="T:System.IO.Compression.DeflateStream"/>.
            </summary>
            <param name="data"></param>
            <exception cref="T:System.Exception">Exceptions of DeflateStream.</exception>
        </member>
        <member name="M:Au.Convert_.Decompress(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decompresses data using <see cref="T:System.IO.Compression.DeflateStream"/>.
            Returns byte[] containing decompressed data.
            </summary>
            <param name="compressedData">Compressed data.</param>
            <param name="index">Start index of compressed data in the compressedData array.</param>
            <param name="count">Length of compressed data in the compressedData array.</param>
            <exception cref="T:System.Exception">Exceptions of DeflateStream.</exception>
        </member>
        <member name="M:Au.Convert_.Decompress(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decompresses data using <see cref="T:System.IO.Compression.DeflateStream"/>.
            Writes the decompressed data to a caller-provided memory stream.
            </summary>
            <param name="streamForDecompressedData">A memory stream where this function will write decompressed data. See example.</param>
            <param name="compressedData">Compressed data.</param>
            <param name="index">Start index of compressed data in the compressedData array.</param>
            <param name="count">Length of compressed data in the compressedData array.</param>
            <exception cref="T:System.Exception">Exceptions of DeflateStream.</exception>
            <example>
            This code is used by the other Decompress overload.
            <code><![CDATA[
            using(var stream = new MemoryStream()) {
            	Decompress(stream, compressedData, index, count);
            	return stream.ToArray();
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Convert_.Utf8LengthFromString(System.String)">
            <summary>
            Returns the number of bytes that would by produced by converting C# string to UTF8, not including the terminating '\0' character.
            </summary>
            <param name="s">C# string (UTF16). Can be null.</param>
        </member>
        <member name="M:Au.Convert_.Utf8FromString(System.String,System.Byte*,System.Int32)">
            <summary>
            Converts C# string to '\0'-terminated UTF8 string. Stores the UTF8 string in caller's buffer.
            Returns UTF8 string length in bytes, not including the terminating '\0' character.
            If fails (unlikely if passed correct arguments), returns 0 and sets buffer="".
            </summary>
            <param name="s">C# string (UTF16). Can be null.</param>
            <param name="buffer">Caller-allocated memory of bufLen length.</param>
            <param name="bufLen">buffer length in bytes. Should be at least <see cref="M:Au.Convert_.Utf8LengthFromString(System.String)"/>+1, else converts only part of string. The maximal possible required buffer length for whole string can be s.Length*3+1.</param>
            <remarks>
            Calls API <msdn>WideCharToMultiByte</msdn>.
            This is the most low-level and therefore fastest overload. Does not allocate any memory. With big strings much faster than .NET Encoding class functions.
            Use buffer/bufLen carefully. If bufLen is greater that the memory buffer length, other memory will be overwritten/damaged.
            </remarks>
        </member>
        <member name="M:Au.Convert_.Utf8FromString(System.String)">
            <summary>
            Converts C# string to '\0'-terminated UTF8 string.
            </summary>
            <param name="s">C# string (UTF16). If null, returns null.</param>
            <remarks>
            How this is different from .NET Encoding class functions: 1. Uses <msdn>WideCharToMultiByte</msdn>. 2. Faster with big strings. 3. The returned string is '\0'-terminated. 4. No exceptions (unless the string is so large that fails to allocate so much memory).
            </remarks>
        </member>
        <member name="M:Au.Convert_.LibUtf8FromString(System.String,System.WeakReference{System.Byte[]}@,System.Int32*,System.Int32)">
            <summary>
            Converts C# string to '\0'-terminated UTF8 string managed by a WeakReference variable.
            </summary>
            <param name="s">C# string (UTF16). If null, returns null, unless allocExtraBytes is not 0.</param>
            <param name="buffer">A WeakReference variable (probably [ThreadStatic]) that manages the returned array. If null, this function will create it.</param>
            <param name="utf8Length">If not null, receives UTF8 text length, not including '\0' and allocExtraBytes.</param>
            <param name="allocExtraBytes">Allocate this number of extra bytes after the string.</param>
        </member>
        <member name="M:Au.Convert_.Utf8ToStringLength(System.Byte*,System.Int32)">
            <summary>
            Returns the number of characters that would by produced by converting UTF8 to C# string.
            The terminating '\0' character is not included in the return value.
            </summary>
            <param name="utf8">UTF8 string. Can be null.</param>
            <param name="lengthBytes">Length of utf8 or part of it. If negative, the function finds utf8 length; then utf8 must be '\0'-terminated.</param>
            <remarks>
            Uses API <msdn>MultiByteToWideChar</msdn>.
            There is no overload that takes byte[], because for it can be used .NET Encoding class functions.
            </remarks>
        </member>
        <member name="M:Au.Convert_.Utf8ToString(System.Byte*,System.Int32)">
            <summary>
            Converts UTF8 string to C# string (which is UTF16).
            The terminating '\0' character is not included in the returned string.
            </summary>
            <param name="utf8">UTF8 string. If null, returns null.</param>
            <param name="lengthBytes">Length of utf8 or part of it. If negative, the function finds utf8 length; then utf8 must be '\0'-terminated.</param>
            <remarks>
            Uses API <msdn>MultiByteToWideChar</msdn>.
            There is no overload that takes byte[], because for it can be used .NET Encoding class functions. The speed is similar; this is slower with short strings but faster with long strings.
            </remarks>
        </member>
        <member name="T:Au.Debug_">
            <summary>
            Functions useful to debug code.
            </summary>
            <remarks>
            The Debug_.PrintX functions write to the same output as <see cref="M:Au.Output.Write(System.String)"/>, not to the trace listeners like <see cref="M:System.Diagnostics.Debug.Print(System.String)"/> etc do. Also they add caller's name, file and line number.
            Functions Print, PrintIf, PrintFunc and Dialog work only if DEBUG is defined, which normally is when the caller project is in Debug configuration. Else they are not called, and arguments not evaluated at run time. This is because they have [<see cref="T:System.Diagnostics.ConditionalAttribute"/>("DEBUG")].
            Note: when used in a library, the above functions depend on DEBUG of the library project and not on DEBUG of the consumer project of the library. For example, the library may be in Release configuration even if its consumer project is in Debug configuration. If your library wants to show some info only if its consumer project is in Debug config, instead you can use code like <c>if(Opt.Debug.Verbose) PrintWarning("text");</c>; see <see cref="M:Au.NoClass.PrintWarning(System.String,System.Int32,System.String)"/>, Opt.Debug.<see cref="P:Au.Types.OptDebug.Verbose" r=""/>.
            </remarks>
        </member>
        <member name="P:Au.Debug_.TextPrefix">
            <summary>
            Prefix for Debug_.Print, Debug_.PrintIf.
            Default is "Debug: ".
            </summary>
            <example>
            Blue text.
            <code><![CDATA[
            Debug_.TextPrefix = "<><c 0xff0000>"; Debug_.TextSuffix = "</c>";
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Debug_.TextSuffix">
            <summary>
            Suffix for Debug_.Print, Debug_.PrintIf.
            </summary>
            <seealso cref="P:Au.Debug_.TextPrefix"/>
        </member>
        <member name="M:Au.Debug_.Print(System.Object,System.String,System.Int32,System.String)">
            <summary>
            Calls <see cref="M:Au.Output.Write(System.String)"/> to show some debug info. Also shows current function name/file/line.
            Works only if DEBUG is defined. Read more in class help.
            The 3 optional arguments are not used explicitly.
            </summary>
        </member>
        <member name="M:Au.Debug_.PrintIf(System.Boolean,System.Object,System.String,System.Int32,System.String)">
            <summary>
            If condition is true, calls <see cref="M:Au.Output.Write(System.String)"/> to show some debug info. Also shows current function name/file/line.
            Works only if DEBUG is defined. Read more in class help.
            The 3 optional arguments are not used explicitly.
            </summary>
        </member>
        <member name="M:Au.Debug_.PrintFunc(System.String)">
            <summary>
            Calls <see cref="M:Au.Output.Write(System.String)"/> with current function name.
            Works only if DEBUG is defined. Read more in class help.
            The optional argument is not used explicitly.
            </summary>
        </member>
        <member name="M:Au.Debug_.Dialog(System.Object,System.String,System.Int32,System.String)">
            <summary>
            Calls <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String)"/> to show some debug info.
            Works only if DEBUG is defined. Read more in class help.
            The 3 optional arguments are not used explicitly.
            </summary>
        </member>
        <member name="M:Au.Debug_.LibCheckFlagsOpt``1(``0,``0)">
            <summary>
            Checks flags and throws ArgumentException if some flags are invalid. The message includes valid flag names.
            </summary>
            <param name="flags">Flags to check.</param>
            <param name="goodFlags">Valid flags.</param>
            <typeparam name="T">The enum type used for flags.</typeparam>
            <remarks>
            Can be used in functions that have an enum flags parameter but not all passed flags are valid for that function or object state.
            Does nothing if Opt.Debug.<see cref="P:Au.Types.OptDebug.Verbose" r=""/> == false.
            When flags are valid, this function is very fast (inline, no calls).
            </remarks>
        </member>
        <member name="P:Au.Debug_.IsAuDebugConfiguration">
            <summary>
            Returns true if using Debug configuration of Au.dll.
            </summary>
        </member>
        <member name="M:Au.Debug_.LibMemoryGet(System.Boolean)">
            <summary>
            Returns managed memory size as formatted string. Uses GC.GetTotalMemory.
            Works in Release too.
            </summary>
            <param name="fromAnchor">Get the difference from previous call to <b>LibMemorySetAnchor</b>.</param>
        </member>
        <member name="M:Au.Debug_.LibMemoryPrint(System.Boolean)">
            <summary>
            Prints managed memory size. Uses GC.GetTotalMemory.
            Works in Release too.
            </summary>
            <param name="fromAnchor">Get the difference from previous call to <b>LibMemorySetAnchor</b>.</param>
        </member>
        <member name="M:Au.Debug_.LibMemorySetAnchor">
            <summary>
            Memorizes current managed memory size, so that next call to another <b>LibMemoryX</b> function with fromAnchor=true (default) will get memory size difference from current memory size.
            </summary>
        </member>
        <member name="T:Au.Process_">
            <summary>
            Process functions. Extends <see cref="T:System.Diagnostics.Process"/>.
            </summary>
        </member>
        <member name="M:Au.Process_.GetName(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Gets process executable file name (like "notepad.exe") or full path.
            Returns null if fails.
            </summary>
            <param name="processId">Process id.</param>
            <param name="fullPath">
            Get full path.
            Note: Fails to get full path if the process belongs to another user session, unless current process is running as administrator; also fails to get full path of some system processes.
            </param>
            <param name="noSlowAPI">When the fast API QueryFullProcessImageName fails, don't try to use another much slower API WTSEnumerateProcesses. Not used if <paramref name="fullPath"/> is true.</param>
            <seealso cref="P:Au.Wnd.ProgramName"/>
            <seealso cref="P:Au.Wnd.ProgramFilePath"/>
            <seealso cref="P:Au.Wnd.ProcessId"/>
        </member>
        <member name="M:Au.Process_.LibProcessInfo.GetName(System.Boolean)">
            <summary>
            Gets process executable file name (like "notepad.exe"). Not full path.
            If contains looks like a DOS path and !cannotOpen, tries to unexpand DOS path.
            Don't call multiple times, because always converts from raw char*.
            </summary>
        </member>
        <member name="M:Au.Process_.AllProcesses(System.Boolean)">
            <summary>
            Gets basic info of all processes: name, id, session id.
            </summary>
            <param name="ofThisSession">Get processes only of this user session (skip services etc).</param>
            <exception cref="T:Au.Types.AuException">Failed. Unlikely.</exception>
        </member>
        <member name="M:Au.Process_.GetProcessIds(System.String,System.Boolean,System.Boolean)">
            <summary>
            Gets process ids of all processes of the specified program.
            Returns array containing 0 or more elements.
            </summary>
            <param name="processName">
            Process executable file name, like "notepad.exe".
            String format: <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">wildcard expression</conceptualLink>.
            </param>
            <param name="fullPath">
            <paramref name="processName"/> is full path.
            Note: Fails to get full path if the process belongs to another user session, unless current process is running as administrator; also fails to get full path of some system processes.
            </param>
            <param name="ofThisSession">Get processes only of this user session.</param>
            <exception cref="T:System.ArgumentException">
            processName is "" or null.
            Invalid wildcard expression ("**options " or regular expression).
            </exception>
        </member>
        <member name="M:Au.Process_.GetProcessId(System.String,System.Boolean,System.Boolean)">
            <inheritdoc cref="M:Au.Process_.GetProcessIds(System.String,System.Boolean,System.Boolean)"/>
            <summary>
            Gets process id of the first found process of the specified program.
            Returns 0 if not found.
            </summary>
        </member>
        <member name="P:Au.Process_.CurrentProcessId">
            <summary>
            Calls API <msdn>GetCurrentProcessId</msdn>.
            </summary>
        </member>
        <member name="P:Au.Process_.CurrentProcessHandle">
            <summary>
            Returns current process handle.
            Calls API <msdn>GetCurrentProcess</msdn>.
            Don't need to close the handle.
            </summary>
        </member>
        <member name="M:Au.Process_.ProcessIdFromHandle(System.IntPtr)">
            <summary>
            Gets process id from handle.
            Returns 0 if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            Calls API <msdn>GetProcessId</msdn>.
            </summary>
            <param name="processHandle">Process handle.</param>
        </member>
        <member name="M:Au.Process_.GetSessionId(System.Int32)">
            <summary>
            Gets user session id of process.
            Returns -1 if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            Calls API <msdn>ProcessIdToSessionId</msdn>.
            </summary>
            <param name="processId">Process id.</param>
        </member>
        <member name="P:Au.Process_.CurrentSessionId">
            <summary>
            Gets user session id of this process.
            Calls API <msdn>ProcessIdToSessionId</msdn> and <msdn>GetCurrentProcessId</msdn>.
            </summary>
        </member>
        <member name="M:Au.Process_.GetVersionInfo(System.Int32)">
            <summary>
            Gets version info of process executable file.
            Return null if fails.
            </summary>
            <param name="processId">Process id.</param>
        </member>
        <member name="M:Au.Process_.GetDescription(System.Int32)">
            <summary>
            Gets description of process executable file.
            Return null if fails.
            </summary>
            <param name="processId">Process id.</param>
            <remarks>
            Calls <see cref="M:Au.Process_.GetVersionInfo(System.Int32)"/> and <see cref="P:System.Diagnostics.FileVersionInfo.FileDescription"/>.
            </remarks>
        </member>
        <member name="T:Au.Process_.LibProcessHandle">
            <summary>
            Opens and manages a process handle.
            Must be disposed.
            </summary>
        </member>
        <member name="P:Au.Process_.LibProcessHandle.Handle">
            
        </member>
        <member name="P:Au.Process_.LibProcessHandle.Is0">
            
        </member>
        <member name="M:Au.Process_.LibProcessHandle.Dispose">
            
        </member>
        <member name="M:Au.Process_.LibProcessHandle.#ctor(System.IntPtr)">
            <summary>
            Attaches a kernel handle to this new variable.
            No exception when handle is invalid.
            </summary>
            <param name="handle"></param>
        </member>
        <member name="M:Au.Process_.LibProcessHandle.FromId(System.Int32,System.UInt32)">
            <summary>
            Opens process handle.
            Calls API OpenProcess.
            Returns null if fails. Supports Native.GetError().
            </summary>
            <param name="processId">Process id.</param>
            <param name="desiredAccess">Desired access (Api.PROCESS_), as documented in MSDN -> OpenProcess.</param>
        </member>
        <member name="M:Au.Process_.LibProcessHandle.FromWnd(Au.Wnd,System.UInt32)">
            <summary>
            Opens window's process handle.
            This overload is more powerful: if API OpenProcess fails, it tries GetProcessHandleFromHwnd, which can open higher integrity level processes, but only if current process is uiAccess and desiredAccess includes only PROCESS_DUP_HANDLE, PROCESS_VM_OPERATION, PROCESS_VM_READ, PROCESS_VM_WRITE, SYNCHRONIZE.
            Returns null if fails. Supports Native.GetError().
            </summary>
            <param name="w"></param>
            <param name="desiredAccess">Desired access (Api.PROCESS_), as documented in MSDN -> OpenProcess.</param>
        </member>
        <member name="T:Au.Process_.LibProcessWaitHandle">
            <summary>
            Process handle that is derived from WaitHandle.
            When don't need to wait, use LibProcessHandle, it's more lightweight and has more creation methods.
            </summary>
        </member>
        <member name="T:Au.Process_.Memory">
            <summary>
            Allocates, writes and reads memory in other process.
            </summary>
            <remarks>
            Objects of this class must be disposed. Example: <c>using(var pm=new Process_.Memory(...)) { ... }</c>.
            </remarks>
        </member>
        <member name="M:Au.Process_.Memory.Finalize">
            
        </member>
        <member name="M:Au.Process_.Memory.Dispose">
            
        </member>
        <member name="P:Au.Process_.Memory.ProcessHandle">
            <summary>
            Process handle.
            Opened with access PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE.
            </summary>
        </member>
        <member name="P:Au.Process_.Memory.Mem">
            <summary>
            Address of memory allocated in that process.
            </summary>
            <remarks>
            The address is invalid in this process.
            </remarks>
        </member>
        <member name="M:Au.Process_.Memory.SetMem(System.IntPtr,System.Boolean)">
            <summary>
            Sets an address of memory in that process that is to be used by the read and write functions.
            </summary>
            <param name="mem">A memory address in that process.</param>
            <param name="freeWhenDisposing">
            Let the Dispose method (or finalizer) call API <msdn>VirtualFreeEx</msdn> to free mem. The memory must be allocated with API <msdn>VirtualAllocEx</msdn> (by any process) or <msdn>VirtualAlloc</msdn> (by that process).
            If false, mem can be any memory in that process, and this variable will not free it. Alternatively you can use <see cref="M:Au.Process_.Memory.ReadOther(System.IntPtr,System.Void*,System.Int32)"/> and <see cref="M:Au.Process_.Memory.WriteOther(System.IntPtr,System.Void*,System.Int32)"/>.</param>
            <exception cref="T:System.InvalidOperationException">This variable already has Mem, unless it was set by this function with <paramref name="freeWhenDisposing"/> = false.</exception>
            <remarks>
            This function can be used if this variable was created with <i>nBytes</i> = 0. Else exception. Also exception if this function previously called with <paramref name="freeWhenDisposing"/> = true.
            </remarks>
        </member>
        <member name="M:Au.Process_.Memory.#ctor(Au.Wnd,System.Int32)">
            <summary>
            Opens window's process handle and optionally allocates memory in that process.
            </summary>
            <param name="w">A window in that process.</param>
            <param name="nBytes">If not 0, allocates this number of bytes of memory in that process.</param>
            <remarks>This is the preferred constructor when the process has windows. It works with windows of <see cref="T:Au.Process_.UacInfo">UAC</see> High integrity level when this process is Medium+uiAccess.</remarks>
            <exception cref="T:Au.Types.WndException">w invalid.</exception>
            <exception cref="T:Au.Types.AuException">Failed to open process handle (usually because of UAC) or allocate memory.</exception>
        </member>
        <member name="M:Au.Process_.Memory.#ctor(System.Int32,System.Int32)">
            <summary>
            Opens window's process handle and optionally allocates memory in that process.
            </summary>
            <param name="processId">Process id.</param>
            <param name="nBytes">If not 0, allocates this number of bytes of memory in that process.</param>
            <exception cref="T:Au.Types.AuException">Failed to open process handle (usually because of <see cref="T:Au.Process_.UacInfo">UAC</see>) or allocate memory.</exception>
        </member>
        <member name="M:Au.Process_.Memory.WriteUnicodeString(System.String,System.Int32)">
            <summary>
            Copies a string from this process to the memory allocated in that process by the constructor.
            In that process the string is written as '\0'-terminated UTF-16 string. For it is used (s.Length+1)*2 bytes of memory in that process (+1 for the '\0', *2 because UTF-16 character size is 2 bytes).
            Returns false if fails.
            </summary>
            <param name="s">A string in this process.</param>
            <param name="offsetBytes">Offset in the memory allocated by the constructor.</param>
        </member>
        <member name="M:Au.Process_.Memory.WriteAnsiString(System.String,System.Int32,System.Text.Encoding)">
            <summary>
            Copies a string from this process to the memory allocated in that process by the constructor.
            In that process the string is written as '\0'-terminated ANSI string, in default or specified encoding.
            Returns false if fails.
            </summary>
            <param name="s">A string in this process. Normal C# string (UTF-16), not ANSI.</param>
            <param name="offsetBytes">Offset in the memory allocated by the constructor.</param>
            <param name="enc">If null, uses system's default ANSI encoding.</param>
        </member>
        <member name="M:Au.Process_.Memory.ReadUnicodeString(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Copies a string from the memory in that process allocated by the constructor to this process.
            Returns the copied string, or null if fails.
            In that process the string must be in Unicode UTF-16 format (ie not ANSI).
            </summary>
            <param name="nChars">Number of characters to copy. In both processes a character is 2 bytes.</param>
            <param name="offsetBytes">Offset in the memory allocated by the constructor.</param>
            <param name="findLength">Find true string length by searching for '\0' character in nChars range. If false, the returned string is of nChars length even if contains '\0' characters.</param>
        </member>
        <member name="M:Au.Process_.Memory.LibReadUnicodeStringCached(System.Int32,System.Int32,System.Boolean)">
            <summary>
            The same as <see cref="M:Au.Process_.Memory.ReadUnicodeString(System.Int32,System.Int32,System.Boolean)"/> but uses our StringCache.
            </summary>
        </member>
        <member name="M:Au.Process_.Memory.ReadAnsiString(System.Int32,System.Int32,System.Boolean,System.Text.Encoding)">
            <summary>
            Copies a string from the memory in that process allocated by the constructor to this process.
            Returns the copies string, or null if fails.
            In that process the string must be in ANSI format (ie not Unicode UTF-16).
            </summary>
            <param name="nBytes">Number bytes to copy. In that process a character is 1 or more bytes (depending on encoding). In this process will be 2 bytes (normal C# string).</param>
            <param name="offsetBytes">Offset in the memory allocated by the constructor.</param>
            <param name="findLength">Find true string length by searching for '\0' character in nBytes range of the ANSI string.</param>
            <param name="enc">If null, uses system's default ANSI encoding.</param>
        </member>
        <member name="M:Au.Process_.Memory.Write(System.Void*,System.Int32,System.Int32)">
            <summary>
            Copies a value-type variable or other memory from this process to the memory in that process allocated by the constructor.
            Returns false if fails.
            </summary>
            <param name="ptr">Unsafe address of a value type variable or other memory in this process.</param>
            <param name="nBytes">Number of bytes to copy.</param>
            <param name="offsetBytes">Offset in the memory allocated by the constructor.</param>
        </member>
        <member name="M:Au.Process_.Memory.WriteOther(System.IntPtr,System.Void*,System.Int32)">
            <summary>
            Copies a value-type variable or other memory from this process to a known memory address in that process.
            Returns false if fails.
            </summary>
            <param name="ptrDestinationInThatProcess">Memory address in that process where to copy memory from this process.</param>
            <param name="ptr">Unsafe address of a value type variable or other memory in this process.</param>
            <param name="nBytes">Number of bytes to copy.</param>
            <seealso cref="M:Au.Process_.Memory.SetMem(System.IntPtr,System.Boolean)"/>
        </member>
        <member name="M:Au.Process_.Memory.Read(System.Void*,System.Int32,System.Int32)">
            <summary>
            Copies from the memory in that process allocated by the constructor to a value-type variable or other memory in this process.
            Returns false if fails.
            </summary>
            <param name="ptr">Unsafe address of a value type variable or other memory in this process.</param>
            <param name="nBytes">Number of bytes to copy.</param>
            <param name="offsetBytes">Offset in the memory allocated by the constructor.</param>
        </member>
        <member name="M:Au.Process_.Memory.ReadOther(System.IntPtr,System.Void*,System.Int32)">
            <summary>
            Copies from a known memory address in that process to a value-type variable or other memory in this process.
            Returns false if fails.
            </summary>
            <param name="ptrSourceInThatProcess">Memory address in that process from where to copy memory.</param>
            <param name="ptr">Unsafe address of a value type variable or other memory in this process.</param>
            <param name="nBytes">Number of bytes to copy.</param>
            <seealso cref="M:Au.Process_.Memory.SetMem(System.IntPtr,System.Boolean)"/>
        </member>
        <member name="T:Au.Process_.UacInfo">
            <summary>
            Holds an access token (security info) of a process and provides various security info, eg UAC integrity level.
            </summary>
        </member>
        <member name="M:Au.Process_.UacInfo.Finalize">
            
        </member>
        <member name="M:Au.Process_.UacInfo.Dispose">
            
        </member>
        <member name="P:Au.Process_.UacInfo.UnsafeTokenHandle">
            <summary>
            The access token handle.
            </summary>
            <remarks>
            The handle is managed by this variable and will be closed when disposing or GC-collecting it. Use <see cref="M:System.GC.KeepAlive(System.Object)"/> where need.
            </remarks>
        </member>
        <member name="P:Au.Process_.UacInfo.Failed">
            <summary>
            Returns true if the last called property function failed.
            Normally it should never fail. Only <see cref="M:Au.Process_.UacInfo.GetOfProcess(System.Int32)"/> can fail (then it returns null).
            </summary>
        </member>
        <member name="T:Au.Process_.UacInfo.IL">
            <summary>
            <see cref="P:Au.Process_.UacInfo.IntegrityLevel"/>.
            </summary>
            <tocexclude />
        </member>
        <member name="T:Au.Process_.UacInfo.ElevationType">
            <summary>
            <see cref="P:Au.Process_.UacInfo.Elevation"/>.
            </summary>
            <tocexclude />
        </member>
        <member name="P:Au.Process_.UacInfo.Elevation">
            <summary>
            Gets the <see cref="T:Au.Process_.UacInfo">UAC</see> elevation type of the process.
            Elevation types:
            Full - runs as administrator (High or System integrity level).
            Limited - runs as standard user (Medium, Medium+UIAccess or Low integrity level) on administrator user session.
            Default - all processes in this user session run as admin, or all as standard user. Can be: non-administrator user session; service session; UAC is turned off.
            Unknown - failed to get. Normally it never happens; only <see cref="M:Au.Process_.UacInfo.GetOfProcess(System.Int32)"/> can fail (then it returns null).
            This property is rarely useful. Instead use other properties of this class.
            </summary>
        </member>
        <member name="P:Au.Process_.UacInfo.IsUIAccess">
            <summary>
            Returns true if the process has <see cref="T:Au.Process_.UacInfo">uiAccess</see> property.
            A uiAccess process can access/automate all windows of processes running in the same user session.
            Most processes don't have this property. They cannot access/automate windows of higher integrity level (High, System, uiAccess) processes and Windows 8 store apps. For example, cannot send keys and Windows messages.
            Note: High IL (admin) processes also can have this property, therefore <c>IsUIAccess</c> is not the same as <c>IntegrityLevelAndUIAccess==IL.UIAccess</c> (<see cref="P:Au.Process_.UacInfo.IntegrityLevelAndUIAccess"/> returns <b>UIAccess</b> only for Medium+uiAccess processes; for High+uiAccess processes it returns <b>High</b>). Some Windows API work slightly differently with uiAccess and non-uiAccess admin processes.
            This property is rarely useful. Instead use other properties of this class.
            </summary>
        </member>
        <member name="P:Au.Process_.UacInfo.IntegrityLevel">
            <summary>
            Gets the <see cref="T:Au.Process_.UacInfo">UAC</see> integrity level (IL) of the process.
            IL from lowest to highest value:
            	<b>Untrusted</b> - the most limited rights. Very rare.
            	<b>Low</b> - very limited rights. Used by Internet Explorer tab processes, Windows Store apps.
            	<b>Medium</b> - limited rights. Most processes (unless UAC turned off).
            	<b>UIAccess</b> - Medium IL + can access/automate High IL windows (user interface).
            		Note: Only the <see cref="P:Au.Process_.UacInfo.IntegrityLevelAndUIAccess"/> property can return <b>UIAccess</b>. This property returns <b>High</b> instead (the same as in Process Explorer).
            	<b>High</b> - most rights. Processes that run as administrator.
            	<b>System</b> - almost all rights. Services, some system processes.
            	<b>Protected</b> - undocumented. Rare.
            	<b>Unknown</b> - failed to get IL. Unlikely.
            The IL enum member values can be used like <c>if(x.IntegrityLevel > IL.Medium) ...</c> .
            If UAC is turned off, most non-service processes on administrator account have High IL; on non-administrator - Medium.
            </summary>
        </member>
        <member name="P:Au.Process_.UacInfo.IntegrityLevelAndUIAccess">
            <summary>
            The same as <see cref="P:Au.Process_.UacInfo.IntegrityLevel"/>, but can return <b>UIAccess</b>.
            </summary>
        </member>
        <member name="M:Au.Process_.UacInfo.GetOfProcess(System.Int32)">
            <summary>
            Opens process access token and creates/returns new <see cref="T:Au.Process_.UacInfo"/> variable that holds it. Then you can use its properties.
            Returns null if failed. For example fails for services and some other processes if current process is not administrator.
            To get <b>UacInfo</b> of this process, instead use <see cref="P:Au.Process_.UacInfo.ThisProcess"/>.
            </summary>
            <param name="processId">Process id. If you have a window, use <see cref="P:Au.Wnd.ProcessId"/>.</param>
        </member>
        <member name="P:Au.Process_.UacInfo.ThisProcess">
            <summary>
            Gets <see cref="T:Au.Process_.UacInfo"/> variable for this process.
            </summary>
        </member>
        <member name="P:Au.Process_.UacInfo.IsAdmin">
            <summary>
            Returns true if this process is running as administrator, ie if the user belongs to the local Administrators group and the process is not limited by <see cref="T:Au.Process_.UacInfo">UAC</see>.
            This function for example can be used to check whether you can write to protected locations in the file system and registry.
            </summary>
        </member>
        <member name="P:Au.Process_.UacInfo.IsUacDisabled">
            <summary>
            Returns true if <see cref="T:Au.Process_.UacInfo">UAC</see> is disabled (turned off) on this Windows 7 computer.
            On Windows 8 and 10 UAC cannot be disabled, although you can disable UAC elevation consent dialogs.
            </summary>
        </member>
        <member name="T:Au.AuDialog">
            <summary>
            Standard dialogs to show information or get user input.
            </summary>
            <remarks>
            You can use static functions (less code) or create class instances (more options).
            More info: <see cref="M:Au.AuDialog.ShowEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            
            Uses task dialog API <msdn>TaskDialogIndirect</msdn>.
            
            Cannot be used in services. Instead use <b>MessageBox.Show</b> with option ServiceNotification or DefaultDesktopOnly, or API <msdn>MessageBox</msdn> with corresponding flags.
            </remarks>
            <example>
            This example creates a class instance, sets properties, shows dialog, uses events, uses result.
            <code><![CDATA[
            var d = new AuDialog(); //info: another constructor has the same parameters as ShowEx
            d.SetText("Main text.", "More text.\nSupports &lt;A HREF=\"link data\"&gt;links&lt;/A&gt; if you subscribe to HyperlinkClicked event.");
            d.SetButtons("1 OK|2 Cancel|3 Custom|4 Custom2");
            d.SetIcon(DIcon.Warning);
            d.SetExpandedText("Expanded info\nand more info.", true);
            d.FlagCanBeMinimized = true;
            d.SetRadioButtons("1 r1|2 r2");
            d.SetCheckbox("Check");
            d.SetTimeout(30, "OK");
            d.HyperlinkClicked += e =&gt; { AuDialog.Show("link clicked", e.LinkHref, owner: e.hwnd); };
            d.ButtonClicked += e =&gt; { Print(e.Button); if(e.Button == 4) e.DoNotCloseDialog = true; };
            d.FlagShowProgressBar = true; d.Timer += e =&gt; { e.dialog.Send.Progress(e.TimerTimeMS / 100); };
            var r = d.ShowDialog();
            Print(r);
            switch(r.Button) { case 1: Print("OK"); break; case DResult.Timeout: Print("timeout"); break; }
            ]]></code>
            </example>
        </member>
        <member name="T:Au.AuDialog.Options">
            <summary>
            Default options used by <see cref="T:Au.AuDialog"/> class functions.
            </summary>
        </member>
        <member name="P:Au.AuDialog.Options.DefaultTitle">
            <summary>
            Default title bar text.
            Default value - current appdomain name. In exe it is exe file name like "example.exe".
            </summary>
        </member>
        <member name="P:Au.AuDialog.Options.RtlLayout">
            <summary>
            Right-to-left layout.
            </summary>
            <seealso cref="P:Au.AuDialog.FlagRtlLayout"/>
        </member>
        <member name="P:Au.AuDialog.Options.TopmostIfNoOwnerWindow">
            <summary>
            If there is no owner window, let the dialog be always on top of most other windows.
            </summary>
            <seealso cref="P:Au.AuDialog.FlagTopmost"/>
        </member>
        <member name="P:Au.AuDialog.Options.DefaultScreen">
            <summary>
            Show dialogs on this screen when screen is not explicitly specified (<see cref="P:Au.AuDialog.Screen"/>) and there is no owner window.
            If screen index is invalid, the 'show' method shows warning, no exception.
            </summary>
        </member>
        <member name="P:Au.AuDialog.Options.UseAppIcon">
            <summary>
            If icon not specified, use <see cref="F:Au.Types.DIcon.App"/>.
            </summary>
        </member>
        <member name="P:Au.AuDialog.Options.AutoOwnerWindow">
            <summary>
            If owner window not specified, use the active window of current thread as owner window (disable it, etc).
            </summary>
            <seealso cref="M:Au.AuDialog.SetOwnerWindow(Au.Types.AnyWnd,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.AuDialog.#ctor">
            
        </member>
        <member name="M:Au.AuDialog.#ctor(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})">
            <summary>
            Initializes a new <see cref="T:Au.AuDialog"/> instance and sets main properties.
            Parameters etc are of <see cref="M:Au.AuDialog.ShowEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </summary>
        </member>
        <member name="M:Au.AuDialog.SetTitleBarText(System.String)">
            <summary>
            Changes title bar text.
            If you don't call this method or title is null or "", dialogs will use <see cref="P:Au.AuDialog.Options.DefaultTitle"/>.
            </summary>
        </member>
        <member name="M:Au.AuDialog.SetText(System.String,System.String)">
            <summary>
            Sets text.
            </summary>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Text below main instruction.</param>
        </member>
        <member name="M:Au.AuDialog.SetIcon(Au.Types.DIcon)">
            <summary>
            Sets common icon.
            </summary>
            <param name="icon"></param>
        </member>
        <member name="M:Au.AuDialog.SetIcon(System.Drawing.Icon)">
            <summary>
            Sets custom icon.
            </summary>
            <param name="icon">
            Icon of size 32 or 16.
            Don't dispose it until the dialog is closed.
            </param>
        </member>
        <member name="M:Au.AuDialog._Buttons.MarshalButtons(Au.AuDialog.TASKDIALOGCONFIG@)">
            <summary>
            Sets c.pButtons, c.cButtons, c.pRadioButtons and c.cRadioButtons.
            Later call MarshalFreeButtons.
            </summary>
        </member>
        <member name="M:Au.AuDialog._Buttons.MarshalFreeButtons(Au.AuDialog.TASKDIALOGCONFIG@)">
            <summary>
            Frees memory allocated by MarshalButtons and sets the c members to null/0.
            </summary>
        </member>
        <member name="M:Au.AuDialog.SetButtons(System.String,System.Boolean,Au.Types.MultiString)">
            <summary>
            Sets common and/or custom buttons and custom buttons style.
            </summary>
            <param name="buttons">
            Common and/or custom buttons, like with <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String)"/>.
            These ids should be negative if you use <paramref name="customButtons"/> too, because ids of <paramref name="customButtons"/> are 1, 2, ... .
            </param>
            <param name="asCommandLinks">Custom buttons style. If false - row of classic buttons. If true - column of command-link buttons that can have multiline text.</param>
            <param name="customButtons">
            Additional custom buttons. All will be custom, even if named "OK" etc.
            List of labels without ids. Can be string like "One|Two|..." or or string[] or List&lt;string&gt;.
            Button ids will be 1, 2, ... .
            <see cref="P:Au.AuDialog.DefaultButton"/> will be 1. You can change it later.
            </param>
        </member>
        <member name="P:Au.AuDialog.DefaultButton">
            <summary>
            Specifies which button responds to the Enter key.
            If 0 or not set, auto-selects.
            </summary>
            <value>Button id.</value>
        </member>
        <member name="M:Au.AuDialog.SetRadioButtons(System.String,System.Int32)">
            <summary>
            Adds radio buttons.
            To get selected radio button id after closing the dialog, use the RadioButton property of the <see cref="T:Au.Types.DResult"/> variable returned by <see cref="M:Au.AuDialog.ShowDialog"/> or the <see cref="P:Au.AuDialog.Result"/> property.
            </summary>
            <param name="buttons">A list of strings "id text" separated by |, like "1 One|2 Two|3 Three".</param>
            <param name="defaultId">Check the radio button that has this id. If omitted or 0, checks the first. If negative, does not check.</param>
        </member>
        <member name="M:Au.AuDialog.SetCheckbox(System.String,System.Boolean)">
            <summary>
            Adds check box (if text is not null/empty).
            To get check box state after closing the dialog, use the IsChecked property of the <see cref="T:Au.Types.DResult"/> variable returned by <see cref="M:Au.AuDialog.ShowDialog"/> or the <see cref="P:Au.AuDialog.Result"/> property.
            </summary>
        </member>
        <member name="M:Au.AuDialog.SetExpandedText(System.String,System.Boolean)">
            <summary>
            Adds text that the user can show and hide.
            </summary>
            <param name="text">Text.</param>
            <param name="showInFooter">Show the text at the bottom of the dialog.</param>
        </member>
        <member name="M:Au.AuDialog.SetExpandControl(System.Boolean,System.String,System.String)">
            <summary>
            Set properties of the control that shows and hides text added by <see cref="M:Au.AuDialog.SetExpandedText(System.String,System.Boolean)"/>.
            </summary>
            <param name="defaultExpanded"></param>
            <param name="collapsedText"></param>
            <param name="expandedText"></param>
        </member>
        <member name="M:Au.AuDialog.SetFooterText(System.String)">
            <summary>
            Adds text and common icon at the bottom of the dialog.
            </summary>
            <param name="text">Text, optionally preceded by an icon character and |, like "i|Text". Icons: x error, ! warning, i info, v shield, a app.</param>
        </member>
        <member name="M:Au.AuDialog.SetFooterText(System.String,Au.Types.DIcon)">
            <summary>
            Adds text and common icon at the bottom of the dialog.
            </summary>
            <param name="text">Text.</param>
            <param name="icon"></param>
        </member>
        <member name="M:Au.AuDialog.SetFooterText(System.String,System.Drawing.Icon)">
            <summary>
            Adds text and custom icon at the bottom of the dialog.
            </summary>
            <param name="text">Text.</param>
            <param name="icon">Icon of size 16. Read more: <see cref="M:Au.AuDialog.SetIcon(System.Drawing.Icon)"/>.</param>
        </member>
        <member name="M:Au.AuDialog.SetEditControl(Au.Types.DEdit,System.Object)">
            <summary>
            Adds Edit or Combo control (if editType is not DEdit.None (0)).
            To get its text after closing the dialog, use the EditText property of the <see cref="T:Au.Types.DResult"/> variable returned by <see cref="M:Au.AuDialog.ShowDialog"/> or the <see cref="P:Au.AuDialog.Result"/> property.
            </summary>
            <param name="editType">Control type/style.</param>
            <param name="editText">Initial text. If editType is DEdit.Combo, it can be a string array, List or IEnumerable; the first item sets combo-box editable text, other items - combo box drop-down list items.</param>
            <remarks>
            The API TaskDialogIndirect does not have an option to add an edit control. This class itself creates it.
            Does not support progress bar.
            </remarks>
        </member>
        <member name="P:Au.AuDialog.Width">
            <summary>
            Sets the width of the dialog's client area.
            The actual width will depend on DPI (the Windows "text size" setting).
            If less than default width, will be used default width.
            </summary>
            <seealso cref="F:Au.Types.DFlags.Wider"/>
        </member>
        <member name="M:Au.AuDialog.SetOwnerWindow(Au.Types.AnyWnd,System.Boolean,System.Boolean)">
            <summary>
            Sets owner window.
            The owner window will be disabled, and this dialog will be on top of it.
            This window will be in owner's screen, if screen was not explicitly specified with the <see cref="P:Au.AuDialog.Screen"/> property. <see cref="P:Au.AuDialog.Options.DefaultScreen"/> is ignored.
            </summary>
            <param name="owner">Owner window, or one of its child/descendant controls. Can be Control (eg Form) or Wnd (window handle). Can be null.</param>
            <param name="ownerCenter">Show the dialog in the center of the owner window. <see cref="M:Au.AuDialog.SetXY(Au.Types.Coord,Au.Types.Coord,System.Boolean)"/> and <see cref="P:Au.AuDialog.Screen"/> are ignored.</param>
            <param name="doNotDisable">Don't disable the owner window. If false, disables if it belongs to this thread.</param>
            <seealso cref="P:Au.AuDialog.Options.AutoOwnerWindow"/>
        </member>
        <member name="M:Au.AuDialog.SetXY(Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Sets dialog position in screen.
            </summary>
            <param name="x">X position in <see cref="P:Au.AuDialog.Screen"/>. If default(Coord) - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="y">Y position in <see cref="P:Au.AuDialog.Screen"/>. If default(Coord) - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="rawXY">x y are relative to the primary screen (ignore <see cref="P:Au.AuDialog.Screen"/> etc). Don't ensure that entire window is in screen.</param>
        </member>
        <member name="P:Au.AuDialog.Screen">
            <summary>
            Sets the screen (display monitor) where to show the dialog in multi-screen environment.
            If null or not set, will be used owner window's screen or <see cref="P:Au.AuDialog.Options.DefaultScreen"/>.
            If screen index is invalid, the 'show' method shows warning, no exception.
            More info: <see cref="T:Au.Types.Screen_"/>, <see cref="M:Au.Wnd.MoveInScreen(Au.Types.Coord,Au.Types.Coord,Au.Types.Screen_,System.Boolean,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Au.AuDialog.SetTimeout(System.Int32,System.String,System.Boolean)">
            <summary>
            Let the dialog close itself after closeAfterS seconds.
            On timeout ShowDialog returns DResult.Timeout.
            Example: <c>d.SetTimeout(30, "OK");</c>
            </summary>
        </member>
        <member name="P:Au.AuDialog.FlagXCancel">
            <summary>
            Allow to cancel even if there is no Cancel button.
            It adds X (Close) button to the title bar, and also allows to close the dialog with the Esc key.
            When the dialog is closed with the X button or Esc, the returned result button id is 0 if there is no Cancel button; else the same as when clicked the Cancel button.
            The same as <see cref="F:Au.Types.DFlags.XCancel"/>.
            </summary>
        </member>
        <member name="P:Au.AuDialog.FlagRtlLayout">
            <summary>
            Right-to left layout.
            Default is AuDialog.Options.RtlLayout.
            </summary>
        </member>
        <member name="P:Au.AuDialog.FlagCanBeMinimized">
            <summary>
            Add 'Minimize' button to the title bar.
            </summary>
        </member>
        <member name="P:Au.AuDialog.FlagShowProgressBar">
            <summary>
            Show progress bar.
            </summary>
        </member>
        <member name="P:Au.AuDialog.FlagShowMarqueeProgressBar">
            <summary>
            Show progress bar that just plays an animation but does not indicate which part of the work is already done.
            </summary>
        </member>
        <member name="P:Au.AuDialog.FlagTopmost">
            <summary>
            Makes the dialog window topmost or non-topmost.
            If true, will set topmost style when creating the dialog. If false, will not set.
            If null (default), the dialog will be topmost if both these are true: no owner window, AuDialog.Options.TopmostIfNoOwnerWindow is true.
            </summary>
        </member>
        <member name="P:Au.AuDialog.FlagEndThread">
            <summary>
            Call <see cref="M:System.Threading.Thread.Abort"/> if selected OK button when there are no other buttons. Also when selected Cancel, No, and on timeout.
            </summary>
        </member>
        <member name="M:Au.AuDialog.ShowDialog">
            <summary>
            Shows the dialog.
            Returns selected button id and other results packed in a <see cref="T:Au.Types.DResult"/> variable.
            Call this method after setting text and other properties.
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="E:Au.AuDialog.Created">
            <summary>
            AuDialog events.
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="E:Au.AuDialog.Destroyed">
            <summary>
            AuDialog events.
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="E:Au.AuDialog.Timer">
            <summary>
            AuDialog events.
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="E:Au.AuDialog.ButtonClicked">
            <summary>
            AuDialog events.
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="E:Au.AuDialog.HyperlinkClicked">
            <summary>
            AuDialog events.
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="E:Au.AuDialog.HelpF1">
            <summary>
            AuDialog events.
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="E:Au.AuDialog.OtherEvents">
            <summary>
            AuDialog events.
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="M:Au.AuDialog.ShowDialogNoWait">
            <summary>
            Shows the dialog in new thread and returns without waiting until it is closed.
            </summary>
            <remarks>
            Calls <see cref="M:Au.AuDialog.ThreadWaitForOpen"/>, therefore the dialog is already open when this function returns.
            More info: <see cref="M:Au.AuDialog.ShowNoWaitEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>
            </remarks>
            <exception cref="T:System.AggregateException">Failed to show dialog.</exception>
        </member>
        <member name="P:Au.AuDialog.Result">
            <summary>
            Gets selected button id and other results packed in a DResult variable.
            It is the same variable as the ShowDialog return value.
            If the result is still unavailable (eg the dialog still not closed):
            	If called from the same thread that called ShowDialog, returns null.
            	If called from another thread, waits until the dialog is closed and the return value is available.
            	Note that ShowDialogNoWait calls ShowDialog in another thread.
            </summary>
        </member>
        <member name="M:Au.AuDialog.ThreadWaitForOpen">
            <summary>
            Can be used by other threads to wait until the dialog is open.
            If returns true, the dialog is open and you can send messages to it.
            If returns false, the dialog is already closed or failed to show.
            </summary>
        </member>
        <member name="M:Au.AuDialog.ThreadWaitForClosed">
            <summary>
            Can be used by other threads to wait until the dialog is closed.
            </summary>
        </member>
        <member name="P:Au.AuDialog.IsOpen">
            <summary>
            Returns true if the dialog is open and your code can send messages to it.
            </summary>
        </member>
        <member name="P:Au.AuDialog.DialogWindow">
            <summary>
            Gets dialog window handle as Wnd.
            Returns default(Wnd) if the dialog is not open.
            </summary>
        </member>
        <member name="P:Au.AuDialog.Send">
            <summary>
            Allows to modify dialog controls while it is open, and close the dialog.
            </summary>
            <remarks>
            Example: <c>d.Send.Close();</c> .
            Example: <c>d.Send.ChangeText2("new text", false);</c> .
            Example: <c>d.Send.Message(TDApi.TDM.CLICK_VERIFICATION, 1);</c> .
            
            Can be used only while the dialog is open. Before showing the dialog returns null. After closing the dialog the returned variable is deactivated; its method calls are ignored.
            Can be used in dialog event handlers. Also can be used in another thread, for example with <see cref="M:Au.AuDialog.ShowNoWaitEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/> and <see cref="M:Au.AuDialog.ShowProgressEx(System.Boolean,System.String,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </remarks>
        </member>
        <member name="P:Au.AuDialog.EditControl">
            <summary>
            Gets edit control handle as Wnd.
            </summary>
        </member>
        <member name="M:Au.AuDialog.ShowEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})">
            <summary>
            Shows dialog.
            Returns selected button id and other results packed in a <see cref="T:Au.Types.DResult"/> variable.
            </summary>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Text below main instruction.</param>
            <param name="buttons">See <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String)"/>. Examples: "OK|Cancel", "1 OK|2 Cancel|5 Save|4 Don't Save".</param>
            <param name="icon"></param>
            <param name="flags"></param>
            <param name="owner">Owner window or null. See <see cref="M:Au.AuDialog.SetOwnerWindow(Au.Types.AnyWnd,System.Boolean,System.Boolean)"/>.</param>
            <param name="expandedText">Text that the user can show and hide.</param>
            <param name="footerText">Text at the bottom of the dialog. Icon can be specified like "i|Text", where i is: x error, ! warning, i info, v shield, a app.</param>
            <param name="title">Title bar text. If omitted, null or "", uses <see cref="P:Au.AuDialog.Options.DefaultTitle"/>.</param>
            <param name="radioButtons">Adds radio buttons. A list of strings "id text" separated by |, like "1 One|2 Two|3 Three".</param>
            <param name="checkBox">If not null/"", shows a check box with this text. To make it checked, append "|true", "|check" or "|checked".</param>
            <param name="defaultButton">id of button that responds to the Enter key.</param>
            <param name="x">X position in <see cref="P:Au.AuDialog.Screen"/>. If default - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="y">Y position in <see cref="P:Au.AuDialog.Screen"/>. If default - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="secondsTimeout">If not 0, auto-close the dialog after this time (seconds) and set result's Button property = <see cref="F:Au.Types.DResult.Timeout"/>.</param>
            <param name="onLinkClick">
            A link-clicked event handler function, eg lambda. Enables hyperlinks in small-font text.
            Example:
            <code><![CDATA[
            AuDialog.ShowEx("", "Text <a href=\"example\">link</a>.", onLinkClick: e => { Print(e.LinkHref); });
            ]]></code>
            </param>
            <remarks>
            The returned <see cref="T:Au.Types.DResult"/> variable has these properties: selected button id, selected radio button id, check box state.
            Tip: DResult supports implicit cast to int. You can use code <c>switch(AuDialog.ShowEx(...))</c> instead of <c>switch(AuDialog.ShowEx(...).Button)</c> .
            Tip: Use named arguments. Example: <c>AuDialog.ShowEx("Text.", icon: DIcon.Info, title: "Title")</c> .
            This function allows you to use most of the dialog features, but not all. Alternatively you can create a AuDialog class instance, set properties and call ShowDialog. Example in <see cref="T:Au.AuDialog"/> class help.
            </remarks>
            <example>
            <code><![CDATA[
            var r = AuDialog.ShowEx("Main text", "More text.", "1 OK|2 Cancel", expandedText: "Expanded text", radioButtons: "1 One|2 Two|3 Three", checkBox: "Check", secondsTimeout: 30);
            Print(r);
            switch(r) {
            case 1: Print("OK"); break;
            case DResult.Timeout: Print("timeout"); break;
            default: Print("Cancel"); break;
            }
            ]]></code>
            </example>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String)">
            <summary>
            Shows dialog.
            Returns selected button id.
            </summary>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Text below main instruction.</param>
            <param name="buttons">
            Button ids and labels, like "1 OK|2 Cancel|5 Save|4 Don't Save".
            Missing ids are auto-generated, for example "OK|Cancel|100 Custom1|Custom2" is the same as "1 OK|2 Cancel|100 Custom1|101 Custom2".
            The first in the list button is <i>default</i>, ie responds to the Enter key. For example, "2 No|1 Yes" adds Yes and No buttons and makes No default.
            Trims newlines around ids and labels. For example, "\r\n1 One\r\n|\r\n2\r\nTwo\r\n\r\n" is the same as "1 One|2 Two".
            
            To create keyboard shortcuts, use &amp; character in custom button labels. Use &amp;&amp; for literal &amp;. Example: "1 &amp;Tuesday[]2 T&amp;hursday[]3 Saturday &amp;&amp; Sunday".
            
            There are 6 <i>common buttons</i>: OK, Yes, No, Retry, Cancel, Close. Buttons that have other labels are <i>custom buttons</i>.
            How common buttons are different:
            	1. DFlags.CommandLinks does not change their style.
            	2. They have keyboard shortcuts that cannot be changed. Inserting &amp; in a label makes it a custom button.
            	3. Button Cancel can be selected with the Esc key. It also adds X (Close) button in title bar, which selects Cancel.
            	4. Always displayed in standard order (eg Yes No, never No Yes). But you can for example use "2 No|1 Yes" to set default button = No.
            	5. The displayed button label is localized, ie different when the Windows UI language is not English.
            
            If omitted, null or "", the dialog will have OK button, id 1.
            You can use <see cref="F:Au.Types.DFlags.CommandLinks"/> in flags to change the style of custom buttons.
            See also: <see cref="M:Au.AuDialog.SetButtons(System.String,System.Boolean,Au.Types.MultiString)"/>.
            </param>
            <param name="icon"></param>
            <param name="flags"></param>
            <param name="owner">Owner window or null. See <see cref="M:Au.AuDialog.SetOwnerWindow(Au.Types.AnyWnd,System.Boolean,System.Boolean)"/>.</param>
            <param name="expandedText">Text that the user can show and hide.</param>
            <remarks>
            Calls <see cref="M:Au.AuDialog.ShowEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            Tip: Use named arguments. Example: <c>AuDialog.Show("Text.", icon: DIcon.Info)</c> .
            </remarks>
            <seealso cref="M:Au.AuDialog.ShowInfo(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String)"/>
            <seealso cref="M:Au.AuDialog.ShowWarning(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String)"/>
            <seealso cref="M:Au.AuDialog.ShowError(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String)"/>
            <seealso cref="M:Au.AuDialog.ShowOKCancel(System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String)"/>
            <seealso cref="M:Au.AuDialog.ShowYesNo(System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String)"/>
            <seealso cref="M:Au.Debug_.Dialog(System.Object,System.String,System.Int32,System.String)"/>
            <example>
            <code><![CDATA[
            if(AuDialog.Show("Show another example?", null, "1 OK|2 Cancel", DIcon.Info) != 1) return;
            Print("OK");
            
            switch(AuDialog.Show("Save changes?", "More info.", "1 Save|2 Don't Save|Cancel")) {
            case 1: Print("save"); break;
            case 2: Print("don't"); break;
            default: Print("cancel"); break;
            }
            ]]></code>
            </example>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowInfo(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String)">
            <summary>
            Shows dialog with DIcon.Info icon.
            Calls <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String)"/>.
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowWarning(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String)">
            <summary>
            Shows dialog with DIcon.Warning icon.
            Calls <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String)"/>.
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowError(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String)">
            <summary>
            Shows dialog with DIcon.Error icon.
            Calls <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String)"/>.
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowOKCancel(System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String)">
            <summary>
            Shows dialog with OK and Cancel buttons.
            Returns true if selected OK.
            Calls <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String)"/>.
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowYesNo(System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String)">
            <summary>
            Shows dialog with Yes and No buttons.
            Returns true if selected Yes.
            Calls <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String)"/>.
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowTextInputEx(System.String,System.String,Au.Types.DEdit,System.Object,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs},System.String,System.Action{Au.Types.DEventArgs})">
            <summary>
            Shows dialog with a text edit field, buttons OK and Cancel, optionally check box, radio buttons and custom buttons.
            Returns results packed in a DResult variable: selected button id (1 for OK, 2 for Cancel), text and check box state.
            </summary>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Read-only text below main instruction, above the edit field.</param>
            <param name="editType">Edit field type. It can be simple text (DEdit.Text, default), multiline, number, password or combo box.</param>
            <param name="editText">Initial edit field text. If editType is Combo, it can be a string array, List or IEnumerable; the first item sets combo-box editable text, other items - combo box drop-down list items.</param>
            <param name="flags"></param>
            <param name="owner">Owner window or null. See <see cref="M:Au.AuDialog.SetOwnerWindow(Au.Types.AnyWnd,System.Boolean,System.Boolean)"/>.</param>
            <param name="expandedText">Text that the user can show and hide.</param>
            <param name="footerText">Text at the bottom of the dialog. Icon can be specified like "i|Text", where i is: x error, ! warning, i info, v shield, a app.</param>
            <param name="title">Title bar text. If omitted, null or "", uses <see cref="P:Au.AuDialog.Options.DefaultTitle"/>.</param>
            <param name="checkBox">If not empty, shows a check box with this text. To make it checked, append "|true", "|check" or "|checked".</param>
            <param name="radioButtons">Adds radio buttons. A list of strings "id text" separated by |, like "1 One|2 Two|3 Three".</param>
            <param name="x">X position in <see cref="P:Au.AuDialog.Screen"/>. If default - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="y">Y position in <see cref="P:Au.AuDialog.Screen"/>. If default - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="secondsTimeout">If not 0, auto-close the dialog after this time, number of seconds.</param>
            <param name="onLinkClick">Enables hyperlinks in small-font text. A link-clicked event handler function, like with <see cref="M:Au.AuDialog.ShowEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.</param>
            <param name="buttons">You can use this to add more buttons. A list of strings "id text" separated by |, like "1 OK|2 Cancel|10 Browse...". See <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String)"/>.</param>
            <param name="onButtonClick">
            A button-clicked event handler function, eg lambda.
            Examples:
            <code><![CDATA[
            AuDialog.ShowTextInputEx("Example", flags: DFlags.CommandLinks, buttons: "OK|Cancel|10 Browse\nSets edit control text.",
            	onButtonClick: e => { if(e.Button == 10) { e.EditText = "text"; e.DoNotCloseDialog = true; } });
            
            AuDialog.ShowTextInputEx("Example", "Try to click OK while text is empty.", onButtonClick: e =>
            {
            	if(e.Button == 1 && Empty(e.EditText)) {
            		AuDialog.Show("Text cannot be empty.", owner: e.hwnd);
            		e.dialog.EditControl.FocusControlOfThisThread();
            		e.DoNotCloseDialog = true;
            	}
            });
            ]]></code>
            </param>
            <remarks>
            This function allows you to use most of the dialog features, but not all. Alternatively you can create a AuDialog class instance, set properties and call ShowDialog. Example in <see cref="T:Au.AuDialog"/> class help.
            </remarks>
            <example>
            <code><![CDATA[
            var r = AuDialog.ShowTextInputEx("Example", "Comments.", checkBox: "Check");
            if(r.Button != 1) return;
            Print(r.EditText);
            Print(r.IsChecked);
            ]]></code>
            </example>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowTextInput(System.String@,System.String,System.String,Au.Types.DEdit,System.Object,Au.Types.DFlags,Au.Types.AnyWnd)">
            <summary>
            Shows dialog with a text edit field and buttons OK and Cancel, and gets that text.
            Returns true if selected OK, false if Cancel.
            </summary>
            <param name="s">Variable that receives the text.</param>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Read-only text below main instruction, above the edit field.</param>
            <param name="editType">Edit field type.</param>
            <param name="editText">Initial edit field text. If editType is DEdit.Combo, it can be a string array, List or IEnumerable; the first item sets combo-box editable text, other items - combo box drop-down list items.</param>
            <param name="flags"></param>
            <param name="owner">Owner window or null. See <see cref="M:Au.AuDialog.SetOwnerWindow(Au.Types.AnyWnd,System.Boolean,System.Boolean)"/>.</param>
            <remarks>
            Calls <see cref="M:Au.AuDialog.ShowTextInputEx(System.String,System.String,Au.Types.DEdit,System.Object,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs},System.String,System.Action{Au.Types.DEventArgs})"/>.
            </remarks>
            <example>
            <code><![CDATA[
            string s;
            if(!AuDialog.ShowTextInput(out s, "Example")) return;
            Print(s);
            
            //or you can declare the variable like this
            if(!AuDialog.ShowTextInput(out string s2, "Example")) return;
            Print(s2);
            ]]></code>
            </example>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowNumberInput(System.Int32@,System.String,System.String,Au.Types.DEdit,System.Object,Au.Types.DFlags,Au.Types.AnyWnd)">
            <summary>
            Shows dialog with a number edit field and buttons OK and Cancel, and gets that number.
            Returns true if selected OK, false if Cancel.
            </summary>
            <param name="i">Variable that receives the number.</param>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Read-only text below main instruction, above the edit field.</param>
            <param name="editType">Edit field type.</param>
            <param name="editText">Initial edit field text.</param>
            <param name="flags"></param>
            <param name="owner">Owner window or null. See <see cref="M:Au.AuDialog.SetOwnerWindow(Au.Types.AnyWnd,System.Boolean,System.Boolean)"/>.</param>
            <remarks>
            Calls <see cref="M:Au.AuDialog.ShowTextInputEx(System.String,System.String,Au.Types.DEdit,System.Object,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs},System.String,System.Action{Au.Types.DEventArgs})"/>.
            </remarks>
            <example>
            <code><![CDATA[
            int i;
            if(!AuDialog.ShowNumberInput(out i, "Example")) return;
            Print(i);
            ]]></code>
            </example>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowListEx(Au.Types.MultiString,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})">
            <summary>
            Shows dialog with a list of command-link buttons.
            Returns results packed in a <see cref="T:Au.Types.DResult"/> variable. Its Button property is id of the selected button, which is its 1-based index in the list; it is 0 if clicked the X (close window) button or pressed Esc.
            The return value can be assigned to an int variable or used in switch; then it is the id (1-based index or 0).
            </summary>
            <param name="list">List items (buttons). Can be string like "One|Two|Three" or or string[] or List&lt;string&gt;. See <see cref="M:Au.AuDialog.SetButtons(System.String,System.Boolean,Au.Types.MultiString)"/>.</param>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Text below main instruction.</param>
            <param name="flags"></param>
            <param name="owner">Owner window or null. See <see cref="M:Au.AuDialog.SetOwnerWindow(Au.Types.AnyWnd,System.Boolean,System.Boolean)"/>.</param>
            <param name="expandedText">Text that the user can show and hide.</param>
            <param name="footerText">Text at the bottom of the dialog. Icon can be specified like "i|Text", where i is: x error, ! warning, i info, v shield, a app.</param>
            <param name="title">Title bar text. If omitted, null or "", uses <see cref="P:Au.AuDialog.Options.DefaultTitle"/>.</param>
            <param name="checkBox">If not empty, shows a check box with this text. To make it checked, append "|true", "|check" or "|checked".</param>
            <param name="defaultButton">id (1-based index) of button that responds to the Enter key.</param>
            <param name="x">X position in <see cref="P:Au.AuDialog.Screen"/>. If default - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="y">Y position in <see cref="P:Au.AuDialog.Screen"/>. If default - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="secondsTimeout">If not 0, auto-close the dialog after this time, number of seconds.</param>
            <param name="onLinkClick">Enables hyperlinks in small-font text. A link-clicked event handler function, like with <see cref="M:Au.AuDialog.ShowEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.</param>
            <remarks>
            This function allows you to use most of the dialog features, but not all. Alternatively you can create a AuDialog class instance, set properties and call ShowDialog. Example in <see cref="T:Au.AuDialog"/> class help.
            </remarks>
            <example>
            <code><![CDATA[
            int r = AuDialog.ShowListEx("One|Two|Three", "Example", y: -1, secondsTimeout: 15);
            if(r <= 0) return; //X/Esc or timeout
            Print(r);
            ]]></code>
            </example>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowList(Au.Types.MultiString,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd)">
            <summary>
            Shows dialog with a list of command-link buttons.
            Returns 1-based index of the selected button. Returns 0 if clicked the X (close window) button or pressed Esc.
            </summary>
            <param name="list">List items (buttons). Can be string like "One|Two|Three" or string[] or List&lt;string&gt;. See <see cref="M:Au.AuDialog.SetButtons(System.String,System.Boolean,Au.Types.MultiString)"/>.</param>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Text below main instruction.</param>
            <param name="flags"></param>
            <param name="owner">Owner window or null. See <see cref="M:Au.AuDialog.SetOwnerWindow(Au.Types.AnyWnd,System.Boolean,System.Boolean)"/>.</param>
            <remarks>
            Calls <see cref="M:Au.AuDialog.ShowListEx(Au.Types.MultiString,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </remarks>
            <example>
            <code><![CDATA[
            int r = AuDialog.ShowList("One|Two|Three", "Example");
            if(r == 0) return; //X/Esc
            Print(r);
            ]]></code>
            </example>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowProgressEx(System.Boolean,System.String,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})">
            <summary>
            Shows dialog with progress bar.
            Creates dialog in new thread and returns without waiting until it is closed.
            Returns <see cref="T:Au.AuDialog"/> variable that can be used to communicate with the dialog using these methods and properties: <see cref="P:Au.AuDialog.IsOpen"/>, <see cref="M:Au.AuDialog.ThreadWaitForClosed"/>, <see cref="P:Au.AuDialog.Result"/> (when closed), <see cref="P:Au.AuDialog.DialogWindow"/>, <see cref="P:Au.AuDialog.Send"/>; through the Send property you can set progress, modify controls and close the dialog (see example).
            Most parameters are the same as with <see cref="M:Au.AuDialog.ShowEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </summary>
            <param name="marquee">Let the progress bar animate without indicating a percent of work done.</param>
            <remarks>
            This function allows you to use most of the dialog features, but not all. Alternatively you can create a AuDialog class instance, set properties and call <see cref="M:Au.AuDialog.ShowDialogNoWait"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var pd = AuDialog.ShowProgressEx(false, "Working", buttons: "1 Stop", y: -1);
            for(int i = 1; i <= 100; i++) {
            	if(!pd.IsOpen) { Print(pd.Result); break; } //if the user closed the dialog
            	pd.Send.Progress(i); //don't need this if marquee
            	Thread.Sleep(50); //do something in the loop
            }
            pd.Send.Close();
            ]]></code>
            </example>
            <exception cref="T:Au.Types.AuException">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowProgress(System.Boolean,System.String,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Shows dialog with progress bar.
            Creates dialog in other thread and returns without waiting until it is closed.
            Returns <see cref="T:Au.AuDialog"/> variable that can be used to communicate with the dialog using these methods and properties: <see cref="P:Au.AuDialog.IsOpen"/>, <see cref="M:Au.AuDialog.ThreadWaitForClosed"/>, <see cref="P:Au.AuDialog.Result"/> (when closed), <see cref="P:Au.AuDialog.DialogWindow"/>, <see cref="P:Au.AuDialog.Send"/>; through the Send property you can set progress, modify controls and close the dialog (see example).
            All parameters except marquee are the same as with <see cref="M:Au.AuDialog.ShowEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </summary>
            <param name="marquee">Let the progress bar animate without indicating a percent of work done.</param>
            <remarks>
            Calls <see cref="M:Au.AuDialog.ShowProgressEx(System.Boolean,System.String,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var pd = AuDialog.ShowProgress(false, "Working");
            for(int i = 1; i <= 100; i++) {
            	if(!pd.IsOpen) { Print(pd.Result); break; } //if the user closed the dialog
            	pd.Send.Progress(i); //don't need this if marquee
            	Thread.Sleep(50); //do something in the loop
            }
            pd.Send.Close();
            ]]></code>
            </example>
            <exception cref="T:Au.Types.AuException">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowNoWaitEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})">
            <summary>
            Shows dialog like <see cref="M:Au.AuDialog.ShowEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/> but does not wait.
            Creates dialog in other thread and returns without waiting until it is closed.
            Returns <see cref="T:Au.AuDialog"/> variable that can be used to communicate with the dialog using these methods and properties: <see cref="P:Au.AuDialog.IsOpen"/>, <see cref="M:Au.AuDialog.ThreadWaitForClosed"/>, <see cref="P:Au.AuDialog.Result"/> (when closed), <see cref="P:Au.AuDialog.DialogWindow"/>, <see cref="P:Au.AuDialog.Send"/>; through the Send property you can modify controls and close the dialog (see example).
            Parameters are the same as with <see cref="M:Au.AuDialog.ShowEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </summary>
            <remarks>
            This function allows you to use most of the dialog features, but not all. Alternatively you can create a AuDialog class instance, set properties and call <see cref="M:Au.AuDialog.ShowDialogNoWait"/>.
            </remarks>
            <example>
            <code><![CDATA[
            AuDialog.ShowNoWait("Simple example");
            
            var d = AuDialog.ShowNoWaitEx("Another example", "text", "1 OK|2 Cancel", y: -1, secondsTimeout: 30);
            2.s(); //do something while the dialog is open
            d.Send.ChangeText2("new text", false);
            2.s(); //do something while the dialog is open
            d.ThreadWaitClosed(); Print(d.Result); //wait until the dialog is closed and get result. Optional, just an example.
            ]]></code>
            </example>
            <exception cref="T:System.AggregateException">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowNoWait(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd)">
            <summary>
            Shows dialog like <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String)"/> but does not wait.
            Creates dialog in other thread and returns without waiting until it is closed.
            Returns <see cref="T:Au.AuDialog"/> variable that can be used to communicate with the dialog using these methods and properties: <see cref="P:Au.AuDialog.IsOpen"/>, <see cref="M:Au.AuDialog.ThreadWaitForClosed"/>, <see cref="P:Au.AuDialog.Result"/> (when closed), <see cref="P:Au.AuDialog.DialogWindow"/>, <see cref="P:Au.AuDialog.Send"/>. Through the <b>Send</b> property you can modify controls and close the dialog. Example in <see cref="M:Au.AuDialog.ShowNoWaitEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/> topic.
            Parameters are the same as with <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String)"/>.
            </summary>
            <remarks>
            Calls <see cref="M:Au.AuDialog.ShowNoWaitEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </remarks>
            <exception cref="T:System.AggregateException">Failed to show dialog.</exception>
        </member>
        <member name="T:Au.CsvTable">
            <summary>
            Parses and composes CSV text. Stores CSV table data in memory as a <b>List</b> of string arrays.
            </summary>
            <remarks>
            CSV is a text format used to store a single table of data in human-readable/editable way.
            It is a list of lines (called rows or records) containing one or more values (called fields or cells) separated by a separator character.
            There is no strictly defined CSV standard. <b>CsvTable</b> uses these rules:
            	Fields containg <see cref="P:Au.CsvTable.Separator"/> characters (default ','), <see cref="P:Au.CsvTable.Quote"/> characters (default '"') and multiple lines must be enclosed in <see cref="P:Au.CsvTable.Quote"/> characters. Example: "ab, cd".
            	Each Quote character in such fields must be escaped (replaced) with two <see cref="P:Au.CsvTable.Quote"/> characters. Example: "ab ""cd"" ef".
            	Fields that start or end with ASCII space or tab characters must be enclosed in <see cref="P:Au.CsvTable.Quote"/> characters, unless <see cref="P:Au.CsvTable.TrimSpaces"/> is false. Example: " ab ".
            	Rows in CSV text can have different field count.
            </remarks>
        </member>
        <member name="M:Au.CsvTable.#ctor">
            
        </member>
        <member name="M:Au.CsvTable.#ctor(System.String)">
            <summary>
            Initializes a new <see cref="T:Au.CsvTable"/> instance and parses CSV text, the same as <see cref="M:Au.CsvTable.FromString(System.String)"/>.
            </summary>
            <param name="csv">CSV text.</param>
            <exception cref="T:Au.Types.AuException">Invalid CSV, eg contains incorrectly enclosed fields.</exception>
            <remarks>
            Uses default <see cref="P:Au.CsvTable.Separator"/>, <see cref="P:Au.CsvTable.Quote"/> and <see cref="P:Au.CsvTable.TrimSpaces"/> values (',', '"', true).
            </remarks>
        </member>
        <member name="P:Au.CsvTable.Data">
            <summary>
            Gets the internal <b>List</b> containing rows as string arrays.
            </summary>
            <remarks>
            It's not a copy; changing it will change the data of this <see cref="T:Au.CsvTable"/> variable.
            You can do anything with the <b>List</b>. For example, sort it, find rows containing certain field values, get/set field values directly, add/remove rows directly.
            All row arrays have <b>Length</b> equal to <see cref="P:Au.CsvTable.ColumnCount"/>, and it must remain so; you can change <b>Length</b>, but then need to call <c>ColumnCount=newLength</c>.
            </remarks>
            <example><code>x.Data.Sort((a,b) => string.CompareOrdinal(a[0], b[0]));</code></example>
        </member>
        <member name="P:Au.CsvTable.Separator">
            <summary>
            Sets or gets the field separator character used when parsing and composing CSV text.
            Initially it is ','.
            </summary>
        </member>
        <member name="P:Au.CsvTable.Quote">
            <summary>
            Sets or gets the quote character used when parsing and composing CSV text.
            Initially it is '"'.
            </summary>
        </member>
        <member name="P:Au.CsvTable.TrimSpaces">
            <summary>
            Whether to ignore ASCII space and tab characters at the beginning and end of fields when parsing CSV.
            Initially true.
            </summary>
        </member>
        <member name="M:Au.CsvTable.FromString(System.String)">
            <summary>
            Parses CSV text and stores all data in internal <b>List</b> of string arrays.
            </summary>
            <param name="csv">
            CSV text.
            If rows in CSV text have different field count, the longest row sets the <see cref="P:Au.CsvTable.ColumnCount"/> property and all row array lenghts; array elements of missing CSV fields will be null.
            </param>
            <exception cref="T:Au.Types.AuException">Invalid CSV, eg contains incorrectly enclosed fields.</exception>
            <remarks>
            Depends on these properties: <see cref="P:Au.CsvTable.Separator"/> (initially ','), <see cref="P:Au.CsvTable.Quote"/> (initially '"'), <see cref="P:Au.CsvTable.TrimSpaces"/> (initially true).
            </remarks>
        </member>
        <member name="M:Au.CsvTable.ToString">
            <summary>
            Composes CSV text from the internal <b>List</b> of string arrays.
            </summary>
            <remarks>
            Depends on these properties: <see cref="P:Au.CsvTable.Separator"/> (initially ','), <see cref="P:Au.CsvTable.Quote"/> (initially '"').
            </remarks>
        </member>
        <member name="P:Au.CsvTable.RowCount">
            <summary>
            Gets or sets row count.
            The 'get' function returns the <b>Count</b> property of the internal <b>List</b> of string arrays.
            The 'set' function can add new rows or remove rows at the end.
            </summary>
        </member>
        <member name="P:Au.CsvTable.ColumnCount">
            <summary>
            Gets or sets column count.
            The 'get' function returns the length of all string arrays in the internal <b>List</b>.
            The 'set' function can add new columns or remove columns at the right.
            </summary>
        </member>
        <member name="P:Au.CsvTable.Item(System.Int32,System.Int32)">
            <summary>
            Gets or sets a field.
            </summary>
            <param name="row">0-based row index. With the 'set' function it can be negative or equal to <see cref="P:Au.CsvTable.RowCount"/>; then adds new row.</param>
            <param name="column">0-based column index. With the 'set' function it can be &gt;= <see cref="P:Au.CsvTable.ColumnCount"/> and &lt; 1000; then sets <c>ColumnCount = column + 1</c>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="P:Au.CsvTable.Item(System.Int32)">
            <summary>
            Gets or sets fields in a row.
            </summary>
            <param name="row">0-based row index. With the 'set' function it can be negative or equal to <see cref="P:Au.CsvTable.RowCount"/>; then adds new row.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            The 'get' function gets the row array. It's not a copy; changing its elements will change the data of this <see cref="T:Au.CsvTable"/> variable.
            The 'set' function sets the row array. Does not copy the array, unless its <b>Length</b> is less than <see cref="P:Au.CsvTable.ColumnCount"/>.
            </remarks>
        </member>
        <member name="M:Au.CsvTable.InsertRow(System.Int32,System.String[])">
            <summary>
            Inserts new row and sets its fields.
            </summary>
            <param name="index">0-based row index. If negative or equal to <see cref="P:Au.CsvTable.RowCount"/>, adds to the end.</param>
            <param name="fields">Row fields. Can be a string array or multiple string arguments. Does not copy the array, unless its <b>Length</b> is less than <see cref="P:Au.CsvTable.ColumnCount"/>. Adds new columns if array <b>Length</b> (or the number of string arguments) is greater than ColumnCount.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.CsvTable.InsertRow(System.Int32)">
            <summary>
            Inserts new empty row.
            </summary>
            <param name="index">0-based row index. If negative or equal to <see cref="P:Au.CsvTable.RowCount"/>, adds to the end.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.CsvTable.RemoveRow(System.Int32,System.Int32)">
            <summary>
            Removes one or more rows.
            </summary>
            <param name="index">0-based row index.</param>
            <param name="count">How many rows to remove, default 1.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:Au.CsvTable.FromFile(System.String)">
            <summary>
            Loads and parses a CSV file.
            </summary>
            <param name="file"></param>
            <exception cref="T:Au.Types.AuException">Invalid CSV, eg contains incorrectly enclosed fields.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.IO.File.ReadAllText(System.String)"/>.</exception>
            <remarks>
            Calls <see cref="M:System.IO.File.ReadAllText(System.String)"/> and <see cref="M:Au.CsvTable.FromString(System.String)"/>.
            </remarks>
        </member>
        <member name="M:Au.CsvTable.ToFile(System.String)">
            <summary>
            Composes CSV and saves to file.
            </summary>
            <param name="file"></param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.IO.File.WriteAllText(System.String,System.String)"/>.</exception>
            <remarks>
            Calls <see cref="M:Au.CsvTable.ToString"/> and <see cref="M:System.IO.File.WriteAllText(System.String,System.String)"/>.
            </remarks>
        </member>
        <member name="M:Au.CsvTable.SetInt(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sets an int number field.
            </summary>
            <param name="row"><see cref="P:Au.CsvTable.Item(System.Int32,System.Int32)"/></param>
            <param name="column"><see cref="P:Au.CsvTable.Item(System.Int32,System.Int32)"/></param>
            <param name="value">The number.</param>
            <param name="hex">Let the number be in hexadecimal format, like 0x3A.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.CsvTable.GetInt(System.Int32,System.Int32)">
            <summary>
            Gets an int number field.
            </summary>
            <param name="row"><see cref="P:Au.CsvTable.Item(System.Int32,System.Int32)"/></param>
            <param name="column"><see cref="P:Au.CsvTable.Item(System.Int32,System.Int32)"/></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.CsvTable.SetDouble(System.Int32,System.Int32,System.Double)">
            <summary>
            Sets a double number field.
            </summary>
            <param name="row"><see cref="P:Au.CsvTable.Item(System.Int32,System.Int32)"/></param>
            <param name="column"><see cref="P:Au.CsvTable.Item(System.Int32,System.Int32)"/></param>
            <param name="value">The number.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.CsvTable.GetDouble(System.Int32,System.Int32)">
            <summary>
            Gets a double number field.
            </summary>
            <param name="row"><see cref="P:Au.CsvTable.Item(System.Int32,System.Int32)"/></param>
            <param name="column"><see cref="P:Au.CsvTable.Item(System.Int32,System.Int32)"/></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="T:Au.Wnd">
            <summary>
            A variable of Wnd type represents a window or control. It is a window handle, also known as HWND.
            </summary>
            <remarks>
            Wnd functions can be used with windows and controls of any process/thread. Also can be used with .NET form/control and WPF window class variables, like <c>Wnd w=(Wnd)form; w.Method(...);</c> or <c>((Wnd)form).Method(...);</c>.
            
            There are two main types of windows - top-level windows and controls. Controls are child windows of top-level windows.
            
            More functions are in the nested classes - <see cref="T:Au.Wnd.Misc"/>, <see cref="T:Au.Wnd.Misc.Desktop"/> etc. They are used mostly in programming, rarely in automation scripts.
            
            What happens when a Wnd function fails:
            <list type="bullet">
            <item>Functions that get window properties don't throw exceptions. They return false/0/null/empty. Most of them support <see cref="M:Au.Types.Native.GetError"/>, and it is mentioned in function documentation.</item>
            <item>Many functions that change window properties throw exception. Exceptions are listed in function documentation. Almost all these functions throw only <see cref="T:Au.Types.WndException"/>.</item>
            <item>Other functions that change window properties return false. They are more often used in programming than in automation scripts.</item>
            <item>When a 'find' function does not find the window or control, it returns default(Wnd) (window handle 0). Then <see cref="P:Au.Wnd.Is0"/> will return true.</item>
            <item>If a function does not follow these rules, it is mentioned in function documentation.</item>
            </list>
            
            Many functions fail if the window's process has a higher <see cref="T:Au.Process_.UacInfo">UAC</see> integrity level (aministrator, uiAccess) than this process, unless this process has uiAccess level. Especially the functions that change window properties. Some functions that still work: <b>Activate</b>, <b>ActivateLL</b>, <b>ShowMinimized</b>, <b>ShowNotMinimized</b>, <b>ShowNotMinMax</b>, <b>Close</b>.
            
            The Wnd type can be used with native Windows API functions without casting. Use Wnd for the parameter type in the declaration, like <c>[DllImport(...)] static extern bool NativeFunction(Wnd hWnd, ...)</c>.
            
            See also: MSDN article <msdn>Window Features</msdn>.
            </remarks>
            <example>
            <code><![CDATA[
            Wnd w = Wnd.Find("* - Notepad");
            if(w.Is0) { Print("window not found"); return; }
            w.Activate();
            Wnd c = w.Child(className: "Button");
            Print(c.Name);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Wnd.Wait(System.Double,System.Boolean,System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)">
            <inheritdoc cref="M:Au.Wnd.Find(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>
            <summary>
            Waits until window exists, is visible (optionally) and active (optionally).
            Returns window handle. On timeout returns default(Wnd) if <paramref name="secondsTimeout"/> is negative; else exception.
            Parameters etc are the same as <see cref="M:Au.Wnd.Find(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>.
            </summary>
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits infinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, after that time interval returns default(Wnd).
            </param>
            <param name="active">The window must be the active window (<see cref="P:Au.Wnd.Active"/>), and not minimized.</param>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
            <remarks>
            By default ignores invisible windows. Use flag <see cref="F:Au.Types.WFFlags.HiddenToo"/> if need.
            If you have a window's Wnd variable, to wait until it is active/visible/etc use <see cref="M:Au.Wnd.WaitForCondition(System.Double,System.Func{Au.Wnd,System.Boolean},System.Boolean)"/> instead.
            </remarks>
            <example>
            <code><![CDATA[
            Wnd w = Wnd.Wait(10, false, "* Notepad");
            Print(w);
            ]]></code>
            Using in a Form/Control event handler.
            <code><![CDATA[
            var f = new Form();
            f.Click += async (unu, sed) =>
              {
            	  Print("waiting for Notepad...");
            	  Wnd w = await Task.Run(() => Wnd.Wait(-10, false, "* Notepad"));
            	  if(w.Is0) Print("timeout"); else Print(w);
              };
            f.ShowDialog();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Wnd.WaitAny(System.Double,System.Boolean,Au.Wnd.Finder[])">
            <summary>
            Waits until any of specified windows exists, is visible (optionally) and active (optionally).
            Returns window handle. On timeout returns default(Wnd) if <paramref name="secondsTimeout"/> is negative; else exception.
            </summary>
            <param name="secondsTimeout"><inheritdoc cref="M:Au.Wnd.Wait(System.Double,System.Boolean,System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/></param>
            <param name="active">The window must be the active window (<see cref="P:Au.Wnd.Active"/>), and not minimized.</param>
            <param name="windows">One or more variables containing window properties.</param>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
            <remarks>
            By default ignores invisible windows. Use flag <see cref="F:Au.Types.WFFlags.HiddenToo"/> if need.
            </remarks>
            <example>
            <code><![CDATA[
            Wnd w = Wnd.WaitAny(10, true, new Wnd.Finder("* Notepad"), new Wnd.Finder("* Word"));
            Print(w);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Wnd.WaitNot(System.Double,System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)">
            <inheritdoc cref="M:Au.Wnd.Find(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>
            <summary>
            Waits until window does not exist.
            Parameters etc are the same as <see cref="M:Au.Wnd.Find(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>.
            </summary>
            <param name="secondsTimeout"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></param>
            <returns><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></returns>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Wnd.Find(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>.</exception>
            <remarks>
            By default ignores invisible windows. Use flag <see cref="F:Au.Types.WFFlags.HiddenToo"/> if need.
            If you have a window's Wnd variable, to wait until it is closed use <see cref="M:Au.Wnd.WaitForClosed(System.Double,System.Boolean)"/> instead.
            Examples: <see cref="M:Au.Wnd.Wait(System.Double,System.Boolean,System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>.
            </remarks>
        </member>
        <member name="M:Au.Wnd.WaitNot(System.Double,Au.Wnd.Finder,Au.Wnd@)">
            <inheritdoc cref="M:Au.Wnd.WaitNot(System.Double,System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>
            <summary>
            Waits until window does not exist.
            </summary>
            <param name="secondsTimeout"></param>
            <param name="f">Window properties etc.</param>
            <param name="wFound">On timeout receives the found window.</param>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
        </member>
        <member name="M:Au.Wnd.WaitNot(System.Double,Au.Wnd.Finder)">
            <inheritdoc cref="M:Au.Wnd.WaitNot(System.Double,Au.Wnd.Finder,Au.Wnd@)"/>
        </member>
        <member name="M:Au.Wnd.WaitForCondition(System.Double,System.Func{Au.Wnd,System.Boolean},System.Boolean)">
            <summary>
            Waits for an user-defined state/condition of this window. For example active, visible, enabled, closed, contains control.
            </summary>
            <param name="secondsTimeout"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></param>
            <param name="condition">Callback function (eg lambda). It is called repeatedly, until returns true.</param>
            <param name="doNotThrowIfClosed">
            Do not throw exception when the window handle is invalid or the window was closed while waiting.
            In such case the callback function must return false, like in the examples with <see cref="P:Au.Wnd.IsAlive"/>. Else exception is thrown (with a small delay) to prevent infinite waiting.
            </param>
            <returns><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></returns>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
            <exception cref="T:Au.Types.WndException">The window handle is invalid or the window was closed while waiting.</exception>
            <example>
            <code><![CDATA[
            Wnd w = Wnd.Find("* Notepad");
            
            //wait max 30 s until window w is active. Exception on timeout or if closed.
            w.WaitForCondition(30, t => t.IsActive);
            Print("active");
            
            //wait max 30 s until window w is enabled. Exception on timeout or if closed.
            w.WaitForCondition(30, t => t.IsEnabled);
            Print("enabled");
            
            //wait until window w is closed
            w.WaitForCondition(0, t => !t.IsAlive, true); //same as w.WaitForClosed()
            Print("closed");
            
            //wait until window w is minimized or closed
            w.WaitForCondition(0, t => t.IsMinimized || !t.IsAlive, true);
            if(!w.IsAlive) { Print("closed"); return; }
            Print("minimized");
            
            //wait until window w contains focused control classnamed "Edit"
            var c = new Wnd.ChildFinder(className: "Edit");
            w.WaitForCondition(10, t => c.Find(t) && c.Result.IsFocused);
            Print("control focused");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Wnd.WaitForName(System.Double,System.String)">
            <summary>
            Waits until this window has the specified name.
            </summary>
            <param name="secondsTimeout"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></param>
            <param name="name">
            Window name. Usually it is the title bar text.
            String format: <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">wildcard expression</conceptualLink>.
            </param>
            <returns><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></returns>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
            <exception cref="T:Au.Types.WndException">The window handle is invalid or the window was closed while waiting.</exception>
            <exception cref="T:System.ArgumentException">Invalid wildcard expression.</exception>
        </member>
        <member name="M:Au.Wnd.WaitForClosed(System.Double,System.Boolean)">
            <summary>
            Waits until this window is closed/destroyed or until its process ends.
            </summary>
            <param name="secondsTimeout"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></param>
            <param name="waitUntilProcessEnds">Wait until the process of this window ends.</param>
            <returns><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></returns>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
            <exception cref="T:Au.Types.AuException">Failed to open process handle when <paramref name="waitUntilProcessEnds"/> is true.</exception>
            <remarks>
            If the window is already closed, immediately returns true.
            </remarks>
        </member>
        <member name="M:Au.Wnd.op_Explicit(System.Windows.Forms.Control)~Au.Wnd">
            <summary>
            Gets the window handle as Wnd from a System.Windows.Forms.Control (or Form etc) variable.
            Returns default(Wnd) if w is null or the handle is still not created.
            </summary>
        </member>
        <member name="M:Au.Wnd.op_Explicit(System.Windows.Window)~Au.Wnd">
            <summary>
            Gets the window handle as Wnd from a System.Windows.Window variable (WPF window).
            Returns default(Wnd) if w is null or the handle is still not created.
            </summary>
        </member>
        <member name="M:Au.Wnd.op_Equality(Au.Wnd,Au.Wnd)">
            <summary>Compares window handles.</summary>
        </member>
        <member name="M:Au.Wnd.op_Inequality(Au.Wnd,Au.Wnd)">
            <summary>Compares window handles.</summary>
        </member>
        <member name="M:Au.Wnd.Equals(Au.Wnd)">
            <summary>
            Returns true if w == this.
            </summary>
        </member>
        <member name="M:Au.Wnd.Equals(System.Nullable{Au.Wnd})">
            <summary>
            Returns true if w != null and w.Value == this.
            </summary>
        </member>
        <member name="M:Au.Wnd.Equals(System.Object)">
            <summary>
            Returns true if obj is Wnd and contains the same window handle.
            </summary>
        </member>
        <member name="M:Au.Wnd.GetHashCode">
            
        </member>
        <member name="P:Au.Wnd.Handle">
            <summary>
            Gets window handle as IntPtr.
            Code <c>w.Handle</c> is the same as <c>(IntPtr)w</c> .
            </summary>
        </member>
        <member name="M:Au.Wnd.ToString">
            <summary>
            Formats string $"{handle}  {ClassName}  \"{Name}\"  {ProgramName}  {Rect}".
            </summary>
        </member>
        <member name="M:Au.Wnd.Send(System.Int32,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>
            Calls API <msdn>SendMessage</msdn>.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.SendS(System.Int32,Au.Types.LPARAM,System.String)">
            <summary>
            Calls API <msdn>SendMessage</msdn> where lParam is string.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.SendS(System.Int32,Au.Types.LPARAM,System.Char[])">
            <summary>
            Calls API <msdn>SendMessage</msdn> where lParam is char[].
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.SendTimeout(System.Int32,System.Int32,Au.Types.LPARAM,Au.Types.LPARAM,Au.Types.Native.SMTO)">
            <summary>
            Calls API <msdn>SendMessageTimeout</msdn>.
            Returns its return value (false if failed). Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
        </member>
        <member name="M:Au.Wnd.SendTimeout(System.Int32,Au.Types.LPARAM@,System.Int32,Au.Types.LPARAM,Au.Types.LPARAM,Au.Types.Native.SMTO)">
            <summary>
            Calls API <msdn>SendMessageTimeout</msdn> and gets the result of the message processing.
            Returns its return value (false if failed). Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
        </member>
        <member name="M:Au.Wnd.SendTimeoutS(System.Int32,Au.Types.LPARAM@,System.Int32,Au.Types.LPARAM,System.String,Au.Types.Native.SMTO)">
            <summary>
            Calls API <msdn>SendMessageTimeout</msdn> where lParam is string.
            Returns its return value (false if failed). Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
        </member>
        <member name="M:Au.Wnd.SendTimeoutS(System.Int32,Au.Types.LPARAM@,System.Int32,Au.Types.LPARAM,System.Char[],Au.Types.Native.SMTO)">
            <summary>
            Calls API <msdn>SendMessageTimeout</msdn> where lParam is char[].
            Returns its return value (false if failed). Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
        </member>
        <member name="M:Au.Wnd.SendNotify(System.Int32,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>
            Calls API <msdn>SendNotifyMessage</msdn>.
            Returns its return value (false if failed). Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
        </member>
        <member name="M:Au.Wnd.Post(System.Int32,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>
            Calls API <msdn>PostMessage</msdn>.
            Returns its return value (false if failed). Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <seealso cref="M:Au.Wnd.Misc.PostThreadMessage(System.Int32,Au.Types.LPARAM,Au.Types.LPARAM)"/>
        </member>
        <member name="T:Au.Wnd.Misc">
            <summary>
            Contains miscellaneous static window-related functions and classes, rarely used or useful only for programmers.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.PostThreadMessage(System.Int32,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>
            Posts a message to the message queue of this thread.
            Calls API <msdn>PostMessage</msdn> with default(Wnd). 
            Returns its return value (false if failed). Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.PostThreadMessage(System.Int32,System.Int32,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>
            Posts a message to the message queue of the specified thread.
            Calls API <msdn>PostThreadMessage</msdn>. 
            Returns its return value (false if failed). Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.WaitForAnActiveWindow">
            <summary>
            Waits while there is no active window.
            It sometimes happens after closing, minimizing or switching the active window, briefly until another window becomes active.
            Waits max 500 ms, then returns false if there is no active window.
            Processes Windows messages that are in the message queue of this thread.
            Don't need to call this after calling functions of this library.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.EnableActivate">
            <summary>
            Temporarily enables this process to activate windows with API <msdn>SetForegroundWindow</msdn>.
            Returns false if fails (unlikely).
            In some cases you may need this function because Windows often disables SetForegroundWindow to not allow applications to activate their windows while the user is working (using keyboard/mouse) with the currently active window. Then SetForegroundWindow just makes the window's taskbar button flash which indicates that the windows wants attention. More info: <msdn>SetForegroundWindow</msdn>.
            Usually you don't call SetForegroundWindow directly. It is called by some other functions, for example Form.Show.
            Don't need to call this function before calling Wnd.Activate and other functions of this library that activate windows.
            </summary>
        </member>
        <member name="T:Au.Wnd.Misc.TaskbarButton">
            <summary>
            Taskbar button flash, progress, add/delete.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.TaskbarButton.Flash(Au.Wnd,System.Int32)">
            <summary>
            Starts or stops flashing the taskbar button.
            </summary>
            <param name="w">Window.</param>
            <param name="count">The number of times to flash. If 0, stops flashing.</param>
        </member>
        <member name="T:Au.Wnd.Misc.TaskbarButton.ProgressState">
            <summary>
            Used by <see cref="M:Au.Wnd.Misc.TaskbarButton.SetProgressState(Au.Wnd,Au.Wnd.Misc.TaskbarButton.ProgressState)"/>.
            </summary>
            <tocexclude />
        </member>
        <member name="M:Au.Wnd.Misc.TaskbarButton.SetProgressState(Au.Wnd,Au.Wnd.Misc.TaskbarButton.ProgressState)">
            <summary>
            Sets the state of the progress indicator displayed on the taskbar button.
            Calls <msdn>ITaskbarList3.SetProgressState</msdn>.
            </summary>
            <param name="w">Button's window.</param>
            <param name="state">Progress indicator state and color.</param>
        </member>
        <member name="M:Au.Wnd.Misc.TaskbarButton.SetProgressValue(Au.Wnd,System.Int32,System.Int32)">
            <summary>
            Sets the value of the progress indicator displayed on the taskbar button.
            Calls <msdn>ITaskbarList3.SetProgressValue</msdn>.
            </summary>
            <param name="w">Button's window.</param>
            <param name="progressValue">Progress indicator value, 0 to progressTotal.</param>
            <param name="progressTotal">Max progress indicator value.</param>
        </member>
        <member name="M:Au.Wnd.Misc.TaskbarButton.Add(Au.Wnd)">
            <summary>
            Adds taskbar button.
            Calls <msdn>ITaskbarList.AddTab</msdn>.
            </summary>
            <param name="w">Button's window.</param>
        </member>
        <member name="M:Au.Wnd.Misc.TaskbarButton.Delete(Au.Wnd)">
            <summary>
            Deletes taskbar button.
            Calls <msdn>ITaskbarList.DeleteTab</msdn>.
            </summary>
            <param name="w">Button's window.</param>
        </member>
        <member name="T:Au.Wnd.Misc.Desktop">
            <summary>
            Arranges windows, shows/hides desktop. The same as the taskbar right-click menu commands.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.Desktop.ToggleShowDesktop">
            <summary>
            Shows or hides desktop.
            If there are non-minimized main windows, minimizes them. Else restores windows recently minimized by this function.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.Desktop.MinimizeWindows">
            <summary>
            Minimizes main windows.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.Desktop.CascadeWindows">
            <summary>
            Cascades non-minimized main windows.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.Desktop.TileWindows(System.Boolean)">
            <summary>
            Arranges non-minimized main windows horizontally or vertically.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.Desktop.UndoMinimizeEtc">
            <summary>
            Restores windows recently minimized, cascaded or tiled with other functions of this class.
            </summary>
        </member>
        <member name="T:Au.Wnd.Misc.WinFormsControlNames">
            <summary>
            Gets programming names of .NET Windows Forms controls.
            </summary>
            <remarks>
            Usually each control has a unique name. It is useful to identify controls without a classic name/text.
            The control id of these controls is not useful, it is not constant.
            </remarks>
        </member>
        <member name="M:Au.Wnd.Misc.WinFormsControlNames.Dispose">
            
        </member>
        <member name="M:Au.Wnd.Misc.WinFormsControlNames.#ctor(Au.Wnd)">
            <summary>
            Prepares to get control names.
            </summary>
            <param name="w">Any top-level or child window of that process.</param>
            <exception cref="T:Au.Types.WndException">w invalid.</exception>
            <exception cref="T:Au.Types.AuException">Failed to allocate process memory (see <see cref="T:Au.Process_.Memory"/>) needed to get control names, usually because of <see cref="T:Au.Process_.UacInfo">UAC</see>.</exception>
        </member>
        <member name="M:Au.Wnd.Misc.WinFormsControlNames.GetControlName(Au.Wnd)">
            <summary>
            Gets control name.
            Returns null if fails or the name is empty.
            </summary>
            <param name="c">The control. Can be a top-level window too. Must be of the same process as the window specified in the constructor.</param>
        </member>
        <member name="M:Au.Wnd.Misc.WinFormsControlNames.IsWinFormsControl(Au.Wnd)">
            <summary>
            Returns true if window class name starts with "WindowsForms".
            Usually it means that we can get Windows Forms control name of w and its child controls.
            </summary>
            <param name="w">The window. Can be top-level or control.</param>
        </member>
        <member name="M:Au.Wnd.Misc.WinFormsControlNames.GetSingleControlName(Au.Wnd)">
            <summary>
            Gets the programming name of a Windows Forms control.
            Returns null if it is not a Windows Forms control or if fails.
            </summary>
            <param name="c">The control. Can be top-level window too.</param>
            <remarks>This function is easy to use and does not throw excaptions. However, when you need names of multiple controls of a single window, better create a WinFormsControlNames instance (once) and for each control call its GetControlNameOrText method, it will be faster.</remarks>
        </member>
        <member name="T:Au.Wnd.Misc.MyWindow">
            <summary>
            Creates window and allows your derived class to replace its window procedure.
            </summary>
            <remarks>
            Similar to <see cref="T:System.Windows.Forms.NativeWindow"/>, but more lightweight and does not change the class name.
            Can register a new window class or extend (subclass) an existing class.
            </remarks>
        </member>
        <member name="P:Au.Wnd.Misc.MyWindow.Handle">
            <summary>
            Native window handle.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.MyWindow.Create(System.String,System.String,Au.Types.Native.WS,Au.Types.Native.WS_EX,System.Int32,System.Int32,System.Int32,System.Int32,Au.Wnd,Au.Types.LPARAM)">
            <summary>
            Creates window.
            Calls API <msdn>CreateWindowEx</msdn>.
            Returns false if failed, for example className is not registered.
            </summary>
            <param name="className">The name of any window class existing in this process. You can register a class with <see cref="M:Au.Wnd.Misc.MyWindow.RegisterClass(System.String,Au.Wnd.Misc.MyWindow.WndClassEx)"/> or use any other class.</param>
            <param name="name">Window name or null.</param>
            <param name="style"></param>
            <param name="exStyle"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="parent">Owner or parent window, or default.</param>
            <param name="controlId">Control id or 0.</param>
            <remarks>
            Your derived class should override <see cref="M:Au.Wnd.Misc.MyWindow.WndProc(Au.Wnd,System.Int32,Au.Types.LPARAM,Au.Types.LPARAM)"/>, which calls the window procedure of window class <paramref name="className"/>.
            The window will be destroyed in these cases: 1. Called <see cref="M:Au.Wnd.Misc.MyWindow.Destroy"/>. 2. Closed by the user or some program/script. 3. When this thread ends. 4. This function called again (then destroys old window and creates new).
            </remarks>
        </member>
        <member name="M:Au.Wnd.Misc.MyWindow.CreateMessageWindow(System.String)">
            <summary>
            Creates <msdn>message-only window</msdn>.
            Styles: WS_POPUP, WS_EX_NOACTIVATE.
            More info: <see cref="M:Au.Wnd.Misc.MyWindow.Create(System.String,System.String,Au.Types.Native.WS,Au.Types.Native.WS_EX,System.Int32,System.Int32,System.Int32,System.Int32,Au.Wnd,Au.Types.LPARAM)"/>.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.MyWindow.Destroy">
            <summary>
            Destroys the window.
            Calls API <msdn>DestroyWindow</msdn>.
            Does nothing if the window is already destroyed, for example closed by the user.
            If the window is not destroyed explicitly, the system destroys it when its thread ends.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.MyWindow.WndProc(Au.Wnd,System.Int32,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>
            Calls the window procedure of the window class (see <see cref="M:Au.Wnd.Misc.MyWindow.Create(System.String,System.String,Au.Types.Native.WS,Au.Types.Native.WS_EX,System.Int32,System.Int32,System.Int32,System.Int32,Au.Wnd,Au.Types.LPARAM)"/>) and manages the lifetime of this variable.
            Your derived class should override this function, call base.WndProc and return its return value, except when don't need default processing.
            More info: <msdn>Window Procedures</msdn>.
            </summary>
            <seealso cref="M:Au.Wnd.Misc.PrintMsg(Au.Wnd,System.Int32,Au.Types.LPARAM,Au.Types.LPARAM,System.Int32[])"/>
        </member>
        <member name="M:Au.Wnd.Misc.MyWindow.RegisterClass(System.String,Au.Wnd.Misc.MyWindow.WndClassEx)">
            <summary>
            Registers new window class.
            Returns class atom.
            </summary>
            <param name="className">Class name.</param>
            <param name="ex">
            Can be used to specify more fields of <msdn>WNDCLASSEX</msdn> that is passed to <msdn>RegisterClassEx</msdn>.
            Defaults: hCursor = arrow; hbrBackground = COLOR_BTNFACE+1; style = CS_GLOBALCLASS; others = 0/null/default.
            This function also adds CS_GLOBALCLASS style.
            </param>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed, for example if the class already exists and was registered not with this function.</exception>
            <remarks>
            Calls API <msdn>RegisterClassEx</msdn>.
            The class then can be used in all appdomains of this process. To create windows, use <see cref="M:Au.Wnd.Misc.MyWindow.Create(System.String,System.String,Au.Types.Native.WS,Au.Types.Native.WS_EX,System.Int32,System.Int32,System.Int32,System.Int32,Au.Wnd,Au.Types.LPARAM)"/>.
            Each class derived from MyWindow provides its own window procedure (overrides <see cref="M:Au.Wnd.Misc.MyWindow.WndProc(Au.Wnd,System.Int32,Au.Types.LPARAM,Au.Types.LPARAM)"/>). Windows created not with <see cref="M:Au.Wnd.Misc.MyWindow.Create(System.String,System.String,Au.Types.Native.WS,Au.Types.Native.WS_EX,System.Int32,System.Int32,System.Int32,System.Int32,Au.Wnd,Au.Types.LPARAM)"/> use API <msdn>DefWindowProc</msdn> as window procedure, and therefore are not useful.
            The window class remains registered until this process ends. Don't need to unregister.
            This function can be called multiple times for the same class, for example called once in each appdomain. Next time it just returns class atom.
            Thread-safe.
            <note type="note">Don't use code like <c>static ushort _atom = Wnd.Misc.MyWindow.RegisterClass("MyClass");</c>, because in Release configuration compiler removes this code if _atom is not used. Instead you can call this function in a static constructor.</note>
            </remarks>
        </member>
        <member name="T:Au.Wnd.Misc.MyWindow.WndClassEx">
            <summary>
            Used with <see cref="M:Au.Wnd.Misc.MyWindow.RegisterClass(System.String,Au.Wnd.Misc.MyWindow.WndClassEx)"/>.
            </summary>
            <tocexclude />
        </member>
        <member name="M:Au.Wnd.Misc.FindMessageWindow(System.String,System.String,Au.Wnd)">
            <summary>
            Finds a message-only window and returns its handle as Wnd. Returns default(Wnd) if not found.
            Calls API <msdn>FindWindowEx</msdn>.
            Faster than <see cref="M:Au.Wnd.Find(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>, which does not find message-only windows.
            Can be used only when you know full name and/or class name.
            Finds hidden windows too.
            </summary>
            <param name="name">
            Name.
            Use null to match any.
            Full, case-insensitive. Wildcard etc not supported.
            </param>
            <param name="className">
            Class name.
            Use null to match any. Cannot be "".
            Full, case-insensitive. Wildcard etc not supported.
            </param>
            <param name="wAfter">If used, starts searching from the next window in the Z order.</param>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="M:Au.Wnd.Misc.WindowRectFromClientRect(Au.Types.RECT@,Au.Types.Native.WS,Au.Types.Native.WS_EX,System.Boolean)">
            <summary>
            Calculates window rectangle from client area rectangle and style.
            Calls API <msdn>AdjustWindowRectEx</msdn>.
            </summary>
            <param name="r">Input - client area rectangle in screen. Output - window rectangle in screen.</param>
            <param name="style"></param>
            <param name="exStyle"></param>
            <param name="hasMenu"></param>
            <remarks>
            Ignores styles WS_VSCROLL, WS_HSCROLL and wrapped menu bar.
            </remarks>
        </member>
        <member name="M:Au.Wnd.Misc.BorderWidth(Au.Types.Native.WS,Au.Types.Native.WS_EX)">
            <summary>
            Calculates window border width from style.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.BorderWidth(Au.Wnd)">
            <summary>
            Gets window border width.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.GetGUIThreadInfo(Au.Types.Native.GUITHREADINFO@,System.Int32)">
            <summary>
            Calls API <msdn>GetGUIThreadInfo</msdn>, which can get some GUI info, eg mouse capturing, menu mode, move/size mode, focus, caret.
            </summary>
            <param name="g">Variable that receives the info.</param>
            <param name="idThread">Thread id. If 0 - the foreground (active window) thread. See <see cref="P:Au.Wnd.ThreadId"/>.</param>
        </member>
        <member name="M:Au.Wnd.Misc.CreateWindow(System.String,System.String,Au.Types.Native.WS,Au.Types.Native.WS_EX,System.Int32,System.Int32,System.Int32,System.Int32,Au.Wnd,Au.Types.LPARAM,System.IntPtr,Au.Types.LPARAM)">
            <summary>
            Creates native/unmanaged window.
            Calls API <msdn>CreateWindowEx</msdn>.
            Later call <see cref="M:Au.Wnd.Misc.DestroyWindow(Au.Wnd)"/> or <see cref="M:Au.Wnd.Close(System.Nullable{System.Boolean},System.Boolean)"/>.
            Usually don't need to specify hInstance.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.CreateWindowAndSetFont(System.String,System.String,Au.Types.Native.WS,Au.Types.Native.WS_EX,System.Int32,System.Int32,System.Int32,System.Int32,Au.Wnd,Au.Types.LPARAM,System.IntPtr,Au.Types.LPARAM,System.IntPtr)">
            <summary>
            Creates native/unmanaged window like <see cref="M:Au.Wnd.Misc.CreateWindow(System.String,System.String,Au.Types.Native.WS,Au.Types.Native.WS_EX,System.Int32,System.Int32,System.Int32,System.Int32,Au.Wnd,Au.Types.LPARAM,System.IntPtr,Au.Types.LPARAM)"/> and sets font.
            If customFontHandle not specified, sets the system UI font, usually it is Segoe UI, 9.
            Later call <see cref="M:Au.Wnd.Misc.DestroyWindow(Au.Wnd)"/> or <see cref="M:Au.Wnd.Close(System.Nullable{System.Boolean},System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.CreateMessageWindow(System.String)">
            <summary>
            Creates native/unmanaged <msdn>message-only window</msdn>.
            Styles: WS_POPUP, WS_EX_NOACTIVATE.
            Later call <see cref="M:Au.Wnd.Misc.DestroyWindow(Au.Wnd)"/> or <see cref="M:Au.Wnd.Close(System.Nullable{System.Boolean},System.Boolean)"/>.
            </summary>
            <param name="className">Window class name. Can be any existing class.</param>
        </member>
        <member name="M:Au.Wnd.Misc.DestroyWindow(Au.Wnd)">
            <summary>
            Destroys a native window of this thread.
            Calls API <msdn>DestroyWindow</msdn>.
            Returns false if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <seealso cref="M:Au.Wnd.Close(System.Nullable{System.Boolean},System.Boolean)"/>
        </member>
        <member name="M:Au.Wnd.Misc.GetWindowsStoreAppId(Au.Wnd,System.Boolean,System.Boolean)">
            <summary>
            Gets window Windows Store app user model id, like "Microsoft.WindowsCalculator_8wekyb3d8bbwe!App".
            Returns null if fails or if called on Windows 7.
            </summary>
            <param name="w"></param>
            <param name="prependShellAppsFolder">Prepend @"shell:AppsFolder\" (to run or get icon).</param>
            <param name="getExePathIfNotWinStoreApp">Get program path if it is not a Windows Store app.</param>
            <remarks>
            Windows Store app window class name can be "Windows.UI.Core.CoreWindow" or "ApplicationFrameWindow".
            </remarks>
        </member>
        <member name="M:Au.Wnd.Misc.SetFontHandle(Au.Wnd,System.IntPtr)">
            <summary>
            Sets native font handle.
            Sends message API <msdn>WM_SETFONT</msdn> with lParam 1.
            Does not copy the font; don't dispose it while the window is alive.
            Use this function only with windows of current process.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.GetFontHandle(Au.Wnd)">
            <summary>
            Gets native font handle.
            Sends message API <msdn>WM_GETFONT</msdn>.
            Does not copy the font; don't need to dispose.
            Use this function only with windows of current process.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.SetIconHandle(Au.Wnd,System.IntPtr,System.Boolean)">
            <summary>
            Sets native icon handle.
            Sends message API <msdn>WM_SETICON</msdn>.
            Does not copy the icon; don't dispose it while the window is alive.
            Use this function only with windows of current process.
            </summary>
            <seealso cref="T:Au.Icons"/>
        </member>
        <member name="M:Au.Wnd.Misc.GetIconHandle(Au.Wnd,System.Boolean)">
            <summary>
            Gets icon that is displayed in window title bar and in its taskbar button.
            Returns icon handle if successful, else default(IntPtr). Later call <see cref="M:Au.Icons.DestroyIconHandle(System.IntPtr)"/> or <see cref="M:Au.Icons.HandleToImage(System.IntPtr,System.Boolean)"/>.
            </summary>
            <param name="w"></param>
            <param name="size32">Get 32x32 icon. If false, gets 16x16 icon.</param>
            <remarks>
            Icon size depends on DPI (text size, can be changed in Control Panel). By default small is 16, large 32.
            This function can be used with windows of any process.
            </remarks>
            <seealso cref="T:Au.Icons"/>
        </member>
        <member name="M:Au.Wnd.Misc.GetClassLong(Au.Wnd,System.Int32)">
            <summary>
            Calls API <msdn>GetClassLong</msdn> if current process is 32-bit, <msdn>GetClassLongPtr</msdn> if 64-bit.
            </summary>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            For index can be used constants from <see cref="T:Au.Types.Native.GCL"/>. All values are the same in 32-bit and 64-bit process.
            </remarks>
        </member>
        <member name="M:Au.Wnd.Misc.GetClassAtom(System.String,System.IntPtr)">
            <summary>
            Gets atom of a window class.
            To get class atom when you have a window w, use <c>Wnd.Misc.GetClassLong(w, Native.GCL.ATOM)</c>.
            </summary>
            <param name="className">Class name.</param>
            <param name="moduleHandle">Native module handle of the exe or dll that registered the class. Don't use if it is a global class (CS_GLOBALCLASS style).</param>
        </member>
        <member name="M:Au.Wnd.Misc.RegisterMessage(System.String,System.Boolean)">
            <summary>
            Calls API <msdn>RegisterWindowMessage</msdn>.
            </summary>
            <param name="name">Message name. Can be any unique string.</param>
            <param name="uacEnable">Also call API <msdn>ChangeWindowMessageFilter</msdn> for the message. More info: <see cref="M:Au.Wnd.Misc.UacEnableMessages(System.Int32[])"/>.</param>
        </member>
        <member name="M:Au.Wnd.Misc.UacEnableMessages(System.Int32[])">
            <summary>
            Calls API <msdn>ChangeWindowMessageFilter</msdn> for each message in the list of messages.
            It allows processes of lower <see cref="T:Au.Process_.UacInfo">UAC</see> integrity level to send these messages to this process.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.InterProcessEnableReceivingWM_COPYDATA">
            <summary>
            Calls API <msdn>ChangeWindowMessageFilter</msdn> to enable receiving WM_COPYDATA message from lower <see cref="T:Au.Process_.UacInfo">UAC</see> integrity level processes, for example if you'll use <see cref="M:Au.Wnd.Misc.InterProcessGetData(Au.Types.LPARAM,System.Int32@)"/>.
            Call this once in process.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.InterProcessSendData(Au.Wnd,System.Int32,System.String,Au.Wnd)">
            <summary>
            Sends data to a window of another process using message <msdn>WM_COPYDATA</msdn>.
            Returns true if the window received the message and returned true from its window procedure.
            See also: <see cref="M:Au.Wnd.Misc.InterProcessGetData(Au.Types.LPARAM,System.Int32@)"/>.
            </summary>
            <param name="w">The window of that process that will receive the message.</param>
            <param name="stringId">An integer identifier of the string, to store in COPYDATASTRUCT.dwData.</param>
            <param name="s">String containing data of any format. Can have '\0' characters.</param>
            <param name="wSender">Optional. A window of this process that sends the message. The receiving window procedure receives it in wParam.</param>
            <seealso cref="T:Au.Util.SharedMemory"/>
        </member>
        <member name="M:Au.Wnd.Misc.InterProcessGetData(Au.Types.LPARAM,System.Int32@)">
            <summary>
            Gets data stored in <msdn>COPYDATASTRUCT</msdn> structure received by a window procedure with <msdn>WM_COPYDATA</msdn> message.
            See also: <see cref="M:Au.Wnd.Misc.InterProcessSendData(Au.Wnd,System.Int32,System.String,Au.Wnd)"/>, <see cref="M:Au.Wnd.Misc.InterProcessEnableReceivingWM_COPYDATA"/>.
            </summary>
            <param name="lParam">lParam of the window procedure when it received WM_COPYDATA message. It is COPYDATASTRUCT pointer.</param>
            <param name="stringId">Receives string id stored in COPYDATASTRUCT.dwData.</param>
            <remarks>
            <note type="note"><see cref="T:Au.Process_.UacInfo">UAC</see> blocks messages sent from processes of lower integrity level. Call <see cref="M:Au.Wnd.Misc.InterProcessEnableReceivingWM_COPYDATA"/> before (once).</note>
            </remarks>
        </member>
        <member name="M:Au.Wnd.Misc.PrintMsg(System.Windows.Forms.Message@,System.Int32[])">
            <summary>
            Writes a Windows message to the output.
            </summary>
            <param name="m"></param>
            <param name="ignore">Messages to not show.</param>
        </member>
        <member name="M:Au.Wnd.Misc.PrintMsg(Au.Wnd,System.Int32,Au.Types.LPARAM,Au.Types.LPARAM,System.Int32[])">
            <summary>
            Writes a Windows message to the output.
            </summary>
            <param name="w"></param>
            <param name="msg"></param>
            <param name="wParam"></param>
            <param name="lParam"></param>
            <param name="ignore">Messages to not show.</param>
        </member>
        <member name="M:Au.Wnd.Misc.PrintMsg(Au.Types.Native.MSG@,System.Int32[])">
            <summary>
            Writes a Windows message to the output.
            </summary>
            <param name="m"></param>
            <param name="ignore">Messages to not show.</param>
        </member>
        <member name="M:Au.Wnd.Misc.SetWindowSubclass(Au.Wnd,Au.Types.SUBCLASSPROC,Au.Types.LPARAM,System.IntPtr)">
            <summary>API <msdn>SetWindowSubclass</msdn></summary>
        </member>
        <member name="M:Au.Wnd.Misc.GetWindowSubclass(Au.Wnd,Au.Types.SUBCLASSPROC,Au.Types.LPARAM,System.IntPtr@)">
            <summary>API <msdn>GetWindowSubclass</msdn></summary>
        </member>
        <member name="M:Au.Wnd.Misc.RemoveWindowSubclass(Au.Wnd,Au.Types.SUBCLASSPROC,Au.Types.LPARAM)">
            <summary>API <msdn>RemoveWindowSubclass</msdn></summary>
        </member>
        <member name="M:Au.Wnd.Misc.DefSubclassProc(Au.Wnd,System.UInt32,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>API <msdn>DefSubclassProc</msdn></summary>
        </member>
        <member name="M:Au.Wnd.Misc.DefWindowProc(Au.Wnd,System.UInt32,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>API <msdn>DefWindowProc</msdn></summary>
        </member>
        <member name="M:Au.Wnd.ThrowIf0">
            <summary>
            If <see cref="P:Au.Wnd.Is0"/>, throws <see cref="T:Au.Types.WndException"/>.
            </summary>
            <exception cref="T:Au.Types.WndException"></exception>
        </member>
        <member name="M:Au.Wnd.ThrowIfInvalid">
            <summary>
            If <see cref="P:Au.Wnd.Is0"/> or !<see cref="P:Au.Wnd.IsAlive"/>, throws <see cref="T:Au.Types.WndException"/>.
            </summary>
            <exception cref="T:Au.Types.WndException"></exception>
        </member>
        <member name="M:Au.Wnd.ThrowUseNative">
            <summary>
            Throws <see cref="T:Au.Types.WndException"/> that uses the last Windows API error (code and message).
            Also the message depends on whether the window handle is 0/invalid.
            </summary>
            <exception cref="T:Au.Types.WndException"></exception>
        </member>
        <member name="M:Au.Wnd.ThrowUseNative(System.String)">
            <summary>
            Throws <see cref="T:Au.Types.WndException"/> that uses mainMessage and the last Windows API error (code and message).
            Also the message depends on whether the window handle is 0/invalid.
            </summary>
            <exception cref="T:Au.Types.WndException"></exception>
        </member>
        <member name="M:Au.Wnd.ThrowUseNative(System.Int32,System.String)">
            <summary>
            Throws <see cref="T:Au.Types.WndException"/> that uses mainMessage and the specified Windows API error code.
            Also the message depends on whether the window handle is 0/invalid.
            </summary>
            <exception cref="T:Au.Types.WndException"></exception>
        </member>
        <member name="M:Au.Wnd.ThrowNoNative(System.String)">
            <summary>
            Throws <see cref="T:Au.Types.WndException"/> that uses mainMessage and does not use the last Windows API error.
            Also the message depends on whether the window handle is 0/invalid.
            </summary>
            <exception cref="T:Au.Types.WndException"></exception>
        </member>
        <member name="P:Au.Wnd.Is0">
            <summary>
            Returns true if the <see cref="T:Au.Wnd">window handle</see> is 0.
            </summary>
            <example>
            <code><![CDATA[
            Wnd w = Wnd.Find("Window*");
            if(w.Is0) { Print("window not found"); return; }
            ]]></code>
            </example>
            <seealso cref="P:Au.Wnd.IsAlive"/>
        </member>
        <member name="P:Au.Wnd.IsAlive">
            <summary>
            Returns true if the <see cref="T:Au.Wnd">window handle</see> identifies an existing window.
            Returns false if the handle is 0 or invalid.
            Invalid non-0 handle usually means that the window is closed/destroyed.
            </summary>
            <remarks>
            Calls <see cref="P:Au.Wnd.Is0"/> and API <msdn>IsWindow</msdn>.
            Although a Wnd variable holds a window handle, which is like a reference to a window, it does not prevent closing that window and making the handle invalid. After closing the window, the OS can even assign the same handle value to a new window, although normally it can happen only after long time.
            <note>Use this carefully with windows of other applications or threads. The window can be closed at any moment, even when your thread is still in this function.</note>
            </remarks>
        </member>
        <member name="P:Au.Wnd.IsVisible">
            <summary>
            Returns true if the window is visible.
            Returns false if is invisible or is a child of invisible parent.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <remarks>
            Calls API <msdn>IsWindowVisible</msdn>. Does not call <see cref="P:Au.Wnd.IsCloaked"/>.
            
            Even when this function returns true, the window may be actually invisible. It can be cloaked, on an inactive Windows 10 virtual desktop (cloaked), inactive Windows Store app (cloaked), transparent, zero-size, minimized, off-screen, covered by other windows or can have zero-size window region.
            </remarks>
            <seealso cref="P:Au.Wnd.IsVisibleEx"/>
            <seealso cref="P:Au.Wnd.IsCloaked"/>
            <seealso cref="P:Au.Wnd.IsVisibleAndNotCloaked"/>
            <seealso cref="M:Au.Wnd.Show(System.Boolean)"/>
            <seealso cref="M:Au.Wnd.Activate"/>
        </member>
        <member name="P:Au.Wnd.IsVisibleEx">
            <summary>
            Returns true if the window is visible.
            Returns false if is invisible or is a child of invisible parent.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <remarks>
            Returns false if API <msdn>IsWindowVisible</msdn> returns false.
            Also returns false if <see cref="P:Au.Wnd.IsCloaked"/> returns true, but only for some popup windows that usually are useless and could cause problems if considered visible.
            Else returns true.
            
            Even when this function returns true, the window may be actually invisible. It can be cloaked (excepth the above case), on an inactive Windows 10 virtual desktop (cloaked), inactive Windows Store app (cloaked), transparent, zero-size, minimized, off-screen, covered by other windows or can have zero-size window region.
            </remarks>
            <seealso cref="P:Au.Wnd.IsVisible"/>
            <seealso cref="P:Au.Wnd.IsCloaked"/>
            <seealso cref="P:Au.Wnd.IsVisibleAndNotCloaked"/>
            <seealso cref="M:Au.Wnd.Show(System.Boolean)"/>
            <seealso cref="M:Au.Wnd.Activate"/>
        </member>
        <member name="P:Au.Wnd.IsVisibleAndNotCloaked">
            <summary>
            Returns true if <see cref="P:Au.Wnd.IsVisible"/> returns true and <see cref="P:Au.Wnd.IsCloaked"/> returns false.
            </summary>
            <seealso cref="P:Au.Wnd.IsVisibleEx"/>
        </member>
        <member name="M:Au.Wnd.Show(System.Boolean)">
            <summary>
            Shows (if hidden) or hides this window.
            Does not activate/deactivate/zorder.
            With windows of current thread usually it's better to use <see cref="M:Au.Wnd.ShowLL(System.Boolean)"/>.
            </summary>
            <remarks>
            Calls API <msdn>ShowWindow</msdn> with SW_SHOWNA or SW_HIDE.
            </remarks>
            <exception cref="T:Au.Types.WndException"/>
        </member>
        <member name="M:Au.Wnd.ShowLL(System.Boolean)">
            <summary>
            Shows (if hidden) or hides this window.
            Does not activate/deactivate/zorder.
            </summary>
            <remarks>
            This library has two similar functions - <see cref="M:Au.Wnd.Show(System.Boolean)"/> and <b>ShowLL</b>. <b>Show</b> is better to use in automation scripts, with windows of any process/thread. <b>ShowLL</b> usually is better to use in programming, with windows of current thread.
            <b>ShowLL</b> is more low-level. Does not throw exception when fails, and does not add a delay; <b>Show</b> adds a small delay when the window is of other thread.
            
            Calls API <msdn>ShowWindow</msdn> with SW_SHOWNA or SW_HIDE.
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="P:Au.Wnd.IsEnabled">
            <summary>
            Gets the enabled state.
            Returns true if the window is enabled.
            Returns false if is disabled or is a child of disabled parent.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="M:Au.Types.Native.GetError"/>.
            Calls API <msdn>IsWindowEnabled</msdn>.
            </summary>
        </member>
        <member name="M:Au.Wnd.Enable(System.Boolean)">
            <summary>
            Enables or disables the window.
            Calls API <msdn>EnableWindow</msdn>.
            </summary>
            <param name="enable">Enable or disable.</param>
            <exception cref="T:Au.Types.WndException"/>
        </member>
        <member name="P:Au.Wnd.IsCloakedGetState">
            <summary>
            Gets the cloaked state.
            Returns 0 if not cloaked or if failed.
            Else returns flags: 1 cloaked by its application, 2 cloaked by Windows, 4 cloaked because its owner window is cloaked.
            On Windows 7 returns 0 because there is no "cloaked window" feature.
            </summary>
            <seealso cref="P:Au.Wnd.IsCloaked"/>
        </member>
        <member name="P:Au.Wnd.IsCloaked">
            <summary>
            Returns true if the window is cloaked.
            Returns false if not cloaked or if failed.
            On Windows 7 returns false because there is no "cloaked window" feature.
            Windows 10 uses window cloaking mostly to hide windows on inactive desktops. Windows 8 - mostly to hide Metro app windows.
            </summary>
            <seealso cref="P:Au.Wnd.IsCloakedGetState"/>
        </member>
        <member name="P:Au.Wnd.IsMinimized">
            <summary>
            Returns true if minimized, false if not.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="M:Au.Types.Native.GetError"/>.
            Calls API <msdn>IsIconic</msdn>.
            </summary>
        </member>
        <member name="P:Au.Wnd.IsMaximized">
            <summary>
            Returns true if maximized, false if not.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="M:Au.Types.Native.GetError"/>.
            Calls API <msdn>IsZoomed</msdn>.
            </summary>
        </member>
        <member name="M:Au.Wnd.ShowMinimized(System.Boolean)">
            <summary>
            If not minimized, minimizes.
            Also unhides.
            </summary>
            <param name="noAnimation">Visually fast, without animation.</param>
            <exception cref="T:Au.Types.WndException">The API call failed. No exception if the window did not obey.</exception>
        </member>
        <member name="M:Au.Wnd.ShowMaximized(System.Boolean)">
            <summary>
            If not minimized, minimizes.
            Also unhides.
            </summary>
            <param name="noAnimation">Visually fast, without animation.</param>
            <exception cref="T:Au.Types.WndException">The API call failed. No exception if the window did not obey.</exception>
        </member>
        <member name="M:Au.Wnd.ShowNotMinMax(System.Boolean)">
            <summary>
            If maximized or minimized, makes normal (not min/max).
            Also unhides.
            </summary>
            <param name="noAnimation">Visually fast, without animation.</param>
            <exception cref="T:Au.Types.WndException">The API call failed. No exception if the window did not obey.</exception>
        </member>
        <member name="M:Au.Wnd.ShowNotMinimized(System.Boolean)">
            <summary>
            If minimized, restores previous non-minimized state (maximized or normal).
            Also unhides.
            </summary>
            <param name="noAnimation">Visually fast, without animation.</param>
            <exception cref="T:Au.Types.WndException">The API call failed. No exception if the window did not obey.</exception>
        </member>
        <member name="M:Au.Wnd._MinMaxRes(System.Int32,System.Boolean)">
            <summary>
            Sets window min/max/normal/restore state.
            Also unhides.
            </summary>
            <param name="state">Must be SW_MINIMIZE, SW_RESTORE (restores to normal/max if minimized), SW_SHOWNORMAL or SW_SHOWMAXIMIZED.</param>
            <param name="noAnimation">Use SetWindowPlacement (no animation).</param>
            <exception cref="T:Au.Types.WndException"/>
        </member>
        <member name="M:Au.Wnd.LibGetWindowPlacement(Au.Types.Api.WINDOWPLACEMENT@,System.String)">
            <summary>
            Initializes a WINDOWPLACEMENT struct and calls API <msdn>GetWindowPlacement</msdn>.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
            <exception cref="T:Au.Types.WndException">Failed. Throws, only if errStr!=null, else returns false.</exception>
        </member>
        <member name="M:Au.Wnd.LibSetWindowPlacement(Au.Types.Api.WINDOWPLACEMENT@,System.String)">
            <summary>
            Sets WINDOWPLACEMENT <b>length</b> field and calls API <msdn>SetWindowPlacement</msdn>.
            </summary>
            <exception cref="T:Au.Types.WndException">Failed. Throws, only if errStr!=null, else returns false.</exception>
        </member>
        <member name="T:Au.Wnd.Lib">
            <summary>
            Internal static functions.
            </summary>
        </member>
        <member name="M:Au.Wnd.Lib.EnableActivate(System.Boolean)">
            <summary>
            No exceptions.
            </summary>
        </member>
        <member name="M:Au.Wnd.Lib._EnableActivate_SendKey(System.Boolean)">
            <summary>
            Sends a key (VK_0 up). It allows to activate now.
            Later this process can always activate easily (without key etc). It works even with higher IL windows.
            Don't know why is this behavior. Tested on all OS from XP to 10.
            Does not work if the foreground process has higher UAC IL.
            </summary>
        </member>
        <member name="M:Au.Wnd.Lib._EnableActivate_MinRes">
            <summary>
            Creates a temporary minimized window and restores it. It activates the window and allows us to activate.
            Then sets 'no active window' to prevent auto-activating another window when destroying the temporary window.
            </summary>
        </member>
        <member name="M:Au.Wnd.Lib._EnableActivate_AllowSetFore">
            <summary>
            Calls Api.AllowSetForegroundWindow(Api.GetCurrentProcessId()).
            </summary>
        </member>
        <member name="F:Au.Wnd.Lib.ActivateFlags.NoThrowIfInvalid">
            <summary>
            Don't call ThrowIfInvalid at the very start (ie called ensures it is valid).
            </summary>
        </member>
        <member name="F:Au.Wnd.Lib.ActivateFlags.NoGetWindow">
            <summary>
            Don't call Get.Window (ie caller ensures it's a top-level window, not control).
            </summary>
        </member>
        <member name="F:Au.Wnd.Lib.ActivateFlags.IgnoreIfNoActivateStyleEtc">
            <summary>
            Don't activate if has WS_EX_NOACTIVATE style or is toolwindow without caption, unless cloaked.
            Then just calls ZorderTop(), which in most cases does not work (inactive window).
            </summary>
        </member>
        <member name="F:Au.Wnd.Lib.ActivateFlags.ForScreenCapture">
            <summary>
            Wait for window animations to end. Eg when switching Win10 desktops.
            </summary>
        </member>
        <member name="M:Au.Wnd.Lib.MoveInScreen(System.Boolean,Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.Wnd,Au.Types.RECT@,Au.Types.Screen_,System.Boolean,System.Boolean,System.Nullable{Au.Types.RECT})">
            <summary>
            Used directly by MoveInScreen, EnsureInScreen, RECT.MoveInScreen, RECT.EnsureInScreen. With inRect used by RECT.MoveInRect.
            </summary>
        </member>
        <member name="T:Au.Wnd.Lib.WinFlags">
            <summary>
            Calls API SetProp/GetProp to set/get window flags <see cref="T:Au.Wnd.Lib.WFlags"/>.
            </summary>
        </member>
        <member name="M:Au.Wnd.Lib.IsSpecHwnd(Au.Wnd)">
            <summary>
            Returns true if w contains a non-zero special handle value (<see cref="T:Au.Types.Native.HWND"/>).
            Note: <b>Native.HWND.TOP</b> is 0.
            </summary>
        </member>
        <member name="T:Au.Wnd.Lib.EnumCallback">
            <summary>
            For EnumWindows2.
            </summary>
        </member>
        <member name="M:Au.Wnd.Lib.EnumWindows2(Au.Wnd.Lib.EnumWindowsAPI,System.Boolean,System.Boolean,Au.Wnd,System.Boolean,System.Int32,Au.Wnd.Lib.EnumCallback,System.Object)">
            <summary>
            This version creates much less garbage (the garbage would be the returned managed array).
            The caller must dispose the returned LibArrayBuilder.
            </summary>
        </member>
        <member name="M:Au.Wnd.LibActivate(Au.Wnd.Lib.ActivateFlags)">
            <summary>
            Activates this window (brings to the foreground).
            The same as <see cref="M:Au.Wnd.Activate"/>, but has some options.
            Returns false if does not activate because of flag IgnoreIfNoActivateStyleEtc.
            </summary>
            <exception cref="T:Au.Types.WndException"/>
        </member>
        <member name="M:Au.Wnd.Activate">
            <summary>
            Activates this window (brings to the foreground).
            Also unhides, restores minimized etc, to ensure that the window is ready to receive sent keys, mouse clicks ect.
            </summary>
            <remarks>
            Activating a window usually also uncloaks it, for example switches to its virtual desktop on Windows 10.
            Fails (throws exception) if cannot activate this window, except:
            <list type="number">
            <item>If this is a control, activates its top-level parent window.</item>
            <item>If this is <see cref="P:Au.Wnd.GetWnd.Root"/>, just deactivates the currently active window.</item>
            <item>When the target application instead activates another window of the same thread.</item>
            </list>
            </remarks>
            <exception cref="T:Au.Types.WndException"/>
            <seealso cref="M:Au.Wnd.ActivateLL"/>
            <seealso cref="P:Au.Wnd.IsActive"/>
            <seealso cref="P:Au.Wnd.Active"/>
            <seealso cref="M:Au.Wnd.SwitchActiveWindow"/>
        </member>
        <member name="M:Au.Wnd.ActivateLL">
            <summary>
            Low-level version of <see cref="M:Au.Wnd.Activate"/>.
            Just calls <see cref="M:Au.Wnd.Misc.EnableActivate"/>, API <msdn>SetForegroundWindow</msdn> and makes sure that it actually worked, but does not check whether it activated exactly this window.
            No exceptions, does not unhide, does not restore minimized, does not check is it a top-level window or control, etc.
            Returns false if fails.
            </summary>
        </member>
        <member name="M:Au.Wnd.Focus">
            <summary>
            Sets the keyboard input focus to this control.
            Also activetes its top-level parent window (see <see cref="M:Au.Wnd.Activate"/>).
            </summary>
            <remarks>
            The control can belong to any process/thread. With controls of this thread you can use the more lightweight function <see cref="M:Au.Wnd.ThisThread.Focus(Au.Wnd)"/>.
            Works not with all windows. For example, does not work with Windows Store apps. Then use <see cref="M:Au.Acc.Focus(System.Boolean)"/>.
            Can instead focus a child control. For example, if this is a ComboBox, it will focus its child Edit control. Then does not throw exception.
            This can be control or top-level window. Top-level windows also can have focus.
            </remarks>
            <exception cref="T:Au.Types.WndException">
            Invalid handle; disabled; failed to set focus; failed to activate parent window.
            Fails to set focus when the target process is admin or uiAccess and this process isn't (see <see cref="T:Au.Process_.UacInfo">UAC</see>).
            </exception>
            <seealso cref="P:Au.Wnd.Focused"/>
            <seealso cref="P:Au.Wnd.IsFocused"/>
            <seealso cref="M:Au.Acc.Focus(System.Boolean)"/>
        </member>
        <member name="P:Au.Wnd.Focused">
            <summary>
            Gets the control or window that has the keyboard input focus.
            </summary>
            <remarks>
            The control/window can belong to any process/thread. With controls/windows of this thread you can use the more lightweight function <see cref="P:Au.Wnd.ThisThread.Focused"/>.
            Calls API <msdn>GetGUIThreadInfo</msdn>.
            </remarks>
            <seealso cref="M:Au.Wnd.Focus"/>
            <seealso cref="P:Au.Wnd.IsFocused"/>
        </member>
        <member name="P:Au.Wnd.IsFocused">
            <summary>
            Returns true if this is the control or window that has the keyboard input focus.
            </summary>
            <remarks>
            This control/window can belong to any process/thread. With controls/windows of this thread you can use the more lightweight function <see cref="M:Au.Wnd.ThisThread.IsFocused(Au.Wnd)"/>.
            Calls <see cref="P:Au.Wnd.Focused"/>.
            </remarks>
            <seealso cref="M:Au.Wnd.Focus"/>
        </member>
        <member name="T:Au.Wnd.ThisThread">
            <summary>
            Functions that can be used only with windows/controls of this thread.
            </summary>
        </member>
        <member name="M:Au.Wnd.ThisThread.Focus(Au.Wnd)">
            <summary>
            Calls API <msdn>SetFocus</msdn>. It sets the keyboard input focus to the specified control or window, which must be of this thread.
            Returns false if fails. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <remarks>
            Fails if the control/window belongs to another thread or is invalid or disabled.
            Can instead focus a child control. For example, if ComboBox, will focus its child Edit control. Then returns true.
            </remarks>
        </member>
        <member name="P:Au.Wnd.ThisThread.Focused">
            <summary>
            Gets the focused control or window of this thread.
            </summary>
            <remarks>
            Calls API <msdn>GetFocus</msdn>.
            </remarks>
        </member>
        <member name="M:Au.Wnd.ThisThread.IsFocused(Au.Wnd)">
            <summary>
            Returns true if w is the focused control or window of this thread.
            </summary>
            <remarks>
            Calls API <msdn>GetFocus</msdn>.
            </remarks>
        </member>
        <member name="P:Au.Wnd.ThisThread.Active">
            <summary>
            Gets the active window of this thread.
            Calls API <msdn>GetActiveWindow</msdn>.
            </summary>
        </member>
        <member name="M:Au.Wnd.GetRect(Au.Types.RECT@,System.Boolean)">
            <summary>
            Gets rectangle (position and size) in screen coordinates.
            </summary>
            <param name="r">Receives the rectangle. Will be default(RECT) if failed.</param>
            <param name="withoutExtendedFrame">Don't include the transparent part of window border. For it is used API <msdn>DwmGetWindowAttribute</msdn>(DWMWA_EXTENDED_FRAME_BOUNDS); it is less reliable.</param>
            <remarks>
            The same as the <see cref="P:Au.Wnd.Rect"/> property.
            Calls API <msdn>GetWindowRect</msdn> and returns its return value.
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="M:Au.Wnd.GetSize(Au.Types.SIZE@)">
            <summary>
            Gets width and height.
            </summary>
            <param name="z">Receives width and height. Will be default(SIZE) if failed.</param>
            <remarks>
            The same as the <see cref="P:Au.Wnd.Size"/> property.
            Calls API <msdn>GetWindowRect</msdn> and returns its return value.
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="P:Au.Wnd.Rect">
            <summary>
            Gets rectangle (position and size) in screen coordinates.
            </summary>
            <remarks>
            Calls <see cref="M:Au.Wnd.GetRect(Au.Types.RECT@,System.Boolean)"/>. Returns default(RECT) if fails (eg window closed).
            </remarks>
        </member>
        <member name="P:Au.Wnd.Size">
            <summary>
            Gets width and height.
            </summary>
            <remarks>
            Calls <see cref="M:Au.Wnd.GetSize(Au.Types.SIZE@)"/>. Returns default(SIZE) if fails (eg window closed).
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="P:Au.Wnd.X">
            <summary>
            Gets horizontal position in screen coordinates.
            </summary>
            <remarks>Calls <see cref="M:Au.Wnd.GetRect(Au.Types.RECT@,System.Boolean)"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.Y">
            <summary>
            Gets vertical position in screen coordinates.
            </summary>
            <remarks>Calls <see cref="M:Au.Wnd.GetRect(Au.Types.RECT@,System.Boolean)"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.Width">
            <summary>
            Gets width.
            </summary>
            <remarks>Calls <see cref="M:Au.Wnd.GetRect(Au.Types.RECT@,System.Boolean)"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.Height">
            <summary>
            Gets height.
            </summary>
            <remarks>Calls <see cref="M:Au.Wnd.GetRect(Au.Types.RECT@,System.Boolean)"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.GetClientRect(Au.Types.RECT@,System.Boolean)">
            <summary>
            Gets client area rectangle.
            </summary>
            <param name="r">Receives the rectangle. Will be default(RECT) if failed.</param>
            <param name="inScreen">
            Get rectangle in screen coordinates; the same as <see cref="M:Au.Wnd.GetWindowAndClientRectInScreen(Au.Types.RECT@,Au.Types.RECT@)"/>.
            If false (default), calls API <msdn>GetClientRect</msdn>; the same as <see cref="P:Au.Wnd.ClientRect"/> or <see cref="M:Au.Wnd.GetClientSize(Au.Types.SIZE@)"/>.</param>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="M:Au.Wnd.GetClientSize(Au.Types.SIZE@)">
            <summary>
            Gets client area width and height.
            </summary>
            <param name="z">Receives width and height. Will be default(RECT) if failed.</param>
            <remarks>
            The same as the <see cref="P:Au.Wnd.ClientSize"/> property.
            The same as <see cref="M:Au.Wnd.GetClientRect(Au.Types.RECT@,System.Boolean)"/>, just the parameter type is different.
            Calls API <msdn>GetClientRect</msdn> and returns its return value.
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="P:Au.Wnd.ClientRect">
            <summary>
            Gets client area rectangle (width and height).
            </summary>
            <remarks>
            The same as <see cref="P:Au.Wnd.ClientSize"/>, just the return type is different.
            The left and top fields are always 0. The right and bottom fields are the width and height of the client area.
            Calls <see cref="M:Au.Wnd.GetClientRect(Au.Types.RECT@,System.Boolean)"/>. Returns default(RECT) if fails (eg window closed).
            </remarks>
        </member>
        <member name="P:Au.Wnd.ClientRectInScreen">
            <summary>
            Gets client area rectangle (width and height) in screen.
            </summary>
            <remarks>
            Calls <see cref="M:Au.Wnd.GetClientRect(Au.Types.RECT@,System.Boolean)"/>. Returns default(RECT) if fails (eg window closed).
            </remarks>
        </member>
        <member name="P:Au.Wnd.ClientSize">
            <summary>
            Gets client area width and height.
            </summary>
            <remarks>
            The same as <see cref="P:Au.Wnd.ClientRect"/>, just the return type is different.
            Calls <see cref="M:Au.Wnd.GetClientSize(Au.Types.SIZE@)"/>. Returns default(SIZE) if fails (eg window closed).
            </remarks>
        </member>
        <member name="P:Au.Wnd.ClientWidth">
            <summary>
            Gets client area width.
            </summary>
            <remarks>Calls <see cref="M:Au.Wnd.GetClientSize(Au.Types.SIZE@)"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.ClientHeight">
            <summary>
            Gets client area height.
            </summary>
            <remarks>Calls <see cref="M:Au.Wnd.GetClientSize(Au.Types.SIZE@)"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.SetClientSize(System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Calculates and sets window rectangle from the specified client area rectangle.
            Calls <see cref="M:Au.Wnd.ResizeLL(System.Int32,System.Int32)"/>.
            </summary>
            <param name="width">Width. Use null to not change.</param>
            <param name="height">Height. Use null to not change.</param>
            <exception cref="T:Au.Types.WndException"/>
        </member>
        <member name="M:Au.Wnd.LibGetWindowInfo(Au.Types.Api.WINDOWINFO@)">
            <summary>
            Calls API <msdn>GetWindowInfo</msdn>.
            </summary>
            <param name="wi">Receives window/client rectangles, styles etc.</param>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.GetWindowAndClientRectInScreen(Au.Types.RECT@,Au.Types.RECT@)">
            <summary>
            Gets window rectangle and client area rectangle, both in screen coordinates.
            </summary>
            <param name="rWindow">Receives window rectangle.</param>
            <param name="rClient">Receives client area rectangle.</param>
            <remarks>Calls API <msdn>GetWindowInfo</msdn>. Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.MapClientToClientOf(Au.Wnd,Au.Types.RECT@)">
            <summary>
            Converts coordinates relative to the client area of this window to coordinates relative to the client area of window w.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.MapClientToClientOf(Au.Wnd,Au.Types.POINT@)">
            <summary>
            Converts coordinates relative to the client area of this window to coordinates relative to the client area of window w.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.MapClientToScreen(Au.Types.RECT@)">
            <summary>
            Converts coordinates relative to the client area of this window to coordinates relative to the screen.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.MapClientToScreen(Au.Types.POINT@)">
            <summary>
            Converts coordinates relative to the client area of this window to coordinates relative to the screen.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.MapScreenToClient(Au.Types.RECT@)">
            <summary>
            Converts coordinates relative to the screen to coordinates relative to the client area of this window.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.MapScreenToClient(Au.Types.POINT@)">
            <summary>
            Converts coordinates relative to the screen to coordinates relative to the client area of this window.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.MapClientToWindow(Au.Types.POINT@)">
            <summary>
            Converts coordinates relative to the client area of this window to coordinates relative to the top-left corner of this window.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.MapClientToWindow(Au.Types.RECT@)">
            <summary>
            Converts coordinates relative to the client area of this window to coordinates relative to the top-left corner of this window.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.MapWindowToClient(Au.Types.POINT@)">
            <summary>
            Converts coordinates relative to the top-left corner of this window to coordinates relative to the client area of this window.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.MapWindowToClient(Au.Types.RECT@)">
            <summary>
            Converts coordinates relative to the top-left corner of this window to coordinates relative to the client area of this window.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.MapWindowToScreen(Au.Types.POINT@)">
            <summary>
            Converts coordinates relative to the top-left corner of this window to screen coordinates.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.MapWindowToScreen(Au.Types.RECT@)">
            <summary>
            Converts coordinates relative to the top-left corner of this window to screen coordinates.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.GetRectInClientOf(Au.Wnd,Au.Types.RECT@)">
            <summary>
            Gets rectangle of this window (usually control) relative to the client area of another window (usually the parent).
            </summary>
            <param name="w">The returned rectangle will be relative to the client area of window w. If w is default(Wnd), gets rectangle in screen.</param>
            <param name="r">Receives the rectangle.</param>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
            <seealso cref="P:Au.Wnd.RectInDirectParent"/>
        </member>
        <member name="P:Au.Wnd.RectInDirectParent">
            <summary>
            Gets child window rectangle in the client area of the direct parent window.
            </summary>
            <remarks>
            Calls <see cref="P:Au.Wnd.GetWnd.DirectParent"/> and <see cref="M:Au.Wnd.GetRectInClientOf(Au.Wnd,Au.Types.RECT@)"/>. Returns default(RECT) if fails (eg window closed).
            </remarks>
        </member>
        <member name="P:Au.Wnd.RectInWindow">
            <summary>
            Gets child window rectangle in the client area of the top-level parent window.
            </summary>
            <remarks>
            Calls <see cref="P:Au.Wnd.Window"/> and <see cref="M:Au.Wnd.GetRectInClientOf(Au.Wnd,Au.Types.RECT@)"/>. Returns default(RECT) if fails (eg window closed).
            </remarks>
        </member>
        <member name="M:Au.Wnd.GetRectNotMinMax(Au.Types.RECT@)">
            <summary>
            Gets rectangle of normal (restored) window even if currently it is minimized or maximized.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.MouseClientXY">
            <summary>
            Returns mouse pointer position relative to the client area of this window.
            </summary>
        </member>
        <member name="M:Au.Wnd.ContainsScreenXY(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Returns true if this window (its rectangle) contains the specified point.
            </summary>
            <param name="x">X coordinate in screen. Not used if default(Coord).</param>
            <param name="y">Y coordinate in screen. Not used if default(Coord).</param>
        </member>
        <member name="M:Au.Wnd.ContainsWindowXY(Au.Wnd,Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Returns true if this control (its rectangle) contains the specified point in parent window.
            </summary>
            <param name="parent">
            Direct or indirect parent window. The coordinates are relative to its client area.
            Actually this and parent can be any windows or controls, the function does not check whether this is a child of parent.
            </param>
            <param name="x">X coordinate. Not used if default(Coord).</param>
            <param name="y">Y coordinate. Not used if default(Coord).</param>
        </member>
        <member name="M:Au.Wnd.ContainsWindowXY(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            This overload calls <see cref="M:Au.Wnd.ContainsWindowXY(Au.Wnd,Au.Types.Coord,Au.Types.Coord)"/>(Window, x, y).
            </summary>
        </member>
        <member name="M:Au.Wnd.SetWindowPos(Au.Types.Native.SWP,System.Int32,System.Int32,System.Int32,System.Int32,Au.Wnd)">
            <summary>
            Calls API <msdn>SetWindowPos</msdn>.
            </summary>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            For <paramref name="wndInsertAfter"/> you can use enum <b>Native.HWND</b> members: <b>TOP</b>, <b>BOTTOM</b>, <b>TOPMOST</b>, <b>NOTOPMOST</b>.
            </remarks>
        </member>
        <member name="M:Au.Wnd.MoveLL(System.Int32,System.Int32,System.Int32,System.Int32,Au.Types.Native.SWP)">
            <summary>
            Moves and resizes.
            </summary>
            <remarks>
            See also <see cref="M:Au.Wnd.Move(Au.Types.Coord,Au.Types.Coord,Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.Types.Screen_)"/>. It is better to use in automation scripts, with windows of any process/thread. It throws exceptions, supports optional/reverse/fractional/workarea coordinates, restores if min/max, does not support SWP flags.
            This function is low-level, it just calls API <msdn>SetWindowPos</msdn> with flags NOZORDER|NOOWNERZORDER|NOACTIVATE|swpFlagsToAdd. It is better to use in programming, with windows of current thread.
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            
            For top-level windows use screen coordinates. For controls - direct parent client coordinates.
            </remarks>
            <seealso cref="M:Au.Wnd.SetWindowPos(Au.Types.Native.SWP,System.Int32,System.Int32,System.Int32,System.Int32,Au.Wnd)"/>
        </member>
        <member name="M:Au.Wnd.MoveLL(System.Int32,System.Int32)">
            <summary>
            Moves.
            </summary>
            <remarks>
            See also <see cref="M:Au.Wnd.Move(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.Types.Screen_)"/>. It is better to use in automation scripts, with windows of any process/thread. It throws exceptions, supports optional/reverse/fractional/workarea coordinates, restores if min/max.
            This function is low-level, it just calls API <msdn>SetWindowPos</msdn> with flags NOSIZE|NOZORDER|NOOWNERZORDER|NOACTIVATE. It is better to use in programming, with windows of current thread.
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            
            For top-level windows use screen coordinates. For controls - direct parent client coordinates.
            </remarks>
            <seealso cref="M:Au.Wnd.SetWindowPos(Au.Types.Native.SWP,System.Int32,System.Int32,System.Int32,System.Int32,Au.Wnd)"/>
        </member>
        <member name="M:Au.Wnd.ResizeLL(System.Int32,System.Int32)">
            <summary>
            Resizes.
            </summary>
            <remarks>
            See also <see cref="M:Au.Wnd.Resize(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.Types.Screen_)"/>. It is better to use in automation scripts, with windows of any process/thread. It throws exceptions, supports optional/reverse/fractional/workarea coordinates, restores if min/max.
            This function is low-level, it just calls API <msdn>SetWindowPos</msdn> with flags NOMOVE|NOZORDER|NOOWNERZORDER|NOACTIVATE. It is better to use in programming, with windows of current thread.
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
            <seealso cref="M:Au.Wnd.SetWindowPos(Au.Types.Native.SWP,System.Int32,System.Int32,System.Int32,System.Int32,Au.Wnd)"/>
        </member>
        <member name="M:Au.Wnd.Move(Au.Types.Coord,Au.Types.Coord,Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.Types.Screen_)">
            <summary>
            Moves and/or resizes.
            </summary>
            <param name="x">Left. If default(Coord), does not move in X axis.</param>
            <param name="y">Top. If default(Coord), does not move in Y axis.</param>
            <param name="width">Width. If default(Coord), does not change width.</param>
            <param name="height">Height. If default(Coord), does not change height.</param>
            <param name="workArea"><i>x y width height</i> are relative to the work area. Not used when this is a child window.</param>
            <param name="screen"><i>x y width height</i> are relative to this screen or its work area. Default - primary. Not used when this is a child window.</param>
            <remarks>
            Also restores the visible top-level window if it is minimized or maximized.
            For top-level windows use screen coordinates. For controls - direct parent client area coordinates.
            With windows of current thread usually it's better to use <see cref="M:Au.Wnd.MoveLL(System.Int32,System.Int32,System.Int32,System.Int32,Au.Types.Native.SWP)"/>.
            </remarks>
            <exception cref="T:Au.Types.WndException"/>
        </member>
        <member name="M:Au.Wnd.Move(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.Types.Screen_)">
            <summary>
            Moves.
            </summary>
            <param name="x">Left. If default(Coord), does not move in X axis.</param>
            <param name="y">Top. If default(Coord), does not move in Y axis.</param>
            <param name="workArea"><i>x y</i> are relative to the work area. Not used when this is a child window.</param>
            <param name="screen"><i>x y</i> are relative to this screen or its work area. Default - primary. Not used when this is a child window.</param>
            <exception cref="T:Au.Types.WndException"/>
            <remarks>
            Also restores the visible top-level window if it is minimized or maximized.
            For top-level windows use screen coordinates. For controls - direct parent client coordinates.
            With windows of current thread usually it's better to use <see cref="M:Au.Wnd.MoveLL(System.Int32,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Au.Wnd.Resize(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.Types.Screen_)">
            <summary>
            Resizes.
            </summary>
            <param name="width">Width. If default(Coord), does not change width.</param>
            <param name="height">Height. If default(Coord), does not change height.</param>
            <param name="workArea">For <see cref="M:Au.Types.Coord.Fraction(System.Double)"/> etc use width/height of the work area. Not used when this is a child window.</param>
            <param name="screen">For <b>Coord.Fraction</b> etc use width/height of this screen. Default - primary. Not used when this is a child window.</param>
            <exception cref="T:Au.Types.WndException"/>
            <remarks>
            Also restores the visible top-level window if it is minimized or maximized.
            With windows of current thread usually it's better to use <see cref="M:Au.Wnd.ResizeLL(System.Int32,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Au.Wnd.MoveInScreen(Au.Types.Coord,Au.Types.Coord,Au.Types.Screen_,System.Boolean,System.Boolean)">
            <summary>
            Moves this window to coordinates x y in specified screen, and ensures that entire window is in screen.
            </summary>
            <param name="x">X coordinate in the specified screen. If default(Coord) - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="y">Y coordinate in the specified screen. If default(Coord) - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="screen">Move to this screen (see <see cref="T:Au.Types.Screen_"/>). If default, uses screen of this window.</param>
            <param name="workArea">Use the work area, not whole screen. Default true.</param>
            <param name="ensureInScreen">If part of window is not in screen, move and/or resize it so that entire window would be in screen. Default true.</param>
            <exception cref="T:Au.Types.WndException"/>
            <remarks>
            If the window is maximized, minimized or hidden, it will have the new position and size when restored, not immediately, except when moving maximized to another screen.
            </remarks>
            <seealso cref="M:Au.Types.RECT.MoveInScreen(Au.Types.Coord,Au.Types.Coord,Au.Types.Screen_,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.Wnd.EnsureInScreen(Au.Types.Screen_,System.Boolean)">
            <summary>
            Moves this window if need, to ensure that entire window is in screen.
            </summary>
            <param name="screen">Move to this screen (see <see cref="T:Au.Types.Screen_"/>). If default, uses screen of this window.</param>
            <param name="workArea">Use the work area, not whole screen. Default true.</param>
            <exception cref="T:Au.Types.WndException"/>
            <remarks>
            If the window is maximized, minimized or hidden, it will have the new position and size when restored, not immediately.
            </remarks>
            <seealso cref="M:Au.Types.RECT.EnsureInScreen(Au.Types.Screen_,System.Boolean)"/>
        </member>
        <member name="M:Au.Wnd.MoveToScreenCenter(Au.Types.Screen_)">
            <summary>
            Moves this window to the center of the screen.
            </summary>
            <param name="screen">Move to this screen (see <see cref="T:Au.Types.Screen_"/>). If default, uses screen of this window.</param>
            <exception cref="T:Au.Types.WndException"/>
            <remarks>Calls <c>ShowNotMinMax(true)</c> and <c>MoveInScreen(default, default, screen, true)</c>.</remarks>
            <seealso cref="M:Au.Types.RECT.MoveInScreen(Au.Types.Coord,Au.Types.Coord,Au.Types.Screen_,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:Au.Wnd.Screen">
            <summary>
            Gets <see cref="T:System.Windows.Forms.Screen"/> object of the screen that contains this window (the biggest part of it) or is nearest to it.
            If this window handle is default(Wnd) or invalid, gets the primary screen.
            Calls <see cref="M:Au.Types.Screen_.ScreenFromWindow(Au.Wnd)"/>.
            </summary>
        </member>
        <member name="M:Au.Wnd.ZorderAbove(Au.Wnd)">
            <summary>
            Places this window before window w in the Z order.
            Also can make this window topmost or non-topmost, depending on where w is in the Z order.
            This window and w can be both top-level windows or both controls of same parent.
            May not work with top-level windows when it would move an inactive window above the active window.
            If w is default(Wnd), calls <see cref="M:Au.Wnd.ZorderBottom"/>.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.ZorderBelow(Au.Wnd)">
            <summary>
            Places this window after window w in the Z order.
            Also can make this window topmost or non-topmost, depending on where w is in the Z order.
            This window and w can be both top-level windows or both controls of same parent.
            May not work with top-level windows when it would move an inactive window above the active window.
            If w is default(Wnd), calls <see cref="M:Au.Wnd.ZorderTop"/>.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.ZorderTop">
            <summary>
            Places this window or control at the top of the Z order.
            If the window was topmost, it will be at the top of topmost windows, else at the top of non-topmost windows (after topmost windows).
            Does not activate.
            In most cases does not work with top-level inactive windows, although returns true; instead use <see cref="M:Au.Wnd.ActivateLL"/>.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.ZorderBottom">
            <summary>
            Places this window or control at the bottom of the Z order.
            If the window was topmost, makes it and its owner window non-topmost.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.ZorderTopmost">
            <summary>
            Makes this window topmost (always on top of non-topmost windows in the Z order).
            Does not activate.
            If this window has an owner window, the owner does not become topmost.
            This cannot be a control.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.ZorderNoTopmost(System.Boolean)">
            <summary>
            Makes this window non-topmost.
            If this window has an owner window, makes the owner window non-topmost too.
            This cannot be a control.
            </summary>
            <param name="afterActiveWindow">Also place this window after the active nontopmost window in the Z order, unless the active window is its owner.</param>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.IsTopmost">
            <summary>
            Returns true if this is a topmost (always-on-top) window.
            </summary>
        </member>
        <member name="M:Au.Wnd.ZorderIsBefore(Au.Wnd)">
            <summary>
            Returns true if this window is above window w in the Z order.
            </summary>
        </member>
        <member name="P:Au.Wnd.Style">
            <summary>
            Gets window style.
            </summary>
            <value>One or more <see cref="T:Au.Types.Native.WS"/> flags and/or class-specific style flags. Reference: <msdn>window styles</msdn>.</value>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
            <seealso cref="M:Au.Wnd.HasStyle(Au.Types.Native.WS,System.Boolean)"/>
            <seealso cref="M:Au.Wnd.SetStyle(Au.Types.Native.WS,Au.Types.SetAddRemove,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:Au.Wnd.ExStyle">
            <summary>
            Gets window extended style.
            </summary>
            <value>One or more <see cref="T:Au.Types.Native.WS_EX"/> flags. Reference: <msdn>extended window styles</msdn>.</value>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
            <seealso cref="M:Au.Wnd.HasExStyle(Au.Types.Native.WS_EX,System.Boolean)"/>
            <seealso cref="M:Au.Wnd.SetExStyle(Au.Types.Native.WS_EX,Au.Types.SetAddRemove,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.Wnd.HasStyle(Au.Types.Native.WS,System.Boolean)">
            <summary>
            Returns true if the window has all specified style flags (see <see cref="P:Au.Wnd.Style"/>).
            </summary>
            <param name="style">One or more styles.</param>
            <param name="any">
            Return true if has any (not necessary all) of the specified styles.
            Note: don't use <see cref="F:Au.Types.Native.WS.CAPTION"/>, because it consists of two other styles - BORDER and DLGFRAME.
            </param>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.HasExStyle(Au.Types.Native.WS_EX,System.Boolean)">
            <summary>
            Returns true if the window has all specified extended style flags (see <see cref="P:Au.Wnd.ExStyle"/>).
            </summary>
            <param name="exStyle">One or more extended styles.</param>
            <param name="any">Return true if has any (not necessary all) of the specified styles.</param>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.SetStyle(Au.Types.Native.WS,Au.Types.SetAddRemove,System.Boolean,System.Boolean)">
            <summary>
            Changes window style.
            </summary>
            <param name="style">One or more <see cref="T:Au.Types.Native.WS"/> flags and/or class-specific style flags. Reference: <msdn>window styles</msdn>.</param>
            <param name="how"></param>
            <param name="updateNC">Update non-client area (frame, title bar).</param>
            <param name="updateClient">Update client area.</param>
            <exception cref="T:Au.Types.WndException"/>
            <seealso cref="P:Au.Wnd.Style"/>
        </member>
        <member name="M:Au.Wnd.SetExStyle(Au.Types.Native.WS_EX,Au.Types.SetAddRemove,System.Boolean,System.Boolean)">
            <summary>
            Changes window extended style.
            </summary>
            <param name="style">One or more <see cref="T:Au.Types.Native.WS_EX"/> flags. Reference: <msdn>extended window styles</msdn>.</param>
            <param name="how"></param>
            <param name="updateNC">Update non-client area (frame, title bar).</param>
            <param name="updateClient">Update client area.</param>
            <exception cref="T:Au.Types.WndException"/>
            <seealso cref="P:Au.Wnd.ExStyle"/>
        </member>
        <member name="P:Au.Wnd.IsPopupWindow">
            <summary>
            Returns true if has Native.WS.POPUP style.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.IsToolWindow">
            <summary>
            Returns true if has Native.WS_EX.TOOLWINDOW style.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.IsResizable">
            <summary>
            Returns true if has Native.WS.THICKFRAME style.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.GetWindowLong(System.Int32)">
            <summary>
            Calls API <msdn>GetWindowLong</msdn> if this process is 32-bit, <msdn>GetWindowLongPtr</msdn> if 64-bit.
            </summary>
            <remarks>
            For index can be used constants from <see cref="T:Au.Types.Native.GWL"/>.
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="M:Au.Wnd.SetWindowLong(System.Int32,Au.Types.LPARAM)">
            <summary>
            Calls API <msdn>SetWindowLong</msdn> if this process is 32-bit, <msdn>SetWindowLongPtr</msdn> if 64-bit.
            </summary>
            <remarks>
            For index can be used constants from <see cref="T:Au.Types.Native.GWL"/>.
            </remarks>
            <exception cref="T:Au.Types.WndException"/>
        </member>
        <member name="P:Au.Wnd.ControlId">
            <summary>
            Gets or sets id of this control.
            The 'get' function supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <exception cref="T:Au.Types.WndException">Failed (only 'set' function).</exception>
        </member>
        <member name="P:Au.Wnd.Prop">
            <summary>
            Returns an object that manages window properties using API <msdn>SetProp</msdn> and co.
            </summary>
            <example>
            <code><![CDATA[
            var w = Wnd.Find("* Explorer");
            w.Prop.Set("example", 5);
            Print(w.Prop["example"]);
            Print(w.Prop); //shows all w properties
            w.Prop.Remove("example"); //you should always remove window properties if don't want to see unrelated applications crashing after some time. And don't use many unique property names.
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Wnd.GetThreadProcessId(System.Int32@)">
            <summary>
            Calls API <msdn>GetWindowThreadProcessId</msdn>.
            Returns thread id and also gets process id.
            Returns 0 if fails. Supports <see cref="M:Au.Types.Native.GetError"/>.
            <note>It is native thread id, not Thread.ManagedThreadId.</note>
            </summary>
        </member>
        <member name="P:Au.Wnd.ThreadId">
            <summary>
            Gets native thread id of this window. Calls API <msdn>GetWindowThreadProcessId</msdn>.
            Returns 0 if fails. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <remarks>
            It is not the same as <see cref="P:System.Threading.Thread.ManagedThreadId"/>.
            </remarks>
        </member>
        <member name="P:Au.Wnd.ProcessId">
            <summary>
            Gets native process id of this window. Calls API <msdn>GetWindowThreadProcessId</msdn>.
            Returns 0 if fails. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
        </member>
        <member name="P:Au.Wnd.IsOfThisThread">
            <summary>
            Returns true if this window belongs to the current thread, false if to another thread.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="M:Au.Types.Native.GetError"/>.
            Calls API <msdn>GetWindowThreadProcessId</msdn>.
            </summary>
        </member>
        <member name="P:Au.Wnd.IsOfThisProcess">
            <summary>
            Returns true if this window belongs to the current process, false if to another process.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="M:Au.Types.Native.GetError"/>.
            Calls API <msdn>GetWindowThreadProcessId</msdn>.
            </summary>
        </member>
        <member name="P:Au.Wnd.IsUnicode">
            <summary>
            Returns true if the window is a Unicode window, false if ANSI.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="M:Au.Types.Native.GetError"/>.
            Calls API <msdn>IsWindowUnicode</msdn>.
            </summary>
        </member>
        <member name="P:Au.Wnd.Is64Bit">
            <summary>
            Returns true if the window is of a 64-bit process, false if of a 32-bit process.
            Also returns false if fails. Supports <see cref="M:Au.Types.Native.GetError"/>.
            If <see cref="P:Au.Ver.Is64BitOS"/> is true, calls API <msdn>GetWindowThreadProcessId</msdn>, <msdn>OpenProcess</msdn> and <msdn>IsWow64Process</msdn>.
            <note>If you know that the window belongs to current process, instead use <see cref="P:System.Environment.Is64BitProcess"/> or <c>IntPtr.Size==8</c>. This function is much slower.</note>
            </summary>
        </member>
        <member name="P:Au.Wnd.IsHung">
            <summary>
            Returns true if thread of this window is considered hung (not responding).
            Calls API <msdn>IsHungAppWindow</msdn>.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.IsHungGhost">
            <summary>
            Returns true if the window is a ghost window that the system creates over a hung (not responding) window to allow the user to minimally interact with it.
            </summary>
        </member>
        <member name="P:Au.Wnd.IsConsole">
            <summary>
            Returns true if this is a console window (class name "ConsoleWindowClass").
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.IsUacAccessDenied">
            <summary>
            Returns true if <see cref="T:Au.Process_.UacInfo">UAC</see> would not allow to automate the window.
            It happens when current process has lower UAC integrity level and is not uiAccess, unless UAC is turned off.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.ClassName">
            <summary>
            Gets class name.
            Returns null if fails, eg if the window is closed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
        </member>
        <member name="M:Au.Wnd.ClassNameIs(System.String)">
            <summary>
            Returns true if the class name of this window matches className. Else returns false.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <param name="className">Class name. Case-insensitive <see cref="M:Au.String_.Like_(System.String,System.String,System.Boolean)">wildcard</see>. Cannot be null.</param>
        </member>
        <member name="M:Au.Wnd.ClassNameIs(System.String[])">
            <summary>
            If the class name of this window matches one of strings in classNames, returns 1-based index of the string. Else returns 0.
            Also returns 0 if fails to get class name (probably window closed or 0 handle). Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <param name="classNames">Class names. Case-insensitive <see cref="M:Au.String_.Like_(System.String,System.String,System.Boolean)">wildcard</see>. The array and strings cannot be null.</param>
        </member>
        <member name="P:Au.Wnd.Name">
            <summary>
            Gets name.
            Returns "" if no name. Returns null if fails, eg if the window is closed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <remarks>
            <note>It is not the .NET Control.Name property. To get it you can use <see cref="P:Au.Wnd.NameWinForms"/>.</note>
            Top-level window name usually its title bar text.
            Control name usually is its text that does not change, for example button or static (label) control text.
            Unlike <see cref="P:Au.Wnd.ControlText"/>, this function usually does not get variable text, for example Edit control editable text, ComboBox control selected item text, status bar text.
            Calls <see cref="M:Au.Wnd.GetText(System.Nullable{System.Boolean},System.Boolean)"/>(false, true).
            </remarks>
            <seealso cref="M:Au.Wnd.SetText(System.String)"/>
            <seealso cref="P:Au.Wnd.ControlText"/>
            <seealso cref="P:Au.Wnd.NameAcc"/>
            <seealso cref="P:Au.Wnd.NameWinForms"/>
        </member>
        <member name="P:Au.Wnd.ControlText">
            <summary>
            Gets control text.
            Returns "" if no text. Returns null if fails, eg if the window is closed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <remarks>
            Unlike <see cref="P:Au.Wnd.Name"/>, this function prefers variable text, for example Edit control editable text, ComboBox control selected item text, status bar text.
            For controls that cannot have such text (eg button, static), it usually gets the same text as <b>Name</b>. For example button and static (label) controls.
            Much slower than <b>Name</b>. Fails if the window is hung.
            Calls <see cref="M:Au.Wnd.GetText(System.Nullable{System.Boolean},System.Boolean)"/>(true, false).
            </remarks>
            <seealso cref="M:Au.Wnd.SetText(System.String)"/>
            <seealso cref="P:Au.Wnd.Name"/>
        </member>
        <member name="M:Au.Wnd.GetText(System.Nullable{System.Boolean},System.Boolean)">
            <summary>
            Gets window/control name or control text.
            Returns "" if it is empty.
            Returns null if fails, eg if the window is closed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            This is a low-level function. You can instead use <see cref="P:Au.Wnd.Name"/> and <see cref="P:Au.Wnd.ControlText"/>.
            </summary>
            <param name="getText">
            false - use API function <msdn>InternalGetWindowText</msdn>. It is fast and usually does not get variable text. This is used by <see cref="P:Au.Wnd.Name"/>.
            true - use API message <msdn>WM_GETTEXT</msdn>. It is slow and prefers variable text. This is used by <see cref="P:Au.Wnd.ControlText"/>. Fails if the window is hung.
            null - try InternalGetWindowText. If it gets "", and this is a control, then try WM_GETTEXT.
            </param>
            <param name="removeUnderlineAmpersand">
            Remove the invisible '&amp;' characters that are used to underline keyboard shortcuts with the Alt key.
            Removes only if this is a control (has style Native.WS.CHILD).
            Calls <see cref="M:Au.Util.StringMisc.RemoveUnderlineAmpersand(System.String)"/>.
            </param>
            <seealso cref="M:Au.Wnd.SetText(System.String)"/>
            <seealso cref="P:Au.Wnd.NameAcc"/>
            <seealso cref="P:Au.Wnd.NameWinForms"/>
        </member>
        <member name="M:Au.Wnd._GetTextFast(System.Boolean)">
            <summary>
            Gets text.
            Returns "" if it is empty.
            Returns null if fails, eg if the control is destroyed or its thread is hung. Supports <see cref="M:Au.Types.Native.GetError"/>.
            Calls API InternalGetWindowText. If it fails, and getControlTextIfEmpty==true, and this is a control, calls _GetTextSlow, which uses WM_GETTEXT.
            </summary>
        </member>
        <member name="M:Au.Wnd._GetTextSlow">
            <summary>
            Gets text.
            Returns "" if it is empty.
            Returns null if fails, eg if the control is destroyed or its thread is hung. Supports <see cref="M:Au.Types.Native.GetError"/>.
            Uses WM_GETTEXT.
            </summary>
        </member>
        <member name="M:Au.Wnd.SetText(System.String)">
            <summary>
            Sets window/control name or control text.
            </summary>
            <param name="text">Text. Can be null, it is the same as "".</param>
            <remarks>
            Uses API <msdn>WM_SETTEXT</msdn>.
            Top-level window name usually its title bar text.
            For variable-text controls (edit, combo box, status bar, ...) this usually is the text that <see cref="P:Au.Wnd.ControlText"/> would get.
            For other controls (button, static, ...) and top-level windows this usually is the text that <see cref="P:Au.Wnd.Name"/> would get.
            </remarks>
            <exception cref="T:Au.Types.WndException">Failed, for example the window is closed.</exception>
            <seealso cref="M:Au.Wnd.GetText(System.Nullable{System.Boolean},System.Boolean)"/>
            <seealso cref="P:Au.Wnd.Name"/>
            <seealso cref="P:Au.Wnd.ControlText"/>
        </member>
        <member name="P:Au.Wnd.NameAcc">
            <summary>
            Gets <see cref="P:Au.Acc.Name"/> of the accessible object (role WINDOW) of this window or control.
            Returns "" if the object has no name or failed to get it. Returns null if invalid window handle.
            </summary>
        </member>
        <member name="P:Au.Wnd.NameWinForms">
            <summary>
            Gets Control.Name property of a .NET Windows Forms control.
            Returns null if it is not a Windows Forms control or if fails.
            <note>Use this with controls of other processes. Don't use with your controls, when you have a Control object.</note>
            <note>This is slow when getting names of multiple controls in a window. Instead create a <see cref="T:Au.Wnd.Misc.WinFormsControlNames"/> instance and call its <see cref="M:Au.Wnd.Misc.WinFormsControlNames.GetControlName(Au.Wnd)"/> method for each control.</note>
            </summary>
            <seealso cref="M:Au.Wnd.Misc.WinFormsControlNames.IsWinFormsControl(Au.Wnd)"/>
        </member>
        <member name="P:Au.Wnd.ProgramName">
            <summary>
            Gets filename of process executable file, like "notepad.exe".
            Return null if fails.
            Calls <see cref="P:Au.Wnd.ProcessId"/> and <see cref="M:Au.Process_.GetName(System.Int32,System.Boolean,System.Boolean)"/>.
            </summary>
        </member>
        <member name="P:Au.Wnd.ProgramFilePath">
            <summary>
            Gets full path of process executable file.
            Return null if fails.
            Calls <see cref="P:Au.Wnd.ProcessId"/> and <see cref="M:Au.Process_.GetName(System.Int32,System.Boolean,System.Boolean)"/>.
            </summary>
        </member>
        <member name="P:Au.Wnd.ProgramDescription">
            <summary>
            Gets description of process executable file.
            Return null if fails.
            Calls <see cref="P:Au.Wnd.ProcessId"/> and <see cref="M:Au.Process_.GetDescription(System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Au.Wnd.Close(System.Nullable{System.Boolean},System.Boolean)">
            <summary>
            Closes the window.
            Returns true if successfuly closed or if it was already closed (the handle is 0 or invalid) or if <paramref name="noWait"/>==true.
            </summary>
            <param name="noWait">
            If true, does not wait until the window is closed.
            If false, waits about 1 s (depends on window type etc) until the window is destroyed or disabled.
            If null (default), waits (as if false) if <see cref="P:Au.Thread_.IsUI"/> returns false.
            </param>
            <param name="useXButton">
            If false (default), uses API message <msdn>WM_CLOSE</msdn>.
            If true, uses API message <msdn>WM_SYSCOMMAND SC_CLOSE</msdn>, like when the user clicks the X button in the title bar.
            Most windows can be closed with any of these messages, but some respond properly only to one of them. For example, some applications on WM_CLOSE don't exit, although the main window is closed. Some applications don't respond to WM_SYSCOMMAND if it is posted soon after opening the window, for example Internet Explorer.
            </param>
            <remarks>
            The window may refuse to be closed. For example, it may be hung, or hide itself instead, or display a "Save?" message box, or is a dialog without X button, or just need more time to close it.
            If the window is of this thread, just calls <see cref="M:Au.Wnd.Send(System.Int32,Au.Types.LPARAM,Au.Types.LPARAM)"/> or <see cref="M:Au.Wnd.Post(System.Int32,Au.Types.LPARAM,Au.Types.LPARAM)"/> (if <paramref name="noWait"/>==true) and returns true.
            </remarks>
            <seealso cref="M:Au.Wnd.WaitForClosed(System.Double,System.Boolean)"/>
            <example>
            <code><![CDATA[
            //close all Notepad windows
            Wnd.FindAll("* Notepad", "Notepad").ForEach(t => t.Close());
            ]]></code>
            </example>
        </member>
        <member name="T:Au.Wnd.ChildFinder">
            <summary>
            Contains control (child window) properties and is used to find the control.
            </summary>
            <remarks>
            Can be used instead of <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/> or <see cref="M:Au.Wnd.ChildAll(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean})"/>.
            Also can be used to find window that contains certain control, like in the example.
            </remarks>
            <example>
            Find window that contains certain control, and get the control too.
            <code><![CDATA[
            var f = new Wnd.ChildFinder("Password*", "Static"); //control properties
            Wnd w = Wnd.Find(className: "#32770", also: t => f.Find(t));
            Print(w);
            Print(f.Result);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Wnd.ChildFinder.#ctor(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)">
            <summary>
            See <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/>.
            </summary>
            <exception cref="T:System.ArgumentException"><inheritdoc cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/></exception>
        </member>
        <member name="P:Au.Wnd.ChildFinder.Result">
            <summary>
            The found control.
            </summary>
        </member>
        <member name="M:Au.Wnd.ChildFinder.Find(Au.Wnd)">
            <summary>
            Finds the specified child control, like <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/>.
            Returns true if found.
            The <see cref="P:Au.Wnd.ChildFinder.Result"/> property will be the control.
            </summary>
            <param name="wParent">Direct or indirect parent window. Can be top-level window or control.</param>
            <exception cref="T:Au.Types.WndException">Invalid wParent.</exception>
        </member>
        <member name="M:Au.Wnd.ChildFinder.FindInList(System.Collections.Generic.IEnumerable{Au.Wnd},Au.Wnd)">
            <summary>
            Finds the specified control in a list of controls.
            Returns 0-based index, or -1 if not found.
            The <see cref="P:Au.Wnd.ChildFinder.Result"/> property will be the control.
            </summary>
            <param name="a">List of controls, for example returned by <see cref="M:Au.Wnd.GetWnd.Children(System.Boolean,System.Boolean,System.Boolean)"/>.</param>
            <param name="wParent">Direct or indirect parent window. Used only for flag DirectChild.</param>
        </member>
        <member name="M:Au.Wnd.ChildFinder.FindAll(Au.Wnd)">
            <summary>
            Finds all matching child controls, like <see cref="M:Au.Wnd.ChildAll(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean})"/>.
            Returns array containing 0 or more control handles as Wnd.
            </summary>
            <param name="wParent">Direct or indirect parent window. Can be top-level window or control.</param>
            <exception cref="T:Au.Types.WndException">Invalid wParent.</exception>
        </member>
        <member name="M:Au.Wnd.ChildFinder.FindAllInList(System.Collections.Generic.IEnumerable{Au.Wnd},Au.Wnd)">
            <summary>
            Finds all matching controls in a list of controls.
            Returns array containing 0 or more control handles as Wnd.
            </summary>
            <param name="a">List of controls, for example returned by <see cref="M:Au.Wnd.GetWnd.Children(System.Boolean,System.Boolean,System.Boolean)"/>.</param>
            <param name="wParent">Direct or indirect parent window. Used only for flag DirectChild.</param>
        </member>
        <member name="M:Au.Wnd.ChildFinder._FindInList(Au.Wnd,Au.Wnd._WndList,System.Action{Au.Wnd})">
            <summary>
            Returns index of matching element or -1.
            Returns -1 if using getAll.
            </summary>
            <param name="wParent">Parent window. Can be default(Wnd) if inList is true and no DirectChild flag and not using winforms name.</param>
            <param name="a">List of Wnd. Does not dispose it.</param>
            <param name="getAll">If not null, calls it for all matching and returns -1.</param>
        </member>
        <member name="M:Au.Wnd.ChildFinder.IsMatch(Au.Wnd,Au.Wnd)">
            <summary>
            Returns true if control c properties match the specified properties.
            </summary>
            <param name="c">A control. Can be 0/invalid, then returns false.</param>
            <param name="wParent">Direct or indirect parent window. If used, returns false if it isn't parent (also depends on flag DirectChild).</param>
        </member>
        <member name="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)">
            <summary>
            Finds a child control and returns its handle as Wnd.
            Returns default(Wnd) if not found. See also: <see cref="P:Au.Wnd.Is0"/>, <see cref="M:Au.Types.ExtensionMethods.OrThrow(Au.Wnd)" r=""/>.
            </summary>
            <param name="name">
            Control name.
            String format: <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">wildcard expression</conceptualLink>.
            null means 'can be any'. "" means 'must not have name'.
            
            By default the function gets control names with <see cref="P:Au.Wnd.Name"/>.
            Can start with these prefix strings:
            <list type="bullet">
            <item>
            "***text " - use <see cref="P:Au.Wnd.ControlText"/>.
            It is slower and can be less reliable (because can get editable text), especially if className not used. It does not remove the invisible '&amp;' characters that are used to underline keyboard shortcuts with the Alt key.
            </item>
            <item>
            "***accName " - use <see cref="P:Au.Wnd.NameAcc"/>.
            Useful when the control itself does not have a name but an adjacent Static text control is used as its name. Examples - Edit controls in dialogs. Slower.
            </item>
            <item>
            "***wfName " - use .NET Windows Forms Control Name property.
            To get it this function uses <see cref="T:Au.Wnd.Misc.WinFormsControlNames"/>. It is slower and can fail because of <see cref="T:Au.Process_.UacInfo">UAC</see>.
            </item>
            <item>
            "***id " (like "***id 15") - use control id.
            To get it this function uses <see cref="P:Au.Wnd.ControlId"/>.
            The id value cannot be wildcard expression.
            See also <see cref="M:Au.Wnd.ChildById(System.Int32,Au.Types.WCFlags)"/>.</item>
            </list>
            </param>
            <param name="className">
            Control class name.
            String format: <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">wildcard expression</conceptualLink>.
            null means 'can be any'. Cannot be "".
            </param>
            <param name="flags"></param>
            <param name="also">
            Callback function. Called for each matching control.
            It can evaluate more properties of the control and return true when they match.
            Example: <c>also: t =&gt; t.IsEnabled</c>
            </param>
            <param name="skip">
            0-based index of matching control.
            For example, if 1, the function skips the first matching control and returns the second.
            </param>
            <exception cref="T:Au.Types.WndException">This variable is invalid (window not found, closed, etc).</exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="name"/> starts with "***", but the prefix is invalid.
            <paramref name="className"/> is "". To match any, use null.
            Invalid wildcard expression ("**options " or regular expression).
            </exception>
            <remarks>
            To create code for this function, use dialog "Find window or control". It is form <b>Au.Tools.Form_Wnd</b> in Au.Tools.dll.
            </remarks>
        </member>
        <member name="M:Au.Wnd.HasChild(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)">
            <summary>
            Returns true if this window contains the specified control.
            Calls <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/>.
            <note type="note">
            Using this function many times with same parameters is inefficient. Instead create new <see cref="T:Au.Wnd.ChildFinder"/> and call <see cref="M:Au.Wnd.ChildFinder.Find(Au.Wnd)"/> or <see cref="M:Au.Wnd.HasChild(Au.Wnd.ChildFinder)"/>. See example.
            </note>
            </summary>
            <exception cref="T:Au.Types.WndException"/>
            <exception cref="T:System.ArgumentException"/>
            <example>
            <code><![CDATA[
            //find window that contains certain control, and get the control too
            var f = new Wnd.ChildFinder("Password*", "Static"); //control properties
            Wnd w = Wnd.Find(className: "#32770", also: t => t.HasChild(f));
            Print(w);
            Print(f.Result);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Wnd.HasChild(Au.Wnd.ChildFinder)">
            <summary>
            Returns true if this window contains the specified control.
            Calls <see cref="M:Au.Wnd.ChildFinder.Find(Au.Wnd)"/>.
            </summary>
            <exception cref="T:Au.Types.WndException"/>
            <example>
            Find window that contains certain control, and get the control too.
            <code><![CDATA[
            var cf = new Wnd.ChildFinder("Password*", "Static"); //control properties
            Wnd w = Wnd.Find(className: "#32770", also: t => t.HasChild(cf));
            Print(w);
            Print(f.Result);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Wnd.HasAcc(Au.Acc.Finder)">
            <summary>
            Returns true if this window contains the specified accessible object.
            Calls <see cref="M:Au.Acc.Finder.Find(Au.Wnd,Au.Wnd.ChildFinder)"/>.
            </summary>
            <exception cref="T:Au.Types.WndException"/>
            <example>
            Find window that contains certain accessible object (AO), and get the AO too.
            <code><![CDATA[
            var af = new Acc.Finder("BUTTON", "OK"); //AO properties
            Wnd w = Wnd.Find(className: "#32770", also: t => t.HasAcc(af));
            Print(w);
            Print(f.Result);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Wnd.ChildById(System.Int32,Au.Types.WCFlags)">
            <summary>
            Finds a child control by its id and returns its handle as Wnd.
            Returns default(Wnd) if not found. See also: <see cref="P:Au.Wnd.Is0"/>, <see cref="M:Au.Types.ExtensionMethods.OrThrow(Au.Wnd)" r=""/>.
            </summary>
            <param name="id">Control id.</param>
            <param name="flags">This function supports flags DirectChild and HiddenToo. If both are set, it is much faster because uses API <msdn>GetDlgItem</msdn>. Else uses API <msdn>EnumChildWindows</msdn>, like <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/>.</param>
            <remarks>
            To create code for this function, use dialog "Find window or control". It is form <b>Au.Tools.Form_Wnd</b> in Au.Tools.dll.
            
            Not all controls have a useful id. If control id is not unique or is different in each window instance, this function is not useful.
            </remarks>
            <exception cref="T:Au.Types.WndException">This variable is invalid (window not found, closed, etc).</exception>
        </member>
        <member name="M:Au.Wnd.ChildAll(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean})">
            <summary>
            Finds all matching child controls.
            Returns List containing 0 or more control handles as Wnd.
            Everything except the return type is the same as with <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/>.
            </summary>
            <exception cref="T:Au.Types.WndException"/>
            <exception cref="T:System.ArgumentException"/>
            <remarks>
            In the returned list, hidden controls (when using WCFlags.HiddenToo) are always after visible controls.
            </remarks>
            <seealso cref="M:Au.Wnd.GetWnd.Children(System.Boolean,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.Wnd.ChildFast(System.String,System.String,Au.Wnd)">
            <summary>
            Finds a direct child control and returns its handle as Wnd.
            Returns default(Wnd) if not found. See also: <see cref="P:Au.Wnd.Is0"/>, <see cref="M:Au.Types.ExtensionMethods.OrThrow(Au.Wnd)" r=""/>.
            Calls API <msdn>FindWindowEx</msdn>.
            Faster than <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/>, which uses API <msdn>EnumChildWindows</msdn>.
            Can be used only when you know full name and/or class name.
            Finds hidden controls too.
            </summary>
            <param name="name">
            Name.
            Use null to match any. "" matches "" (no name).
            Full, case-insensitive. Wildcard etc not supported.
            Must include the invisible '&amp;' characters that are used to underline keyboard shortcuts with the Alt key.
            </param>
            <param name="className">
            Class name.
            Use null to match any. Cannot be "".
            Full, case-insensitive. Wildcard etc not supported.
            </param>
            <param name="wAfter">If used, starts searching from the next control in the Z order.</param>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="T:Au.Wnd.GetWnd">
            <summary>
            Static functions of this class are used to get special windows (used like <c>Wnd w = Wnd.GetWnd.Top;</c>) and all windows.
            Instances of this class are used to get related windows and controls, like <c>Wnd w2 = w1.Get.FirstChild;</c> (here w1 is a Wnd variable).
            </summary>
        </member>
        <member name="M:Au.Wnd.GetWnd.Children(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets child controls, including all descendants.
            Returns array containing 0 or more control handles as Wnd.
            </summary>
            <param name="directChild">Need only direct children, not grandchildren.</param>
            <param name="onlyVisible">Need only visible controls.</param>
            <param name="sortFirstVisible">Place all array elements of hidden controls at the end of the array.</param>
            <exception cref="T:Au.Types.WndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            Calls API <msdn>EnumChildWindows</msdn>.
            </remarks>
            <seealso cref="M:Au.Wnd.ChildAll(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean})"/>
        </member>
        <member name="M:Au.Wnd.GetWnd.AllWindows(System.Boolean,System.Boolean)">
            <summary>
            Gets top-level windows.
            Returns array containing window handles as Wnd.
            </summary>
            <param name="onlyVisible">Need only visible windows.</param>
            <param name="sortFirstVisible">Place all array elements of hidden windows at the end of the array, even if the hidden windows are before some visible windows in the Z order.</param>
            <remarks>
            Calls API <msdn>EnumWindows</msdn>.
            <note>The list can be bigger than you expect, because there are many invisible windows, tooltips, etc. See also <see cref="M:Au.Wnd.GetWnd.MainWindows(System.Boolean)"/>.</note>
            By default array elements are sorted to match the Z order.
            On Windows 8 and later gets only desktop windows, not Windows Store app Metro-style windows (on Windows 10 only few such windows exist), unless this process has <see cref="T:Au.Process_.UacInfo">UAC</see> integrity level uiAccess; to get such windows you can use <see cref="M:Au.Wnd.FindFast(System.String,System.String,Au.Wnd)"/>.
            </remarks>
            <seealso cref="M:Au.Wnd.FindAll(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>
        </member>
        <member name="M:Au.Wnd.GetWnd.ThreadWindows(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Gets top-level windows of a thread.
            Returns array containing 0 or more window handles as Wnd.
            </summary>
            <param name="threadId">
            Unmanaged thread id.
            See <see cref="P:Au.Thread_.NativeId"/>, <see cref="P:Au.Wnd.ThreadId"/>.
            If 0, throws exception. If other invalid value (ended thread?), returns empty list. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </param>
            <param name="onlyVisible">Need only visible windows.</param>
            <param name="sortFirstVisible">Place all array elements of hidden windows at the end of the array, even if the hidden windows are before some visible windows in the Z order.</param>
            <exception cref="T:System.ArgumentException">0 threadId.</exception>
            <remarks>
            Calls API <msdn>EnumThreadWindows</msdn>.
            </remarks>
            <seealso cref="P:Au.Thread_.IsUI"/>
        </member>
        <member name="M:Au.Wnd.GetWnd.#ctor(Au.Wnd)">
            
        </member>
        <member name="M:Au.Wnd.GetWnd.Left(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Gets a sibling control to the left from this.
            Returns default(Wnd) if there is no sibling.
            </summary>
            <param name="distance">Horizontal distance from the left of this control. Default 10.</param>
            <param name="yOffset">Vertical offset from the top of this control. If negative - up. Default 5.</param>
            <param name="topChild">If at that point is a visible child of the sibling, get that child. Default false.</param>
            <exception cref="T:Au.Types.WndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            This function is used mostly with controls, but supports top-level windows too.
            </remarks>
        </member>
        <member name="M:Au.Wnd.GetWnd.Right(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Gets a sibling control to the right from this.
            Returns default(Wnd) if there is no sibling.
            </summary>
            <param name="distance">Horizontal distance from the right of this control. Default 10.</param>
            <param name="yOffset">Vertical offset from the top of this control. If negative - up. Default 5.</param>
            <param name="topChild">If at that point is a visible child of the sibling, get that child. Default false.</param>
            <exception cref="T:Au.Types.WndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            This function is used mostly with controls, but supports top-level windows too.
            </remarks>
        </member>
        <member name="M:Au.Wnd.GetWnd.Above(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Gets a sibling control above this.
            Returns default(Wnd) if there is no sibling.
            </summary>
            <param name="distance">Vertical distance from the top of this control. Default 10.</param>
            <param name="xOffset">Horizontal offset from the left of this control. If negative - to the left. Default 5.</param>
            <param name="topChild">If at that point is a visible child of the sibling, get that child. Default false.</param>
            <exception cref="T:Au.Types.WndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            This function is used mostly with controls, but supports top-level windows too.
            </remarks>
        </member>
        <member name="M:Au.Wnd.GetWnd.Below(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Gets a sibling control below this.
            Returns default(Wnd) if there is no sibling.
            </summary>
            <param name="distance">Vertical distance from the bottom of this control. Default 10.</param>
            <param name="xOffset">Horizontal offset from the left of this control. If negative - to the left. Default 5.</param>
            <param name="topChild">If at that point is a visible child of the sibling, get that child. Default false.</param>
            <exception cref="T:Au.Types.WndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            This function is used mostly with controls, but supports top-level windows too.
            </remarks>
        </member>
        <member name="M:Au.Wnd.GetWnd.Next(System.Int32)">
            <summary>
            Gets next sibling window or control in the Z order.
            Returns default(Wnd) if this is the last or if fails.
            </summary>
            <param name="skip">How many next windows to skip.</param>
            <remarks>
            If this is a top-level window, gets next top-level window, else gets next control of the same direct parent.
            Calls API <msdn>GetWindow</msdn>(GW_HWNDNEXT).
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="M:Au.Wnd.GetWnd.Previous(System.Int32)">
            <summary>
            Gets previous sibling window or control in the Z order.
            Returns default(Wnd) if this is the first or if fails.
            </summary>
            <param name="skip">How many previous windows to skip.</param>
            <remarks>
            If this is a top-level window, gets previous top-level window, else gets previous control of the same direct parent.
            Calls API <msdn>GetWindow</msdn>(GW_HWNDPREV).
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="P:Au.Wnd.GetWnd.FirstSibling">
            <summary>
            Gets the first sibling window or control in the Z order.
            If this is the first, returns this.
            </summary>
            <remarks>
            If this is a top-level window, gets the first top-level window, else gets the first control of the same direct parent.
            Calls API <msdn>GetWindow</msdn>(this, GW_HWNDFIRST).
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="P:Au.Wnd.GetWnd.LastSibling">
            <summary>
            Gets the last sibling window or control in the Z order.
            If this is the last, returns this, not default(Wnd).
            </summary>
            <remarks>
            If this is a top-level window, gets the last top-level window, else gets the last control of the same direct parent.
            Calls API <msdn>GetWindow</msdn>(this, GW_HWNDLAST).
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="P:Au.Wnd.GetWnd.FirstChild">
            <summary>
            Gets the first direct child control in the Z order.
            Returns default(Wnd) if no children or if fails.
            </summary>
            <remarks>
            Calls API <msdn>GetWindow</msdn>(GW_CHILD).
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="P:Au.Wnd.GetWnd.LastChild">
            <summary>
            Gets the last direct child control in the Z order.
            Returns default(Wnd) if no children or if fails.
            </summary>
            <remarks>
            Calls API <msdn>GetWindow</msdn>.
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="M:Au.Wnd.GetWnd.Child(System.Int32)">
            <summary>
            Gets a direct child control by index.
            Returns default(Wnd) if no children or if index is invalid or if fails.
            </summary>
            <param name="index">0-based index of the child control in the Z order.</param>
            <remarks>
            Calls API <msdn>GetWindow</msdn>.
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="P:Au.Wnd.GetWnd.Owner">
            <summary>
            Gets the owner window of this top-level window.
            Returns default(Wnd) if this window isn't owned or if fails.
            </summary>
            <remarks>
            A window that has an owner window is always on top of it.
            Controls don't have an owner window.
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            This function is the same as <see cref="P:Au.Wnd.Owner"/>, which also allows to change owner.
            </remarks>
        </member>
        <member name="P:Au.Wnd.GetWnd.Window">
            <summary>
            Gets the top-level parent window of this control.
            If this is a top-level window, returns this.
            Returns default(Wnd) if fails.
            </summary>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            This function is the same as <see cref="P:Au.Wnd.Window"/>.
            </remarks>
        </member>
        <member name="P:Au.Wnd.GetWnd.DirectParent">
            <summary>
            Gets the direct parent window or control of this control.
            Returns default(Wnd) if this is a top-level window or if fails.
            </summary>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="P:Au.Wnd.GetWnd.DirectParentOrOwner">
            <summary>
            Gets the direct parent window or control of this control, or the owner window of this top-level window.
            Returns default(Wnd) if this is an unowned top-level window or if fails.
            </summary>
            <remarks>
            Calls API <msdn>GetParent</msdn>.
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="M:Au.Wnd.GetWnd.LastActiveOwnedOrThis(System.Boolean)">
            <summary>
            Gets the most recently active window in the chain of windows owned by this window, or this window itself if there are no such windows.
            Returns default(Wnd) if fails.
            </summary>
            <param name="includeOwners">Can return an owner (or owner's owner and so on) of this window too.</param>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="M:Au.Wnd.GetWnd.RootOwnerOrThis(System.Boolean)">
            <summary>
            Gets the bottom-most owner window in the chain of owner windows of this window.
            If this window is not owned, returns this window.
            Returns default(Wnd) if fails.
            </summary>
            <param name="supportControls">If this is a child window, use its top-level parent window instead.</param>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.GetWnd.OwnersAndThis(System.Boolean)">
            <summary>
            Gets all owner windows of this window, including this window or its top-level parent.
            Returns array that starts with this window or its top-level parent (if control).
            </summary>
            <param name="onlyVisible">Skip invisible windows.</param>
            <remarks>
            This window can be top-level window or control. If control, its top-level parent window will be the first in the array.
            This function for example can be used to temporarily hide a tool window and its owners when capturing something from the screen.
            </remarks>
        </member>
        <member name="P:Au.Wnd.GetWnd.Top">
            <summary>
            Gets the very first top-level window in the Z order.
            </summary>
            <remarks>
            Probably it is a topmost window.
            Calls API <msdn>GetTopWindow</msdn>(default(Wnd)).
            </remarks>
        </member>
        <member name="P:Au.Wnd.GetWnd.Root">
            <summary>
            Calls API <msdn>GetDesktopWindow</msdn>. It gets the virtual parent window of all top-level windows.
            </summary>
            <remarks>
            <note>It is not the desktop window (see <see cref="P:Au.Wnd.GetWnd.Desktop"/>) that displays icons and wallpaper.</note>
            </remarks>
        </member>
        <member name="P:Au.Wnd.GetWnd.Shell">
            <summary>
            Calls API <msdn>GetShellWindow</msdn>. It gets a window of the shell process (usually process "explorer", class name "Progman").
            </summary>
            <remarks>
            It can be the window that contains desktop icons (see <see cref="P:Au.Wnd.GetWnd.Desktop"/>) or other window of the same thread.
            </remarks>
        </member>
        <member name="P:Au.Wnd.GetWnd.Desktop">
            <summary>
            Gets the desktop window that displays desktop icons and wallpaper in its child control <see cref="P:Au.Wnd.GetWnd.DesktopControl"/>.
            </summary>
            <remarks>
            The "Show Desktop" command (Win+D) activates this window.
            <note>It is not API <msdn>GetDesktopWindow</msdn> (see <see cref="P:Au.Wnd.GetWnd.Root"/>)</note>
            <note>This function is not very reliable. May stop working on a new Windows version or don't work with a custom shell.</note>
            </remarks>
        </member>
        <member name="P:Au.Wnd.GetWnd.DesktopControl">
            <summary>
            Gets the control of "SysListView32" class that contains desktop icons and wallpaper. It is a child of <see cref="P:Au.Wnd.GetWnd.Desktop"/>.
            </summary>
            <remarks>
            <note>This function is not very reliable. May stop working on a new Windows version or don't work with a custom shell.</note>
            </remarks>
        </member>
        <member name="M:Au.Wnd.GetWnd.IsMainWindow(Au.Wnd,System.Boolean,System.Boolean)">
            <summary>
            Returns true if window w is considered a main window, ie probably is in the Windows taskbar.
            Returns false if it is invisible, cloaked, owned, toolwindow, menu, etc.
            </summary>
            <param name="w"></param>
            <param name="allDesktops">On Windows 10 include (return true for) windows on all virtual desktops. On Windows 8 include Windows Store apps (only if this process has <see cref="T:Au.Process_.UacInfo">UAC</see> integrity level uiAccess).</param>
            <param name="skipMinimized">Return false if w is minimized.</param>
        </member>
        <member name="M:Au.Wnd.GetWnd.MainWindows(System.Boolean)">
            <summary>
            Gets main windows, ie those that probably are in the Windows taskbar.
            Returns array containing 0 or more Wnd.
            </summary>
            <param name="allDesktops">On Windows 10 include windows on all virtual desktops. On Windows 8 include Windows Store apps (only if this process has <see cref="T:Au.Process_.UacInfo">UAC</see> integrity level uiAccess).</param>
            <remarks>
            Uses <see cref="M:Au.Wnd.GetWnd.IsMainWindow(Au.Wnd,System.Boolean,System.Boolean)"/>.
            Does not match the order of buttons in the Windows taskbar.
            </remarks>
        </member>
        <member name="M:Au.Wnd.GetWnd.NextMain(Au.Wnd,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets next window in the Z order, skipping invisible and other windows that probably are not in the Windows taskbar.
            Returns default(Wnd) if there are no such windows.
            </summary>
            <param name="w">Start from this window. If default(Wnd), starts from the top of the Z order.</param>
            <param name="allDesktops">On Windows 10 include windows on all virtual desktops. On Windows 8 include Windows Store apps (only if this process has <see cref="T:Au.Process_.UacInfo">UAC</see> integrity level uiAccess).</param>
            <param name="skipMinimized">Skip minimized windows.</param>
            <param name="retryFromTop">If w is not default(Wnd) and there are no matching windows after it, retry from the top of the Z order. Then can return w.</param>
            <remarks>
            Uses <see cref="M:Au.Wnd.GetWnd.IsMainWindow(Au.Wnd,System.Boolean,System.Boolean)"/>.
            This function is quite slow. Does not match the order of buttons in the Windows taskbar.
            </remarks>
        </member>
        <member name="T:Au.Wnd.WButton">
            <summary>
            Like <see cref="T:Au.Wnd"/>, but has only button, check box and radio button functions - Click, Check etc.
            </summary>
        </member>
        <member name="P:Au.Wnd.WButton.W">
            <summary>
            Button handle as Wnd.
            </summary>
        </member>
        <member name="M:Au.Wnd.WButton.op_Implicit(Au.Wnd.WButton)~Au.Wnd">
            <summary>
            Implicit cast Wnd=WButton.
            </summary>
        </member>
        <member name="M:Au.Wnd.WButton.op_Explicit(Au.Wnd)~Au.Wnd.WButton">
            <summary>
            Explicit cast WButton=(WButton)Wnd.
            </summary>
        </member>
        <member name="M:Au.Wnd.WButton.ToString">
            
        </member>
        <member name="M:Au.Wnd.WButton.Click(System.Boolean)">
            <summary>
            Sends a "click" message to this button control. Does not use the mouse.
            </summary>
            <param name="useAcc">Use <see cref="M:Au.Acc.DoAction"/>. If false (default), posts <msdn>BM_CLICK</msdn> message.</param>
            <exception cref="T:Au.Types.WndException">This window is invalid.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Works not with all button controls. Sometimes does not work if the window is inactive.
            Check boxes and radio buttons also are buttons. This function can click them.
            </remarks>
            <example>
            <code><![CDATA[
            Wnd.Find("Options").Child("Cancel").AsButton.Click();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Wnd.WButton.Check(System.Boolean,System.Boolean)">
            <summary>
            Checks or unchecks this check box. Does not use the mouse.
            Calls <see cref="M:Au.Wnd.WButton.SetCheckState(System.Int32,System.Boolean)"/> with state 0 or 1.
            </summary>
            <param name="on">Checks if true, unchecks if false.</param>
            <param name="useAcc"></param>
            <exception cref="T:Au.Types.WndException">This window is invalid.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Works not with all button controls. Sometimes does not work if the window is inactive.
            If this is a radio button, does not uncheck other radio buttons in its group.
            </remarks>
        </member>
        <member name="M:Au.Wnd.WButton.SetCheckState(System.Int32,System.Boolean)">
            <summary>
            Sets checkbox state. Does not use the mouse.
            </summary>
            <param name="state">0 unchecked, 1 checked, 2 indeterminate.</param>
            <param name="useAcc">Use <see cref="M:Au.Acc.DoAction"/>. If false (default), posts <msdn>BM_SETCHECK</msdn> message and also BN_CLICKED notification to the parent window; if that is not possible, instead uses <msdn>BM_CLICK</msdn> message.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid state.</exception>
            <exception cref="T:Au.Types.WndException">This window is invalid.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Does nothing if the check box already has the specified check state (if can get it).
            Works not with all button controls. Sometimes does not work if the window is inactive.
            If this is a radio button, does not uncheck other radio buttons in its group.
            </remarks>
        </member>
        <member name="M:Au.Wnd.WButton.IsChecked(System.Boolean)">
            <summary>
            Gets check state of this check box or radio button.
            Calls <see cref="M:Au.Wnd.WButton.GetCheckState(System.Boolean)"/> and returns true if it returns 1.
            </summary>
        </member>
        <member name="M:Au.Wnd.WButton.GetCheckState(System.Boolean)">
            <summary>
            Gets check state of this check box or radio button.
            Returns 0 if unchecked, 1 if checked, 2 if indeterminate. Also returns 0 if this is not a button or if failed to get state.
            </summary>
            <param name="useAcc">Use <see cref="P:Au.Acc.State"/>. If false (default) and this button has a standard checkbox style, uses API <msdn>BM_GETCHECK</msdn>.</param>
        </member>
        <member name="P:Au.Wnd.AsButton">
            <summary>
            Casts this to <see cref="T:Au.Wnd.WButton"/>.
            </summary>
        </member>
        <member name="M:Au.Wnd.ButtonClick(System.Int32,System.Boolean)">
            <summary>
            Finds a child button by id and sends a "click" message. Does not use the mouse.
            Calls <see cref="M:Au.Wnd.WButton.Click(System.Boolean)"/>.
            </summary>
            <param name="buttonId">Control id of the button. This function calls <see cref="M:Au.Wnd.ChildById(System.Int32,Au.Types.WCFlags)"/> to find the button.</param>
            <param name="useAcc">Use <see cref="M:Au.Acc.DoAction"/>. If false (default), posts <msdn>BM_CLICK</msdn> message.</param>
            <exception cref="T:Au.Types.NotFoundException">Button not found.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Wnd.ChildById(System.Int32,Au.Types.WCFlags)"/> and <see cref="M:Au.Wnd.WButton.Click(System.Boolean)"/>.</exception>
            <example>
            <code><![CDATA[
            Wnd.Find("Options").ButtonClick(2);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Wnd.ButtonClick(System.String,System.String,System.Boolean)">
            <summary>
            Finds a child button by name and sends a "click" message. Does not use the mouse.
            Calls <see cref="M:Au.Wnd.WButton.Click(System.Boolean)"/>.
            </summary>
            <param name="buttonName">Button name. This function calls <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/> to find the button.</param>
            <param name="className">Button class name to pass to <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/>.</param>
            <param name="useAcc">Use <see cref="M:Au.Acc.DoAction"/>. If false (default), posts <msdn>BM_CLICK</msdn> message.</param>
            <exception cref="T:Au.Types.NotFoundException">Button not found.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/> and <see cref="M:Au.Wnd.WButton.Click(System.Boolean)"/>.</exception>
            <example>
            <code><![CDATA[
            Wnd.Find("Options").ButtonClick("Cancel");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Wnd.MenuClick(System.Int32,System.Boolean)">
            <summary>
            Posts a "menu item clicked" notification (<msdn>WM_COMMAND</msdn>) as if that menu item was clicked. Does not use the mouse.
            </summary>
            <param name="itemId">Menu item id. Must be in range 1 to 0xffff.</param>
            <param name="systemMenu">The menu item is in the title bar's context menu, not in the menu bar. Posts <msdn>WM_SYSCOMMAND</msdn> instead.</param>
            <exception cref="T:Au.Types.WndException">Invalid window.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid itemId.</exception>
            <remarks>
            Works only with standard (classic) menus. The drop-down menu window class name must be "#32768". Works with menu items in window menu bar, system menu and some context menus.
            Does not use the menu itself. Just posts WM_COMMAND or WM_SYSCOMMAND message. Even if a menu item with this id does not exist.
            This variable is the window that contains the menu bar or system menu. Or the drop-down menu window (class "#32768") that contains the menu item.
            </remarks>
        </member>
        <member name="M:Au.Wnd.FromXY(Au.Types.POINT,Au.Types.WXYFlags)">
            <summary>
            Gets visible top-level window or control from point.
            </summary>
            <param name="p">
            Coordinates relative to the primary screen.
            Tip: When need coordinates relative to another screen or/and the work area, use <see cref="M:Au.Types.Coord.Normalize(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.Types.Screen_,System.Boolean,System.Boolean)"/> or tuple (x, y, workArea) etc. Example: <c>var a = Wnd.FromXY((x, y, true));</c>. Also when need <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.
            </param>
            <param name="flags"></param>
            <remarks>
            Alternatively can be used API <msdn>WindowFromPoint</msdn>, <msdn>ChildWindowFromPointEx</msdn> or <msdn>RealChildWindowFromPoint</msdn>, but all they have various limitations and are not very useful in automation scripts.
            This function gets non-transparent controls that are behind (in the Z order) transparent controls (group button, tab control etc); supports more control types than <msdn>RealChildWindowFromPoint</msdn>. Also does not skip disabled controls. All this is not true with flag Raw.
            This function is not very fast. Fastest when used flag NeedWindow. Flag Raw also makes it faster.
            </remarks>
        </member>
        <member name="M:Au.Wnd.FromMouse(Au.Types.WXYFlags)">
            <summary>
            Gets visible top-level window or control from mouse cursor position.
            More info: <see cref="M:Au.Wnd.FromXY(Au.Types.POINT,Au.Types.WXYFlags)"/>.
            </summary>
        </member>
        <member name="M:Au.Wnd.ChildFromXY(Au.Types.Coord,Au.Types.Coord,System.Boolean,System.Boolean)">
            <summary>
            Gets child control from point.
            Returns default(Wnd) if the point is not in a child control or not in the client area of this window.
            </summary>
            <param name="x">X coordinate in the client area of this window. Can be <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="y">Y coordinate in the client area of this window. Can be <b>Coord.Reverse</b> etc.</param>
            <param name="directChild">Get direct child, not a child of a child and so on.</param>
            <param name="screenXY">x y are relative to the pimary screen, not to the client area.</param>
            <exception cref="T:Au.Types.WndException">This variable is invalid (window not found, closed, etc).</exception>
        </member>
        <member name="M:Au.Wnd.ChildFromXY(Au.Types.POINT,System.Boolean,System.Boolean)">
            <inheritdoc cref="M:Au.Wnd.ChildFromXY(Au.Types.Coord,Au.Types.Coord,System.Boolean,System.Boolean)"/>
            <param name="p">Coordinates in the client area of this window.</param>
            <param name="directChild">Get direct child, not a child of a child and so on.</param>
            <param name="screenXY">p is relative to the pimary screen, not to the client area.</param>
        </member>
        <member name="M:Au.Wnd._SiblingXY(Au.Wnd._SibXY,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Get sibling control in space: left, right, above or below.
            Returns default(Wnd) if there is no sibling.
            </summary>
            <param name="direction"></param>
            <param name="distance">Distance from this control (from its edge) in the specified direction. Default 10.</param>
            <param name="edgeOffset">
            Distance in perpendicular direction, along the specified edge. Default 5.
            If <paramref name="direction"/> is <b>Left</b> or <b>Right</b>, 0 is the top edge, 1 is 1 pixel down, -1 is 1 pixel up, and so on.
            If <paramref name="direction"/> is <b>Above</b> or <b>Below</b>, 0 is the left edge, 1 is 1 pixel to the right, -1 is 1 pixel to the left, and so on.
            </param>
            <param name="topChild">If at that point is a visible child or descendant of the sibling, get that child/descendant. Default false.</param>
            <exception cref="T:Au.Types.WndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            This function is used mostly with controls, but supports top-level windows too.
            </remarks>
        </member>
        <member name="M:Au.Wnd.SetTransparency(System.Boolean,System.Nullable{System.Double},System.Nullable{Au.Types.ColorInt})">
            <summary>
            Sets transparency.
            On Windows 7 works only with top-level windows, on newer OS also with controls.
            </summary>
            <param name="allowTransparency">Set or remove WS_EX_LAYERED style that is required for transparency. If false, other parameters are not used.</param>
            <param name="opacity">Opacity from 0.0 (completely transparent) to 1.0 (opaque). If null, sets default value (opaque).</param>
            <param name="colorRGB">Make pixels painted with this color completely transparent. If null, sets default value (no transparent color). The alpha byte is not used.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">opacity is less than 0.0 or greater than 1.0.</exception>
            <exception cref="T:Au.Types.WndException"/>
        </member>
        <member name="P:Au.Wnd.IsFullScreen">
            <summary>
            Returns true if this is a full-screen window and not desktop.
            </summary>
        </member>
        <member name="P:Au.Wnd.LibIsOfShellThread">
            <summary>
            Returns true if this belongs to GetShellWindow's thread (usually it is the desktop window).
            </summary>
        </member>
        <member name="P:Au.Wnd.LibIsOfShellProcess">
            <summary>
            Returns true if this belongs to GetShellWindow's process (eg a folder window, desktop, taskbar).
            </summary>
        </member>
        <member name="P:Au.Wnd.IsWindows8MetroStyle">
            <summary>
            Returns true if this window has Metro style, ie is not a classic desktop window.
            On Windows 8/8.1 most Windows Store app windows and many shell windows have Metro style.
            On Windows 10 few windows have Metro style.
            On Windows 7 there are no Metro style windows.
            </summary>
            <seealso cref="M:Au.Wnd.Misc.GetWindowsStoreAppId(Au.Wnd,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:Au.Wnd.IsWindows10StoreApp">
            <summary>
            Returns non-zero if this window is a Windows 10 Store app window: 1 if class name is "ApplicationFrameWindow", 2 if "Windows.UI.Core.CoreWindow".
            </summary>
            <seealso cref="M:Au.Wnd.Misc.GetWindowsStoreAppId(Au.Wnd,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.Wnd.SavePositionSizeState(System.Boolean)">
            <summary>
            Gets window position, size and state stored in a string that can be used with <see cref="M:Au.Wnd.RestorePositionSizeState(System.String,System.Boolean,System.Boolean)"/>.
            Returns null if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <param name="canBeMinimized">If now the window is minimized, let RestorePositionSizeState make it minimized. If false, RestorePlacement will restore it to the most recent non-minimized state.</param>
        </member>
        <member name="M:Au.Wnd.RestorePositionSizeState(System.String,System.Boolean,System.Boolean)">
            <summary>
            Restores window position, size and state that is stored in a string created by <see cref="M:Au.Wnd.SavePositionSizeState(System.Boolean)"/>.
            </summary>
            <param name="s">The string. Can be null/"".</param>
            <param name="ensureInScreen">Call <see cref="M:Au.Wnd.EnsureInScreen(Au.Types.Screen_,System.Boolean)"/>. Even when s is null/"".</param>
            <param name="showActivate">Call <see cref="M:Au.Wnd.Show(System.Boolean)"/>(true) and <see cref="M:Au.Wnd.ActivateLL"/>. Even when s is null/"".</param>
            <exception cref="T:Au.Types.WndException"/>
        </member>
        <member name="M:Au.Wnd.LibMinimalSleepIfOtherThread">
            <summary>
            if(!IsOfThisThread) { Thread.Sleep(15); SendTimeout(1000, 0); }
            </summary>
        </member>
        <member name="M:Au.Wnd.LibMinimalSleepNoCheckThread">
            <summary>
            Thread.Sleep(15); SendTimeout(1000, 0);
            </summary>
        </member>
        <member name="M:Au.Wnd._GetWindowsStoreAppId(Au.Wnd,System.String@,System.Boolean,System.Boolean)">
            <summary>
            Gets window Windows Store app user model id, like "Microsoft.WindowsCalculator_8wekyb3d8bbwe!App".
            Returns 1 if gets user model id, 2 if gets path, 0 if fails.
            </summary>
            <param name="w">Window.</param>
            <param name="appId">Receives app ID.</param>
            <param name="prependShellAppsFolder">Prepend @"shell:AppsFolder\" (to run or get icon).</param>
            <param name="getExePathIfNotWinStoreApp">Get program path if it is not a Windows Store app.</param>
        </member>
        <member name="M:Au.Wnd._WindowsStoreAppFrameChild(Au.Wnd)">
            <summary>
            On Win10+, if w is "ApplicationFrameWindow", returns the real app window "Windows.UI.Core.CoreWindow" hosted by w.
            If w is minimized, cloaked (eg on other desktop) or the app is starting, the "Windows.UI.Core.CoreWindow" is not its child. Then searches for a top-level window named like w. It is unreliable, but MS does not provide API for this.
            Info: "Windows.UI.Core.CoreWindow" windows hosted by "ApplicationFrameWindow" belong to separate processes. All "ApplicationFrameWindow" windows belong to a single process.
            </summary>
        </member>
        <member name="T:Au.Wnd.Finder">
            <summary>
            Contains top-level window properties and can be used to find the window.
            </summary>
            <remarks>
            Can be used instead of <see cref="M:Au.Wnd.Find(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/> or <see cref="M:Au.Wnd.FindAll(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>.
            These codes are equivalent:
            <code>Wnd w = Wnd.Find(a, b, c, d, e); if(!w.Is0) Print(w);</code>
            <code>var p = new Wnd.Finder(a, b, c, d, e); if(p.Find()) Print(p.Result);</code>
            Also can find in a list of windows.
            </remarks>
        </member>
        <member name="M:Au.Wnd.Finder.#ctor(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)">
            <summary>
            See <see cref="M:Au.Wnd.Find(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>.
            </summary>
            <exception cref="T:System.ArgumentException">
            className is "". To match any, use null.
            programEtc is "" or 0. To match any, use null.
            Invalid wildcard expression ("**options " or regular expression).
            </exception>
        </member>
        <member name="P:Au.Wnd.Finder.Result">
            <summary>
            The found window.
            </summary>
        </member>
        <member name="M:Au.Wnd.Finder.Find">
            <summary>
            Finds the specified window, like <see cref="M:Au.Wnd.Find(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>.
            Returns true if found.
            The <see cref="P:Au.Wnd.Finder.Result"/> property will be the window.
            </summary>
        </member>
        <member name="M:Au.Wnd.Finder.FindInList(System.Collections.Generic.IEnumerable{Au.Wnd})">
            <summary>
            Finds the specified window in a list of windows.
            Returns 0-based index, or -1 if not found.
            The <see cref="P:Au.Wnd.Finder.Result"/> property will be the window.
            </summary>
            <param name="a">Array or list of windows, for example returned by <see cref="M:Au.Wnd.GetWnd.AllWindows(System.Boolean,System.Boolean)"/>.</param>
        </member>
        <member name="M:Au.Wnd.Finder.FindAll">
            <summary>
            Finds all matching windows, like <see cref="M:Au.Wnd.FindAll(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>.
            Returns array containing 0 or more window handles as Wnd.
            </summary>
        </member>
        <member name="M:Au.Wnd.Finder.FindAllInList(System.Collections.Generic.IEnumerable{Au.Wnd})">
            <summary>
            Finds all matching windows in a list of windows.
            Returns array containing 0 or more window handles as Wnd.
            </summary>
            <param name="a">Array or list of windows, for example returned by <see cref="M:Au.Wnd.GetWnd.AllWindows(System.Boolean,System.Boolean)"/>.</param>
        </member>
        <member name="M:Au.Wnd.Finder._FindInList(Au.Wnd._WndList,System.Action{Au.Wnd})">
            <summary>
            Returns index of matching element or -1.
            Returns -1 if using getAll.
            </summary>
            <param name="a">List of Wnd. Does not dispose it.</param>
            <param name="getAll">If not null, calls it for all matching and returns -1.</param>
        </member>
        <member name="M:Au.Wnd.Finder.IsMatch(Au.Wnd)">
            <summary>
            Returns true if window w properties match the specified properties.
            </summary>
            <param name="w">A top-level window. Can be 0/invalid, then returns false.</param>
        </member>
        <member name="M:Au.Wnd.Find(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)">
             <summary>
             Finds a top-level window and returns its handle as Wnd.
             Returns default(Wnd) if not found. See examples.
             </summary>
             <param name="name">
             Window name. Usually it is the title bar text.
             String format: <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">wildcard expression</conceptualLink>.
             null means 'can be any'. "" means 'must not have name'.
             </param>
             <param name="className">
             Window class name.
             String format: <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">wildcard expression</conceptualLink>.
             null means 'can be any'. Cannot be "".
             </param>
             <param name="programEtc">
             Program file name, like "notepad.exe".
             String format: <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">wildcard expression</conceptualLink>.
             null means 'can be any'. Cannot be "". Cannot be path.
             Or <see cref="M:Au.Types.WFEtc.Process(System.Int32)"/>(process id), <see cref="M:Au.Types.WFEtc.Thread(System.Int32)"/>(thread id), <see cref="M:Au.Types.WFEtc.Owner(Au.Types.AnyWnd)"/>(owner window).
             See <see cref="P:Au.Wnd.ProcessId"/>, <see cref="P:Au.Process_.CurrentProcessId"/>, <see cref="P:Au.Wnd.ThreadId"/>, <see cref="P:Au.Thread_.NativeId"/>, <see cref="P:Au.Wnd.Owner"/>.
             </param>
             <param name="flags"></param>
             <param name="also">
             Callback function. Called for each matching window.
             It can evaluate more properties of the window and return true when they match.
             Example: <c>also: t =&gt; !t.IsPopupWindow</c>.
            
             Called after evaluating all other parameters except <paramref name="contains"/>.
             </param>
             <param name="contains">
             Text, image or other object in the client area of the window. Depends on type:
             string - an accessible object that must be in the window. Format: "'role' name" or "name". See <see cref="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,System.String,Au.Wnd.ChildFinder)"/>.
             <see cref="T:Au.Acc.Finder"/> - arguments for <see cref="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,System.String,Au.Wnd.ChildFinder)"/>. Defines an accessible object that must be in the window.
             <see cref="T:Au.Wnd.ChildFinder"/> - arguments for <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/>. Defines a child control that must be in the window.
             <see cref="T:System.Drawing.Image"/> or <see cref="T:System.Drawing.Bitmap"/> - image that must be visible in the window. To find it, this function calls <see cref="M:Au.WinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,Au.Types.WIAlso})"/> with flag <see cref="F:Au.Types.WIFlags.WindowDC"/>. See also <see cref="M:Au.WinImage.LoadImage(System.String)"/>.
            
             This parameter is evaluated after <paramref name="also"/>.
             </param>
             <remarks>
             To create code for this function, use dialog "Find window or control". It is form <b>Au.Tools.Form_Wnd</b> in Au.Tools.dll.
             
             If there are multiple matching windows, gets the first in the Z order matching window, preferring visible windows.
             On Windows 8 and later finds only desktop windows, not Windows Store app Metro-style windows (on Windows 10 only few such windows exist), unless this process has uiAccess; to find such windows you can use <see cref="M:Au.Wnd.FindFast(System.String,System.String,Au.Wnd)"/>.
             To find message-only windows use <see cref="M:Au.Wnd.Misc.FindMessageWindow(System.String,System.String,Au.Wnd)"/> instead.
             </remarks>
             <exception cref="T:System.ArgumentException">
             <paramref name="className"/> is "". To match any, use null.
             <paramref name="programEtc"/> is "" or 0. To match any, use null.
             Invalid wildcard expression ("**options " or regular expression).
             </exception>
             <example>
             Try to find Notepad window. Return if not found.
             <code>
             Wnd w = Wnd.Find("* Notepad");
             if(w.Is0) { Print("not found"); return; }
             </code>
             Try to find Notepad window. Throw NotFoundException if not found.
             <code>
             Wnd w1 = Wnd.Find("* Notepad").OrThrow();
             </code>
             </example>
        </member>
        <member name="M:Au.Wnd.FindAll(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)">
            <inheritdoc cref="M:Au.Wnd.Find(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>
            <summary>
            Finds all matching windows.
            Returns array containing 0 or more window handles as Wnd.
            Parameters etc are the same as <see cref="M:Au.Wnd.Find(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>.
            </summary>
            <remarks>
            The list is sorted to match the Z order, however hidden windows (when using <see cref="F:Au.Types.WFFlags.HiddenToo"/>) are always after visible windows.
            </remarks>
            <seealso cref="M:Au.Wnd.GetWnd.AllWindows(System.Boolean,System.Boolean)"/>
            <seealso cref="M:Au.Wnd.GetWnd.MainWindows(System.Boolean)"/>
            <seealso cref="M:Au.Wnd.GetWnd.ThreadWindows(System.Int32,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.Wnd.FindFast(System.String,System.String,Au.Wnd)">
            <summary>
            Finds a top-level window and returns its handle as Wnd.
            Returns default(Wnd) if not found. See also: <see cref="P:Au.Wnd.Is0"/>, <see cref="M:Au.Types.ExtensionMethods.OrThrow(Au.Wnd)" r=""/>.
            </summary>
            <param name="name">
            Name.
            Use null to match any.
            Full, case-insensitive. Wildcard etc not supported.
            </param>
            <param name="className">
            Class name.
            Use null to match any. Cannot be "".
            Full, case-insensitive. Wildcard etc not supported.
            </param>
            <param name="wAfter">If used, starts searching from the next window in the Z order.</param>
            <remarks>
            Calls API <msdn>FindWindowEx</msdn>.
            Faster than <see cref="M:Au.Wnd.Find(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>, which uses API <msdn>EnumWindows</msdn>.
            Can be used only full name and/or class name.
            Finds hidden windows too.
            To find message-only windows use <see cref="M:Au.Wnd.Misc.FindMessageWindow(System.String,System.String,Au.Wnd)"/> instead.
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            It is not recommended to use this function in a loop to enumerate windows. It would be unreliable because window positions in the Z order can be changed while enumerating. Also then it would be slower than <b>Find</b> and <b>FindAll</b>.
            </remarks>
        </member>
        <member name="M:Au.Wnd.FindOrRun(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object,System.Action,System.Double,System.Boolean)">
            <inheritdoc cref="M:Au.Wnd.Find(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>
            <summary>
            Finds a top-level window (<see cref="M:Au.Wnd.Find(System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>). If found, activates (optionally), else calls callback function and waits for the window. The callback should open the window, for example call <see cref="M:Au.Shell.Run(System.String,System.String,Au.Types.SRFlags,Au.Types.SRMore)"/>.
            Returns window handle as Wnd. Returns default(Wnd) if not found (if <paramref name="runWaitS"/> is negative; else exception).
            </summary>
            <param name="run">Callback function. See example.</param>
            <param name="runWaitS">How long to wait for the window after calling the callback function. Seconds. Default 60. See <see cref="M:Au.Wnd.Wait(System.Double,System.Boolean,System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>.</param>
            <param name="needActiveWindow">Finally the window must be active. Default: true.</param>
            <exception cref="T:System.TimeoutException"><paramref name="runWaitS"/> time has expired. Not thrown if <paramref name="runWaitS"/> &lt;= 0.</exception>
            <remarks>
            The algorithm is:
            <code>
            var w=Wnd.Find(...);
            if(w.Is0) { run(); w=Wnd.Wait(runWaitS, needActiveWindow, ...); }
            else if(needActiveWindow) w.Activate();
            return w;
            </code>
            </remarks>
            <example>
            <code><![CDATA[
            Wnd w = Wnd.FindOrRun("* Notepad", run: () => Shell.Run("notepad.exe"));
            Print(w);
            ]]></code>
            </example>
        </member>
        <member name="T:Au.Wnd._WndList">
            <summary>
            An enumerable list of Wnd for <see cref="M:Au.Wnd.Finder._FindInList(Au.Wnd._WndList,System.Action{Au.Wnd})"/> and <see cref="M:Au.Wnd.ChildFinder._FindInList(Au.Wnd,Au.Wnd._WndList,System.Action{Au.Wnd})"/>.
            Holds Util.LibArrayBuilder or IEnumerator or single Wnd or none.
            Must be disposed if it is Util.LibArrayBuilder or IEnumerator, else disposing is optional.
            </summary>
        </member>
        <member name="P:Au.Wnd.Get">
            <summary>
            Gets related windows and controls.
            Use like <c>Wnd w2 = w1.Get.Owner;</c> (here w1 is a Wnd variable).
            </summary>
        </member>
        <member name="M:Au.Wnd.SwitchActiveWindow">
            <summary>
            Activates next non-minimized main window, like with Alt+Tab.
            Returns true if activated, false if there is no such window or failed to activate.
            </summary>
            <remarks>
            Uses <see cref="M:Au.Wnd.GetWnd.NextMain(Au.Wnd,System.Boolean,System.Boolean,System.Boolean)"/>, <see cref="M:Au.Wnd.GetWnd.LastActiveOwnedOrThis(System.Boolean)"/>, <see cref="M:Au.Wnd.Activate"/>.
            An alternative way - send Alt+Tab keys, but it works not everywhere.
            </remarks>
        </member>
        <member name="P:Au.Wnd.Owner">
            <summary>
            Gets or sets the owner window of this top-level window.
            </summary>
            <exception cref="T:Au.Types.WndException">Failed (only the 'set' function).</exception>
            <remarks>
            A window that has an owner window is always on top of it.
            Don't call this for controls, they don't have an owner window.
            The 'get' function returns default(Wnd) if this window isn't owned or is invalid. Supports <see cref="M:Au.Types.Native.GetError"/>.
            The 'set' function can fail, eg if the owner's process has higher <see cref="T:Au.Process_.UacInfo">UAC</see> integrity level.
            </remarks>
        </member>
        <member name="P:Au.Wnd.Window">
            <summary>
            Gets the top-level parent window of this control.
            If this is a top-level window, returns this. Returns default(Wnd) if this window is invalid.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.IsChild">
            <summary>
            Returns true if this is a child window (control), false if top-level window.
            </summary>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            Uses <see cref="P:Au.Wnd.GetWnd.DirectParent"/>.
            Another way is <c>w.HasStyle(Native.WS.CHILD)</c>. It is faster but less reliable, because some top-level windows have WS_CHILD style and some child windows don't.
            </remarks>
        </member>
        <member name="M:Au.Wnd.IsChildOf(Au.Wnd)">
            <summary>
            Returns true if this is a direct or indirect child (descendant) of window w.
            </summary>
            <remarks>
            Calls API <msdn>IsChild</msdn>.
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="P:Au.Wnd.Active">
            <summary>
            Gets the active (foreground) window.
            Calls API <msdn>GetForegroundWindow</msdn>.
            Returns default(Wnd) if there is no active window; more info: <see cref="M:Au.Wnd.Misc.WaitForAnActiveWindow"/>.
            </summary>
        </member>
        <member name="P:Au.Wnd.IsActive">
            <summary>
            Returns true if this window is the active (foreground) window.
            </summary>
        </member>
        <member name="P:Au.Wnd.LibIsActiveOrNoActiveAndThisIsWndRoot">
            <summary>
            Returns true if this window is the active (foreground) window.
            If this is <see cref="P:Au.Wnd.GetWnd.Root"/>, returns true if there is no active window.
            </summary>
        </member>
        <member name="T:Au.Time">
            <summary>
            Time functions. Get time, sleep/wait, doevents.
            </summary>
            <seealso cref="T:Au.WaitFor"/>
        </member>
        <member name="P:Au.Time.Microseconds">
            <summary>
            Gets the number of microseconds elapsed since Windows startup.
            </summary>
            <remarks>
            Uses API <msdn>QueryPerformanceCounter</msdn>.
            Independent of computer clock time changes.
            MSDN article: <msdn>Acquiring high-resolution time stamps</msdn>.
            </remarks>
        </member>
        <member name="P:Au.Time.Milliseconds">
            <summary>
            Gets the number of milliseconds elapsed since Windows startup.
            </summary>
            <remarks>
            Uses API <msdn>QueryPerformanceCounter</msdn>.
            Similar to <see cref="P:System.Environment.TickCount"/>, but more precise (1 ms) and returns a 64-bit value.
            Independent of computer clock time changes.
            </remarks>
        </member>
        <member name="P:Au.Time.MillisecondsWithoutComputerSleepTime">
            <summary>
            Gets the number of milliseconds elapsed since Windows startup, not including the sleep/hibernate time.
            </summary>
            <remarks>
            Uses API <msdn>QueryUnbiasedInterruptTime</msdn>.
            The precision is 1-16 milliseconds.
            Independent of computer clock time changes.
            </remarks>
        </member>
        <member name="M:Au.Time.Sleep(System.Int32)">
            <summary>
            Waits <paramref name="timeMilliseconds"/> milliseconds.
            </summary>
            <param name="timeMilliseconds">Time to wait, milliseconds. Or <see cref="F:System.Threading.Timeout.Infinite"/>.</param>
            <remarks>
            Calls <see cref="M:System.Threading.Thread.Sleep(System.Int32)"/>.
            Does not process Windows messages and other events, therefore should not be used in threads with windows, timers, hooks, events or COM, unless <paramref name="timeMilliseconds"/> is small. Supports APC.
            If the computer goes to sleep or hibernate during that time, the real time is the specified time + the sleep/hibernate time.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeMilliseconds"/> is negative and not Timeout.Infinite (-1).</exception>
            <example>
            <code><![CDATA[
            Time.Sleep(50);
            50.ms(); //the same
            0.05.s(); //the same
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Time.ms(System.Int32)">
            <summary>
            Waits <paramref name="timeMilliseconds"/> milliseconds. The same as <see cref="M:Au.Time.Sleep(System.Int32)"/>.
            </summary>
            <inheritdoc cref="M:Au.Time.Sleep(System.Int32)"/>
        </member>
        <member name="M:Au.Time.s(System.Int32)">
            <summary>
            Waits <paramref name="timeSeconds"/> seconds.
            The same as <see cref="M:Au.Time.Sleep(System.Int32)"/> and <see cref="M:Au.Time.ms(System.Int32)"/>, but the time is specified in seconds, not milliseconds.
            </summary>
            <param name="timeSeconds">Time to wait, seconds.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSeconds"/> is less than 0 or greater than 2147483 (int.MaxValue/1000, 24.8 days).</exception>
            <remarks><inheritdoc cref="M:Au.Time.Sleep(System.Int32)"/></remarks>
            <example>
            <code><![CDATA[
            Time.Sleep(5000);
            5000.ms(); //the same
            5.s(); //the same
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Time.s(System.Double)">
            <summary>
            Waits <paramref name="timeSeconds"/> seconds.
            The same as <see cref="M:Au.Time.Sleep(System.Int32)"/> and <see cref="M:Au.Time.ms(System.Int32)"/>, but the time is specified in seconds, not milliseconds.
            </summary>
            <param name="timeSeconds">Time to wait, seconds. The smallest value is 0.001 (1 ms).</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSeconds"/> is less than 0 or greater than 2147483 (int.MaxValue/1000, 24.8 days).</exception>
            <remarks><inheritdoc cref="M:Au.Time.Sleep(System.Int32)"/></remarks>
            <example>
            <code><![CDATA[
            Time.Sleep(2500);
            2500.ms(); //the same
            2.5.s(); //the same
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Time.SleepDoEvents(System.Int32)">
            <summary>
            Waits <paramref name="timeMS"/> milliseconds. While waiting, retrieves and dispatches Windows messages and other events.
            </summary>
            <param name="timeMS">Time to wait, milliseconds. Or <see cref="F:System.Threading.Timeout.Infinite"/>.</param>
            <remarks>
            Unlike <see cref="M:Au.Time.Sleep(System.Int32)"/>, this function retrieves and dispatches Windows messages, calls .NET event handlers, hook procedures, timer functions, COM/RPC, etc. Supports APC.
            This function can be used in threads with windows. However usually there are better ways, for example timer, other thread, async/await/Task. In some places this function does not work as expected, for example in Form/Control mouse event handlers .NET blocks other mouse events.
            Be careful, this function is as dangerous as <see cref="M:System.Windows.Forms.Application.DoEvents"/>.
            Calls API <msdn>MsgWaitForMultipleObjectsEx</msdn> and <see cref="M:Au.Time.DoEvents"/>.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeMS"/> is negative and not Timeout.Infinite.</exception>
            <seealso cref="M:Au.WaitFor.MessagesAndCondition(System.Double,System.Func{System.Boolean})"/>
            <seealso cref="M:Au.WaitFor.PostedMessage(System.Double,Au.Types.WaitMsgCallback)"/>
            <seealso cref="T:Au.Util.MessageLoop"/>
        </member>
        <member name="M:Au.Time.LibSleepDoEvents(System.Int32,System.Boolean)">
            <summary>SleepDoEvents + noSetPrecision.</summary>
        </member>
        <member name="M:Au.Time.DoEvents">
            <summary>
            Retrieves and dispatches events and Windows messages from the message queue of this thread.
            </summary>
            <remarks>
            Similar to <see cref="M:System.Windows.Forms.Application.DoEvents"/>, but more lightweight. Uses API functions <msdn>PeekMessage</msdn>, <msdn>TranslateMessage</msdn> and <msdn>DispatchMessage</msdn>.
            Be careful, this function is as dangerous as <b>Application.DoEvents</b>.
            </remarks>
        </member>
        <member name="T:Au.Time.LibSleepPrecision">
            <summary>
            Temporarily changes the time resolution/precision of Thread.Sleep and some other functions.
            </summary>
            <remarks>
            Uses API <msdn>timeBeginPeriod</msdn>, which requests a time resolution for various system timers and wait functions. Actually it is the system thread scheduling timer period.
            Normal resolution on Windows 7-10 is 15.625 ms. It means that, for example, <c>Thread.Sleep(1);</c> sleeps not 1 but 1-15 ms. If you set resolution 1, it sleeps 1-2 ms.
            The new resolution is revoked (<msdn>timeEndPeriod</msdn>) when disposing the LibSleepPrecision variable or when this process ends. See example. See also <see cref="M:Au.Time.LibSleepPrecision.TempSet1(System.Int32)"/>.
            The resolution is applied to all threads and processes. Other applications can change it too. For example, often web browsers temporarily set resolution 1 ms when opening a web page.
            The system uses the smallest period (best resolution) that currently is set by any application. You cannot make it bigger than current value.
            <note>It is not recommended to keep small period (high resolution) for a long time. It can be bad for power saving.</note>
            Don't need this for Time.SleepX and functions that use them (Mouse.Click etc). They call <see cref="M:Au.Time.LibSleepPrecision.TempSet1(System.Int32)"/> when the sleep time is 1-99 ms.
            This does not change the minimal period of <see cref="T:Au.Timer_"/> and System.Windows.Forms.Timer.
            </remarks>
            <example>
            <code><![CDATA[
            _Test("before");
            using(new Time.LibSleepPrecision(2)) {
            	_Test("in");
            }
            _Test("after");
            
            void _Test(string name)
            {
            	Print(name);
            	Perf.First();
            	for(int i = 0; i < 8; i++) { Thread.Sleep(1); Perf.Next(); }
            	Perf.Write();
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Time.LibSleepPrecision.#ctor(System.Int32)">
            <summary>
            Calls API <msdn>timeBeginPeriod</msdn>.
            </summary>
            <param name="periodMS">
            New system timer period, milliseconds.
            Should be 1. Other values may stuck and later cannot be made smaller due to bugs in OS or some applications; this bug would impact many functions of this library.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">periodMS &lt;= 0.</exception>
        </member>
        <member name="M:Au.Time.LibSleepPrecision.Dispose">
            <summary>
            Calls API <msdn>timeEndPeriod</msdn>.
            </summary>
        </member>
        <member name="M:Au.Time.LibSleepPrecision.Finalize">
            
        </member>
        <member name="P:Au.Time.LibSleepPrecision.Current">
            <summary>
            Gets current actual system time resolution (period).
            The return value usually is between 0.5 and 15.625 milliseconds. Returns 0 if fails.
            </summary>
        </member>
        <member name="M:Au.Time.LibSleepPrecision.TempSet1(System.Int32)">
            <summary>
            Temporarily sets the system wait precision to 1 ms. It will be revoked after the specified time or when this appdomain ends.
            If already set, just updates the revoking time.
            </summary>
            <param name="endAfterMS">Revoke after this time, milliseconds.</param>
            <example>
            <code><![CDATA[
            Print(Time.LibSleepPrecision.Current); //probably 15.625
            Time.LibSleepPrecision.TempSet1(500);
            Print(Time.LibSleepPrecision.Current); //1
            Thread.Sleep(600);
            Print(Time.LibSleepPrecision.Current); //probably 15.625 again
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Time.LibSleepPrecision.LibTempSet1(System.Int32)">
            <summary>
            Calls TempSetMax if sleepTimeMS is 1-99.
            </summary>
            <param name="sleepTimeMS">milliseconds of the caller 'sleep' function.</param>
        </member>
        <member name="T:Au.Timer_">
            <summary>
            Timer that uses API <msdn>SetTimer</msdn> and API <msdn>KillTimer</msdn>.
            </summary>
            <remarks>
            Similar to System.Windows.Forms.Timer, but more lightweight, for example does not create a hidden window.
            Use in UI threads. Does not work if this thread does not retrieve/dispatch posted messages (<msdn>WM_TIMER</msdn>).
            </remarks>
            <example>
            <code><![CDATA[
            //this example sets 3 timers
            Timer_.After(500, () => Print("after 500 ms"));
            Timer_.Every(1000, () => Print("every 1000 ms"));
            var t3 = new Timer_(() => Print("after 3000 ms")); t3.Start(3000, true); //the same as Timer_.After
            MessageBox.Show("");
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Timer_.Tag">
            <summary>
            Some object or value attached to this Timer_ variable.
            </summary>
        </member>
        <member name="M:Au.Timer_.#ctor(System.Action{Au.Timer_},System.Object)">
            
        </member>
        <member name="M:Au.Timer_.#ctor(System.Action,System.Object)">
            
        </member>
        <member name="M:Au.Timer_.Start(System.Int32,System.Boolean)">
            <summary>
            Starts timer. If already started, resets and changes its period.
            </summary>
            <param name="periodMilliseconds">Time interval (period) of calling the callback function (constructor's parameter <i>timerAction</i>), milliseconds. The minimal time is 10-20, even if this parameter is less than that.</param>
            <param name="singlePeriod">Call the callback function once (stop the timer before calling the callback function).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Negative periodMilliseconds.</exception>
            <exception cref="T:System.InvalidOperationException">Called not in the same thread as previous <b>Start</b>.</exception>
            <exception cref="T:System.ComponentModel.Win32Exception">API <msdn>SetTimer</msdn> returned 0. Unlikely.</exception>
            <remarks>
            If already started, this function must be called in the same thread as when started.
            </remarks>
        </member>
        <member name="M:Au.Timer_.Stop">
            <summary>
            Stops the timer.
            </summary>
            <exception cref="T:System.InvalidOperationException">Called not in the same thread as <b>Start</b>.</exception>
            <remarks>
            The callback function will not be called after this.
            Later you can start the timer again (call <see cref="M:Au.Timer_.Start(System.Int32,System.Boolean)"/>).
            Don't need to call this function for single-period timers. For periodic timers it is optional; the timer stops when the thread ends.
            This function must be called in the same thread as <b>Start</b>.
            </remarks>
        </member>
        <member name="M:Au.Timer_.After(System.Int32,System.Action,System.Object)">
            <summary>
            Sets new one-time timer.
            Returns new <see cref="T:Au.Timer_"/> object. Usually you don't need it.
            </summary>
            <param name="timeMilliseconds">Time after which will be called the callback function, milliseconds. The minimal time is 10-20, even if this parameter is less than that.</param>
            <param name="timerAction">Callback function.</param>
            <param name="tag">Something to pass to the callback function as <see cref="P:Au.Timer_.Tag"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Negative periodMilliseconds.</exception>
            <exception cref="T:System.ComponentModel.Win32Exception">API <msdn>SetTimer</msdn> returned 0. Unlikely.</exception>
            <remarks>
            The callback function will be called in this thread.
            This thread must must get/dispatch posted messages, eg call Application.Run() or Form.ShowModal() or AuDialog.Show(). The callback function is not called while this thread does not do it.
            </remarks>
        </member>
        <member name="M:Au.Timer_.After(System.Int32,System.Action{Au.Timer_},System.Object)">
            <inheritdoc cref="M:Au.Timer_.After(System.Int32,System.Action,System.Object)"/>
        </member>
        <member name="M:Au.Timer_.Every(System.Int32,System.Action,System.Object)">
            <summary>
            Sets new periodic timer.
            Returns new <see cref="T:Au.Timer_"/> object that can be used to modify timer properties if you want to do it not in the callback function; usually don't need it.
            </summary>
            <param name="periodMilliseconds">Time interval (period) of calling the callback function, milliseconds. The minimal period is 10-20, even if this parameter is less than that.</param>
            <param name="timerAction">Callback function.</param>
            <param name="tag">Something to pass to the callback function as <see cref="P:Au.Timer_.Tag"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Negative periodMilliseconds.</exception>
            <exception cref="T:System.ComponentModel.Win32Exception">API <msdn>SetTimer</msdn> returned 0. Unlikely.</exception>
            <remarks>
            The callback function will be called in this thread.
            This thread must must get/dispatch posted messages, eg call Application.Run() or Form.ShowModal() or AuDialog.Show(). The callback function is not called while this thread does not do it.
            </remarks>
        </member>
        <member name="M:Au.Timer_.Every(System.Int32,System.Action{Au.Timer_},System.Object)">
            <inheritdoc cref="M:Au.Timer_.Every(System.Int32,System.Action,System.Object)"/>
        </member>
        <member name="T:Au.WaitFor">
            <summary>
            Contains functions to wait for a user-defined condition or variable.
            </summary>
            <remarks>
            Specialized 'wait for' functions are in other classes, for example <see cref="M:Au.Wnd.Wait(System.Double,System.Boolean,System.String,System.String,Au.Types.WFEtc,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>.
            
            All 'wait for' functions have a <i>secondsTimeout</i> parameter. It is the maximal time to wait, seconds. If it is 0, waits infinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, then stops waiting and returns default value of that type (false, etc).
            
            While waiting, most functions by default don't dispatch Windows messages, events, hooks, timers, COM/RPC, etc. For example, if used in a Form/Control event handler, the form would stop responding. Use another thread, for example async/await/Task, like in the example. Or option <see cref="P:Au.Types.OptWaitFor.DoEvents">Opt.WaitFor.DoEvents</see>.
            </remarks>
            <seealso cref="T:Au.Time"/>
            <example>
            <code><![CDATA[
            WaitFor.Condition(0, () => Keyb.IsScrollLock);
            Print("ScrollLock now is toggled");
            ]]></code>
            Using in a Form/Control event handler.
            <code><![CDATA[
            var f = new Form();
            f.Click += async (unu, sed) =>
              {
            	  Print("waiting...");
            	  var result = await Task.Run(() => WaitFor.Condition(-10, () => Keyb.IsScrollLock));
            	  if(w.Is0) Print("timeout"); else Print(result);
              };
            f.ShowDialog();
            ]]></code>
            </example>
        </member>
        <member name="T:Au.WaitFor.Loop">
            <summary>
            Can be used to easily implement 'wait for' functions with a timeout.
            </summary>
            <remarks>
            See examples. The code works like most 'wait for' functions of this library: on timeout throws exception, unless secondsTimeout is negative.
            Similar code is used by most 'wait for' functions of this library.
            See also <see cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/>; usually it's easier; internally it uses similar code too.
            </remarks>
            <example>
            <code><![CDATA[
            public static bool WaitForMouseLeftButtonDown(double secondsTimeout)
            {
            	var x = new WaitFor.Loop(secondsTimeout);
            	for(; ; ) {
            		if(Mouse.IsPressed(MButtons.Left)) return true;
            		if(!x.Sleep()) return false;
            	}
            }
            ]]></code>
            The same with WaitFor.Condition.
            <code><![CDATA[
            static bool WaitForMouseLeftButtonDown2(double secondsTimeout)
            {
            	return WaitFor.Condition(secondsTimeout, () => Mouse.IsPressed(MButtons.Left));
            }
            ]]></code>
            </example>
        </member>
        <member name="P:Au.WaitFor.Loop.Period">
            <summary>
            Current period (<see cref="M:Au.WaitFor.Loop.Sleep"/> sleep time), milliseconds.
            Initially it is <see cref="P:Au.Types.OptWaitFor.Period">Opt.WaitFor.Period</see>, optionally multiplied by constructor's <i>options.Period</i>/10. Default 10 ms. Then each <see cref="M:Au.WaitFor.Loop.Sleep"/> increments it until <see cref="P:Au.WaitFor.Loop.MaxPeriod"/>.
            </summary>
        </member>
        <member name="P:Au.WaitFor.Loop.MaxPeriod">
            <summary>
            Maximal period (<see cref="M:Au.WaitFor.Loop.Sleep"/> sleep time), milliseconds.
            It is <see cref="P:Au.WaitFor.Loop.Period"/>*50 (default 500).
            </summary>
        </member>
        <member name="P:Au.WaitFor.Loop.TimeRemaining">
            <summary>
            Gets or sets the remaining time, milliseconds.
            </summary>
        </member>
        <member name="M:Au.WaitFor.Loop.#ctor(System.Double,Au.Types.OptWaitFor)">
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits infinitely. If &gt;0, after that time interval <see cref="M:Au.WaitFor.Loop.Sleep"/> throws <see cref="T:System.TimeoutException"/>. If &lt;0, then <see cref="M:Au.WaitFor.Loop.Sleep"/> returns false.
            </param>
            <param name="options">Options. If null, uses <see cref="P:Au.Opt.WaitFor"/>, else combines with it.</param>
        </member>
        <member name="M:Au.WaitFor.Loop.Sleep">
            <summary>
            Calls <see cref="M:Au.WaitFor.Loop.IsTimeout"/>. If it returns true, returns false.
            Else sleeps for <see cref="P:Au.WaitFor.Loop.Period"/> milliseconds, increments <b>Period</b> if it is less than <see cref="P:Au.WaitFor.Loop.MaxPeriod"/>, and returns true.
            </summary>
            <exception cref="T:System.TimeoutException">The <i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
        </member>
        <member name="M:Au.WaitFor.Loop.IsTimeout">
            <summary>
            If the <i>secondsTimeout</i> time is not expired, returns false.
            Else if <i>secondsTimeout</i> is negative, returns true.
            Else throws <see cref="T:System.TimeoutException"/>.
            </summary>
            <exception cref="T:System.TimeoutException">The <i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
        </member>
        <member name="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)">
            <summary>
            Waits for an user-defined condition.
            </summary>
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits infinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, after that time interval returns false.
            </param>
            <param name="condition">Callback function (eg lambda). It is called repeatedly, until returns true. The calling period depends on <paramref name="options"/>.</param>
            <param name="options">Options. If null, uses <see cref="P:Au.Opt.WaitFor"/>, else combines with it.</param>
            <returns>Returns true. On timeout returns false if <paramref name="secondsTimeout"/> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><paramref name="secondsTimeout"/> time has expired (if &gt; 0).</exception>
            <remarks>More info: <see cref="T:Au.WaitFor"/>.</remarks>
            <example><inheritdoc cref="T:Au.WaitFor"/></example>
        </member>
        <member name="M:Au.WaitFor.Handle(System.Double,Au.Types.WHFlags,System.IntPtr[])">
            <summary>
            Waits for a kernel object (event, mutex, etc).
            </summary>
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits infinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, after that time interval returns 0.
            </param>
            <param name="flags"></param>
            <param name="handles">One or more handles of kernel objects. Max 63.</param>
            <returns>
            Returns 1-based index of the first signaled handle. Negative if abandoned mutex.
            On timeout returns 0 if <paramref name="secondsTimeout"/> is negative; else exception.
            </returns>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
            <exception cref="T:Au.Types.AuException">Failed. For example a handle is invalid.</exception>
            <remarks>
            Uses API <msdn>WaitForMultipleObjectsEx</msdn> or <msdn>MsgWaitForMultipleObjectsEx</msdn>. Alertable.
            Does not use <see cref="P:Au.Opt.WaitFor"/>.
            </remarks>
        </member>
        <member name="M:Au.WaitFor.LibWait(System.Int64,Au.Types.WHFlags,System.IntPtr[])">
            <summary>
            Waits for a signaled kernel handle. Or just sleeps, if handles is null/empty.
            If flag DoEvents, dispatches received messages, hook notifications, etc.
            Calls API <msdn>WaitForMultipleObjectsEx</msdn> or <msdn>MsgWaitForMultipleObjectsEx</msdn> with QS_ALLINPUT. Alertable.
            When a handle becomes signaled, returns its 0-based index. If abandoned mutex, returns 0-based index + Api.WAIT_ABANDONED_0 (0x80).
            If timeMS>0, waits max timeMS and on timeout returns Api.WAIT_TIMEOUT.
            If failed, returns -1. Supports Native.GetError.
            </summary>
        </member>
        <member name="M:Au.WaitFor.LibWait(System.Int64,Au.Types.WHFlags,System.Object,Au.Types.LibWaitVariable,System.IntPtr[])">
            <summary>
            The same as <see cref="M:Au.WaitFor.LibWait(System.Int64,Au.Types.WHFlags,System.IntPtr[])"/> + can wait for message and variable.
            If msgCallback is not null, calls it when dispatching messages. If returns true, stops waiting and returns handles?.Length.
            	If it is WaitMsgCallback, calls it before dispatching a posted message.
            	If it is Func{bool}, calls it after dispatching one or more messages.
            If stopVar is not null, when it becomes true stops waiting and returns handles?.Length + 1.
            </summary>
        </member>
        <member name="M:Au.WaitFor.PostedMessage(System.Double,Au.Types.WaitMsgCallback)">
            <summary>
            Waits for a posted message received by this thread.
            </summary>
            <param name="secondsTimeout"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></param>
            <param name="callback">Callback function that returns true to stop waiting. More info in Remarks.</param>
            <returns><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></returns>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
            <remarks>
            While waiting, dispatches Windows messages etc, like <see cref="M:Au.Time.SleepDoEvents(System.Int32)"/>. Before dispatching a posted message, calls the callback function. Stops waiting when it returns true. Does not dispatch the message if the function sets the message field = 0.
            Does not use <see cref="P:Au.Opt.WaitFor"/>.
            </remarks>
            <example>
            <code><![CDATA[
            Timer_.After(2000, t => { Print("timer"); });
            WaitFor.PostedMessage(5, (ref Native.MSG m) => { Print(m); return m.message == 0x113; }); //WM_TIMER
            Print("finished");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.WaitFor.MessagesAndCondition(System.Double,System.Func{System.Boolean})">
            <summary>
            Waits for a variable or other condition that is changed while processing messages or other events received by this thread.
            </summary>
            <param name="secondsTimeout"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></param>
            <param name="condition">Callback function that returns true to stop waiting. More info in Remarks.</param>
            <returns><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></returns>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
            <remarks>
            While waiting, dispatches Windows messages etc, like <see cref="M:Au.Time.SleepDoEvents(System.Int32)"/>. After dispatching one or more messages or other events (posted messages, messages sent by other threads, hooks, etc), calls the callback function. Stops waiting when it returns true.
            Similar to <see cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/>. Differences: 1. Always dispatches messages etc. 2. Does not call the callback function when there are no messages etc.
            Does not use <see cref="P:Au.Opt.WaitFor"/>.
            </remarks>
            <example>
            <code><![CDATA[
            bool stop = false;
            Timer_.After(2000, t => { Print("timer"); stop = true; });
            WaitFor.MessagesAndCondition(5, () => stop);
            Print(stop);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.WaitFor.Variable(System.Double,System.Boolean@,Au.Types.OptWaitFor)">
            <summary>
            Waits until a variable is set = true.
            </summary>
            <param name="secondsTimeout"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></param>
            <param name="variable">Stop waiting when this variable is set to true.</param>
            <param name="options"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></param>
            <returns><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></returns>
            <exception cref="T:System.TimeoutException"><inheritdoc cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/></exception>
            <remarks>
            This function is useful when the variable can be changed by any thread. To wait for a variable changed while processing messages etc in this thread, it's better to use <see cref="M:Au.WaitFor.MessagesAndCondition(System.Double,System.Func{System.Boolean})"/>.
            </remarks>
            <example>
            <code><![CDATA[
            bool stop = false;
            Task.Run(() => { 2.s(); Print("task"); stop = true; });
            WaitFor.Variable(5, stop);
            Print(stop);
            ]]></code>
            </example>
        </member>
        <member name="T:Au.Registry_">
            <summary>
            Registry functions. Extends <see cref="T:Microsoft.Win32.Registry"/>.
            </summary>
        </member>
        <member name="F:Au.Registry_.AuKey">
            <summary>
            Default registry key, used when the key argument is null or @"\" or starts with @"\".
            </summary>
        </member>
        <member name="M:Au.Registry_.ParseKeyString(System.String@)">
            <summary>
            Parses registry key string and returns hive as RegistryKey.
            If key starts with "HKEY_", removes hive name from it and returns that hive. For example, if key is @"HKEY_LOCAL_MACHINE\Software\Test", sets key=@"Software\Test" and returns Registry.LocalMachine.
            Else if key is null or @"\", sets key=Registry_.AuKey (@"Software\Au") and returns Registry.CurrentUser.
            Else if key starts with @"\", prepends Registry_.AuKey (@"Software\Au") and returns Registry.CurrentUser.
            Else just returns Registry.CurrentUser.
            Valid hive names: "HKEY_CURRENT_USER", "HKEY_LOCAL_MACHINE", "HKEY_CLASSES_ROOT", "HKEY_USERS", "HKEY_PERFORMANCE_DATA" or "HKEY_CURRENT_CONFIG".
            </summary>
            <param name="key">Registry key. Can start with a hive name.</param>
            <exception cref="T:System.ArgumentException">'key' starts with "HKEY_" but it is an invalid hive name.</exception>
        </member>
        <member name="M:Au.Registry_.Open(System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Opens a key for read access.
            Returns null if the key does not exist.
            Uses <see cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String)"/>.
            </summary>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", the function just returns parentKeyOrHive.</param>
            <exception cref="T:System.ArgumentException">'key' starts with "HKEY_" but it is an invalid hive name.</exception>
            <exception cref="T:System.ObjectDisposedException">'parentKeyOrHive' is a closed key handle.</exception>
            <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to read the registry key.</exception>
        </member>
        <member name="M:Au.Registry_.CreateOrOpen(System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Creates a new key or opens an existing key for write access.
            Uses <see cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)"/>.
            </summary>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", the function just returns parentKeyOrHive.</param>
            <exception cref="T:System.ArgumentException">'key' starts with "HKEY_" but it is an invalid hive name.</exception>
            <exception cref="T:System.ObjectDisposedException">'parentKeyOrHive' is a closed key handle.</exception>
            <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create or open the registry key.</exception>
            <exception cref="T:System.UnauthorizedAccessException">parentKeyOrHive was not opened with write access.</exception>
            <exception cref="T:System.IO.IOException">See <see cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)"/>.</exception>
        </member>
        <member name="M:Au.Registry_.CanOpen(System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Returns true if key exists and you can open it to read.
            Uses <see cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String)"/>.
            </summary>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/>.</param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive.</param>
            <exception cref="T:System.ArgumentException">'key' starts with "HKEY_" but it is an invalid hive name.</exception>
            <exception cref="T:System.ObjectDisposedException">'parentKeyOrHive' is a closed key handle.</exception>
        </member>
        <member name="M:Au.Registry_.GetInt(System.Int32@,System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Gets value of REG_DWORD type.
            Returns false if the value or key does not exist.
            </summary>
            <param name="data">Receives data.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.ArgumentException">'key' starts with "HKEY_" but it is an invalid hive name.</exception>
            <exception cref="T:System.ObjectDisposedException">'parentKeyOrHive' is a closed key handle.</exception>
            <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to read the registry key.</exception>
            <exception cref="T:System.IO.IOException">The key has been marked for deletion.</exception>
            <exception cref="T:System.InvalidCastException">Wrong value type.</exception>
        </member>
        <member name="M:Au.Registry_.GetLong(System.Int64@,System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Gets value of REG_QWORD type.
            Returns false if the value or key does not exist.
            </summary>
            <param name="data">Receives data.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.Exception">Exceptions are listed in <see cref="M:Au.Registry_.GetInt(System.Int32@,System.String,System.String,Microsoft.Win32.RegistryKey)"/> topic.</exception>
        </member>
        <member name="M:Au.Registry_.GetString(System.String@,System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Gets string value of REG_SZ or REG_EXPAND_SZ type.
            Returns false if the value or key does not exist.
            </summary>
            <param name="data">Receives data.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.Exception">Exceptions are listed in <see cref="M:Au.Registry_.GetInt(System.Int32@,System.String,System.String,Microsoft.Win32.RegistryKey)"/> topic.</exception>
        </member>
        <member name="M:Au.Registry_.GetStringArray(System.String[]@,System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Gets string value of REG_MULTI_SZ type.
            Returns false if the value or key does not exist.
            </summary>
            <param name="data">Receives data.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.Exception">Exceptions are listed in <see cref="M:Au.Registry_.GetInt(System.Int32@,System.String,System.String,Microsoft.Win32.RegistryKey)"/> topic.</exception>
        </member>
        <member name="M:Au.Registry_.SetInt(System.Int32,System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Sets value of REG_DWORD type.
            Creates key and value if don't exist.
            </summary>
            <param name="data">Data.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.ArgumentException">'key' starts with "HKEY_" but it is an invalid hive name.</exception>
            <exception cref="T:System.ObjectDisposedException">'parentKeyOrHive' is a closed key handle.</exception>
            <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create, open or modify the registry key.</exception>
            <exception cref="T:System.UnauthorizedAccessException">parentKeyOrHive was not opened with write access.</exception>
            <exception cref="T:System.IO.IOException">See <see cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)"/>.</exception>
        </member>
        <member name="M:Au.Registry_.SetLong(System.Int64,System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Sets value of REG_QWORD type.
            Creates key and value if don't exist.
            </summary>
            <param name="data">Data.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.Exception">Exceptions are listed in <see cref="M:Au.Registry_.SetInt(System.Int32,System.String,System.String,Microsoft.Win32.RegistryKey)"/> topic.</exception>
        </member>
        <member name="M:Au.Registry_.SetString(System.String,System.String,System.String,Microsoft.Win32.RegistryKey,System.Boolean)">
            <summary>
            Sets string value of REG_SZ or REG_EXPAND_SZ type.
            Creates key and value if don't exist.
            </summary>
            <param name="data">Data.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <param name="REG_EXPAND_SZ">Let the registry value type be REG_EXPAND_SZ.</param>
            <exception cref="T:System.Exception">Exceptions are listed in <see cref="M:Au.Registry_.SetInt(System.Int32,System.String,System.String,Microsoft.Win32.RegistryKey)"/> topic.</exception>
        </member>
        <member name="M:Au.Registry_.SetStringArray(System.String[],System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Sets string value of REG_MULTI_SZ type.
            Creates key and value if don't exist.
            </summary>
            <param name="data">Data.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.Exception">Exceptions are listed in <see cref="M:Au.Registry_.SetInt(System.Int32,System.String,System.String,Microsoft.Win32.RegistryKey)"/> topic.</exception>
        </member>
        <member name="M:Au.Registry_.SetBinary(System.Void*,System.Int32,System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Sets value of REG_BINARY type.
            Creates key and value if don't exist.
            </summary>
            <param name="data">Data. For example a struct variable (unsafe address).</param>
            <param name="size">Data size. For example, Marshal.SizeOf(variable) or Marshal.SizeOf(typeof(DATA)).</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.Exception">Exceptions thrown by <see cref="M:Au.Registry_.CreateOrOpen(System.String,Microsoft.Win32.RegistryKey)"/>.</exception>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to write the value to the key.</exception>
        </member>
        <member name="M:Au.Registry_.GetBinary(System.Void*,System.Int32,System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Gets binary data. The registry value type can be REG_BINARY or any other.
            Returns registry data size that the function copied into the 'data' memory.
            Returns 0 if the key or value does not exist.
            </summary>
            <param name="data">Receives data. For example a struct variable (unsafe address).</param>
            <param name="size">data memory size. For example, Marshal.SizeOf(variable). Must be &gt;= registry data size.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.Exception">Exceptions thrown by <see cref="M:Au.Registry_.Open(System.String,Microsoft.Win32.RegistryKey)"/>.</exception>
            <exception cref="T:System.ComponentModel.Win32Exception">The value exists but failed to get it, for example the specified size is smaller than registry data size.</exception>
        </member>
        <member name="T:Au.Icons">
            <summary>
            Gets icons for files etc.
            </summary>
            <seealso cref="T:Au.Util.IconsAsync"/>
        </member>
        <member name="M:Au.Icons.GetFileIconHandle(System.String,System.Int32,Au.Types.GIFlags)">
            <inheritdoc cref="M:Au.Icons.GetFileIcon(System.String,System.Int32,Au.Types.GIFlags)"/>
            <returns>Returns icon handle, or default(IntPtr) if failed.</returns>
            <remarks>Later call <see cref="M:Au.Icons.DestroyIconHandle(System.IntPtr)"/> or some <b>HandleToX</b> function that will destroy the icon.</remarks>
        </member>
        <member name="M:Au.Icons.GetFileIcon(System.String,System.Int32,Au.Types.GIFlags)">
            <summary>
            Gets file icon.
            Extracts icon directly from the file, or gets shell icon, depending on file type, icon index, flags etc.
            </summary>
            <returns>Returns null if failed.</returns>
            <param name="file">
            Can be:
            Path of any file or folder.
            URL, like "http://..." or "mailto:a@b.c" or "file:///path".
            ITEMIDLIST like ":: HexEncodedITEMIDLIST". It can be of any file, folder, URL or virtual object like Control Panel. See <see cref="M:Au.Shell.Pidl.ToHexString"/>.
            Shell object parsing name, like @"::{CLSID-1}\::{CLSID-2}" or "shell:AppsFolder\WinStoreAppId".
            File type like ".txt" or URL protocol like "http:".
            If it is a file containing multiple icons (eg exe, dll), can be specified icon index like "path,index" or native icon resource id like "path,-id".
            If not full path, the function will look in <see cref="P:Au.Folders.ThisAppImages"/>. See also <see cref="T:Au.Types.GIFlags"/>.
            Supports environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>).
            </param>
            <param name="size">Icon width and height. Also can be enum <see cref="T:Au.Types.IconSize"/>, cast to int.</param>
            <param name="flags"></param>
            <seealso cref="M:Au.Wnd.Misc.GetIconHandle(Au.Wnd,System.Boolean)"/>
        </member>
        <member name="M:Au.Icons.GetFileIconImage(System.String,System.Int32,Au.Types.GIFlags)">
            <inheritdoc cref="M:Au.Icons.GetFileIcon(System.String,System.Int32,Au.Types.GIFlags)"/>
            <remarks>
            Calls <see cref="M:Au.Icons.GetFileIconHandle(System.String,System.Int32,Au.Types.GIFlags)"/> and converts to Bitmap.
            </remarks>
        </member>
        <member name="M:Au.Icons.GetPidlIconHandle(Au.Shell.Pidl,System.Int32)">
            <inheritdoc cref="M:Au.Icons.GetPidlIcon(Au.Shell.Pidl,System.Int32)"/>
            <returns>Returns icon handle, or default(IntPtr) if failed.</returns>
            <remarks>Later call <see cref="M:Au.Icons.DestroyIconHandle(System.IntPtr)"/> or some <b>HandleToX</b> function that will destroy the icon.</remarks>
        </member>
        <member name="M:Au.Icons.GetPidlIcon(Au.Shell.Pidl,System.Int32)">
            <summary>
            Gets icon of a file or other shell object specified as ITEMIDLIST.
            </summary>
            <returns>Returns null if failed.</returns>
            <param name="pidl">ITEMIDLIST pointer (PIDL).</param>
            <param name="size">Icon width and height. Also can be enum <see cref="T:Au.Types.IconSize"/>, cast to int.</param>
        </member>
        <member name="M:Au.Icons.GetPidlIconImage(Au.Shell.Pidl,System.Int32)">
            <inheritdoc cref="M:Au.Icons.GetPidlIcon(Au.Shell.Pidl,System.Int32)"/>
            <remarks>Calls <see cref="M:Au.Icons.GetPidlIconHandle(Au.Shell.Pidl,System.Int32)"/> and converts to Bitmap.</remarks>
        </member>
        <member name="M:Au.Icons.GetShellIconSize(Au.Types.IconSize)">
            <summary>
            Gets the width and height of shell icons of standard sizes - small, large, extra large and jumbo.
            Jumbo is always 256. Others depend on text size (DPI) that can be changed in Control Panel. If text size is 100%, they usually are 16, 32, 48.
            </summary>
        </member>
        <member name="M:Au.Icons.LoadIconHandle(System.String,System.Int32,System.Int32)">
            <inheritdoc cref="M:Au.Icons.LoadIcon(System.String,System.Int32,System.Int32)"/>
            <returns>Returns icon handle, or default(IntPtr) if failed.</returns>
            <remarks>Later call <see cref="M:Au.Icons.DestroyIconHandle(System.IntPtr)"/> or some <b>HandleToX</b> function that will destroy the icon.</remarks>
        </member>
        <member name="M:Au.Icons.LoadIcon(System.String,System.Int32,System.Int32)">
            <summary>
            Extracts icon from file that contains it.
            </summary>
            <returns>Returns null if failed.</returns>
            <param name="file">.ico, .exe, .dll or other file that contains one or more icons. Also supports cursor files - .cur, .ani. Must be full path, without icon index. Supports environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>).</param>
            <param name="index">Icon index or negative icon resource id in the .exe/.dll file.</param>
            <param name="size">Icon width and height. Also can be enum <see cref="T:Au.Types.IconSize"/>, cast to int.</param>
        </member>
        <member name="M:Au.Icons.GetStockIconHandle(Au.Types.StockIcon,System.Int32)">
            <inheritdoc cref="M:Au.Icons.GetStockIcon(Au.Types.StockIcon,System.Int32)"/>
            <returns>Returns icon handle, or default(IntPtr) if failed.</returns>
            <remarks>Later call <see cref="M:Au.Icons.DestroyIconHandle(System.IntPtr)"/> or some <b>HandleToX</b> function that will destroy the icon.</remarks>
        </member>
        <member name="M:Au.Icons.GetStockIcon(Au.Types.StockIcon,System.Int32)">
            <summary>
            Gets a shell stock icon.
            </summary>
            <returns>Returns null if failed.</returns>
            <param name="icon">Shell stock icon id.</param>
            <param name="size">Icon width and height. Also can be enum <see cref="T:Au.Types.IconSize"/>, cast to int.</param>
        </member>
        <member name="M:Au.Icons.GetAppIconHandle(System.Int32)">
            <inheritdoc cref="M:Au.Icons.GetAppIcon(System.Int32)"/>
            <returns>Returns native icon handle, or default(IntPtr) if there are no icons.</returns>
            <remarks>The icon is cached and protected from destroying, therefore don't need to destroy it, and not error to do it.</remarks>
        </member>
        <member name="M:Au.Icons.GetAppIcon(System.Int32)">
            <summary>
            Gets the first icon from unmanaged resources of this app.
            If the entry assembly of this appdomain is dll with icon, gets that icon; else gets exe icon.
            </summary>
            <returns>Returns null if there are no icons.</returns>
            <param name="size">Icon width and height. Also can be enum <see cref="T:Au.Types.IconSize"/>, cast to int.</param>
        </member>
        <member name="M:Au.Icons.CreateIconHandle(System.Int32,System.Int32,System.Action{System.Drawing.Graphics})">
            <inheritdoc cref="M:Au.Icons.CreateIcon(System.Int32,System.Int32,System.Action{System.Drawing.Graphics})"/>
            <returns>Returns native icon handle.</returns>
            <remarks>Later call <see cref="M:Au.Icons.DestroyIconHandle(System.IntPtr)"/> or some <b>HandleToX</b> function that will destroy the icon.</remarks>
        </member>
        <member name="M:Au.Icons.CreateIcon(System.Int32,System.Int32,System.Action{System.Drawing.Graphics})">
            <summary>
            Creates icon at run time.
            </summary>
            <param name="width"></param>
            <param name="height"></param>
            <param name="drawCallback">Called to draw icon. If null, the icon will be completely transparent.</param>
        </member>
        <member name="M:Au.Icons.DestroyIconHandle(System.IntPtr)">
            <summary>
            Destroys native icon.
            Calls API <msdn>DestroyIcon</msdn>. Does nothing if iconHandle is default(IntPtr).
            </summary>
        </member>
        <member name="M:Au.Icons.HandleToIcon(System.IntPtr,System.Boolean)">
            <summary>
            Converts unmanaged icon to Icon object.
            Returns null if hIcon is default(IntPtr).
            </summary>
            <param name="hIcon">Icon handle.</param>
            <param name="destroyIcon">If true (default), the returned variable owns the unmanaged icon and destroys it when disposing. If false, the returned variable just uses the unmanaged icon and will not destroy; the caller later should destroy it with <see cref="M:Au.Icons.DestroyIconHandle(System.IntPtr)"/>.</param>
        </member>
        <member name="M:Au.Icons.HandleToImage(System.IntPtr,System.Boolean)">
            <summary>
            Converts unmanaged icon to Bitmap object and destroys the unmanaged icon.
            Returns null if hIcon is default(IntPtr) or if fails to convert.
            </summary>
            <param name="hIcon">Icon handle.</param>
            <param name="destroyIcon">If true (default), destroys the unmanaged icon.</param>
        </member>
        <member name="M:Au.Icons.ParseIconLocation(System.String@,System.Int32@)">
            <summary>
            Parses icon location string.
            Returns true if it includes icon index or resource id.
            </summary>
            <param name="s">Icon location. Can be "path,index" or "path,-id" or just path. Receives path.</param>
            <param name="index">Receives the number or 0.</param>
            <remarks>Also supports path enclosed in double quotes like "\"path\",index", and spaces between comma and index like "path, index".</remarks>
        </member>
        <member name="T:Au.Icons.ImageCache">
            <summary>
            Gets icons of files etc as Bitmap. Uses 2-level cache - memory and file.
            </summary>
            <threadsafety static="true" instance="true"/>
            <seealso cref="T:Au.Util.IconsAsync"/>
        </member>
        <member name="M:Au.Icons.ImageCache.#ctor(System.String,System.Int32)">
            
        </member>
        <member name="M:Au.Icons.ImageCache.Finalize">
            
        </member>
        <member name="M:Au.Icons.ImageCache.Dispose">
            <summary>
            Calls <see cref="M:Au.Icons.ImageCache.SaveCacheFileNow"/>.
            </summary>
        </member>
        <member name="M:Au.Icons.ImageCache.SaveCacheFileNow">
            <summary>
            Saves to the cache file now, if need.
            Don't need to call this explicitly. It is called by Dispose.
            </summary>
        </member>
        <member name="M:Au.Icons.ImageCache.ClearCache">
            <summary>
            Clears the memory cache and deletes the cache file.
            </summary>
        </member>
        <member name="M:Au.Icons.ImageCache.GetImage(System.String,System.Boolean,Au.Types.GIFlags,System.Action{System.Drawing.Bitmap,System.Object},System.Object)">
            <summary>
            Gets file icon as <b>Bitmap</b>.
            If it is in the memory cache, gets it from there.
            Else if it is in the file cache, gets it from there and adds to the memory cache.
            Else gets from file (uses <see cref="M:Au.Icons.GetFileIconImage(System.String,System.Int32,Au.Types.GIFlags)"/> and adds to the file cache and to the memory cache.
            Returns null if <b>GetFileIconImage</b> failed, eg file does not exist.
            </summary>
            <param name="file">Any file or folder.</param>
            <param name="useExt">
            Get file type icon, depending on filename extension. Use this to avoid getting separate image object for each file of same type.
            This is ignored if filename extension is ".ico" or ".exe" or starts with ".exe," or ".dll,".
            </param>
            <param name="giFlags">Flags for <see cref="M:Au.Icons.GetFileIconImage(System.String,System.Int32,Au.Types.GIFlags)"/>.</param>
            <param name="autoUpdate">
            If not null, the cached image will be auto-updated when changed. Then will be called this function. It can update the image in UI.
            How it works: If this function finds cached image, it sets timer that after ~50 ms loads that icon/image from file again and compares with the cached image. If different, updates the cache. Does it once, not periodically.
            Use only in UI threads. Does not work if this thread does not retrieve/dispatch posted messages.
            </param>
            <param name="auParam">Something to pass to the <paramref name="autoUpdate"/> callback function.</param>
        </member>
        <member name="M:Au.Icons.ImageCache.GetImage(System.String,System.Func{System.Drawing.Bitmap},System.Action{System.Drawing.Bitmap,System.Object},System.Object,System.Boolean)">
            <summary>
            Gets any icon or image using callback function.
            If it is in the memory cache, gets it from there.
            Else if it is in the file cache, gets it from there and adds to the memory cache.
            Else calls callback function, which should return image, and adds to the file cache and to the memory cache.
            Returns null if the callback function returns null.
            </summary>
            <param name="name">Some unique name. It is used to identify this image in cache.</param>
            <param name="callback">Called to get image. To convert icon handle to image, use <see cref="M:Au.Icons.HandleToImage(System.IntPtr,System.Boolean)"/>.</param>
            <param name="autoUpdate"><inheritdoc cref="M:Au.Icons.ImageCache.GetImage(System.String,System.Boolean,Au.Types.GIFlags,System.Action{System.Drawing.Bitmap,System.Object},System.Object)"/></param>
            <param name="auParam">Something to pass to the <paramref name="autoUpdate"/> callback function.</param>
            <param name="auDispose">If true (default), auto-updating can dispose unused image returned by <paramref name="callback"/>.</param>
        </member>
        <member name="T:Au.Script">
            <summary>
            Base class of user main script class. Manages script options, calling script methods on launch/trigger, etc.
            </summary>
        </member>
        <member name="M:Au.Script.CallFirstMethod">
            <summary>
            Calls the first non-static method of the derived class.
            The method must have 0 parameters.
            </summary>
        </member>
        <member name="M:Au.Script.CallTriggerMethod(System.String,System.Object)">
            <summary>
            Calls a non-static method of the derived class by name.
            </summary>
            <param name="name">Method name. The method must have 0 or 1 parameter.</param>
            <param name="eventData">An argument.</param>
        </member>
        <member name="T:Au.Perf">
            <summary>
            Code speed measurement. Easier to use than <see cref="T:System.Diagnostics.Stopwatch"/>.
            </summary>
            <remarks>
            Stores data in shared memory, therefore the same measurement can be used in multiple appdomains and even processes. See also <see cref="T:Au.Perf.Inst"/>.
            </remarks>
        </member>
        <member name="T:Au.Perf.Inst">
            <summary>
            The same as <see cref="T:Au.Perf"/> class, but allows to have multiple independent speed measurements.
            </summary>
            <remarks>
            Stores data in the variable, not in shared memory.
            </remarks>
        </member>
        <member name="P:Au.Perf.Inst.Incremental">
            <summary><inheritdoc cref="P:Au.Perf.Incremental"/></summary>
            <example>
            <code><![CDATA[
            var perf = new Perf.Inst();
            perf.Incremental = true;
            for(int i = 0; i < 5; i++) {
            	Thread.Sleep(100); //not included in the measurement
            	perf.First();
            	Thread.Sleep(30); //will make sum ~150000
            	perf.Next();
            	Thread.Sleep(10); //will make sum ~50000
            	perf.Next();
            	Thread.Sleep(100); //not included in the measurement
            }
            perf.Write(); //speed:  154317  51060  (205377)
            perf.Incremental = false;
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Perf.Inst.First">
            <inheritdoc cref="M:Au.Perf.First"/>
        </member>
        <member name="M:Au.Perf.Inst.First(System.Int32)">
            <summary>
            Calls <see cref="M:Au.Perf.WakeCPU(System.Int32)"/> and <see cref="M:Au.Perf.Inst.First"/>.
            </summary>
        </member>
        <member name="M:Au.Perf.Inst.Next(System.Char)">
            <inheritdoc cref="M:Au.Perf.Next(System.Char)"/>
        </member>
        <member name="M:Au.Perf.Inst.Write">
            <summary>
            Formats a string from time values collected by calling <see cref="M:Au.Perf.Inst.First"/> and <see cref="M:Au.Perf.Inst.Next(System.Char)"/>, and shows it in the output.
            The string contains the number of microseconds of each code execution between calling <b>First</b> and each <b>Next</b>.
            </summary>
        </member>
        <member name="M:Au.Perf.Inst.NW(System.Char)">
            <summary>
            Calls <see cref="M:Au.Perf.Inst.Next(System.Char)"/> and <see cref="M:Au.Perf.Inst.Write"/>.
            </summary>
            <param name="cMark">A character to mark that time in the results string, like "A=150".</param>
        </member>
        <member name="M:Au.Perf.Inst.ToString">
            <summary>
            Formats a string from time values collected by calling <see cref="M:Au.Perf.Inst.First"/> and <see cref="M:Au.Perf.Inst.Next(System.Char)"/>.
            The string contains the number of microseconds of each code execution between calling <b>First</b> and each <b>Next</b>.
            </summary>
        </member>
        <member name="M:Au.Perf.Inst.ToArray">
            <summary>
            Return array of time values collected by calling <see cref="M:Au.Perf.Inst.First"/> and <see cref="M:Au.Perf.Inst.Next(System.Char)"/>.
            Each element is the number of microseconds of each code execution between calling <b>First</b> and each <b>Next</b>.
            </summary>
        </member>
        <member name="P:Au.Perf.Inst.TimeTotal">
            <summary>
            Gets the number of microseconds between <see cref="M:Au.Perf.Inst.First"/> and the last <see cref="M:Au.Perf.Inst.Next(System.Char)"/>.
            </summary>
        </member>
        <member name="M:Au.Perf.Inst.Execute(System.Int32,System.Action)">
            <summary>
            Executes <paramref name="code"/> (lambda) <paramref name="count"/> times, and then calls <see cref="M:Au.Perf.Inst.Next(System.Char)"/>.
            </summary>
        </member>
        <member name="M:Au.Perf.Inst.ExecuteMulti(System.Int32,System.Int32,System.Action[])">
            <summary>
            <paramref name="countAll"/> times executes this code: <c>First(); foreach(Action a in codes) Execute(countEach, a); Write();</c>.
            </summary>
        </member>
        <member name="M:Au.Perf.StartNew">
            <summary>
            Creates and returns new <see cref="T:Au.Perf.Inst"/> variable and calls its <see cref="M:Au.Perf.Inst.First"/>.
            </summary>
        </member>
        <member name="P:Au.Perf.Incremental">
            <summary>
            If true, times of each new First/Next/Next... measurement are added to previous measurement times.
            Finally you can call <see cref="M:Au.Perf.Write"/> or <see cref="M:Au.Perf.ToString"/> to get the sums.
            Usually used to measure code in loops. See example.
            </summary>
            <example>
            <code><![CDATA[
            Perf.Incremental = true;
            for(int i = 0; i < 5; i++) {
            	Thread.Sleep(100); //not included in the measurement
            	Perf.First();
            	Thread.Sleep(30); //will make sum ~150000
            	Perf.Next();
            	Thread.Sleep(10); //will make sum ~50000
            	Perf.Next();
            	Thread.Sleep(100); //not included in the measurement
            }
            Perf.Write(); //speed:  154317  51060  (205377)
            Perf.Incremental = false;
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Perf.First">
            <summary>
            Stores current time in the first element of an internal array.
            </summary>
        </member>
        <member name="M:Au.Perf.First(System.Int32)">
            <summary>
            Calls <see cref="M:Au.Perf.WakeCPU(System.Int32)"/> and <see cref="M:Au.Perf.First"/>.
            </summary>
        </member>
        <member name="M:Au.Perf.Next(System.Char)">
            <summary>
            Stores current time in next element of an internal array.
            </summary>
            <remarks>
            Don't call <b>Next</b> more than 16 times after <b>First</b>, because the array has fixed size.
            </remarks>
            <param name="cMark">A character to mark this time in the results string, like "A=150".</param>
        </member>
        <member name="M:Au.Perf.Write">
            <summary>
            Formats a string from time values collected by calling <see cref="M:Au.Perf.First"/> and <see cref="M:Au.Perf.Next(System.Char)"/>, and shows it in the output.
            The string contains the number of microseconds of each code execution between calling <b>First</b> and each <b>Next</b>.
            </summary>
            <example>
            <code><![CDATA[
            Perf.First(100);
            CODE1;
            Perf.Next();
            CODE2;
            Perf.Next();
            Perf.Write(); //speed:  timeOfCODE1  timeOfCODE2  (totalTime)
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Perf.NW(System.Char)">
            <summary>
            Calls <see cref="M:Au.Perf.Next(System.Char)"/> and <see cref="M:Au.Perf.Write"/>.
            </summary>
            <param name="cMark">A character to mark that time in the results string, like "A=150".</param>
        </member>
        <member name="M:Au.Perf.ToString">
            <summary>
            Formats a string from time values collected by calling <see cref="M:Au.Perf.First"/> and <see cref="M:Au.Perf.Next(System.Char)"/>.
            The string contains the number of microseconds of each code execution between calling <b>First</b> and each <b>Next</b>.
            </summary>
        </member>
        <member name="M:Au.Perf.ToArray">
            <summary>
            Return array of time values collected by calling <see cref="M:Au.Perf.First"/> and <see cref="M:Au.Perf.Next(System.Char)"/>.
            Each element is the number of microseconds of each code execution between calling <b>First</b> and each <b>Next</b>.
            </summary>
        </member>
        <member name="P:Au.Perf.TimeTotal">
            <summary>
            Gets the number of microseconds between <see cref="M:Au.Perf.First"/> and the last <see cref="M:Au.Perf.Next(System.Char)"/>.
            </summary>
        </member>
        <member name="M:Au.Perf.Execute(System.Int32,System.Action)">
            <summary>
            Executes <paramref name="code"/> (lambda) <paramref name="count"/> times, and then calls <see cref="M:Au.Perf.Next(System.Char)"/>.
            </summary>
        </member>
        <member name="M:Au.Perf.ExecuteMulti(System.Int32,System.Int32,System.Action[])">
            <summary>
            <paramref name="countAll"/> times executes this code: <c>First(); foreach(Action a in codes) Execute(countEach, a); Write();</c>.
            </summary>
        </member>
        <member name="M:Au.Perf.WakeCPU(System.Int32)">
            <summary>
            Executes some code in loop for the specified amount of time. It should make CPU to run at full speed.
            </summary>
            <param name="timeMilliseconds">How long to speed up CPU, milliseconds. The minimal required time probably is about 100 ms, but depends on CPU.</param>
            <remarks>
            Code speed measurements often are misleading because of variable CPU speed. Most CPU don't run at full speed when not actively used.
            
            You can make CPU speed constant in Control Panel -> Power Options -> ... Advanced -> Processor power management -> Minimum or maximum power state.
            There are programs that show current CPU speed. For example HWMonitor.
            </remarks>
        </member>
    </members>
</doc>
