using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using System.ComponentModel;
using System.Reflection;
using Microsoft.Win32;
using System.Runtime.ExceptionServices;
using System.Windows.Forms;
using System.Drawing;
//using System.Linq;

using Au.Types;
using static Au.NoClass;

#pragma warning disable 1591 //missing XML documentation

namespace Au
{
	/// <summary>
	/// Gets known/special folder paths (Desktop, Temp, etc).
	/// </summary>
	/// <remarks>
	/// For return values is used type <see cref="FolderPath"/>, not string. It is implicitly convertible to string. Its operator + appends a filename or relative path string, with @"\" separator if need. Example: <c>string s = Folders.Desktop + "file.txt"; //C:\Users\Name\Desktop\file.txt</c>
	/// If a function cannot get folder path, the return value contains null string. Then the + operator would throw AuException.
	///
	/// Some folders are known only on newer Windows versions or only on some computers. Some property-get functions have a suffix like "_Win8" which means that the folder is unavailable on older Windows.
	/// Some known folders, although supported and registerd, may be still not created.
	/// 
	/// Some folders are virtual, for example Control Panel. They don't have a file system path, but can be identified by an unmanaged array called "ITEMIDLIST" or "PIDL". Functions of the nested class <see cref="VirtualPidl"/> return it as <see cref="Shell.Pidl"/>. Functions of the nested class <see cref="Virtual"/> return it as string <c>":: HexEncodedITEMIDLIST"</c> that can be used with some functions of this library (of classes Shell, Shell.Pidl, Icons) but not with .NET or native functions.
	///
	/// Most functions use Windows "Known Folders" API, such as <msdn>SHGetKnownFolderPath</msdn>.
	/// The list of Windows predefined known folders: <msdn>KNOWNFOLDERID</msdn>.
	/// Names of folders specific to this application have "This" prefix, like ThisApp.
	/// 
	/// Some paths depend on the bitness (32 or 64 bit) of the OS and this process.
	/// The example paths below are for English versions of Windows on most computers.
	/// <list type="definition">
	/// <item>
	/// <term>32-bit Windows</term>
	/// <description>
	/// System, SystemX86, SystemX64: <c>@"C:\WINDOWS\system32"</c>
	/// ProgramFiles, ProgramFilesX86, ProgramFilesX64: <c>@"C:\Program Files"</c>
	/// ProgramFilesCommon, ProgramFilesCommonX86, ProgramFilesCommonX64: <c>@"C:\Program Files\Common Files"</c>
	/// </description>
	/// </item>
	/// <item>
	/// <term>64-bit Windows, 64-bit process</term>
	/// <description>
	/// System, SystemX64: <c>@"C:\WINDOWS\system32"</c>
	/// SystemX86: <c>@"C:\WINDOWS\SysWOW64"</c>
	/// ProgramFiles, ProgramFilesX64: <c>@"C:\Program Files"</c>
	/// ProgramFilesX86: <c>@"C:\Program Files (x86)"</c>
	/// ProgramFilesCommon, ProgramFilesCommonX64: <c>@"C:\Program Files\Common Files"</c>
	/// ProgramFilesCommonX86: <c>@"C:\Program Files (x86)\Common Files"</c>
	/// </description>
	/// </item>
	/// <item>
	/// <term>64-bit Windows, 32-bit process</term>
	/// <description>
	/// System: <c>@"C:\WINDOWS\system32"</c>. However the OS in most cases redirects this path to <c>@"C:\WINDOWS\SysWOW64"</c>.
	/// SystemX86: <c>@"C:\WINDOWS\SysWOW64"</c>
	/// SystemX64: <c>@"C:\WINDOWS\Sysnative"</c>. The OS redirects it to the true <c>@"C:\WINDOWS\system32"</c>. It is a special path that you don't see in Explorer.
	/// ProgramFiles, ProgramFilesX86: <c>@"C:\Program Files (x86)"</c>
	/// ProgramFilesX64: <c>@"C:\Program Files"</c>
	/// ProgramFilesCommon, ProgramFilesCommonX86: <c>@"C:\Program Files (x86)\Common Files"</c>
	/// ProgramFilesCommonX64: <c>@"C:\Program Files\Common Files"</c>
	/// </description>
	/// </item>
	/// </list>
	/// </remarks>
	[DebuggerStepThrough]
	public static class Folders
	{
		#region generated by macro "Auto create special folders class from KNOWNFOLDERID"

		public static FolderPath AccountPictures_Win8 => _Get(0x008ca0b1, 0x55b44c56, 0xb8a84de4, 0xb299d3be);
		public static FolderPath AdminTools => _Get(0x724EF170, 0xA42D4FEF, 0x9F26B60E, 0x846FBA4F);
		public static FolderPath ApplicationShortcuts_Win8 => _Get(0xA3918781, 0xE5F24890, 0xB3D9A7E5, 0x4332328C);
		public static FolderPath CameraRoll_Win81 => _Get(0xAB5FB87B, 0x7CE24F83, 0x915D5508, 0x46C9537B);
		public static FolderPath CDBurning => _Get(0x9E52AB10, 0xF80D49DF, 0xACB84330, 0xF5687855);
		public static FolderPath CommonAdminTools => _Get(0xD0384E7D, 0xBAC34797, 0x8F14CBA2, 0x29B392B5);
		public static FolderPath CommonOEMLinks => _Get(0xC1BAE2D0, 0x10DF4334, 0xBEDD7AA2, 0x0B227A9D);
		public static FolderPath CommonPrograms => _Get(0x0139D44E, 0x6AFE49F2, 0x86903DAF, 0xCAE6FFB8);
		public static FolderPath CommonStartMenu => _Get(0xA4115719, 0xD62E491D, 0xAA7CE74B, 0x8BE3B067);
		public static FolderPath CommonStartup => _Get(0x82A5EA35, 0xD9CD47C5, 0x9629E15D, 0x2F714E6E);
		public static FolderPath CommonTemplates => _Get(0xB94237E7, 0x57AC4347, 0x9151B08C, 0x6C32D1F7);
		public static FolderPath Contacts => _Get(0x56784854, 0xC6CB462b, 0x816988E3, 0x50ACB882);
		public static FolderPath Cookies => _Get(0x2B0F765D, 0xC0E94171, 0x908E08A6, 0x11B84FF6);
		public static FolderPath Desktop => _Get(0xB4BFCC3A, 0xDB2C424C, 0xB0297FE9, 0x9A87C641);
		public static FolderPath DeviceMetadataStore => _Get(0x5CE4A5E9, 0xE4EB479D, 0xB89F130C, 0x02886155);
		public static FolderPath Documents => _Get(0xFDD39AD0, 0x238F46AF, 0xADB46C85, 0x480369C7);
		public static FolderPath DocumentsLibrary => _Get(0x7B0DB17D, 0x9CD24A93, 0x973346CC, 0x89022E7C);
		public static FolderPath Downloads => _Get(0x374DE290, 0x123F4565, 0x916439C4, 0x925E467B);
		public static FolderPath Favorites => _Get(0x1777F761, 0x68AD4D8A, 0x87BD30B7, 0x59FA33DD);
		public static FolderPath Fonts => _Get(0xFD228CB7, 0xAE114AE3, 0x864C16F3, 0x910AB8FE);
		public static FolderPath GameTasks => _Get(0x054FAE61, 0x4DD84787, 0x80B60902, 0x20C4B700);
		public static FolderPath History => _Get(0xD9DC8A3B, 0xB784432E, 0xA7815A11, 0x30A75963);
		public static FolderPath ImplicitAppShortcuts => _Get(0xBCB5256F, 0x79F64CEE, 0xB725DC34, 0xE402FD46);
		public static FolderPath InternetCache => _Get(0x352481E8, 0x33BE4251, 0xBA856007, 0xCAEDCF9D);
		public static FolderPath Libraries => _Get(0x1B3EA5DC, 0xB5874786, 0xB4EFBD1D, 0xC332AEAE);
		public static FolderPath Links => _Get(0xbfb9d5e0, 0xc6a9404c, 0xb2b2ae6d, 0xb6af4968);
		public static FolderPath LocalAppData => _Get(0xF1B32785, 0x6FBA4FCF, 0x9D557B8E, 0x7F157091);
		public static FolderPath LocalAppDataLow => _Get(0xA520A1A4, 0x17804FF6, 0xBD181673, 0x43C5AF16);
		public static FolderPath LocalizedResourcesDir => _Get(0x2A00375E, 0x224C49DE, 0xB8D1440D, 0xF7EF3DDC);
		public static FolderPath Music => _Get(0x4BD8D571, 0x6D1948D3, 0xBE974222, 0x20080E43);
		public static FolderPath MusicLibrary => _Get(0x2112AB0A, 0xC86A4FFE, 0xA3680DE9, 0x6E47012E);
		public static FolderPath NetHood => _Get(0xC5ABBF53, 0xE17F4121, 0x89008662, 0x6FC2C973);
		public static FolderPath OriginalImages => _Get(0x2C36C0AA, 0x58124b87, 0xBFD04CD0, 0xDFB19B39);
		public static FolderPath PhotoAlbums => _Get(0x69D2CF90, 0xFC334FB7, 0x9A0CEBB0, 0xF0FCB43C);
		public static FolderPath PicturesLibrary => _Get(0xA990AE9F, 0xA03B4E80, 0x94BC9912, 0xD7504104);
		public static FolderPath Pictures => _Get(0x33E28130, 0x4E1E4676, 0x835A9839, 0x5C3BC3BB);
		public static FolderPath Playlists => _Get(0xDE92C1C7, 0x837F4F69, 0xA3BB86E6, 0x31204A23);
		public static FolderPath PrintHood => _Get(0x9274BD8D, 0xCFD141C3, 0xB35EB13F, 0x55A758F4);
		public static FolderPath Profile => _Get(0x5E6C858F, 0x0E224760, 0x9AFEEA33, 0x17B67173);
		public static FolderPath ProgramData => _Get(0x62AB5D82, 0xFDC14DC3, 0xA9DD070D, 0x1D495D97);
		/// <summary>More info in class help.</summary>
		public static FolderPath ProgramFiles => __ProgramFiles ?? (__ProgramFiles = _ProgramFiles);
		static string __ProgramFiles;
		static FolderPath _ProgramFiles => _Get(0x905e63b6, 0xc1bf494e, 0xb29c65b7, 0x32d3d21a);
		//broken static FolderPath ProgramFilesX64 => _Get(0x6D809377, 0x6AF0444b, 0x8957A377, 0x3F02200E);
		/// <summary>More info in class help.</summary>
		public static FolderPath ProgramFilesX86 => __ProgramFilesX86 ?? (__ProgramFilesX86 = _ProgramFilesX86);
		static string __ProgramFilesX86;
		static FolderPath _ProgramFilesX86 => _Get(0x7C5A40EF, 0xA0FB4BFC, 0x874AC0F2, 0xE0B9FA8E);
		/// <summary>More info in class help.</summary>
		public static FolderPath ProgramFilesCommon => _Get(0xF7F1ED05, 0x9F6D47A2, 0xAAAE29D3, 0x17C6F066);
		//broken static FolderPath ProgramFilesCommonX64 => _Get(0x6365D5A7, 0x0F0D45E5, 0x87F60DA5, 0x6B6A4F7D);
		/// <summary>More info in class help.</summary>
		public static FolderPath ProgramFilesCommonX86 => _Get(0xDE974D24, 0xD9C64D3E, 0xBF91F445, 0x5120B917);
		public static FolderPath Programs => _Get(0xA77F5D77, 0x2E2B44C3, 0xA6A2ABA6, 0x01054A51);
		public static FolderPath Public => _Get(0xDFDF76A2, 0xC82A4D63, 0x906A5644, 0xAC457385);
		public static FolderPath PublicDesktop => _Get(0xC4AA340D, 0xF20F4863, 0xAFEFF87E, 0xF2E6BA25);
		public static FolderPath PublicDocuments => _Get(0xED4824AF, 0xDCE445A8, 0x81E2FC79, 0x65083634);
		public static FolderPath PublicDownloads => _Get(0x3D644C9B, 0x1FB84f30, 0x9B45F670, 0x235F79C0);
		public static FolderPath PublicGameTasks => _Get(0xDEBF2536, 0xE1A84c59, 0xB6A24145, 0x86476AEA);
		public static FolderPath PublicLibraries => _Get(0x48DAF80B, 0xE6CF4F4E, 0xB8000E69, 0xD84EE384);
		public static FolderPath PublicMusic => _Get(0x3214FAB5, 0x97574298, 0xBB6192A9, 0xDEAA44FF);
		public static FolderPath PublicPictures => _Get(0xB6EBFB86, 0x6907413C, 0x9AF74FC2, 0xABF07CC5);
		public static FolderPath PublicRingtones => _Get(0xE555AB60, 0x153B4D17, 0x9F04A5FE, 0x99FC15EC);
		public static FolderPath PublicUserTiles_Win8 => _Get(0x0482af6c, 0x08f14c34, 0x8c90e17e, 0xc98b1e17);
		public static FolderPath PublicVideos => _Get(0x2400183A, 0x618549FB, 0xA2D84A39, 0x2A602BA3);
		public static FolderPath QuickLaunch => _Get(0x52a4f021, 0x7b7548a9, 0x9f6b4b87, 0xa210bc8f);
		public static FolderPath Recent => _Get(0xAE50C081, 0xEBD2438A, 0x86558A09, 0x2E34987A);
		public static FolderPath RecordedTV => _Get(0x1A6FDBA2, 0xF42D4358, 0xA798B74D, 0x745926C5);
		public static FolderPath ResourceDir => _Get(0x8AD10C31, 0x2ADB4296, 0xA8F7E470, 0x1232C972);
		public static FolderPath Ringtones => _Get(0xC870044B, 0xF49E4126, 0xA9C3B52A, 0x1FF411E8);
		public static FolderPath RoamingAppData => _Get(0x3EB685DB, 0x65F94CF6, 0xA03AE3EF, 0x65729F3D);
		public static FolderPath RoamedTileImages_Win8 => _Get(0xAAA8D5A5, 0xF1D64259, 0xBAA878E7, 0xEF60835E);
		public static FolderPath RoamingTiles_Win8 => _Get(0x00BCFC5A, 0xED944e48, 0x96A13F62, 0x17F21990);
		public static FolderPath SampleMusic => _Get(0xB250C668, 0xF57D4EE1, 0xA63C290E, 0xE7D1AA1F);
		public static FolderPath SamplePictures => _Get(0xC4900540, 0x23794C75, 0x844B64E6, 0xFAF8716B);
		public static FolderPath SamplePlaylists => _Get(0x15CA69B3, 0x30EE49C1, 0xACE16B5E, 0xC372AFB5);
		public static FolderPath SampleVideos => _Get(0x859EAD94, 0x2E8548AD, 0xA71A0969, 0xCB56A6CD);
		public static FolderPath SavedGames => _Get(0x4C5C32FF, 0xBB9D43b0, 0xB5B42D72, 0xE54EAAA4);
		public static FolderPath SavedPictures => _Get(0x3B193882, 0xD3AD4eab, 0x965A6982, 0x9D1FB59F);
		public static FolderPath SavedPicturesLibrary => _Get(0xE25B5812, 0xBE884bd9, 0x94B02923, 0x3477B6C3);
		public static FolderPath SavedSearches => _Get(0x7d1d3a04, 0xdebb4115, 0x95cf2f29, 0xda2920da);
		public static FolderPath Screenshots_Win8 => _Get(0xb7bede81, 0xdf944682, 0xa7d857a5, 0x2620b86f);
		public static FolderPath SearchHistory_Win81 => _Get(0x0D4C3DB6, 0x03A3462F, 0xA0E60892, 0x4C41B5D4);
		public static FolderPath SearchTemplates_Win81 => _Get(0x7E636BFE, 0xDFA94D5E, 0xB456D7B3, 0x9851D8A9);
		public static FolderPath SendTo => _Get(0x8983036C, 0x27C0404B, 0x8F08102D, 0x10DCFD74);
		public static FolderPath SidebarDefaultParts => _Get(0x7B396E54, 0x9EC54300, 0xBE0A2482, 0xEBAE1A26);
		public static FolderPath SidebarParts => _Get(0xA75D362E, 0x50FC4fb7, 0xAC2CA8BE, 0xAA314493);
		public static FolderPath SkyDrive_Win81 => _Get(0xA52BBA46, 0xE9E1435f, 0xB3D928DA, 0xA648C0F6);
		public static FolderPath SkyDriveCameraRoll_Win81 => _Get(0x767E6811, 0x49CB4273, 0x87C220F3, 0x55E1085B);
		public static FolderPath SkyDriveDocuments_Win81 => _Get(0x24D89E24, 0x2F194534, 0x9DDE6A66, 0x71FBB8FE);
		public static FolderPath SkyDrivePictures_Win81 => _Get(0x339719B5, 0x8C474894, 0x94C2D8F7, 0x7ADD44A6);
		public static FolderPath StartMenu => _Get(0x625B53C3, 0xAB484EC1, 0xBA1FA1EF, 0x4146FC19);
		public static FolderPath Startup => _Get(0xB97D20BB, 0xF46A4C97, 0xBA105E36, 0x08430854);
		/// <summary>More info in class help.</summary>
		public static FolderPath System => __System ?? (__System = _System);
		static string __System;
		static FolderPath _System => _Get(0x1AC14E77, 0x02E74E5D, 0xB7442EB1, 0xAE5198B7);
		/// <summary>More info in class help.</summary>
		public static FolderPath SystemX86 => _Get(0xD65231B0, 0xB2F14857, 0xA4CEA8E7, 0xC6EA7D27);
		public static FolderPath Templates => _Get(0xA63293E8, 0x664E48DB, 0xA079DF75, 0x9E0509F7);
		public static FolderPath TreeProperties => _Get(0x9E3995AB, 0x1F9C4F13, 0xB82748B2, 0x4B6C7174);
		public static FolderPath UserProfiles => _Get(0x0762D272, 0xC50A4BB0, 0xA382697D, 0xCD729B80);
		public static FolderPath UserProgramFiles => _Get(0x5CD7AEE2, 0x22194A67, 0xB85D6C9C, 0xE15660CB);
		public static FolderPath UserProgramFilesCommon => _Get(0xBCBD3057, 0xCA5C4622, 0xB42DBC56, 0xDB0AE516);
		public static FolderPath Videos => _Get(0x18989B1D, 0x99B5455B, 0x841CAB7C, 0x74E4DDFC);
		public static FolderPath VideosLibrary => _Get(0x491E922F, 0x56434AF4, 0xA7EB4E7A, 0x138D8174);
		public static FolderPath Windows => __Windows ?? (__Windows = _Windows);
		static string __Windows;
		static FolderPath _Windows => _Get(0xF38BF404, 0x1D4342F2, 0x930567DE, 0x0B28FC23);

		[DebuggerStepThrough]
		public static class Virtual
		{
			public static FolderPath AddNewPrograms { get { return _GetV(0xde61d971, 0x5ebc4f02, 0xa3a96c82, 0x895e5c04); } }
			public static FolderPath Apps_Win8 { get { return _GetV(0x1e87508d, 0x89c242f0, 0x8a7e645a, 0x0f50ca58); } }
			public static FolderPath AppUpdates { get { return _GetV(0xa305ce99, 0xf527492b, 0x8b1a7e76, 0xfa98d6e4); } }
			public static FolderPath ChangeRemovePrograms { get { return _GetV(0xdf7266ac, 0x92744867, 0x8d553bd6, 0x61de872d); } }
			public static FolderPath Computer { get { return _GetV(0x0AC0837C, 0xBBF8452A, 0x850D79D0, 0x8E667CA7); } }
			public static FolderPath Conflict { get { return _GetV(0x4bfefb45, 0x347d4006, 0xa5beac0c, 0xb0567192); } }
			public static FolderPath Connections { get { return _GetV(0x6F0CD92B, 0x2E9745D1, 0x88FFB0D1, 0x86B8DEDD); } }
			public static FolderPath ControlPanel { get { return _GetV(0x82A74AEB, 0xAEB4465C, 0xA014D097, 0xEE346D63); } }
			public static FolderPath Games { get { return _GetV(0xCAC52C1A, 0xB53D4edc, 0x92D76B2E, 0x8AC19434); } }
			public static FolderPath HomeGroup { get { return _GetV(0x52528A6B, 0xB9E34ADD, 0xB60D588C, 0x2DBA842D); } }
			public static FolderPath HomeGroupCurrentUser_Win8 { get { return _GetV(0x9B74B6A3, 0x0DFD4f11, 0x9E785F78, 0x00F2E772); } }
			public static FolderPath Internet { get { return _GetV(0x4D9F7874, 0x4E0C4904, 0x967B40B0, 0xD20C3E4B); } }
			public static FolderPath Network { get { return _GetV(0xD20BEEC4, 0x5CA84905, 0xAE3BBF25, 0x1EA09B53); } }
			public static FolderPath Printers { get { return _GetV(0x76FC4E2D, 0xD6AD4519, 0xA66337BD, 0x56068185); } }
			public static FolderPath RecycleBin { get { return _GetV(0xB7534046, 0x3ECB4C18, 0xBE4E64CD, 0x4CB7D6AC); } }
			public static FolderPath SEARCH_CSC { get { return _GetV(0xee32e446, 0x31ca4aba, 0x814fa5eb, 0xd2fd6d5e); } }
			public static FolderPath SearchHome { get { return _GetV(0x190337d1, 0xb8ca4121, 0xa6396d47, 0x2d16972a); } }
			public static FolderPath SEARCH_MAPI { get { return _GetV(0x98ec0e18, 0x20984d44, 0x86446697, 0x9315a281); } }
			public static FolderPath SyncManager { get { return _GetV(0x43668BF8, 0xC14E49B2, 0x97C97477, 0x84D784B7); } }
			public static FolderPath SyncResults { get { return _GetV(0x289a9a43, 0xbe444057, 0xa41b587a, 0x76d7e7f9); } }
			public static FolderPath SyncSetup { get { return _GetV(0x0F214138, 0xB1D34a90, 0xBBA927CB, 0xC0C5389A); } }
			public static FolderPath UsersFiles { get { return _GetV(0xf3ce0f7c, 0x49014acc, 0x8648d5d4, 0x4b04ef8f); } }
			public static FolderPath UsersLibraries { get { return _GetV(0xA302545D, 0xDEFF464b, 0xABE861C8, 0x648D939B); } }
		}

		[DebuggerStepThrough]
		public static class VirtualPidl
		{
			public static Shell.Pidl AddNewPrograms { get { return _GetVI(0xde61d971, 0x5ebc4f02, 0xa3a96c82, 0x895e5c04); } }
			public static Shell.Pidl Apps_Win8 { get { return _GetVI(0x1e87508d, 0x89c242f0, 0x8a7e645a, 0x0f50ca58); } }
			public static Shell.Pidl AppUpdates { get { return _GetVI(0xa305ce99, 0xf527492b, 0x8b1a7e76, 0xfa98d6e4); } }
			public static Shell.Pidl ChangeRemovePrograms { get { return _GetVI(0xdf7266ac, 0x92744867, 0x8d553bd6, 0x61de872d); } }
			public static Shell.Pidl Computer { get { return _GetVI(0x0AC0837C, 0xBBF8452A, 0x850D79D0, 0x8E667CA7); } }
			public static Shell.Pidl Conflict { get { return _GetVI(0x4bfefb45, 0x347d4006, 0xa5beac0c, 0xb0567192); } }
			public static Shell.Pidl Connections { get { return _GetVI(0x6F0CD92B, 0x2E9745D1, 0x88FFB0D1, 0x86B8DEDD); } }
			public static Shell.Pidl ControlPanel { get { return _GetVI(0x82A74AEB, 0xAEB4465C, 0xA014D097, 0xEE346D63); } }
			public static Shell.Pidl Games { get { return _GetVI(0xCAC52C1A, 0xB53D4edc, 0x92D76B2E, 0x8AC19434); } }
			public static Shell.Pidl HomeGroup { get { return _GetVI(0x52528A6B, 0xB9E34ADD, 0xB60D588C, 0x2DBA842D); } }
			public static Shell.Pidl HomeGroupCurrentUser_Win8 { get { return _GetVI(0x9B74B6A3, 0x0DFD4f11, 0x9E785F78, 0x00F2E772); } }
			public static Shell.Pidl Internet { get { return _GetVI(0x4D9F7874, 0x4E0C4904, 0x967B40B0, 0xD20C3E4B); } }
			public static Shell.Pidl Network { get { return _GetVI(0xD20BEEC4, 0x5CA84905, 0xAE3BBF25, 0x1EA09B53); } }
			public static Shell.Pidl Printers { get { return _GetVI(0x76FC4E2D, 0xD6AD4519, 0xA66337BD, 0x56068185); } }
			public static Shell.Pidl RecycleBin { get { return _GetVI(0xB7534046, 0x3ECB4C18, 0xBE4E64CD, 0x4CB7D6AC); } }
			public static Shell.Pidl SEARCH_CSC { get { return _GetVI(0xee32e446, 0x31ca4aba, 0x814fa5eb, 0xd2fd6d5e); } }
			public static Shell.Pidl SearchHome { get { return _GetVI(0x190337d1, 0xb8ca4121, 0xa6396d47, 0x2d16972a); } }
			public static Shell.Pidl SEARCH_MAPI { get { return _GetVI(0x98ec0e18, 0x20984d44, 0x86446697, 0x9315a281); } }
			public static Shell.Pidl SyncManager { get { return _GetVI(0x43668BF8, 0xC14E49B2, 0x97C97477, 0x84D784B7); } }
			public static Shell.Pidl SyncResults { get { return _GetVI(0x289a9a43, 0xbe444057, 0xa41b587a, 0x76d7e7f9); } }
			public static Shell.Pidl SyncSetup { get { return _GetVI(0x0F214138, 0xB1D34a90, 0xBBA927CB, 0xC0C5389A); } }
			public static Shell.Pidl UsersFiles { get { return _GetVI(0xf3ce0f7c, 0x49014acc, 0x8648d5d4, 0x4b04ef8f); } }
			public static Shell.Pidl UsersLibraries { get { return _GetVI(0xA302545D, 0xDEFF464b, 0xABE861C8, 0x648D939B); } }
		}

		#endregion

		#region other paths

		/// <summary>
		/// Temp folder (temporary files) of this user account.
		/// </summary>
		public static FolderPath Temp => __Temp ?? (__Temp = Path.GetTempPath().TrimEnd('\\'));
		static string __Temp;

		/// <summary>
		/// Folder containing assemblies of this appdomain.
		/// Calls <see cref="AppDomain.BaseDirectory"/>.
		/// </summary>
		/// <remarks>
		/// Unlike <see cref="ThisProcess"/>, this path can be different for each appdomain; it is set when creating the AppDomain.
		/// See also <see cref="Application.ExecutablePath"/>, it gets full path (with file name) of appdomain's entry assembly.
		/// </remarks>
		public static FolderPath ThisApp => __App ?? (__App = AppDomain.CurrentDomain.BaseDirectory.TrimEnd('\\'));
		static string __App;

		//Differences from Application.xAppDataPath: no version, no ClickOnce support.
		static string _DefaultAppSubDir => __defaultAppSubDir ?? (__defaultAppSubDir = /*Application.CompanyName + "\\" + */Application.ProductName);
		static string __defaultAppSubDir;

		/// <summary>
		/// Gets or sets path of the temporary files folder of this application.
		/// Default is Folders.Temp + Application.ProductName.
		/// The 'set' function does not change system settings, it just remembers a string that will be later returned by the 'get' function in this appdomain.
		/// The 'get' function creates the folder if does not exist.
		/// </summary>
		public static FolderPath ThisAppTemp
		{
			get
			{
				if(__appTemp == null) __appTemp = Path.GetTempPath() + _DefaultAppSubDir;
				Files.CreateDirectory(__appTemp);
				return __appTemp;
			}
			set
			{
				__appTemp = value;
			}
		}
		static string __appTemp;

		/// <summary>
		/// Gets or sets path of user document files folder of this application.
		/// Default is Folders.Documents + Application.ProductName.
		/// The 'set' function does not change system settings, it just remembers a string that will be later returned by the 'get' function in this appdomain.
		/// The 'get' function creates the folder if does not exist.
		/// </summary>
		public static FolderPath ThisAppDocuments
		{
			get
			{
				if(__appDocuments == null) __appDocuments = Documents + _DefaultAppSubDir;
				Files.CreateDirectory(__appDocuments);
				return __appDocuments;
			}
			set
			{
				__appDocuments = value;
			}
		}
		static string __appDocuments;

		/// <summary>
		/// Gets or sets path of private files folder of this application on this user account.
		/// Default is Folders.RoamingAppData + Application.ProductName.
		/// The 'set' function does not change system settings, it just remembers a string that will be later returned by the 'get' function in this appdomain.
		/// The 'get' function creates the folder if does not exist.
		/// </summary>
		public static FolderPath ThisAppData
		{
			get
			{
				if(__appData == null) __appData = RoamingAppData + _DefaultAppSubDir;
				Files.CreateDirectory(__appData);
				return __appData;
			}
			set
			{
				__appData = value;
			}
		}
		static string __appData;

		/// <summary>
		/// Gets or sets path of local (non-roaming) private files folder of this application on this user account.
		/// Default is Folders.LocalAppData + Application.ProductName.
		/// The 'set' function does not change system settings, it just remembers a string that will be later returned by the 'get' function in this appdomain.
		/// The 'get' function creates the folder if does not exist.
		/// </summary>
		public static FolderPath ThisAppDataLocal
		{
			get
			{
				if(__appDataLocal == null) __appDataLocal = LocalAppData + _DefaultAppSubDir;
				Files.CreateDirectory(__appDataLocal);
				return __appDataLocal;
			}
			set
			{
				__appDataLocal = value;
			}
		}
		static string __appDataLocal;

		/// <summary>
		/// Gets or sets path of common (all users) private files folder of this application.
		/// Default is Folders.ProgramData + Application.ProductName.
		/// The 'set' function does not change system settings, it just remembers a string that will be later returned by the 'get' function in this appdomain.
		/// Note: the ProgramData folder has special permissions. Programs running not as administrator usually cannot write there.
		/// This function does not auto-create the folder; usually it is created when installing the application.
		/// </summary>
		public static FolderPath ThisAppDataCommon
		{
			get => __appDataCommon ?? (__appDataCommon = ProgramData + _DefaultAppSubDir);
			set { __appDataCommon = value; }
		}
		static string __appDataCommon;

		/// <summary>
		/// Folder containing the program file of this process.
		/// Calls <see cref="Application.StartupPath"/>.
		/// Unlike <see cref="ThisApp"/>, this path is the same for all app domains of this process.
		/// </summary>
		public static FolderPath ThisProcess => Application.StartupPath;

		/// <summary>
		/// Gets or sets path of images (icons etc) folder of this application.
		/// Default is ThisApp + "Images".
		/// Functions of these classes will look for image there: Icons, AuMenu, AuToolbar, possibly some other.
		/// </summary>
		public static FolderPath ThisAppImages
		{
			get
			{
				if(__appImages == null) __appImages = ThisApp + "Images";
				return __appImages;
			}
			set
			{
				__appImages = value;
			}
		}
		static string __appImages;

		/// <summary>
		/// Gets non-redirected path of the System32 folder.
		/// </summary>
		/// <remarks>
		/// If this process is 32-bit and OS is 64-bit, when it uses the <see cref="System"/> folder path (@"C:\WINDOWS\system32"), the OS in most cases redirects it to @"C:\Windows\SysWOW64", which contains 32-bit versions of program files. Use SystemX64 when you want to avoid the redirection and access the true System32 folder which on 64-bit OS contains 64-bit program files.
		/// More info in class help.
		/// </remarks>
		/// <seealso cref="Files.Misc.DisableRedirection"/>
		/// <seealso cref="Ver.Is32BitProcessOn64BitOS"/>
		public static FolderPath SystemX64 => __SystemX64 ?? (__SystemX64 = Ver.Is32BitProcessOn64BitOS ? (FolderPath)(Windows + "Sysnative") : System);
		static string __SystemX64;

		/// <summary>More info in class help.</summary>
		public static FolderPath ProgramFilesX64 => __ProgramFilesX64 ?? (__ProgramFilesX64 = Ver.Is32BitProcessOn64BitOS ? EnvVar("ProgramW6432") : ProgramFiles);
		static string __ProgramFilesX64;
		/// <summary>More info in class help.</summary>
		public static FolderPath ProgramFilesCommonX64 => __ProgramFilesCommonX64 ?? (__ProgramFilesCommonX64 = Ver.Is32BitProcessOn64BitOS ? EnvVar("CommonProgramW6432") : ProgramFilesCommon);
		static string __ProgramFilesCommonX64;
		//The normal retrieving method for these folders is broken. Fails even on 64-bit OS if process is 32-bit.

		/// <summary>
		/// Gets CD/DVD drive path, like @"D:\".
		/// Returns null if unavailable.
		/// </summary>
		public static FolderPath CdDvdDrive
		{
			get
			{
				foreach(DriveInfo di in DriveInfo.GetDrives()) {
					if(di.DriveType == DriveType.CDRom) return di.Name;
				}
				return null;
			}
		}

		/// <summary>Calls <see cref="RemovableDrive(int)"/>(0).</summary>
		public static FolderPath RemovableDrive0 => RemovableDrive(0);
		/// <summary>Calls <see cref="RemovableDrive(int)"/>(1).</summary>
		public static FolderPath RemovableDrive1 => RemovableDrive(1);
		/// <summary>Calls <see cref="RemovableDrive(int)"/>(2).</summary>
		public static FolderPath RemovableDrive2 => RemovableDrive(2);
		/// <summary>Calls <see cref="RemovableDrive(int)"/>(3).</summary>
		public static FolderPath RemovableDrive3 => RemovableDrive(3);

		/// <summary>
		/// Gets removable/external/USB drive path, like @"F:\".
		/// Returns null if unavailable.
		/// </summary>
		/// <param name="driveIndex">0-based removable drive index.</param>
		/// <remarks>Uses <see cref="DriveInfo.GetDrives"/> and counts only drives of type DriveType.Removable.</remarks>
		public static FolderPath RemovableDrive(int driveIndex = 0)
		{
			foreach(DriveInfo di in DriveInfo.GetDrives()) {
				if(di.DriveType == DriveType.Removable && driveIndex-- == 0) return di.Name;
			}
			return null;
		}

		/// <summary>
		/// Gets removable/external/USB drive name (like @"F:\") by its volume label.
		/// Returns null if unavailable.
		/// </summary>
		/// <param name="volumeLabel">Volume label. You can see it in drive Properties dialog; it is not the drive name that is displayed in File Explorer.</param>
		public static FolderPath RemovableDrive(string volumeLabel)
		{
			foreach(DriveInfo di in DriveInfo.GetDrives()) {
				if(di.DriveType == DriveType.Removable) {
					string v = null; try { v = di.VolumeLabel; } catch { continue; }
					if(!v.Equals_(volumeLabel, true)) continue;
					return di.Name;
				}
			}
			return null;
		}

		/// <summary>
		/// Gets the value of an environment variable.
		/// Returns null if unavailable.
		/// </summary>
		public static FolderPath EnvVar(string envVar)
		{
			return Path_.LibGetEnvVar(envVar);
		}

		#endregion

		#region private functions

		//Gets non-virtual known folder path from KNOWNFOLDERID specified with 4 uints.
		static FolderPath _Get(uint a, uint b, uint c, uint d)
		{
			//info: we don't use caching. It seems the API use caching internally.
			//Speed first time (ngened, shell32.dll loaded (almost 1 ms)) - 200, then 90. It is for each folder first time; next time 1.
			//tested: with IKnownFolder much slower.

			var guid = new KNOWNFOLDERID(a, b, c, d);
			return (0 == SHGetKnownFolderPath(ref guid, KNOWN_FOLDER_FLAG.KF_FLAG_DONT_VERIFY, Zero, out string R)) ? R : null;
		}

		//Gets virtual known folder ITEMIDLIST from KNOWNFOLDERID specified with 4 uints.
		static Shell.Pidl _GetVI(uint a, uint b, uint c, uint d)
		{
			var guid = new KNOWNFOLDERID(a, b, c, d);
			if(0 != SHGetKnownFolderIDList(ref guid, KNOWN_FOLDER_FLAG.KF_FLAG_DONT_VERIFY, Zero, out IntPtr pidl)) return null;
			return new Shell.Pidl(pidl);
		}

		//Gets virtual known folder ITEMIDLIST from KNOWNFOLDERID specified with 4 uints.
		//Returns string ":: HexEncodedITEMIDLIST".
		static FolderPath _GetV(uint a, uint b, uint c, uint d)
		{
			using(var pidl = _GetVI(a, b, c, d)) {
				if(pidl == null) return null;
				return pidl.ToHexString();
			}
		}

		#endregion

		#region API

		//GUID that can be inited with 4 uints.
		struct KNOWNFOLDERID
		{
			uint _a; ushort _b, _c; byte _d, _e, _f, _g, _h, _i, _j, _k;

			public KNOWNFOLDERID(uint a, uint b, uint c, uint d)
			{
				_a = a;
				_b = (ushort)(b >> 16);
				_c = (ushort)b;
				_d = (byte)(c >> 24);
				_e = (byte)(c >> 16);
				_f = (byte)(c >> 8);
				_g = (byte)c;
				_h = (byte)(d >> 24);
				_i = (byte)(d >> 16);
				_j = (byte)(d >> 8);
				_k = (byte)d;
			}
		}

		[DllImport("shell32.dll")]
		static extern int SHGetKnownFolderPath(ref KNOWNFOLDERID rfid, KNOWN_FOLDER_FLAG dwFlags, IntPtr hToken, out string ppszPath);

		[DllImport("shell32.dll")]
		static extern int SHGetKnownFolderIDList(ref KNOWNFOLDERID rfid, KNOWN_FOLDER_FLAG dwFlags, IntPtr hToken, out IntPtr ppidl);

		[Flags]
		enum KNOWN_FOLDER_FLAG :uint
		{
			KF_FLAG_SIMPLE_IDLIST = 0x00000100,
			KF_FLAG_NOT_PARENT_RELATIVE = 0x00000200,
			KF_FLAG_DEFAULT_PATH = 0x00000400,
			KF_FLAG_INIT = 0x00000800,
			KF_FLAG_NO_ALIAS = 0x00001000,
			KF_FLAG_DONT_UNEXPAND = 0x00002000,
			KF_FLAG_DONT_VERIFY = 0x00004000,
			KF_FLAG_CREATE = 0x00008000,
			KF_FLAG_NO_APPCONTAINER_REDIRECTION = 0x00010000,
			KF_FLAG_ALIAS_ONLY = 0x80000000
		}

		enum KF_DEFINITION_FLAGS
		{
			KFDF_LOCAL_REDIRECT_ONLY = 0x2,
			KFDF_ROAMABLE = 0x4,
			KFDF_PRECREATE = 0x8,
			KFDF_STREAM = 0x10,
			KFDF_PUBLISHEXPANDEDPATH = 0x20
		}

		[StructLayout(LayoutKind.Sequential)]
		struct KNOWNFOLDER_DEFINITION
		{
			public KF_CATEGORY category;

			[MarshalAs(UnmanagedType.LPWStr)]
			public string pszName;

			[MarshalAs(UnmanagedType.LPWStr)]
			public string pszDescription;

			public Guid fidParent;

			[MarshalAs(UnmanagedType.LPWStr)]
			public string pszRelativePath;

			[MarshalAs(UnmanagedType.LPWStr)]
			public string pszParsingName;

			[MarshalAs(UnmanagedType.LPWStr)]
			public string pszToolTip;

			[MarshalAs(UnmanagedType.LPWStr)]
			public string pszLocalizedName;

			[MarshalAs(UnmanagedType.LPWStr)]
			public string pszIcon;

			[MarshalAs(UnmanagedType.LPWStr)]
			public string pszSecurity;

			public uint dwAttributes;
			public KF_DEFINITION_FLAGS kfdFlags;
			public Guid ftidType;
		}

		enum FFFP_MODE
		{
			FFFP_EXACTMATCH = 0,
			FFFP_NEARESTPARENTMATCH = 1
		}

		[ComImport, Guid("8BE2D872-86AA-4d47-B776-32CCA40C7018"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		interface IKnownFolderManager
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime), PreserveSig]
			int FolderIdFromCsidl(int nCsidl, out Guid pfid);

			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime), PreserveSig]
			int FolderIdToCsidl(ref Guid rfid, out int pnCsidl);

			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime), PreserveSig]
			int GetFolderIds(out IntPtr ppKFId, out uint ids); //KNOWNFOLDERID **ppKFId

			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime), PreserveSig]
			int GetFolder(ref Guid rfid, [MarshalAs(UnmanagedType.Interface)] out IKnownFolder kf);

			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime), PreserveSig]
			int GetFolderByName([In, MarshalAs(UnmanagedType.LPWStr)] string pszCanonicalName, [MarshalAs(UnmanagedType.Interface)] out IKnownFolder kf);

			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime), PreserveSig]
			int RegisterFolder(ref Guid rfid, ref KNOWNFOLDER_DEFINITION pKFD);

			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime), PreserveSig]
			int UnregisterFolder(ref Guid rfid);

			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime), PreserveSig]
			int FindFolderFromPath([In, MarshalAs(UnmanagedType.LPWStr)] string pszPath, FFFP_MODE mode, [MarshalAs(UnmanagedType.Interface)] out IKnownFolder kf);

			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime), PreserveSig]
			int FindFolderFromIDList(IntPtr pidl, [MarshalAs(UnmanagedType.Interface)] out IKnownFolder kf);

			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime), PreserveSig]
			int Redirect(ref Guid rfid, IntPtr hwnd, uint Flags,
					[In, MarshalAs(UnmanagedType.LPWStr)] string pszTargetPath, uint cFolders,
					ref Guid pExclusion, [MarshalAs(UnmanagedType.LPWStr)] out string ppszError);
		}

		[ComImport, Guid("4df0c730-df9d-4ae3-9153-aa6b82e9795a")]
		class KnownFolderManager
		{
		}

		enum KF_CATEGORY
		{
			KF_CATEGORY_VIRTUAL = 1,
			KF_CATEGORY_FIXED = 2,
			KF_CATEGORY_COMMON = 3,
			KF_CATEGORY_PERUSER = 4
		}

		[ComImport, Guid("3AA7AF7E-9B36-420c-A8E3-F77D4674A488"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		interface IKnownFolder
		{
			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime), PreserveSig]
			int GetId(out Guid guid);

			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime), PreserveSig]
			int GetCategory(out KF_CATEGORY category);

			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime), PreserveSig]
			//int GetShellItem(uint dwFlags, ref Guid riid, out Api.IShellItem si);
			int GetShellItem(uint dwFlags, ref Guid riid, out IntPtr si);

			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime), PreserveSig]
			int GetPath(uint dwFlags, [MarshalAs(UnmanagedType.LPWStr)]out string path);

			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime), PreserveSig]
			int SetPath(uint dwFlags, [In, MarshalAs(UnmanagedType.LPWStr)] string pszPath);

			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime), PreserveSig]
			int GetIDList(uint dwFlags, out IntPtr idList);

			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime), PreserveSig]
			int GetFolderType(out Guid fType);

			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime), PreserveSig]
			int GetRedirectionCapabilities(out uint caps);

			[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime), PreserveSig]
			int GetFolderDefinition(out KNOWNFOLDER_DEFINITION def);
		}

		#endregion

		#region public methods

		/// <summary>
		/// Gets canonical names and paths of all known folders, including custom known folders registerd by applications.
		/// Can be useful for information. These names then can be used with <see cref="GetFolder"/>.
		/// Example: <c>Print(Folders.GetKnownFolders());</c>
		/// </summary>
		public static Dictionary<string, string> GetKnownFolders()
		{
			var dict = new Dictionary<string, string>();

			var man = new KnownFolderManager() as IKnownFolderManager;
			IntPtr ipIds = Zero;
			try {
				if(man.GetFolderIds(out ipIds, out uint nIds) != 0) return null;
				unsafe
				{
					Guid* gp = (Guid*)ipIds;
					for(uint i = 0; i < nIds; i++) {
						IKnownFolder kf = null;
						try {
							if(man.GetFolder(gp[i], out kf) != 0) continue;
							if(kf.GetFolderDefinition(out var fd) != 0) continue;
							string path = null;
							if(fd.category == KF_CATEGORY.KF_CATEGORY_VIRTUAL) {
								path = "<virtual>";
							} else {
								if(kf.GetPath(0, out path) != 0) path = "<unavailable>";
							}
							dict.Add(fd.pszName, path);
						}
						catch { }
						finally { Api.ReleaseComObject(kf); }
					}
				}
			}
			catch {
				dict = null;
			}
			finally {
				Marshal.FreeCoTaskMem(ipIds);
				Api.ReleaseComObject(man);
			}
			return dict;
		}

		/// <summary>
		/// Gets path of a known folder by its name as string.
		/// Returns null if unavailable.
		/// </summary>
		/// <param name="folderName">
		/// A property name of this class. Examples: "Documents", "Temp", "ThisApp".
		/// Or a property name of the nested class Virtual, like "Virtual.ControlPanel". Gets ":: HexEncodedITEMIDLIST".
		/// Or known folder canonical name. See <see cref="GetKnownFolders"/>. If has prefix "Virtual.", gets ":: HexEncodedITEMIDLIST". Much slower, but allows to get paths of folders registered by applications.
		/// </param>
		public static FolderPath GetFolder(string folderName)
		{
			if(Empty(folderName)) return null;
			bool isVirtual = folderName.StartsWith_("Virtual.");
			if(isVirtual) folderName = folderName.Substring(8);

			//properties of this class
			Type ty = isVirtual ? typeof(Virtual) : typeof(Folders);
			var pi = ty.GetProperty(folderName, BindingFlags.GetProperty | BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Static);
			if(pi != null) {
				var o = pi.GetValue(null);
				if(o is FolderPath fp) return fp;
				return null;
			}
			//Using reflection is not the fastest way, but simplest, cannot make bugs, and don't need maitenance. Fast enough.

			//default and custom registered known folders by canonical name
			string R = null;
			IKnownFolderManager man = null; IKnownFolder kf = null;
			try {
				man = (IKnownFolderManager)new KnownFolderManager();
				if(man.GetFolderByName(folderName, out kf) != 0) return null;
				if(isVirtual) {
					if(0 != kf.GetIDList(0, out IntPtr pidl)) return null;
					R = Shell.Pidl.LibToHexString(pidl);
					Marshal.FreeCoTaskMem(pidl);
				} else {
					if(0 != kf.GetPath(0, out R)) return null;
					R = Path_.ExpandEnvVar(R);
				}
				//tested: works in MTA apartment too. And all props.
			}
			catch { }
			finally {
				Api.ReleaseComObject(kf);
				Api.ReleaseComObject(man);
			}

			return R;

			//speed:
			//	The get-property code is 2 times slower than calling properties directly.
			//	The IKnownFolderManager code is 90 times slower than the get-property code.
		}

		#endregion

		public struct FolderPath
		{
			string _path;
			FolderPath(string path) { _path = path; }

			public static implicit operator FolderPath(string path) { return new FolderPath(path); }
			public static implicit operator string(FolderPath f) { return f._path; }
			public override string ToString() { return _path; }

			/// <summary>
			/// Calls <see cref="Path_.Combine"/>(fp, append).
			/// Example: <c>string s = Folders.Desktop + "file.txt";</c>
			/// </summary>
			/// <exception cref="AuException">f is empty. Most likely, used code <c>Folders.X + "append"</c> and failed to get X.</exception>
			public static string operator +(FolderPath fp, string append)
			{
				if(Empty(fp._path)) throw new AuException("No folder path.");
				return Path_.Combine(fp._path, append);
			}
		}

		//FUTURE:
		//	Unexpand(). Would create string like @"Documents + ""...""" or like @"%Folders.Documents%\...".

		//DON'T: public static class VirtualNAME that returns parsing name, eg "::{CLSID}\...".
		//	What is good: native/.NET shellexecute supports it.
		//	What is bad: native/.NET shellexecute supports only some. Almost nothing works in a 32-bit process on 64-bit OS; then even cannot convert the string to ITEMIDLIST. Some parsing names have other formats and the API gets wrong parsing names.

		//DON'T: The + operator returns FolderPath. Then Folders.Desktop + subfolder + file would return "desktop\subfolder\file". Probably not good.
	}
}
