<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Au</name>
    </assembly>
    <members>
        <member name="M:Au.Types.Cpp.Cpp_AccFromWindow(System.Int32,Au.Wnd,Au.Types.AccOBJID,Au.Types.Cpp.Cpp_Acc@,Au.Types.BSTR@)">
            <summary>
            flags: 1 inproc, 2 get only name.
            </summary>
        </member>
        <member name="M:Au.Types.Cpp.Cpp_RegexCompile(System.String,Au.Types.LPARAM,Au.Types.RXFlags,System.Int32@,Au.Types.BSTR@)">
            <summary>This and related API are documented in the C++ dll project.</summary>
        </member>
        <member name="T:Au.Types.Cpp.RegexMatch">
            <summary>This and related API are documented in the C++ dll project.</summary>
        </member>
        <member name="M:Au.Types.Cpp.Cpp_RegexMatch(System.Runtime.InteropServices.HandleRef,System.String,Au.Types.LPARAM,Au.Types.LPARAM,Au.Types.RXMatchFlags,Au.Types.Cpp.PcreCalloutT,Au.Types.Cpp.RegexMatch@,Au.Types.BSTR@)">
            <summary>This and related API are documented in the C++ dll project.</summary>
        </member>
        <member name="T:Au.Types.AFFlags">
            <summary>
            Flags for <see cref="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,Au.Wnd.ChildFinder)"/> and similar functions.
            </summary>
        </member>
        <member name="F:Au.Types.AFFlags.Reverse">
            <summary>
            Search in reverse order. It can make faster.
            When control class or id is specified in the <i>prop</i> argument, controls are searched not in reverse order. Only accessible objects in them are searched in reverse order.
            </summary>
        </member>
        <member name="F:Au.Types.AFFlags.HiddenToo">
            <summary>
            The accessible object can be invisible.
            Without this flag skips objects that are invisible (have state INVISIBLE) or are descendants of invisible WINDOW, DOCUMENT, PROPERTYPAGE, GROUPING, ALERT, MENUPOPUP.
            Regardless of this flag, always skips invisible standard objects of nonclient area: TITLEBAR, MENUBAR, SCROLLBAR, GRIP.
            </summary>
        </member>
        <member name="F:Au.Types.AFFlags.MenuToo">
            <summary>
            Always search in MENUITEM.
            Without this flag skips MENUITEM descendant objects (for speed), unless role is MENUITEM or MENUPOPUP or searching in web page.
            </summary>
        </member>
        <member name="F:Au.Types.AFFlags.ClientArea">
            <summary>
            Search only in the client area of the window or control.
            Skips the title bar, standard menubars and scrollbars. Searches only in the client area root object (but will not find the object itself).
            When control class or id is specified in the <i>prop</i> argument, this flag is applied to these controls. Not applied to other controls.
            Don't use this flag when searching in Acc or web page (role prefix "web:" etc) or with flag UIA.
            </summary>
        </member>
        <member name="F:Au.Types.AFFlags.NotInProc">
            <summary>
            Search without loading dll into the target process.
            Disadvantages: 1. Much slower. 2. Some properties are not supported, for example HTML attributes (while searching and later). 3. And more.
            Even without this flag, the default search method is not used with Windows Store app windows, console windows, most Java windows, windows of protected processes and processes of higher UAC integrity level, Firefox web page if its multiprocess feature is not disabled.
            Some windows have child controls that belong to a different process or thread than the window. Example - Internet Explorer. When searching in such windows, the default search method is not used when searching in these controls. Workaround - find the control(s) and search in it/them. For it can be used one of: 1. With Internet Explorer use role prefix "web:". 2. Find the control with <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/> and search in it. 3. Use <see cref="M:Au.Acc.Finder.Find(Au.Wnd,Au.Wnd.ChildFinder)"/>.
            Don't need this flag when searching in Acc (then it is inherited from the Acc variable).
            See also: <see cref="P:Au.Acc.MiscFlags"/>.
            </summary>
        </member>
        <member name="F:Au.Types.AFFlags.UIA">
            <summary>
            Use UI Automation API.
            Need this flag to find objects in windows that don't support accessible objects but support UI Automation elements.
            Examples of such windows: Microsoft Edge web browser (web page), JavaFX applications.
            Objects found with this flag never have HtmlX properties, but can have <see cref="P:Au.Acc.UiaId"/>.
            This flag can be used with most other windows too.
            Don't use this flag when searching in Acc (then it is inherited from the Acc variable) or web page (role prefix "web:" etc).
            See also: <see cref="P:Au.Acc.MiscFlags"/>.
            </summary>
        </member>
        <member name="T:Au.Types.LibEnum">
            <summary>
            A workaround to add internal members to public enums.
            </summary>
        </member>
        <member name="F:Au.Types.LibEnum.AFFlags_Mark">
            <summary>
            Used by tools like "Find accessible object", together with AccMiscFlags_Marked.
            </summary>
        </member>
        <member name="F:Au.Types.LibEnum.AccMiscFlags_Marked">
            <summary>
            Used by tools like "Find accessible object", together with AFFlags_Mark.
            </summary>
        </member>
        <member name="T:Au.Types.AWFlags">
            <summary>
            Flags for <see cref="M:Au.Acc.FromWindow(Au.Wnd,Au.Types.AccOBJID,Au.Types.AWFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.AWFlags.NoThrow">
            <summary>Don't throw exception when fails. Then returns null.</summary>
        </member>
        <member name="F:Au.Types.AWFlags.NotInProc">
            <summary>
            Don't load dll into the target process.
            More info: <see cref="F:Au.Types.AFFlags.NotInProc"/>.
            </summary>
        </member>
        <member name="T:Au.Types.AXYFlags">
            <summary>
            Flags for <see cref="M:Au.Acc.FromXY(System.Drawing.Point,Au.Types.AXYFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.AXYFlags.UIA">
            <summary>
            Use UI Automation API.
            Need this flag with some windows that don't support accessible objects but support UI Automation elements.
            When this flag is not specified, the function detects most such windows and uses UI Automation API, but the detection is not perfect.
            More info: <see cref="F:Au.Types.AFFlags.UIA"/>.
            This flag can be used with most other windows too.
            </summary>
        </member>
        <member name="F:Au.Types.AXYFlags.PreferLink">
            <summary>
            Get the direct parent object if it's LINK or BUTTON.
            Usually links have one or more children of type TEXT, STATICTEXT, IMAGE or other.
            </summary>
        </member>
        <member name="F:Au.Types.AXYFlags.NotInProc">
            <summary>
            Don't load dll into the target process.
            More info: <see cref="F:Au.Types.AFFlags.NotInProc"/>.
            </summary>
        </member>
        <member name="F:Au.Types.AXYFlags.NoThrow">
            <summary>Don't throw exception when fails. Then returns null.</summary>
        </member>
        <member name="T:Au.Types.AccMiscFlags">
            <summary>
            Flags returned by <see cref="P:Au.Acc.MiscFlags"/>.
            </summary>
        </member>
        <member name="F:Au.Types.AccMiscFlags.InProc">
            <summary>
            This accessible object was retrieved by the dll loaded into its process.
            More info: <see cref="F:Au.Types.AFFlags.NotInProc"/>.
            </summary>
        </member>
        <member name="F:Au.Types.AccMiscFlags.UIA">
            <summary>
            This accessible object was retrieved using UI Automation API.
            More info: <see cref="F:Au.Types.AFFlags.UIA"/>.
            </summary>
        </member>
        <member name="F:Au.Types.AccMiscFlags.Java">
            <summary>
            This accessible object was retrieved using Java Access Bridge API.
            More info: <see cref="T:Au.Acc"/>.
            </summary>
        </member>
        <member name="T:Au.Types.AccOBJID">
            <summary>
            Accessible object ids of window parts and some special objects.
            Used with <see cref="M:Au.Acc.FromWindow(Au.Wnd,Au.Types.AccOBJID,Au.Types.AWFlags)"/>
            </summary>
            <remarks>
            The names are as in API <msdn>AccessibleObjectFromWindow</msdn> documentation but without prefix "OBJID_". Except Java and UIA.
            </remarks>
        </member>
        <member name="F:Au.Types.AccOBJID.Java">
            <summary>
            The root Java object. Can be used when the window's class name starts with "SunAwt".
            </summary>
        </member>
        <member name="F:Au.Types.AccOBJID.UIA">
            <summary>
            Use UI Automation API.
            More info: <see cref="F:Au.Types.AFFlags.UIA"/>.
            </summary>
        </member>
        <member name="T:Au.Types.AccROLE">
            <summary>
            Standard roles of accessible objects.
            Used with <see cref="P:Au.Acc.RoleInt"/>
            </summary>
            <remarks>
            Most names are as in API <msdn>IAccessible.get_accRole</msdn> documentation but without prefix "ROLE_SYSTEM_". These are renamed: PUSHBUTTON to BUTTON, CHECKBUTTON to CHECKBOX, GRAPHIC to IMAGE, OUTLINE to TREE, OUTLINEITEM to TREEITEM, OUTLINEBUTTON to TREEBUTTON,
            </remarks>
        </member>
        <member name="T:Au.Types.AccSTATE">
            <summary>
            Accessible object state flags.
            Used by <see cref="P:Au.Acc.State"/>.
            </summary>
            <remarks>
            Most names are as in API <msdn>IAccessible.get_accState</msdn> documentation but without prefix "STATE_SYSTEM_".
            </remarks>
        </member>
        <member name="T:Au.Types.AccSELFLAG">
            <summary>
            Accessible object selection flags.
            Used by <see cref="M:Au.Acc.Select(Au.Types.AccSELFLAG)"/>.
            </summary>
            <remarks>
            The names are as in API <msdn>IAccessible.accSelect</msdn> documentation but without prefix "SELFLAG_".
            </remarks>
        </member>
        <member name="T:Au.Types.AccEVENT">
            <summary>
            Event constants for API <msdn>SetWinEventHook</msdn>.
            </summary>
            <remarks>
            The names are as in API documentation but without prefix "EVENT_".
            </remarks>
        </member>
        <member name="T:Au.Types.LibAccHookFlags">
            <summary>
            Flags for API <msdn>SetWinEventHook</msdn>.
            </summary>
            <remarks>
            The names are as in API documentation but without prefix "WINEVENT_".
            There are no flags for OUTOFCONTEXT and INCONTEXT. OUTOFCONTEXT is default (0). INCONTEXT cannot be used in managed code.
            </remarks>
        </member>
        <member name="T:Au.Types.AccProperties">
            <summary>
            Used with <see cref="M:Au.Acc.GetProperties(System.String,Au.Types.AccProperties@)"/>.
            </summary>
        </member>
        <member name="T:Au.Types.BIUnblock">
            <summary>Infrastructure.</summary>
            <tocexclude />
        </member>
        <member name="M:Au.Types.BIUnblock.Start(Au.Types.BIUnblock.What)">
            <summary>
            Starts blocking input.
            </summary>
        </member>
        <member name="M:Au.Types.BIUnblock.Stop">
            <summary>
            Stops blocking input.
            </summary>
        </member>
        <member name="M:Au.Types.BIUnblock.Dispose">
            <summary>
            Calls Stop.
            </summary>
        </member>
        <member name="M:Au.Types.Api.PROPVARIANT.Dispose">
            <summary>
            Calls PropVariantClear.
            </summary>
        </member>
        <member name="M:Au.Types.Api.SizeOf``1(``0)">
            <summary>
            Gets the native size of a struct variable.
            Returns (uint)Marshal.SizeOf(typeof(T)).
            Speed: the same (in Release config) as Marshal.SizeOf(typeof(T)), and 2 times faster than Marshal.SizeOf(v).
            </summary>
        </member>
        <member name="M:Au.Types.Api.SizeOf``1">
            <summary>
            Gets the native size of a type.
            Returns (uint)Marshal.SizeOf(typeof(T)).
            </summary>
        </member>
        <member name="M:Au.Types.Api.GetProcAddress(System.String,System.String)">
            <summary>
            Gets dll module handle (Api.GetModuleHandle) or loads dll (Api.LoadLibrary), and returns unmanaged exported function address (Api.GetProcAddress).
            See also: GetDelegate.
            </summary>
        </member>
        <member name="M:Au.Types.Api.GetDelegate``1(``0@,System.String,System.String)">
            <summary>
            Calls <see cref="M:Au.Types.Api.GetProcAddress(System.String,System.String)"/> (loads dll or gets handle) and <see cref="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.Api.GetDelegate``1(``0@,System.IntPtr,System.String)">
            <summary>
            Calls API <see cref="M:Au.Types.Api.GetProcAddress(System.IntPtr,System.String)"/> and <see cref="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.Api.GetDelegate``1(System.IntPtr,``0@)">
            <summary>
            Calls <see cref="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)"/>.
            </summary>
            <typeparam name="T">Delegate type.</typeparam>
            <param name="f">Unmanaged function address.</param>
            <param name="deleg">Receives managed delegate of type T.</param>
        </member>
        <member name="M:Au.Types.Api.ReleaseComObject``1(``0)">
            <summary>
            If o is not null, calls <see cref="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.Api.WINDOWPLACEMENT.flags">
            <summary> WPF_ </summary>
        </member>
        <member name="M:Au.Types.Api.SECURITY_ATTRIBUTES.#ctor">
            <summary>
            Creates SECURITY_ATTRIBUTES that allows UAC low integrity level processes to open the kernel object.
            </summary>
        </member>
        <member name="T:Au.Types.Native">
            <summary>
            Windows API types and constants used with public functions (parameters etc) of this library.
            Also several helper functions.
            </summary>
        </member>
        <member name="M:Au.Types.Native.ClearError">
            <summary>
            Calls API <msdn>SetLastError</msdn>(0), which clears the Windows API error code of this thread.
            Need it before calling some functions if you want to use <see cref="M:Au.Types.Native.GetError"/> or <see cref="M:Au.Types.Native.GetErrorMessage">GetErrorMessage</see>.
            </summary>
        </member>
        <member name="M:Au.Types.Native.SetError(System.Int32)">
            <summary>
            Calls API <msdn>SetLastError</msdn>, which sets the Windows API error code of this thread.
            </summary>
        </member>
        <member name="M:Au.Types.Native.GetError">
             <summary>
             Gets the Windows API error code of this thread.
             Calls <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
             </summary>
             <remarks>
             Many Windows API functions, when failed, set an error code. Code 0 means no error. It is stored in an internal thread-specific int variable. But only if the API declaration's DllImport attribute has SetLastError = true.
             Some functions of this library simply call these API functions and don't throw exception when API fail. For example, most Wnd propery-get functions.
             When failed, they return false/0/null/empty. Then you can call <b>Native.GetError</b> to get the error code. Also you can use <see cref="M:Au.Types.Native.GetErrorMessage">GetErrorMessage</see>.
             
             Most of these functions set the code only when failed, and don't clear old error code when succeeded. Therefore may need to call <see cref="M:Au.Types.Native.ClearError"/> before.
            
             Windows API error code definitions and documentation are not included in this library. You can look for them in API function documentation on the internet.
             </remarks>
             <example>
             <code><![CDATA[
             Wnd w = Wnd.Find("Notepag");
             //if(w.Is0) return; //assume you don't use this
             Native.ClearError();
             bool enabled = w.IsEnabled; //returns true if enabled, false if disabled or failed
             int e = Native.GetError();
             if(e != 0) { Print(e, Native.GetErrorMessage(e)); return; } //1400, Invalid window handle
             Print(enabled);
             ]]></code>
             </example>
        </member>
        <member name="M:Au.Types.Native.GetErrorMessage">
            <summary>
            Gets the text message of the Windows API error code of this thread.
            Returns null if the code is 0.
            The string always ends with ".".
            </summary>
        </member>
        <member name="M:Au.Types.Native.GetErrorMessage(System.Int32)">
            <summary>
            Gets the text message of a Windows API error code.
            Returns null if errorCode is 0.
            The string always ends with ".".
            </summary>
        </member>
        <member name="T:Au.Types.Native.MSG">
            <summary><msdn>MSG</msdn></summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.Native.SHSTOCKICONID">
            <summary><msdn>SHSTOCKICONID</msdn></summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.Native.GUITHREADINFO">
            <summary><msdn>GUITHREADINFO</msdn></summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.Native.SIGDN">
            <summary><msdn>SIGDN</msdn></summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.Native.WNDPROC">
            <summary><msdn>WNDPROC</msdn></summary>
            <tocexclude />
        </member>
        <member name="F:Au.Types.Native.SWP_NOSIZE">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.SWP_NOMOVE">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.SWP_NOZORDER">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.SWP_NOREDRAW">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.SWP_NOACTIVATE">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.SWP_FRAMECHANGED">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.SWP_SHOWWINDOW">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.SWP_HIDEWINDOW">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.SWP_NOCOPYBITS">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.SWP_NOOWNERZORDER">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.SWP_NOSENDCHANGING">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.SWP_DEFERERASE">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.SWP_ASYNCWINDOWPOS">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GWL_WNDPROC">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GWL_USERDATA">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GWL_STYLE">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GWL_ID">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GWL_HWNDPARENT">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GWL_HINSTANCE">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GWL_EXSTYLE">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.DWL_MSGRESULT">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.DWL_DLGPROC_32">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.DWL_DLGPROC_64">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.DWL_USER_32">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.DWL_USER_64">
            <exclude />
        </member>
        <member name="P:Au.Types.Native.DWLP_DLGPROC">
            <exclude />
        </member>
        <member name="P:Au.Types.Native.DWLP_USER">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GCW_ATOM">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GCL_WNDPROC">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GCL_STYLE">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GCL_MENUNAME">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GCL_HMODULE">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GCL_HICONSM">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GCL_HICON">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GCL_HCURSOR">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GCL_HBRBACKGROUND">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GCL_CBWNDEXTRA">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.GCL_CBCLSEXTRA">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_POPUP">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_CHILD">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_MINIMIZE">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_VISIBLE">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_DISABLED">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_CLIPSIBLINGS">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_CLIPCHILDREN">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_MAXIMIZE">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_BORDER">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_DLGFRAME">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_VSCROLL">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_HSCROLL">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_SYSMENU">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_THICKFRAME">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_GROUP">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_TABSTOP">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_MINIMIZEBOX">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_MAXIMIZEBOX">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_CAPTION">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_OVERLAPPEDWINDOW">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_POPUPWINDOW">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_EX_DLGMODALFRAME">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_EX_NOPARENTNOTIFY">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_EX_TOPMOST">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_EX_ACCEPTFILES">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_EX_TRANSPARENT">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_EX_MDICHILD">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_EX_TOOLWINDOW">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_EX_WINDOWEDGE">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_EX_CLIENTEDGE">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_EX_CONTEXTHELP">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_EX_RIGHT">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_EX_LEFT">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_EX_RTLREADING">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_EX_LTRREADING">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_EX_LEFTSCROLLBAR">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_EX_RIGHTSCROLLBAR">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_EX_CONTROLPARENT">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_EX_STATICEDGE">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_EX_APPWINDOW">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_EX_LAYERED">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_EX_NOINHERITLAYOUT">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_EX_LAYOUTRTL">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_EX_COMPOSITED">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_EX_NOACTIVATE">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.WS_EX_NOREDIRECTIONBITMAP">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.SMTO_BLOCK">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.SMTO_ABORTIFHUNG">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.SMTO_NOTIMEOUTIFNOTHUNG">
            <exclude />
        </member>
        <member name="F:Au.Types.Native.SMTO_ERRORONEXIT">
            <exclude />
        </member>
        <member name="T:Au.Types.Keys_">
            <summary>
            Keys and modifiers that are missing in enum <see cref="T:System.Windows.Forms.Keys"/>.
            </summary>
        </member>
        <member name="F:Au.Types.Keys_.Windows">
            <summary>
            Modifier key Windows (flag). Can be used like Keys.Shift etc.
            Can be used only with functions of this library or other libraries that support it. Don't use with .NET functions.
            </summary>
        </member>
        <member name="F:Au.Types.Keys_.NumEnter">
            <summary>
            Numpad Enter key.
            Can be used only with functions of this library or other libraries that support it. Don't use with .NET functions.
            </summary>
        </member>
        <member name="T:Au.Types.WIArea">
            <summary>
            Defines the search area for <see cref="M:Au.WinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,System.Boolean})"/> and similar functions.
            It can be a window/control, accessible object, another image or a rectangle in screen.
            Also allows to specify a rectangle in it, which makes the search area smaller and the function faster.
            Example: <c>WinImage.Find(new WIArea(w, 100, 100, 100, 100), "image.png");</c>.
            </summary>
        </member>
        <member name="T:Au.Types.WIFlags">
            <summary>
            Flags for <see cref="M:Au.WinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,System.Boolean})"/> and similar functions.
            </summary>
        </member>
        <member name="F:Au.Types.WIFlags.WindowDC">
            <summary>
            Get pixels from the device context (DC) of the window client area, not from screen DC.
            Not used when area is Bitmap.
            Notes:
            Usually much faster.
            Can get pixels from window parts that are covered by other windows or offscreen. But not from hidden and minimized windows.
            Does not work on Windows 7 if Aero theme is turned off. Then this flag is ignored.
            If the window is DPI-scaled, the image must be captured from its non-scaled version.
            Cannot find images in some windows (including Windows Store apps), and in some window parts (glass). All pixels captured from these windows/parts are black.
            </summary>
        </member>
        <member name="F:Au.Types.WIFlags.AllMustExist">
            <summary>
            When the image argument specifies multiple images, all they must exist, else result is "not found".
            The result rectangle is of the last image. To get all rectangles, use the <i>also</i> parameter: <c>also: t => { rectList.Add(t.Rect); return true; }</c>.
            </summary>
        </member>
        <member name="T:Au.Types.RXMatch">
            <summary>
            Regular expression match info.
            Used with <see cref="T:Au.Regex_"/> class functions and String extension methods like <see cref="M:Au.String_.RegexMatch_(System.String,System.String,Au.Types.RXMatch@,Au.Types.RXFlags)"/>.
            </summary>
            <remarks>
            Contains info about a regular expression match found in the subject string: index, length, substring, etc.
            Also contains an array of group matches, as <see cref="T:Au.Types.RXGroup"/>. Groups are regular expression parts enclosed in (), except (?...).
            Group matches can be accessed like array elements. Group 0 is whole match. Group 1 is the first group. See examples.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "ab cd-45-ef gh";
            if(s.RegexMatch_(@"\b([a-z]+)-(\d+)\b", out RXMatch m))
            	Print(
            		m.GroupCountPlusOne, //3 (whole match and 2 groups)
            		m.Index, //3, same as m[0].Index
            		m.Value, //"cd-45-ef", same as m[0].Value
            		m[1].Index, //3
            		m[1].Value, //"cd"
            		m[2].Index, //6
            		m[2].Value //"45"
            		);
            ]]></code>
            A group in the subject string may not exist even if whole match found. Then its Exists property is false, Index -1, Length 0, Value null.
            <code><![CDATA[
            var s = "ab cd--ef gh";
            if(s.RegexMatch_(@"\b([a-z]+)-(\d+)?-([a-z]+)\b", out RXMatch m))
            	Print(
            		m.GroupCountPlusOne, //4 (whole match and 3 groups)
            		m[2].Exists, //false
            		m[2].Index, //-1
            		m[2].Length, //0
            		m[2].Value //null
            		);
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Types.RXMatch.GroupCountPlusOne">
            <summary>
            The number of groups in the regular expression, + 1 for the whole match.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Index">
            <summary>
            Start offset of the match in the subject string. The same as that of group 0.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.EndIndex">
            <summary>
            <see cref="P:Au.Types.RXMatch.Index"/> + <see cref="P:Au.Types.RXMatch.Length"/>. The same as that of group 0.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Length">
            <summary>
            Length of the match in the subject string. The same as that of group 0.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Value">
            <summary>
            The match (substring) in the subject string. The same as that of group 0.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Subject">
            <summary>
            The subject string in which this match was found.
            </summary>
        </member>
        <member name="M:Au.Types.RXMatch.ToString">
            <summary>
            Returns <see cref="P:Au.Types.RXMatch.Value"/>.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.IndexNoK">
            <summary>
            Start offset of whole match regardless of \K.
            When the regular expression contains \K, this is different (less) than <see cref="P:Au.Types.RXMatch.Index"/>.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Mark">
            <summary>
            The name of a found mark, or null.
            Marks can be inserted in regular expression pattern like (*MARK:name) or (*:name).
            After a full successful match, it is the last mark encountered on the matching path through the pattern. After a "no match" or a partial match, it is the last encountered mark. For example, consider this pattern: "^(*MARK:A)((*MARK:B)a|b)c". When it matches "bc", the mark is A. The B mark is "seen" in the first branch of the group, but it is not on the matching path. On the other hand, when this pattern fails to match "bx", the mark is B.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Exists">
            <summary>
            Gets the return value of the <see cref="M:Au.Regex_.Match(System.String,Au.Types.RXMatch@,Au.Types.RXMore)"/> call.
            Can be false only when the function returned false but a mark is available (see <see cref="P:Au.Types.RXMatch.Mark"/>). Otherwise, when the function returns flase, it returns null instead of a RXMatch object.
            When false, all properties except Exists and Mark have undefined values or throw exception.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.IsPartial">
            <summary>
            Returns true if this match is partial.
            Partial match is possible if used a PARTIAL_ flag.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Item(System.Int32)">
            <summary>
            Gets group info. Index 0 is whole match. Index 1 is the first group.
            </summary>
            <param name="i">1-based group index, or 0 for whole match.</param>
            <exception cref="T:System.IndexOutOfRangeException">The index is &lt; 0 or &gt;= GroupCountPlusOne.</exception>
        </member>
        <member name="M:Au.Types.RXMatch.GroupNumberFromName(System.String,System.Boolean@)">
            <summary>
            Finds a named group and returns its 1-based index.
            Returns -1 if not found.
            </summary>
            <param name="name">Group name.</param>
            <param name="notUnique">Receives true if more than 1 group have this name.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <remarks>
            If more than 1 group have this name, prefers the first group that matched (<see cref="P:Au.Types.RXGroup.Exists"/> is true).
            </remarks>
            <seealso cref="M:Au.Regex_.GroupNumberFromName(System.String)"/>
        </member>
        <member name="M:Au.Types.RXMatch.ExpandReplacement(System.String)">
            <summary>
            Returns the expanded version of the specified replacement pattern.
            </summary>
            <param name="repl">
            Replacement pattern.
            Can consist of any combination of literal text and substitutions like $1.
            Supports .NET regular expression substitution syntax. See <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)"/>. Also replaces $* with the name of the last encountered mark.
            </param>
            <remarks>
            Works like <see cref="M:System.Text.RegularExpressions.Match.Result(System.String)"/>.
            See also: <see cref="M:Au.Regex_.Replace(System.String,System.String,System.Int32,Au.Types.RXMore)"/>.
            </remarks>
        </member>
        <member name="T:Au.Types.RXGroup">
            <summary>
            Regular expression group match info.
            Used with <see cref="T:Au.Types.RXMatch"/>, <see cref="T:Au.Regex_"/> and some String extension methods.
            </summary>
            <remarks>
            Groups are regular expression parts enclosed in (). Except non-capturing parts, like (?:...) and (?options). A RXGroup variable contains info about a group found in the subject string: index, length, substring.
            
            Some groups specified in regular expression may not exist in the subject string even if it matches the regular expression. For example, regular expression "A(\d+)?B" matches string "AB", but group (\d+) does not exist. Then <see cref="P:Au.Types.RXGroup.Exists"/> is false, <see cref="P:Au.Types.RXGroup.Index"/> -1, <see cref="P:Au.Types.RXGroup.Length"/> 0, <see cref="P:Au.Types.RXGroup.Value"/> null.
            
            When a group matches multiple times, the RXGroup variable contains only the last instance. For example, if subject is <c>"begin 12 345 67 end"</c> and regular expression is <c>(\d+ )+</c>, value of group 1 is <c>"67"</c>. If you need all instances (<c>"12"</c>, <c>"345"</c>, <c>"67"</c>), instead use .NET <see cref="T:System.Text.RegularExpressions.Regex"/> and <see cref="P:System.Text.RegularExpressions.Group.Captures"/>. Also you can get all instances with <see cref="P:Au.Regex_.Callout"/>.
            
            Examples and more info: <see cref="T:Au.Types.RXMatch"/>, <see cref="T:Au.Regex_"/>.
            </remarks>
        </member>
        <member name="P:Au.Types.RXGroup.Index">
            <summary>
            Start offset of the group match in the subject string.
            </summary>
        </member>
        <member name="P:Au.Types.RXGroup.EndIndex">
            <summary>
            <see cref="P:Au.Types.RXGroup.Index"/> + <see cref="P:Au.Types.RXGroup.Length"/>.
            </summary>
        </member>
        <member name="P:Au.Types.RXGroup.Length">
            <summary>
            Length of the group match in the subject string.
            </summary>
        </member>
        <member name="P:Au.Types.RXGroup.Value">
            <summary>
            String value of the group match in the subject string.
            </summary>
        </member>
        <member name="P:Au.Types.RXGroup.Exists">
            <summary>
            Returns true if the group exists in the subject string, false if does not exist.
            More info in <see cref="T:Au.Types.RXGroup"/> help. Example in <see cref="T:Au.Types.RXMatch"/> help.
            </summary>
            <remarks>
            Other ways to detect it: if a group does not exist, its Index is -1 and Value is null.
            </remarks>
        </member>
        <member name="M:Au.Types.RXGroup.ToString">
            <summary>
            Returns <see cref="P:Au.Types.RXGroup.Value"/>.
            </summary>
        </member>
        <member name="T:Au.Types.RXMore">
            <summary>
            Rarely used parameters for <see cref="T:Au.Regex_"/> class functions.
            </summary>
            <remarks>
            The constructor allows you to set initial values of fields. You can modify them later if need. Regex_ functions don't modify them.
            
            The start/end fields can be used to specify part of subject string. When a function has parameter <i>group</i>, the start/end fields don't depend on it; they are used to specify where to search for whole match.
            </remarks>
        </member>
        <member name="F:Au.Types.RXMore.start">
            <summary>
            The start index (offset) in the subject string.
            Default 0. Valid values are from 0 to (including) subject length.
            The subject part before it is not ignored if regular expression starts with a lookbehind assertion or anchor, eg <c>^</c> or <c>\b</c> or <c>(?&lt;=...)</c>. Instead of <c>^</c> you can use <c>\G</c>. More info in PCRE documentation topic <see href="https://www.pcre.org/current/doc/html/pcre2api.html">pcre2api</see>, chapter "The string to be matched by pcre2_match()".
            </summary>
        </member>
        <member name="F:Au.Types.RXMore.end">
            <summary>
            The end index (offset) in the subject string. As if the string ends here.
            If negative (default -1), is used subject string length. Else valid values are from <see cref="F:Au.Types.RXMore.start"/> to (including) subject length.
            </summary>
        </member>
        <member name="F:Au.Types.RXMore.matchFlags">
            <summary>
            Options.
            The same options also can be set when calling Regex_ constructor. Constructor's flags and matchFlags are added, which means that matchFlags cannot unset flags set when calling constructor.
            </summary>
        </member>
        <member name="M:Au.Types.RXMore.#ctor(System.Int32,System.Int32,Au.Types.RXMatchFlags)">
            <summary>
            Sets field values.
            If <paramref name="end"/> is -1 (default), will be used subject string length.
            </summary>
        </member>
        <member name="T:Au.Types.RXCalloutFunc">
            <summary>
            Delegate type of callout callback function.
            See <see cref="P:Au.Regex_.Callout"/>.
            </summary>
        </member>
        <member name="T:Au.Types.RXCalloutData">
            <summary>
            Managed version of PCRE API struct pcre2_callout_block.
            When you set <see cref="P:Au.Regex_.Callout"/>, your callout function's parameter is of this type.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            Most properties are pcre2_callout_block fields as documented in PCRE help. Other properties and methods are easier/safer versions of unsafe fields like offset_vector.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.Result">
            <summary>
            Sets the return value of the callout function, as documented in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            Default 0.
            If 1, matching fails at the current point, but the testing of other matching possibilities goes ahead, just as if a lookahead assertion had failed.
            If -1 (PCRE2_ERROR_NOMATCH), the match function returns false (no match). Values less tan -2 are PCRE error codes and cause exception.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.callout_number">
            <summary>
            Callout number, eg 5 for "(?C5)".
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.capture_top">
            <summary>
            One more than the number of the highest numbered captured group so far.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.capture_last">
            <summary>
            The number of the most recently captured group.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.start_match">
            <summary>
            The offset within the subject string at which the current match attempt started. But depends on \K etc.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.current_position">
            <summary>
            The current offset within the subject string.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.pattern_position">
            <summary>
            The offset in the regular expression to the next item to be matched.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.next_item_length">
            <summary>
            The length of the next item to be processed in the regular expression.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.callout_string_offset">
            <summary>
            The callout string offset in the regular expression. Used with callouts like "(?C'calloutString')".
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.callout_string">
            <summary>
            The callout string, eg "xyz" for "(?C'xyz')".
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.mark">
            <summary>
            The most recently passed (*MARK), (*PRUNE), or (*THEN) item in the match, or null if no such items have been passed.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="M:Au.Types.RXCalloutData.Group(System.Int32)">
            <summary>
            Gets the start index and length of the specified group in the subject string.
            </summary>
            <param name="group">Group number (1-based index).</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="group"/> must be &gt; 0 and &lt; capture_top.</exception>
        </member>
        <member name="M:Au.Types.RXCalloutData.GroupValue(System.Int32)">
            <summary>
            Gets the value (substring) of the specified group.
            </summary>
            <param name="group">Group number (1-based index).</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="group"/> must be &gt; 0 and &lt; capture_top.</exception>
        </member>
        <member name="P:Au.Types.RXCalloutData.LastGroup">
            <summary>
            Gets the start index and length of the most recently captured group in the subject string.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.LastGroupValue">
            <summary>
            Gets the value (substring) of the most recently captured group.
            </summary>
        </member>
        <member name="T:Au.Types.RXFlags">
            <summary>
            Flags for <see cref="T:Au.Regex_"/> constructor.
            Documented in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2api.html">pcre2api</see>.
            </summary>
            <remarks>
            Many options also can be specified in regular expression (RE):
            <list type="bullet">
            <item>These can be anywhere in RE: (?i) CASELESS, (?m) MULTILINE, (?s) DOTALL, (?n) NO_AUTO_CAPTURE, (?x) EXTENDED, (?xx) EXTENDED_MORE, (?J) DUPNAMES, (?U) UNGREEDY. Can be multiple, like (?ms). Can be unset, like (?-i). RE "\Qtext\E" is like RE "text" with flag LITERAL.</item>
            <item>Instead of ANCHORED can be used \A or \G at the start of RE. Or ^, except in multiline mode.</item>
            <item>Instead of ENDANCHORED can be used \z at the end of RE. Or $, except in multiline mode.</item>
            <item>Flag UTF is implicitly added if RE contains non-ASCII characters and there is no flag NEVER_UTF.</item>
            <item>These must be at the very start and are named like flags: (*UTF), (*UCP), (*NOTEMPTY), (*NOTEMPTY_ATSTART), (*NO_AUTO_POSSESS), (*NO_DOTSTAR_ANCHOR), (*NO_START_OPT).</item>
            <item>More info in <see href="https://www.pcre.org/current/doc/html/pcre2pattern.html">PCRE syntax reference</see>.</item>
            </list>
            Some of RXFlags flags also exist in <see cref="T:Au.Types.RXMatchFlags"/>. You can set them either when calling Regex_ constructor or when calling Regex_ functions that have parameter <i>more</i>. You can use different flags for each function call with the same Regex_ variable.
            </remarks>
        </member>
        <member name="F:Au.Types.RXFlags.UTF">
            <summary>
            Fully support Unicode text (case-insensitivity etc). More info in PCRE documentation topic <see href="https://www.pcre.org/current/doc/html/pcre2unicode.html">pcre2unicode</see>.
            This flag is implicitly added if regular expression contains non-ASCII characters and there is no flag NEVER_UTF.
            </summary>
        </member>
        <member name="T:Au.Types.RXMatchFlags">
            <summary>
            Flags for <see cref="M:Au.Regex_.Match(System.String,Au.Types.RXMatch@,Au.Types.RXMore)"/> and other <see cref="T:Au.Regex_"/> class functions.
            Documented in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2api.html">pcre2api</see>.
            </summary>
            <remarks>
            These flags also exist in <see cref="T:Au.Types.RXFlags"/> (Regex_ constructor flags). You can set them either when calling constructor or when calling other functions.
            </remarks>
        </member>
        <member name="T:Au.Types.Separators">
            <summary>
            Contains several string constants that can be used with some 'split string' functions of this library to specify separators.
            </summary>
        </member>
        <member name="F:Au.Types.Separators.Whitespace">
            <summary>
            Specifies that separators are all characters for which <see cref="M:System.Char.IsWhiteSpace(System.Char)"/> returns true.
            </summary>
        </member>
        <member name="F:Au.Types.Separators.Word">
            <summary>
            Specifies that separators are all characters for which <see cref="M:System.Char.IsLetterOrDigit(System.Char)"/> returns false.
            </summary>
        </member>
        <member name="F:Au.Types.Separators.Line">
            <summary>
            Specifies that separators are substrings "\r\n", as well as single ASCII line break characters '\r' and '\n'.
            </summary>
        </member>
        <member name="T:Au.Types.SegFlags">
            <summary>
            Flags for <see cref="M:Au.String_.Segments_(System.String,System.String,Au.Types.SegFlags)"/> and some other functions.
            </summary>
        </member>
        <member name="F:Au.Types.SegFlags.NoEmpty">
            <summary>
            Don't return empty substrings.
            For example, is string is "one  two " and separators is " ", return {"one", "two"} instead of {"one", "", "two", ""}.
            </summary>
        </member>
        <member name="T:Au.Types.SegParser">
            <summary>
            Splits a string or StringSegment into StringSegments.
            Used with foreach. Also used internally by some functions of this library, for example <see cref="M:Au.String_.Split_(System.String,System.String,Au.Types.SegFlags)"/> and <see cref="M:Au.String_.SplitLines_(System.String,System.Boolean)"/>.
            Normally you don't create Segmenter instances explicitly; instead use <see cref="M:Au.String_.Segments_(System.String,System.String,Au.Types.SegFlags)"/> or <see cref="M:Au.StringSegment.Split(System.String,Au.Types.SegFlags)"/> with foreach.
            </summary>
        </member>
        <member name="M:Au.Types.SegParser.#ctor(System.String,System.String,Au.Types.SegFlags)">
            <summary>
            Initializes this instance to split a string.
            </summary>
            <param name="s">The string.</param>
            <param name="separators">A string containing characters that delimit substrings. Or one of <see cref="T:Au.Types.Separators"/> constants.</param>
            <param name="flags"></param>
        </member>
        <member name="M:Au.Types.SegParser.#ctor(Au.StringSegment@,System.String,Au.Types.SegFlags)">
            <summary>
            Initializes this instance to split a StringSegment.
            </summary>
            <param name="seg">The StringSegment.</param>
            <param name="separators">A string containing characters that delimit substrings. Or one of <see cref="T:Au.Types.Separators"/> constants.</param>
            <param name="flags"></param>
        </member>
        <member name="M:Au.Types.SegParser.GetEnumerator">
            <tocexclude />
        </member>
        <member name="M:Au.Types.SegParser.System#Collections#Generic#IEnumerable{Au#StringSegment}#GetEnumerator">
            <tocexclude />
        </member>
        <member name="M:Au.Types.SegParser.System#Collections#IEnumerable#GetEnumerator">
            <tocexclude />
        </member>
        <member name="P:Au.Types.SegParser.Current">
            <tocexclude />
        </member>
        <member name="P:Au.Types.SegParser.System#Collections#IEnumerator#Current">
            <tocexclude />
        </member>
        <member name="M:Au.Types.SegParser.MoveNext">
            <tocexclude />
        </member>
        <member name="M:Au.Types.SegParser.Dispose">
            <tocexclude />
        </member>
        <member name="M:Au.Types.SegParser.Reset">
            <tocexclude />
        </member>
        <member name="M:Au.Types.SegParser.ToStringArray(System.Int32)">
            <summary>
            Returns segment values as string[].
            </summary>
            <param name="maxCount">The maximum number of substrings to get. If negative (default), gets all.</param>
        </member>
        <member name="T:Au.Types.NamespaceDoc">
            <summary>
            Types of function parameters and return values, base classes, exceptions.
            Class NetExtensions contains extension methods for various .NET classes.
            </summary>
        </member>
        <member name="T:Au.Types.JustNull">
            <summary>Infrastructure.</summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.JustNull2">
            <summary>Infrastructure.</summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.Types`2">
            <summary>
            Used for method parameters that accept one of two types.
            </summary>
            <remarks>
            Some methods have one or several parameters that must be one of several types. There are several ways of implementing such functions.
            1. Overloaded methods. However some programmers often don't like it, because in some cases need to create many overloads, then maintain their documentation. Also then method users have to spend much time to find the correct overload.
            2. Generic methods. However in most cases the compiler cannot protect from using an unsupported type. Also then method users don't see the allowed types instantly in intellisense.
            3. Using the Object type for the parameter. However then the compiler does not protect from using an unsupported type. Also then method users don't see the allowed types instantly in intellisense. Also slower, especially with value types (need boxing).
            4. Using this type for the parameter. It does not have the above problems.
            
            When a parameter is of type Types&lt;T1, T2&gt;, method users can pass only values of type T1 or T2, else compiler error. They see the allowed types instantly in intellisense.
            Also there are similar types that can be used to support more parameter types:
            <see cref="T:Au.Types.Types`3"/>
            <see cref="T:Au.Types.Types`4"/>
            
            To support null (for example for optional parameters), use nullable. See examples.
            </remarks>
            <example>
            <code><![CDATA[
            static void Example1(Types<string, IEnumerable<string>> x)
            {
            	switch(x.type) {
            	case 1: Print("string", x.v1); break;
            	case 2: Print("IEnumerable<string>", x.v2); break;
            	default: throw new ArgumentException(); //0 if has default value, eg assigned default(Types<string, IEnumerable<string>>), unlikely
            	}
            }
            
            static void Example2(int param1, Types<int, double>? optionalParam = null)
            {
            	var p = optionalParam.GetValueOrDefault();
            	switch(p.type) {
            	case 0: Print("null"); break;
            	case 1: Print("int", p.v1); break;
            	case 2: Print("double", p.v2); break;
            	}
            }
            
            static void TestExamples()
            {
            	Example1("S");
            	Example1(new string[] { "a", "b" });
            	//Example1(5); //compiler error
            	//Example1(null); //compiler error
            	Example1((string)null);
            	//Example1(default(Types<string, IEnumerable<string>>)); //the function throws exception
            
            	Example2(0, 5);
            	Example2(0, 5.5);
            	//Example2(0, "S"); //compiler error
            	Example2(0, null);
            	Example2(0);
            	//Example2(0, default(Types<int, double>)); //the function throws exception
            }
            ]]></code>
            </example>
        </member>
        <member name="F:Au.Types.Types`2.type">
            <summary> Value type. 1 if T1 (v1 is valid), 2 if T2 (v2 is valid), 0 if unassigned. </summary>
        </member>
        <member name="F:Au.Types.Types`2.v1">
            <summary> Value of type T1. Valid when type is 1. </summary>
        </member>
        <member name="F:Au.Types.Types`2.v2">
            <summary> Value of type T2. Valid when type is 2. </summary>
        </member>
        <member name="M:Au.Types.Types`2.op_Implicit(`0)~Au.Types.Types{`0,`1}">
            <summary> Assignment of a value of type T1. </summary>
        </member>
        <member name="M:Au.Types.Types`2.op_Implicit(`1)~Au.Types.Types{`0,`1}">
            <summary> Assignment of a value of type T2. </summary>
        </member>
        <member name="M:Au.Types.Types`2.op_Implicit(Au.Types.JustNull)~Au.Types.Types{`0,`1}">
            <summary>Infrastructure.</summary>
        </member>
        <member name="M:Au.Types.Types`2.op_Implicit(Au.Types.JustNull2)~Au.Types.Types{`0,`1}">
            <summary>Infrastructure.</summary>
        </member>
        <member name="T:Au.Types.Types`3">
            <summary>
            Used for method parameters that accept one of three types.
            More info: <see cref="T:Au.Types.Types`2"/>.
            </summary>
        </member>
        <member name="F:Au.Types.Types`3.type">
            <summary> Value type. 1 if T1 (v1 is valid), 2 if T2 (v2 is valid), 3 if T3 (v3 is valid), 0 if unassigned (unlikely). </summary>
        </member>
        <member name="F:Au.Types.Types`3.v1">
            <summary> Value of type T1. Valid when type is 1. </summary>
        </member>
        <member name="F:Au.Types.Types`3.v2">
            <summary> Value of type T2. Valid when type is 2. </summary>
        </member>
        <member name="F:Au.Types.Types`3.v3">
            <summary> Value of type T3. Valid when type is 3. </summary>
        </member>
        <member name="M:Au.Types.Types`3.op_Implicit(`0)~Au.Types.Types{`0,`1,`2}">
            <summary> Assignment of a value of type T1. </summary>
        </member>
        <member name="M:Au.Types.Types`3.op_Implicit(`1)~Au.Types.Types{`0,`1,`2}">
            <summary> Assignment of a value of type T2. </summary>
        </member>
        <member name="M:Au.Types.Types`3.op_Implicit(`2)~Au.Types.Types{`0,`1,`2}">
            <summary> Assignment of a value of type T3. </summary>
        </member>
        <member name="M:Au.Types.Types`3.op_Implicit(Au.Types.JustNull)~Au.Types.Types{`0,`1,`2}">
            <summary>Infrastructure.</summary>
        </member>
        <member name="M:Au.Types.Types`3.op_Implicit(Au.Types.JustNull2)~Au.Types.Types{`0,`1,`2}">
            <summary>Infrastructure.</summary>
        </member>
        <member name="T:Au.Types.Types`4">
            <summary>
            Used for method parameters that accept one of four types.
            More info: <see cref="T:Au.Types.Types`2"/>.
            </summary>
        </member>
        <member name="F:Au.Types.Types`4.type">
            <summary> Value type. 1 if T1 (v1 is valid), 2 if T2 (v2 is valid), and so on. 0 if unassigned (unlikely). </summary>
        </member>
        <member name="F:Au.Types.Types`4.v1">
            <summary> Value of type T1. Valid when type is 1. </summary>
        </member>
        <member name="F:Au.Types.Types`4.v2">
            <summary> Value of type T2. Valid when type is 2. </summary>
        </member>
        <member name="F:Au.Types.Types`4.v3">
            <summary> Value of type T3. Valid when type is 3. </summary>
        </member>
        <member name="F:Au.Types.Types`4.v4">
            <summary> Value of type T4. Valid when type is 4. </summary>
        </member>
        <member name="M:Au.Types.Types`4.op_Implicit(`0)~Au.Types.Types{`0,`1,`2,`3}">
            <summary> Assignment of a value of type T1. </summary>
        </member>
        <member name="M:Au.Types.Types`4.op_Implicit(`1)~Au.Types.Types{`0,`1,`2,`3}">
            <summary> Assignment of a value of type T2. </summary>
        </member>
        <member name="M:Au.Types.Types`4.op_Implicit(`2)~Au.Types.Types{`0,`1,`2,`3}">
            <summary> Assignment of a value of type T3. </summary>
        </member>
        <member name="M:Au.Types.Types`4.op_Implicit(`3)~Au.Types.Types{`0,`1,`2,`3}">
            <summary> Assignment of a value of type T4. </summary>
        </member>
        <member name="M:Au.Types.Types`4.op_Implicit(Au.Types.JustNull)~Au.Types.Types{`0,`1,`2,`3}">
            <summary>Infrastructure.</summary>
        </member>
        <member name="M:Au.Types.Types`4.op_Implicit(Au.Types.JustNull2)~Au.Types.Types{`0,`1,`2,`3}">
            <summary>Infrastructure.</summary>
        </member>
        <member name="T:Au.Types.Coord">
            <summary>
            Contains x or y coordinate. Used for parameters of functions like Mouse.Move, Wnd.Move.
            Allows to easily specify coordinates of these types: normal, reverse (from right or bottom of a rectangle), fractional (fraction of width or height of a rectangle), null.
            Also has functions to convert to normal coodinates.
            </summary>
        </member>
        <member name="T:Au.Types.Coord.CoordType">
            <summary>
            Coord variable value type.
            </summary>
        </member>
        <member name="F:Au.Types.Coord.CoordType.None">
            <summary>
            No value. Assigned null or default(Coord).
            </summary>
        </member>
        <member name="F:Au.Types.Coord.CoordType.Normal">
            <summary>
            <see cref="P:Au.Types.Coord.Value"/> is pixel offset from left or top of a rectangle.
            </summary>
        </member>
        <member name="F:Au.Types.Coord.CoordType.Reverse">
            <summary>
            <see cref="P:Au.Types.Coord.Value"/> is pixel offset from right or bottom of a rectangle, towards left or top.
            </summary>
        </member>
        <member name="F:Au.Types.Coord.CoordType.Fraction">
            <summary>
            <see cref="P:Au.Types.Coord.FractionValue"/> is fraction of a rectangle, where 0.0 is left or top, and 1.0 is right or bottom (outside of the rectangle).
            </summary>
        </member>
        <member name="P:Au.Types.Coord.Type">
            <summary>
            Value type.
            </summary>
        </member>
        <member name="P:Au.Types.Coord.Value">
            <summary>
            Non-fraction value.
            </summary>
        </member>
        <member name="P:Au.Types.Coord.FractionValue">
            <summary>
            Fraction value.
            </summary>
        </member>
        <member name="P:Au.Types.Coord.IsEmpty">
            <summary>
            Returns true if Type == None (when assigned null or default(Coord)).
            </summary>
        </member>
        <member name="M:Au.Types.Coord.op_Implicit(System.Int32)~Au.Types.Coord">
            <summary>
            Creates Coord of Normal type.
            </summary>
        </member>
        <member name="M:Au.Types.Coord.op_Implicit(Au.Types.JustNull)~Au.Types.Coord">
            <summary>
            Infrastructure. Allows to assign null.
            </summary>
            <param name="v">null.</param>
        </member>
        <member name="M:Au.Types.Coord.Reverse(System.Int32)">
            <summary>
            Creates Coord of Reverse type.
            Value 0 is at the right or bottom, and does not belong to the rectangle. Positive values are towards left or top.
            </summary>
        </member>
        <member name="M:Au.Types.Coord.Fraction(System.Double)">
            <summary>
            Creates Coord of Fraction type.
            Value 0.0 is the left or top of the rectangle. Value 1.0 is the right or bottom of the rectangle. Values &lt;0.0 and &gt;=1.0 are outside of the rectangle.
            </summary>
        </member>
        <member name="P:Au.Types.Coord.Center">
            <summary>
            Returns <see cref="M:Au.Types.Coord.Fraction(System.Double)">Fraction</see>(0.5).
            </summary>
        </member>
        <member name="P:Au.Types.Coord.Max">
            <summary>
            Returns <see cref="M:Au.Types.Coord.Reverse(System.Int32)">Reverse</see>(0).
            This point will be outside of the rectangle. See also <see cref="P:Au.Types.Coord.MaxInside"/>.
            </summary>
        </member>
        <member name="P:Au.Types.Coord.MaxInside">
            <summary>
            Returns <see cref="M:Au.Types.Coord.Reverse(System.Int32)">Reverse</see>(1).
            This point will be inside of the rectangle, at the very right or bottom, assuming that the rectangle is not empty.
            </summary>
        </member>
        <member name="M:Au.Types.Coord.NormalizeInRect(Au.Types.Coord,Au.Types.Coord,Au.Types.RECT,System.Boolean,System.Boolean)">
            <summary>
            Converts fractional/reverse coordinates to normal coordinates in a rectangle.
            </summary>
            <param name="x">X coordinate relative to r.</param>
            <param name="y">Y coordinate relative to r.</param>
            <param name="r">The rectangle.</param>
            <param name="widthHeight">Use only width and height of r. If false, the function adds r offset (left and top).</param>
            <param name="centerIfEmpty">If x or y is default(Coord), use Coord.Center. Not used with widthHeight.</param>
        </member>
        <member name="M:Au.Types.Coord.NormalizeInWindow(Au.Types.Coord,Au.Types.Coord,Au.Wnd,System.Boolean,System.Boolean)">
            <summary>
            Returns normal coordinates relative to the client area of a window. Converts fractional/reverse coordinates etc.
            </summary>
            <param name="x">X coordinate relative to the client area of w.</param>
            <param name="y">Y coordinate relative to the client area of w.</param>
            <param name="w">The window.</param>
            <param name="nonClient">x y are relative to the entire w rectangle, not to its client area.</param>
            <param name="centerIfEmpty">If x or y is default(Coord), use Coord.Center.</param>
        </member>
        <member name="M:Au.Types.Coord.Normalize(Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions,System.Boolean)">
            <summary>
            Returns normal coordinates relative to the primary screen. Converts fractional/reverse coordinates etc.
            </summary>
            <param name="x">X coordinate relative to the specified screen (default - primary).</param>
            <param name="y">Y coordinate relative to the specified screen (default - primary).</param>
            <param name="co">Can be used to specify screen (see <see cref="M:Au.Screen_.FromObject(System.Object)"/>) and/or whether x y are relative to the work area.</param>
            <param name="widthHeight">Use only width and height of the screen rectangle. If false, the function adds its offset (left and top, which can be nonzero if using the work area or a non-primary screen).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid screen index.</exception>
        </member>
        <member name="M:Au.Types.Coord.ToString">
            
        </member>
        <member name="T:Au.Types.CoordOptions">
            <summary>
            Screen and other options for functions that accept coordinates as <see cref="T:Au.Types.Coord"/>.
            </summary>
        </member>
        <member name="P:Au.Types.CoordOptions.Screen">
            <summary>
            Screen index or anything that can be converted to <see cref="P:Au.Types.CoordOptions.Screen"/> with <see cref="M:Au.Screen_.FromObject(System.Object)"/>.
            </summary>
        </member>
        <member name="P:Au.Types.CoordOptions.WorkArea">
            <summary>
            If true, coordinates are relative to the work area, not to whole screen.
            </summary>
        </member>
        <member name="M:Au.Types.CoordOptions.#ctor">
            
        </member>
        <member name="M:Au.Types.CoordOptions.#ctor(System.Boolean,System.Object)">
            
        </member>
        <member name="T:Au.Types.DOwner">
            <summary>
            Dialog owner window handle.
            Used for function parameters where the function needs a window handle as <see cref="P:Au.Types.DOwner.Wnd"/> but also allows to pass a variable of any of these types directly: System.Windows.Forms.Control (Form or any control class), System.Windows.Window (WPF window), IntPtr (window handle).
            </summary>
        </member>
        <member name="M:Au.Types.DOwner.op_Implicit(Au.Wnd)~Au.Types.DOwner">
            <summary> Assignment of a value of type Wnd. </summary>
        </member>
        <member name="M:Au.Types.DOwner.op_Implicit(System.IntPtr)~Au.Types.DOwner">
            <summary> Assignment of a value of type Wnd. </summary>
        </member>
        <member name="M:Au.Types.DOwner.op_Implicit(System.Windows.Forms.Control)~Au.Types.DOwner">
            <summary> Assignment of a value of type System.Windows.Forms.Control (Form or any control class). </summary>
        </member>
        <member name="M:Au.Types.DOwner.op_Implicit(System.Windows.Window)~Au.Types.DOwner">
            <summary> Assignment of a value of type System.Windows.Window (WPF window). </summary>
        </member>
        <member name="P:Au.Types.DOwner.Wnd">
            <summary>
            Gets the window or control handle as Wnd.
            Returns default(Wnd) if not assigned.
            </summary>
        </member>
        <member name="P:Au.Types.DOwner.IsEmpty">
            <summary>
            true if not assigned.
            </summary>
        </member>
        <member name="T:Au.Types.SORestore">
            <summary>Infrastructure.</summary>
            <tocexclude />
        </member>
        <member name="M:Au.Types.SORestore.Dispose">
            <summary>
            Restores Options saved by <see cref="P:Au.AuScriptOptions.Temp"/>.
            </summary>
        </member>
        <member name="T:Au.Types.SORestoreWarnings">
            <summary>Infrastructure.</summary>
            <tocexclude />
        </member>
        <member name="M:Au.Types.SORestoreWarnings.Dispose">
            <summary>
            Restores warnings disabled by <see cref="M:Au.AuScriptOptions.DisableWarnings(System.String[])"/>.
            </summary>
        </member>
        <member name="T:Au.Types.PNFlags">
            <summary>
            flags for <see cref="M:Au.Path_.Normalize(System.String,System.String,Au.Types.PNFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.PNFlags.DoNotExpandDosPath">
            <summary>Don't call API <msdn>GetLongPathName</msdn>.</summary>
        </member>
        <member name="F:Au.Types.PNFlags.DoNotPrefixLongPath">
            <summary>Don't call <see cref="M:Au.Path_.PrefixLongPathIfNeed(System.String)"/>.</summary>
        </member>
        <member name="F:Au.Types.PNFlags.DoNotRemoveEndSeparator">
            <summary>Don't remove '\\' character at the end.</summary>
        </member>
        <member name="F:Au.Types.PNFlags.CanBeUrlOrShell">
            <summary>If path is not a file-system path but looks like URL (eg "http:..." or "file:...") or starts with "::", don't throw exception and don't process more (only expand environment variables).</summary>
        </member>
        <member name="T:Au.Types.SRFlags">
            <summary>
            flags for <see cref="M:Au.Shell.Run(System.String,System.String,Au.Types.SRFlags,Au.Types.SRMore)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.SRFlags.ShowErrorUI">
            <summary>
            Show error message box if fails, for example if file not found.
            Note: this does not disable exceptions. Still need exception handling. Or call <see cref="M:Au.Shell.TryRun(System.String,System.String,Au.Types.SRFlags,Au.Types.SRMore)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.SRFlags.WaitForExit">
            <summary>
            If started new process, wait until it exits.
            Uses <see cref="M:System.Threading.WaitHandle.WaitOne"/>.
            </summary>
        </member>
        <member name="T:Au.Types.SRMore">
            <summary>
            More parameters for <see cref="M:Au.Shell.Run(System.String,System.String,Au.Types.SRFlags,Au.Types.SRMore)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.SRMore.WorkingDirectory">
            <summary>
            Initial working directory for the new process.
            Some programs look for their files in the working directory and fail to start if it is not the program's directory.
            If null (default), the function gets parent directory path from the <i>file</i> parameter, if possible (if full path is specified or found).
            If this is "" or invalid or the function cannot find full path, the new process will inherit the curent working directory of this process.
            </summary>
        </member>
        <member name="F:Au.Types.SRMore.Verb">
            <summary>
            File's right-click menu command, also known as verb. For example "edit", "print", "properties". The default verb is bold in the menu.
            Not all menu items will work. Some may have different name than in the menu. Use verb "RunAs" for "Run as administrator".
            </summary>
        </member>
        <member name="F:Au.Types.SRMore.OwnerWindow">
            <summary>
            Owner window for error message boxes.
            Also, new window should be opened on the same screen. However many programs ignore it.
            </summary>
        </member>
        <member name="F:Au.Types.SRMore.WindowState">
            <summary>
            Preferred window state.
            Many programs ignore it.
            </summary>
        </member>
        <member name="F:Au.Types.SRMore.NeedProcessHandle">
            <summary>
            Get process handle, if possible.
            The <see cref="P:Au.Types.SRMore.ProcessHandle"/> property will contain it.
            </summary>
        </member>
        <member name="P:Au.Types.SRMore.ProcessHandle">
            <summary>
            This is an [Out] value.
            When the function returns, if <see cref="F:Au.Types.SRMore.NeedProcessHandle"/> was set to true, contains process handle in a <see cref="T:System.Threading.WaitHandle"/> variable.
            null if did not start new process (eg opened the document in an existing process) or did not get process handle for some other reason.
            Note: WaitHandle is disposable.
            </summary>
            <example>
            This code does the same as Shell.Run(@"notepad.exe", flags: SRFlags.WaitForExit);
            <code><![CDATA[
            var p = new SRMore() { NeedProcessHandle = true };
            Shell.Run(@"notepad.exe", more: p);
            using(var h = p.ProcessHandle) h?.WaitOne();
            ]]></code>
            </example>
        </member>
        <member name="T:Au.Types.SetAddRemove">
            <summary>
            Specifies whether to set, add or remove flags.
            </summary>
        </member>
        <member name="F:Au.Types.SetAddRemove.Set">
            <summary>Set flags = the specified value.</summary>
        </member>
        <member name="F:Au.Types.SetAddRemove.Add">
            <summary>Add the specified flags, don't change others.</summary>
        </member>
        <member name="F:Au.Types.SetAddRemove.Remove">
            <summary>Remove the specified flags, don't change others.</summary>
        </member>
        <member name="F:Au.Types.SetAddRemove.Xor">
            <summary>Toggle the specified flags, don't change others.</summary>
        </member>
        <member name="T:Au.Types.AuException">
            <summary>
            The base exception used in this library.
            Some constructors support Windows API error code. Then Message will contain its error description.
            If the string passed to the constructor starts with "*", replaces the "*" with "Failed to ". If does not end with ".", appends ".".
            </summary>
        </member>
        <member name="M:Au.Types.AuException.#ctor">
            <summary>
            Sets Message = "Failed.".
            Sets NativeErrorCode = 0.
            </summary>
        </member>
        <member name="M:Au.Types.AuException.#ctor(System.String)">
            <summary>
            Sets Message = message.
            Sets NativeErrorCode = 0.
            </summary>
        </member>
        <member name="M:Au.Types.AuException.#ctor(System.Int32)">
            <summary>
            Sets Message = "Failed. " + Native.GetErrorMessage(winApiErrorCode).
            Sets NativeErrorCode = (winApiErrorCode != 0) ? winApiErrorCode : Native.GetError().
            </summary>
        </member>
        <member name="M:Au.Types.AuException.#ctor(System.Int32,System.String)">
            <summary>
            Sets Message = message + " " + Native.GetErrorMessage(winApiErrorCode).
            Sets NativeErrorCode = (winApiErrorCode != 0) ? winApiErrorCode : Native.GetError().
            </summary>
        </member>
        <member name="M:Au.Types.AuException.#ctor(System.String,System.Exception)">
            <summary>
            Sets Message = message + "\r\n\t" + innerException.Message.
            Sets NativeErrorCode = 0.
            </summary>
        </member>
        <member name="M:Au.Types.AuException.#ctor(System.Int32,System.String,System.Exception)">
            <summary>
            Sets Message = message + " " + Native.GetErrorMessage(winApiErrorCode) + "\r\n\t" + innerException.Message.
            Sets NativeErrorCode = (winApiErrorCode != 0) ? winApiErrorCode : Native.GetError().
            </summary>
        </member>
        <member name="P:Au.Types.AuException.NativeErrorCode">
            <summary> Gets the Windows API error code. </summary>
        </member>
        <member name="P:Au.Types.AuException.Message">
            <summary> Gets error message. </summary>
        </member>
        <member name="F:Au.Types.AuException.FormattedMessage">
            <summary> String created by FormatMessage(), which should be called by the Message override if null. Initially null. </summary>
        </member>
        <member name="M:Au.Types.AuException.FormatMessage(System.String,System.String)">
            <summary>
            Formats error message. Sets and returns FormattedMessage.
            As base text, uses the text passed to the constructor (default "Failed.").
            If it starts with "*", replaces the "*" with "Failed to ".
            If it ends with "*", replaces the "*" with commonPostfix if it is not empty.
            If then the message does not end with ".", appends ".".
            If appendMessage is null, uses Native.GetErrorMessage(NativeErrorCode) if NativeErrorCode not 0.
            If then appendMessage is not empty, appends " " and appendMessage.
            Also appends InnerException.Message in new tab-indented line if InnerException is not null.
            </summary>
        </member>
        <member name="M:Au.Types.AuException.ThrowIfHresultNot0(System.Int32,System.String)">
            <summary>
            If errorCode is not 0, throws AuException that includes the code and its message.
            More info: <see cref="M:Au.Types.AuException.FormatMessage(System.String,System.String)"/>.
            </summary>
            <param name="errorCode">Windows API error code or HRESULT.</param>
            <param name="message">Main message. The message of the error code will be appended to it.</param>
        </member>
        <member name="M:Au.Types.AuException.ThrowIfHresultNegative(System.Int32,System.String)">
            <summary>
            If errorCode is less than 0, throws AuException that includes the code and its message.
            More info: <see cref="M:Au.Types.AuException.FormatMessage(System.String,System.String)"/>.
            </summary>
            <param name="errorCode">Windows API error code or HRESULT.</param>
            <param name="message">Main message. The message of the error code will be appended to it.</param>
        </member>
        <member name="T:Au.Types.WndException">
            <summary>
            Exception thrown mostly by <see cref="T:Au.Wnd"/> functions.
            </summary>
            <remarks>
            Some constructors support Windows API error code. Then Message also will contain its error description.
            If error code ERROR_INVALID_WINDOW_HANDLE, Message also depends on whether the window handle is 0.
            If parameter 'winApiErrorCode' is 0 or not used: if the window handle is invalid, uses ERROR_INVALID_WINDOW_HANDLE.
            If the string passed to the constructor starts with "*", replaces the "*" with "Failed to ". If ends with "*", replaces the "*" with " window.". If does not end with ".", appends ".".
            </remarks>
        </member>
        <member name="M:Au.Types.WndException.#ctor(Au.Wnd)">
            <summary>
            Sets NativeErrorCode = w.IsAlive ? 0 : ERROR_INVALID_WINDOW_HANDLE.
            Sets Message = "Failed.".
            </summary>
        </member>
        <member name="M:Au.Types.WndException.#ctor(Au.Wnd,System.String)">
            <summary>
            Sets NativeErrorCode = w.IsAlive ? 0 : ERROR_INVALID_WINDOW_HANDLE.
            </summary>
        </member>
        <member name="M:Au.Types.WndException.#ctor(Au.Wnd,System.Int32)">
            <summary>
            Sets NativeErrorCode = (winApiErrorCode != 0) ? winApiErrorCode : (w.IsAlive ? Native.GetError() : ERROR_INVALID_WINDOW_HANDLE).
            Sets Message = "Failed.".
            </summary>
        </member>
        <member name="M:Au.Types.WndException.#ctor(Au.Wnd,System.Int32,System.String)">
            <summary>
            Sets NativeErrorCode = (winApiErrorCode != 0) ? winApiErrorCode : (w.IsAlive ? Native.GetError() : ERROR_INVALID_WINDOW_HANDLE).
            </summary>
        </member>
        <member name="M:Au.Types.WndException.#ctor(Au.Wnd,System.String,System.Exception)">
            <summary>
            Sets NativeErrorCode = w.IsAlive ? 0 : ERROR_INVALID_WINDOW_HANDLE.
            </summary>
        </member>
        <member name="M:Au.Types.WndException.#ctor(Au.Wnd,System.Int32,System.String,System.Exception)">
            <summary>
            Sets NativeErrorCode = (winApiErrorCode != 0) ? winApiErrorCode : (w.IsAlive ? Native.GetError() : ERROR_INVALID_WINDOW_HANDLE).
            </summary>
        </member>
        <member name="P:Au.Types.WndException.Window">
            <summary> Gets the window passed to the constructor. </summary>
        </member>
        <member name="P:Au.Types.WndException.Message">
            <summary> Gets error message. </summary>
        </member>
        <member name="T:Au.Types.NotFoundException">
            <summary>
            Functions that search for an object can throw this exception when not found.
            </summary>
        </member>
        <member name="M:Au.Types.NotFoundException.#ctor">
            <summary>
            Sets Message = "Not found.".
            </summary>
        </member>
        <member name="M:Au.Types.NotFoundException.#ctor(System.String)">
            <summary>
            Sets Message = message.
            </summary>
        </member>
        <member name="T:Au.Types.ExtensionMethods">
            <summary>
            Adds extension methods to some .NET classes.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.OrThrow(Au.Wnd)">
            <summary>
            If this is default(Wnd), throws <see cref="T:Au.Types.NotFoundException"/>, else returns this.
            </summary>
            <exception cref="T:Au.Types.NotFoundException"></exception>
            <example>
            <code><![CDATA[
            var w1 = Wnd.Find("Example").OrThrow();
            var w2 = +Wnd.Find("Example"); //the same
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Types.ExtensionMethods.OrThrow(Au.Acc)">
            <summary>
            If this is null, throws <see cref="T:Au.Types.NotFoundException"/>, else returns this.
            </summary>
            <exception cref="T:Au.Types.NotFoundException"></exception>
            <example>
            <code><![CDATA[
            var w = Wnd.Find("Example").OrThrow();
            
            var a1 = Acc.Find(w, "web:LINK", "Example").OrThrow();
            var a2 = +Acc.Find(w, "web:LINK", "Example"); //the same
            
            var a3 = (Acc.Find(w, "web:LINK", "Example")?.Navigate("example")).OrThrow();
            var a4 = +Acc.Find(w, "web:LINK", "Example")?.Navigate("example"); //the same
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Types.ExtensionMethods.OrThrow(Au.WinImage)">
            <summary>
            If this is null, throws <see cref="T:Au.Types.NotFoundException"/>, else returns this.
            </summary>
            <exception cref="T:Au.Types.NotFoundException"></exception>
            <example>
            <code><![CDATA[
            var w = Wnd.Find("Example").OrThrow();
            var r1 = WinImage.Find(w, "example").OrThrow();
            var r2 = +WinImage.Find(w, "example"); //the same
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Types.ExtensionMethods.MouseMove(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Moves the cursor (mouse pointer) to the position x y relative to this window.
            Calls <see cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.
            By default x y coordinates are relative to the client area; default - center.
            </summary>
            <exception cref="T:Au.Types.NotFoundException">Window object not found (this variable is 0).</exception>
            <exception cref="T:System.Exception">Exceptions of Mouse.Move.</exception>
        </member>
        <member name="M:Au.Types.ExtensionMethods.MouseClick(Au.Wnd,Au.Types.Coord,Au.Types.Coord,Au.Types.MButton,System.Boolean)">
            <summary>
            Clicks, double-clicks, presses or releases a mouse button at position x y relative to this window.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.
            By default x y coordinates are relative to the client area; default - center. Default action - left click.
            </summary>
            <exception cref="T:Au.Types.NotFoundException">Window object not found (this variable is 0).</exception>
            <exception cref="T:System.Exception">Exceptions of Mouse.ClickEx.</exception>
        </member>
        <member name="M:Au.Types.ExtensionMethods.MouseMove(Au.Acc,Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Moves the cursor (mouse pointer) to this accessible object.
            Calls <see cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.
            </summary>
            <param name="t"></param>
            <param name="x">X coordinate in the bounding rectangle of this object. Default - center.</param>
            <param name="y">Y coordinate in the bounding rectangle of this object. Default - center.</param>
            <exception cref="T:Au.Types.NotFoundException">Accessible object not found (this variable is null).</exception>
            <exception cref="T:Au.Types.AuException">Failed to get object rectangle (<see cref="M:Au.Acc.GetRect(Au.Types.RECT@,Au.Wnd)"/>) or container window (<see cref="P:Au.Acc.WndContainer"/>).</exception>
            <exception cref="T:System.Exception">Exceptions of Mouse.Move.</exception>
        </member>
        <member name="M:Au.Types.ExtensionMethods.MouseClick(Au.Acc,Au.Types.Coord,Au.Types.Coord,Au.Types.MButton)">
            <summary>
            Clicks this accessible object.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.
            </summary>
            <param name="t"></param>
            <param name="x">X coordinate in the bounding rectangle of this object. Default - center.</param>
            <param name="y">Y coordinate in the bounding rectangle of this object. Default - center.</param>
            <param name="button">Which button and how to use it.</param>
            <exception cref="T:Au.Types.NotFoundException">Accessible object not found (this variable is null).</exception>
            <exception cref="T:Au.Types.AuException">Failed to get object rectangle (<see cref="M:Au.Acc.GetRect(Au.Types.RECT@,Au.Wnd)"/>) or container window (<see cref="P:Au.Acc.WndContainer"/>).</exception>
            <exception cref="T:System.Exception">Exceptions of Mouse.ClickEx.</exception>
        </member>
        <member name="M:Au.Types.ExtensionMethods.MouseMove(Au.WinImage,Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Moves the mouse to the found image.
            Calls <see cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/> or <see cref="M:Au.Mouse.Move(Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)"/>.
            </summary>
            <param name="t"></param>
            <param name="x">X coordinate in the found image. Default - center.</param>
            <param name="y">Y coordinate in the found image. Default - center.</param>
            <exception cref="T:Au.Types.NotFoundException">Image not found (this variable is null).</exception>
            <exception cref="T:System.InvalidOperationException">area is Bitmap.</exception>
            <exception cref="T:System.Exception">Exceptions of Mouse.Move.</exception>
        </member>
        <member name="M:Au.Types.ExtensionMethods.MouseClick(Au.WinImage,Au.Types.Coord,Au.Types.Coord,Au.Types.MButton)">
            <summary>
            Clicks the found image.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/> or <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)"/>.
            </summary>
            <param name="t"></param>
            <param name="x">X coordinate in the found image. Default - center.</param>
            <param name="y">Y coordinate in the found image. Default - center.</param>
            <param name="button">Which button and how to use it.</param>
            <exception cref="T:Au.Types.NotFoundException">Image not found (this variable is null).</exception>
            <exception cref="T:System.InvalidOperationException">area is Bitmap.</exception>
            <exception cref="T:System.Exception">Exceptions of Mouse.ClickEx.</exception>
        </member>
        <member name="M:Au.Types.ExtensionMethods.CreateHandle_(System.Windows.Forms.Control)">
            <summary>
            If control handle still not created, creates handle.
            Like <see cref="M:System.Windows.Forms.Control.CreateHandle"/>, which is protected.
            Unlike <see cref="M:System.Windows.Forms.Control.CreateControl"/>, creates handle even if invisible, and does not create child control handles.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.MouseClientXY_(System.Windows.Forms.Control)">
            <summary>
            Gets mouse cursor position in client area coordinates.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.MouseWindowXY_(System.Windows.Forms.Control)">
            <summary>
            Gets mouse cursor position in window coordinates.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.SetCueBanner_(System.Windows.Forms.TextBox,System.String,System.Boolean)">
            <summary>
            Sets the textual cue, or tip, that is displayed by the edit control to prompt the user for information.
            Does not if Multiline.
            Sends API <msdn>EM_SETCUEBANNER</msdn>.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.SetCueBanner_(System.Windows.Forms.ComboBox,System.String)">
            <summary>
            Sets the textual cue, or tip, that is displayed by the ComboBox edit control to prompt the user for information.
            Sends API <msdn>CB_SETCUEBANNER</msdn>.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.Add_``1(System.Windows.Forms.ContainerControl,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.String,System.Windows.Forms.AnchorStyles)">
            <summary>
            Creates a control, sets its commonly used properties (Bounds, Text, tooltip, Anchor) and adds it to the Controls collection of this.
            </summary>
            <typeparam name="T">Control class.</typeparam>
            <param name="t"></param>
            <param name="x">Left.</param>
            <param name="y">Top.</param>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
            <param name="text">The <see cref="P:System.Windows.Forms.Control.Text"/> property.</param>
            <param name="tooltip">Tooltip text.
            This function creates a ToolTip component and assigns it to the Tag property of this.</param>
            <param name="anchor">The <see cref="P:System.Windows.Forms.Control.Anchor"/> property.</param>
        </member>
        <member name="M:Au.Types.ExtensionMethods.Attribute_(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
            <summary>
            Gets XML attribute value.
            If the attribute does not exist, returns null.
            If the attribute value is empty, returns "".
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.Attribute_(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.String)">
            <summary>
            Gets XML attribute value.
            If the attribute does not exist, returns defaultValue.
            If the attribute value is empty, returns "".
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.Attribute_(System.Xml.Linq.XElement,System.String@,System.Xml.Linq.XName)">
            <summary>
            Gets XML attribute value.
            If the attribute does not exist, sets value=null and returns false.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.Attribute_(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Int32)">
            <summary>
            Gets attribute value converted to int (<see cref="M:Au.String_.ToInt32_(System.String)"/>).
            If the attribute does not exist, returns defaultValue.
            If the attribute value is empty or does not begin with a valid number, returns 0.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.Attribute_(System.Xml.Linq.XElement,System.Int32@,System.Xml.Linq.XName)">
            <summary>
            Gets attribute value converted to int (<see cref="M:Au.String_.ToInt32_(System.String)"/>).
            If the attribute does not exist, sets value=0 and returns false.
            If the attribute value is empty or does not begin with a valid number, sets value=0 and returns true.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.Attribute_(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Single)">
            <summary>
            Gets attribute value converted to float (<see cref="M:Au.String_.ToFloat_(System.String,System.Boolean)"/>).
            If the attribute does not exist, returns defaultValue.
            If the attribute value is empty or is not a valid float number, returns 0F.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.Attribute_(System.Xml.Linq.XElement,System.Single@,System.Xml.Linq.XName)">
            <summary>
            Gets attribute value converted to float (<see cref="M:Au.String_.ToFloat_(System.String,System.Boolean)"/>).
            If the attribute does not exist, sets value=0F and returns false.
            If the attribute value is empty or is not a valid number, sets value=0F and returns true.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.HasAttribute_(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
            <summary>
            Returns true if this element has the specified attribute.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.Descendant_(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
            <summary>
            Gets the first found descendant element.
            Returns null if not found.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.Descendant_(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Xml.Linq.XName,System.String,System.Boolean)">
            <summary>
            Gets the first found descendant element that has the specified attribute.
            Returns null if not found.
            </summary>
            <param name="t"></param>
            <param name="name">Element name. If null, can be any name.</param>
            <param name="attributeName">Attribute name.</param>
            <param name="attributeValue">Attribute value. If null, can be any value.</param>
            <param name="ignoreCase">Case-insensitive attributeValue.</param>
        </member>
        <member name="M:Au.Types.ExtensionMethods.Element_(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Xml.Linq.XName,System.String,System.Boolean)">
            <summary>
            Gets the first found direct child element that has the specified attribute.
            Returns null if not found.
            </summary>
            <param name="t"></param>
            <param name="name">Element name. If null, can be any name.</param>
            <param name="attributeName">Attribute name.</param>
            <param name="attributeValue">Attribute value. If null, can be any value.</param>
            <param name="ignoreCase">Case-insensitive attributeValue.</param>
        </member>
        <member name="M:Au.Types.ExtensionMethods.PreviousElement_(System.Xml.Linq.XElement)">
            <summary>
            Gets previous sibling element.
            Returns null if no element.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.NextElement_(System.Xml.Linq.XElement)">
            <summary>
            Gets next sibling element.
            Returns null if no element.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.ToString_(System.Double,System.String)">
            <summary>
            Converts double to string.
            Uses invariant culture, therefore decimal point is always '.', not ',' etc.
            Calls <see cref="M:System.Double.ToString(System.String,System.IFormatProvider)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.ToString_(System.Single,System.String)">
            <summary>
            Converts double to string.
            Uses invariant culture, therefore decimal point is always '.', not ',' etc.
            Calls <see cref="M:System.Single.ToString(System.String,System.IFormatProvider)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.ToString_(System.Decimal,System.String)">
            <summary>
            Converts double to string.
            Uses invariant culture, therefore decimal point is always '.', not ',' etc.
            Calls <see cref="M:System.Decimal.ToString(System.String,System.IFormatProvider)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.IsEmpty_(System.Drawing.Rectangle)">
            <summary>
            Returns true if t.Width &lt;= 0 || t.Height &lt;= 0.
            This extension method has been added because Rectangle.IsEmpty returns true only when all fields are 0, which is not very useful.
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.Has_``1(``0,``0)">
            <summary>
            Returns true if this enum variable has flag(s) f (all bits).
            Compiled as inlined code <c>(t &amp; flag) == flags</c>. The same as Enum.HasFlag, but much much faster.
            The enum type must be of size 4 (default).
            </summary>
        </member>
        <member name="M:Au.Types.ExtensionMethods.HasAny_``1(``0,``0)">
            <summary>
            Returns true if this enum variable has one or more flag bits specified in f.
            Compiled as inlined code <c>(t &amp; flags) != 0</c>. This is different from Enum.HasFlag.
            The enum type must be of size 4 (default).
            </summary>
        </member>
        <member name="T:Au.Types.LPARAM">
            <summary>
            Similar to IntPtr (can be 32-bit or 64-bit), but more useful for usually-non-pointer values, eg wParam/lParam of SendMessage.
            Unlike IntPtr:
            	Has implicit casts from/to most integral types.
            	Does not check overflow when casting from uint etc. IntPtr throws exception on overflow, which can create strange bugs.
            </summary>
            <remarks>
            There is no struct WPARAM. Use LPARAM instead, because it is the same in all cases except when casting to long or ulong (ambigous signed/unsigned).
            There is no cast operators for enum. When need, cast through int or uint. For Wnd cast through IntPtr.
            </remarks>
        </member>
        <member name="T:Au.Types.RECT">
            <summary>
            Contains rectangle coordinates.
            Unlike Rectangle, which contains fields for width and height and therefore cannot be used with Windows API functions, RECT contains fields for right and bottom and can be used with Windows API.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Initializes this instance.
            </summary>
            <param name="left"></param>
            <param name="top"></param>
            <param name="rightOrWidth">right or width, depending on <paramref name="useWidthHeight"/>.</param>
            <param name="bottomOrHeight">bottom or height, depending on <paramref name="useWidthHeight"/>.</param>
            <param name="useWidthHeight">If true, used width/height. If false, used right/bottom.</param>
        </member>
        <member name="M:Au.Types.RECT.Set(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sets fields like the constructor <see cref="M:Au.Types.RECT.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)"/>.
            </summary>
        </member>
        <member name="P:Au.Types.RECT.Is0">
            <summary>
            Returns true if all fields == 0.
            </summary>
        </member>
        <member name="P:Au.Types.RECT.IsEmpty">
            <summary>
            Returns true if the rectangle is empty or invalid: <c>right&lt;=left || bottom&lt;=top;</c>
            </summary>
        </member>
        <member name="P:Au.Types.RECT.Width">
            <summary>
            Gets or sets width.
            </summary>
        </member>
        <member name="P:Au.Types.RECT.Height">
            <summary>
            Gets or sets height.
            </summary>
        </member>
        <member name="P:Au.Types.RECT.CenterX">
            <summary>
            Gets horizontal center.
            </summary>
        </member>
        <member name="P:Au.Types.RECT.CenterY">
            <summary>
            Gets vertical center.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Contains(System.Int32,System.Int32)">
            <summary>
            Returns true if this rectangle contains the specified point.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Contains(System.Drawing.Point)">
            <summary>
            Returns true if this rectangle contains the specified point.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Contains(Au.Types.RECT)">
            <summary>
            Returns true if this rectangle contains entire specified rectangle.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Inflate(System.Int32,System.Int32)">
            <summary>
            Makes this rectangle bigger or smaller: <c>left-=dx; right+=dx; top-=dy; bottom+=dy;</c>
            Use negative dx/dy to make the rectangle smaller. Note: too big negative dx/dy can make it invalid (right&lt;left or bottom&lt;top).
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Intersect(Au.Types.RECT)">
            <summary>
            Replaces this rectangle with the intersection of itself and the specified rectangle.
            Returns true if the rectangles intersect.
            If they don't intersect, makes this RECT empty (IsEmpty would return true).
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Intersect(Au.Types.RECT,Au.Types.RECT)">
            <summary>
            Returns the intersection rectangle of two rectangles.
            If they don't intersect, returns empty rectangle (IsEmpty would return true).
            </summary>
        </member>
        <member name="M:Au.Types.RECT.IntersectsWith(Au.Types.RECT)">
            <summary>
            Returns true if this rectangle and another rectangle intersect.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Offset(System.Int32,System.Int32)">
            <summary>
            Moves this rectangle by the specified offsets: <c>left+=dx; right+=dx; top+=dy; bottom+=dy;</c>
            Negative dx moves to the left. Negative dy moves up.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Union(Au.Types.RECT)">
            <summary>
            Replaces this rectangle with the union of itself and the specified rectangle.
            Union is the smallest rectangle that contains two full rectangles.
            Returns true if finally this rectangle is not empty.
            If either rectangle is empty (Width or Height is &lt;=0), the result is another rectangle. If both empty - empty rectangle.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Union(Au.Types.RECT,Au.Types.RECT)">
            <summary>
            Returns the union of two rectangles.
            Union is the smallest rectangle that contains two full rectangles.
            If either rectangle is empty (Width or Height is &lt;=0), the result is another rectangle. If both empty - empty rectangle.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.MoveInScreen(Au.Types.Coord,Au.Types.Coord,System.Object,System.Boolean,System.Boolean)">
            <summary>
            Moves this rectangle to the specified coordinates in the specified screen, and ensures that whole rectangle is in screen.
            Final rectangle coordinates are relative to the primary screen.
            </summary>
            <param name="x">X coordinate in the specified screen. If null - screen center. You also can use Coord.Reverse etc.</param>
            <param name="y">Y coordinate in the specified screen. If null - screen center. You also can use Coord.Reverse etc.</param>
            <param name="screen">Use this screen (see <see cref="M:Au.Screen_.FromObject(System.Object)"/>). If null (default), uses the primary screen.</param>
            <param name="workArea">Use the work area, not whole screen. Default true.</param>
            <param name="ensureInScreen">If part of rectangle is not in screen, move and/or resize it so that entire rectangle would be in screen. Default true.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid screen index.</exception>
            <remarks>
            This function can be used to calculate new window location before creating it. If window already exists, use <see cref="M:Au.Wnd.MoveInScreen(Au.Types.Coord,Au.Types.Coord,System.Object,System.Boolean,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:Au.Types.RECT.EnsureInScreen(System.Object,System.Boolean)">
            <summary>
            Adjusts this rectangle to ensure that whole rectangle is in screen.
            Initial and final rectangle coordinates are relative to the primary screen.
            </summary>
            <param name="screen">Use this screen (see <see cref="M:Au.Screen_.FromObject(System.Object)"/>). If null (default), uses screen of the rectangle (or nearest).</param>
            <param name="workArea">Use the work area, not whole screen. Default true.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid screen index.</exception>
            <remarks>
            This function can be used to calculate new window location before creating it. If window already exists, use <see cref="M:Au.Wnd.EnsureInScreen(System.Object,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="T:Au.Types.ColorInt">
            <summary>
            Color, as int in 0xAARRGGBB format.
            Can convert from/to <see cref="T:System.Drawing.Color"/>, Windows native COLORREF (0xBBGGRR), from string.
            </summary>
        </member>
        <member name="F:Au.Types.ColorInt.color">
            <summary>
            Color value in 0xAARRGGBB format.
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.#ctor(System.Int32,System.Boolean)">
            <summary>
            Creates ColorInt from color value in 0xAARRGGBB format.
            </summary>
            <param name="colorARGB"></param>
            <param name="makeOpaque">Set alpha = 0xFF.</param>
        </member>
        <member name="M:Au.Types.ColorInt.op_Implicit(System.Int32)~Au.Types.ColorInt">
            <summary>
            Creates ColorInt from color value in 0xRRGGBB format.
            Makes opaque (alpha 0xFF).
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.#ctor(System.Drawing.Color)">
            <summary>
            Creates ColorInt from <see cref="T:System.Drawing.Color"/>.
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.op_Implicit(System.Drawing.Color)~Au.Types.ColorInt">
            <summary>
            Creates ColorInt from <see cref="T:System.Drawing.Color"/>.
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.FromString(System.String,Au.Types.ColorInt@)">
            <summary>
            Creates ColorInt from color name (<see cref="M:System.Drawing.Color.FromName(System.String)"/>) or string in "0xRRGGBB" or "#RRGGBB" format.
            </summary>
            <remarks>
            If s is a hex number that contains 6 or less hex digits, makes opaque (alpha 0xFF).
            If s is null or invalid, sets c.color = 0 and returns false.
            </remarks>
        </member>
        <member name="M:Au.Types.ColorInt.FromBGR(System.Int32,System.Boolean)">
            <summary>
            Creates ColorInt (0xRRGGBB) from Windows native COLORREF (0xBBGGRR).
            </summary>
            <param name="colorBGR">Color in 0xBBGGRR format.</param>
            <param name="makeOpaque">Set alpha = 0xFF.</param>
        </member>
        <member name="M:Au.Types.ColorInt.ToBGR(System.Boolean)">
            <summary>
            Creates Windows native COLORREF (0xBBGGRR) from ColorInt (0xRRGGBB).
            Returns color in COLORREF format. Does not modify this variable.
            </summary>
            <param name="zeroAlpha">Set the alpha byte = 0.</param>
        </member>
        <member name="M:Au.Types.ColorInt.op_Implicit(Au.Types.ColorInt)~System.Drawing.Color">
            <summary>
            Creates <see cref="T:System.Drawing.Color"/> from ColorInt.
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.op_Implicit(Au.Types.ColorInt)~System.Int32">
            <summary>
            Creates int from ColorInt.
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.SwapRB(System.Int32)">
            <summary>
            Converts color from ARGB (0xAARRGGBB) to ABGR (0xAABBGGRR) or vice versa (swaps the red and blue bytes).
            ARGB is used in .NET, GDI+ and HTML/CSS.
            ABGR is used by most Windows native API.
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.Brightness0to255">
            <summary>
            Calculates color's perceived brightness.
            Returns a value in range 0 (brightness of black color) to 1 (brightness of white color).
            </summary>
            <remarks>
            Unlike Color.GetBrightness, this function gives different weights for red, green and blue components.
            Does not use alpha.
            </remarks>
        </member>
        <member name="M:Au.Types.ColorInt.AdjustLuminance(System.Int32,System.Boolean)">
            <summary>
            Changes color's luminance (makes darker or brighter).
            Returns new color. Does not modify this variable.
            </summary>
            <param name="n">The luminance in units of 0.1 percent of the range (which depends on totalRange). Can be from -1000 to 1000.</param>
            <param name="totalRange">If true, n is in the whole luminance range (from minimal to maximal possible). If false, n is in the range from current luminance of the color to the maximal (if n positive) or minimal (if n negative) luminance.</param>
            <remarks>
            Calls API <msdn>ColorAdjustLuma</msdn>.
            Does not change hue and saturation. Does not use alpha.
            </remarks>
        </member>
        <member name="M:Au.Types.VARIANT.Dispose">
            <summary>
            Calls VariantClear.
            </summary>
        </member>
        <member name="M:Au.Types.VARIANT.ToString">
            <summary>
            Converts to string.
            Does not cache.
            </summary>
        </member>
        <member name="M:Au.Types.VARIANT.ToStringAndDispose(System.Boolean)">
            <summary>
            Converts to string.
            By default adds to our string cache.
            Disposes this VARIANT.
            </summary>
        </member>
        <member name="P:Au.Types.BSTR.Is0">
            <summary>
            Returns true if the string is null.
            </summary>
        </member>
        <member name="P:Au.Types.BSTR.Item(System.Int32)">
            <summary>
            Unsafe.
            </summary>
        </member>
        <member name="M:Au.Types.BSTR.ToString">
            <summary>
            Converts to string.
            Does not dispose. Doen not cache.
            </summary>
        </member>
        <member name="M:Au.Types.BSTR.ToStringAndDispose(System.Boolean)">
            <summary>
            Converts to string and frees the BSTR (calls Dispose()).
            By default adds to our string cache.
            </summary>
        </member>
        <member name="T:Au.Types.AuMTBase">
            <summary>
            Base class of AuMenu and AuToolbar.
            </summary>
        </member>
        <member name="P:Au.Types.AuMTBase.MainToolStrip">
            <summary>
            Gets ToolStrip of AuMenu and AuToolbar, which override this.
            </summary>
        </member>
        <member name="P:Au.Types.AuMTBase.LastItem">
            <summary>
            Gets the last added item as ToolStripItem, which is the base type of ToolStripMenuItem, ToolStripButton and other supported types.
            The item can be added with m.Add(...), m[...]=, m.Separator() and m.Submenu(...).
            </summary>
        </member>
        <member name="E:Au.Types.AuMTBase.ItemAdded">
            <summary>
            Occurs when an item is added.
            Allows to set item properties in single place instead of after each 'add item' code line.
            For example, the event handler can set item properties common to all items, or set item properties encoded in item text.
            </summary>
        </member>
        <member name="P:Au.Types.AuMTBase.IconFlags">
            <summary>
            Flags to pass to <see cref="M:Au.Icons.GetFileIconHandle(System.String,System.Int32,Au.Types.GIFlags)"/>. See <see cref="T:Au.Types.GIFlags"/>.
            </summary>
        </member>
        <member name="P:Au.Types.AuMTBase.IconSize">
            <summary>
            Image width and height.
            Also can be enum <see cref="T:Au.Icons.ShellSize"/>, cast to int.
            Set it before adding items.
            </summary>
            <remarks>
            To set different size for a submenu: <c>using(m.Submenu("sub")) { m.LastMenuItem.DropDown.ImageScalingSize = new Size(24, 24);</c>
            </remarks>
        </member>
        <member name="M:Au.Types.AuMTBase.Finalize">
            
        </member>
        <member name="T:Au.Types.MTClickArgs">
            <summary>
            Data passed to Click event handler functions of AuMenu and AuToolbar.
            </summary>
        </member>
        <member name="P:Au.Types.MTClickArgs.Item">
            <summary>
            Gets the clicked item as ToolStripItem.
            </summary>
        </member>
        <member name="P:Au.Types.MTClickArgs.MenuItem">
            <summary>
            Gets the clicked item as ToolStripMenuItem.
            Returns null if it is not ToolStripMenuItem.
            </summary>
        </member>
        <member name="M:Au.Types.MTClickArgs.ToString">
            <summary>
            Gets item text.
            </summary>
        </member>
        <member name="T:Au.Types.MButton">
            <summary>
            button parameter type for <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,System.Boolean)"/> and similar functions.
            There are two groups of values:
            1. Button (Left, Right, Middle, X1, X2). Default or 0: Left.
            2. Action (Down, Up, DoubleClick). Default: click.
            Multiple values from the same group cannot be combined. For example Left|Right is invalid.
            Values from different groups can be combined. For example Right|Down.
            </summary>
        </member>
        <member name="F:Au.Types.MButton.Left">
            <summary>
            The left button.
            </summary>
        </member>
        <member name="F:Au.Types.MButton.Right">
            <summary>
            The right button.
            </summary>
        </member>
        <member name="F:Au.Types.MButton.Middle">
            <summary>
            The middle button.
            </summary>
        </member>
        <member name="F:Au.Types.MButton.X1">
            <summary>
            The 4-th button.
            </summary>
        </member>
        <member name="F:Au.Types.MButton.X2">
            <summary>
            The 5-th button.
            </summary>
        </member>
        <member name="F:Au.Types.MButton.Down">
            <summary>(flag) Press and don't release.</summary>
        </member>
        <member name="F:Au.Types.MButton.Up">
            <summary>(flag) Don't press, only release.</summary>
        </member>
        <member name="F:Au.Types.MButton.DoubleClick">
            <summary>(flag) Double-click.</summary>
        </member>
        <member name="T:Au.Types.MRelease">
            <summary>
            The Dispose function releases mouse buttons pressed by the function that returned this variable.
            </summary>
            <tocexclude />
        </member>
        <member name="M:Au.Types.MRelease.op_Implicit(Au.Types.MButton)~Au.Types.MRelease">
            
        </member>
        <member name="M:Au.Types.MRelease.Dispose">
            <summary>
            Releases mouse buttons pressed by the function that returned this variable.
            </summary>
        </member>
        <member name="T:Au.Types.KScan">
            
        </member>
        <member name="T:Au.Types.Wildex">
            <summary>
            This class implements <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">wildcard expression</conceptualLink> parsing and matching (comparing).
            Typically used in 'find' functions. For example, <see cref="M:Au.Wnd.Find(System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)">Wnd.Find</see> uses it to compare window name, class name and program.
            The 'find' function creates a Wildex instance (which parses the wildcard expression), then calls <see cref="M:Au.Types.Wildex.Match(System.String)"/> for each item (eg window) to compare some its property text.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid "**options " or regular expression.</exception>
            <example>
            <code><![CDATA[
            //This version does not support wildcard expressions.
            Document Find1(string name, string date)
            {
            	return Documents.Find(x => x.Name.Equals_(name) && x.Date.Equals_(date));
            }
            
            //This version supports wildcard expressions.
            //null-string arguments are not compared.
            Document Find2(string name, string date)
            {
            	Wildex n = name, d = date; //null if the string is null
            	return Documents.Find(x => (n == null || n.Match(x.Name)) && (d == null || d.Match(x.Date)));
            }
            
            //Example of calling such function.
            //Find item whose name is "example" (case-insensitive) and date starts with "2017-".
            var item = x.Find2("example", "2017-*");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Types.Wildex.#ctor(System.String)">
            <param name="wildcardExpression">
            <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">Wildcard expression</conceptualLink>.
            Cannot be null (throws exception).
            "" will match "".
            </param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException">Invalid "**options " or regular expression.</exception>
        </member>
        <member name="M:Au.Types.Wildex.op_Implicit(System.String)~Au.Types.Wildex">
            <summary>
            Creates new Wildex from wildcard expression string.
            If the string is null, returns null.
            </summary>
            <param name="wildcardExpression">
            <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">Wildcard expression</conceptualLink>.
            </param>
        </member>
        <member name="M:Au.Types.Wildex.Match(System.String)">
            <summary>
            Compares a string with the <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">wildcard expression</conceptualLink> used to create this <see cref="T:Au.Types.Wildex"/>.
            Returns true if they match.
            </summary>
            <param name="s">String. If null, returns false. If "", returns true if it was "" or "*" or a regular expression that matches "".</param>
        </member>
        <member name="T:Au.Types.Wildex.WildType">
            <summary>
            The type of text (wildcard expression) used when creating the Wildex variable.
            </summary>
        </member>
        <member name="F:Au.Types.Wildex.WildType.Text">
            <summary>
            Simple text (option t, or no *? characters and no t r R options).
            Match() calls <see cref="M:Au.String_.Equals_(System.String,System.String,System.Boolean)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.Wildex.WildType.Wildcard">
            <summary>
            Wildcard (has *? characters and no t r R options).
            Match() calls <see cref="M:Au.String_.Like_(System.String,System.String,System.Boolean)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.Wildex.WildType.RegexPcre">
            <summary>
            PCRE regular expression (option r).
            Match() calls <see cref="M:Au.Regex_.IsMatch(System.String,Au.Types.RXMore)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.Wildex.WildType.RegexNet">
            <summary>
            .NET egular expression (option R).
            Match() calls <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.Wildex.WildType.Multi">
            <summary>
            Multiple parts (option m).
            Match() calls Match() for each part (see <see cref="P:Au.Types.Wildex.MultiArray"/>) and returns true if all negative (option n) parts return true (or there are no such parts) and some positive (no option n) part returns true (or there are no such parts).
            If you want to implement a different logic, call Match() for each <see cref="P:Au.Types.Wildex.MultiArray"/> element (instead of calling Match() for this variable).
            </summary>
        </member>
        <member name="P:Au.Types.Wildex.Text">
            <summary>
            Gets the wildcard or simple text.
            null if TextType is Regex or Multi.
            </summary>
        </member>
        <member name="P:Au.Types.Wildex.RegexPcre">
            <summary>
            Gets the Regex object created from regular expression string.
            null if TextType is not RegexPcre (no option r).
            </summary>
        </member>
        <member name="P:Au.Types.Wildex.RegexNet">
            <summary>
            Gets the Regex object created from regular expression string.
            null if TextType is not RegexNet (no option R).
            </summary>
        </member>
        <member name="P:Au.Types.Wildex.MultiArray">
            <summary>
            Array of Wildex variables, one for each part in multi-part text.
            null if TextType is not Multi (no option m).
            </summary>
        </member>
        <member name="P:Au.Types.Wildex.TextType">
            <summary>
            Gets the type of text (wildcard, regex, etc).
            </summary>
        </member>
        <member name="P:Au.Types.Wildex.IgnoreCase">
            <summary>
            Is case-insensitive?
            </summary>
        </member>
        <member name="P:Au.Types.Wildex.Not">
            <summary>
            Has option n?
            </summary>
        </member>
        <member name="M:Au.Types.Wildex.ToString">
            
        </member>
        <member name="M:Au.Types.Wildex.HasWildcards(System.String)">
            <summary>
            Returns true if string contains wildcard characters: '*', '?'.
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="T:Au.Types.WildexStruct">
            <summary>
            A slim version of <see cref="T:Au.Types.Wildex"/>.
            </summary>
            <remarks>
            Has all the same capabilities as Wildex, but is just a struct of single pointer size.
            The pointer is Object that can be of one of these types:
            <see cref="T:Au.Types.Wildex"/> - if the assigned string was with wildcard expression options, like "**c text". To compare it with other strings, <see cref="M:Au.Types.WildexStruct.Match(System.String)"/> calls <see cref="M:Au.Types.Wildex.Match(System.String)"/>.
            <see cref="T:System.String"/> - if the assigned string was without wildcard expression options. To compare it with other strings, <see cref="M:Au.Types.WildexStruct.Match(System.String)"/> calls <see cref="M:Au.String_.Like_(System.String,System.String,System.Boolean)"/> with <i>ignoreCase</i> true.
            null - if was not assigned a non-null string.
            </remarks>
        </member>
        <member name="M:Au.Types.WildexStruct.#ctor(System.String)">
            <param name="wildcardExpression">
            <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">Wildcard expression</conceptualLink>.
            Cannot be null (throws exception).
            "" will match "".
            </param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException">Invalid "**options " or regular expression.</exception>
        </member>
        <member name="M:Au.Types.WildexStruct.op_Implicit(System.String)~Au.Types.WildexStruct">
            <summary>
            Creates new WildexStruct from wildcard expression string.
            If the string is null, returns empty variable. Then it's <see cref="P:Au.Types.WildexStruct.HasValue"/> property is false, <see cref="P:Au.Types.WildexStruct.Value"/> property is null, and <see cref="M:Au.Types.WildexStruct.Match(System.String)"/> must not ne called.
            </summary>
            <param name="wildcardExpression">
            <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">Wildcard expression</conceptualLink>.
            </param>
        </member>
        <member name="M:Au.Types.WildexStruct.Match(System.String)">
            <summary>
            Compares a string with the <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">wildcard expression</conceptualLink> used to create this variable.
            Returns true if they match.
            </summary>
            <param name="s">String. If null, returns false. If "", returns true if it was "" or "*" or a regular expression that matches "".</param>
        </member>
        <member name="P:Au.Types.WildexStruct.HasValue">
            <summary>
            Returns true if assigned a non-null string.
            This variable contains either the string or <see cref="T:Au.Types.Wildex"/>.
            If this property is false, don't call <see cref="M:Au.Types.WildexStruct.Match(System.String)"/>, it will throw exception.
            </summary>
        </member>
        <member name="P:Au.Types.WildexStruct.Value">
            <summary>
            Returns Wildex if the assigned string was with wildcard expression options, like "**c text".
            Returns String if the assigned string was without wildcard expression options.
            Returns null if was not assigned a non-null string.
            </summary>
        </member>
        <member name="M:Au.Types.WildexStruct.ToString">
            
        </member>
        <member name="T:Au.Types.DIcon">
            <summary>
            AuDialog icon. Used with <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String)"/> and similar functions.
            </summary>
        </member>
        <member name="F:Au.Types.DIcon.App">
            <summary>
            Your application icon.
            It is the first native icon of the entry assembly of this appdomain; if there are no icons - of the program file of this process (if it's different); if there are no icons too - the default program icon.
            </summary>
        </member>
        <member name="T:Au.Types.DEdit">
            <summary>
            Text edit field type for <see cref="M:Au.AuDialog.ShowTextInputEx(System.String,System.String,Au.Types.DEdit,System.Object,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.String,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs},System.String,System.Action{Au.Types.DEventArgs})"/> and <see cref="M:Au.AuDialog.SetEditControl(Au.Types.DEdit,System.Object)"/>.
            </summary>
        </member>
        <member name="T:Au.Types.DFlags">
            <summary>
            AuDialog flags. Used with <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String)"/> and similar functions.
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.CommandLinks">
            <summary>
            Display custom buttons as a column of command-links, not as a row of classic buttons.
            Command links can have multi-line text. The first line has bigger font.
            More info about custom buttons: <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.EndThread">
            <summary>
            Call <see cref="M:System.Threading.Thread.Abort"/> if selected OK button when there are no other buttons. Also when selected Cancel, No, and on timeout.
            The same as <see cref="P:Au.AuDialog.FlagEndThread"/>.
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.ExpandDown">
            <summary>
            Show expanded text in footer.
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.OwnerCenter">
            <summary>
            Show the dialog in the center of the owner window.
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.RawXY">
            <summary>
            x y are relative to the primary screen (ignore <see cref="T:System.Windows.Forms.Screen"/> etc). Don't ensure thet entire window is in screen.
            More info: <see cref="M:Au.AuDialog.SetXY(Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. 
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.Topmost">
            <summary>
            Make the dialog a topmost window (always on top of other windows), regardless of AuDialog.Options.TopmostIfNoOwnerWindow etc.
            More info: <see cref="P:Au.AuDialog.FlagTopmost"/>. 
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.Wider">
            <summary>
            Set <see cref="P:Au.AuDialog.Width"/> = 700.
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.XCancel">
            <summary>
            Allow to cancel even if there is no Cancel button.
            It adds X (Close) button to the title bar, and also allows to close the dialog with the Esc key.
            When the dialog is closed with the X button or Esc, the returned result button id is 0 if there is no Cancel button; else the same as when clicked the Cancel button.
            The same as <see cref="P:Au.AuDialog.FlagXCancel"/>.
            </summary>
        </member>
        <member name="T:Au.Types.DResult">
            <summary>
            Dialog result, returned by <see cref="M:Au.AuDialog.ShowEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/> and similar functions.
            Contains multiple result values: selected button id, selected radio button id, check box state, edit field text.
            </summary>
        </member>
        <member name="F:Au.Types.DResult.Timeout">
            <summary>
            Returned <see cref="P:Au.Types.DResult.Button"/> value on timeout.
            </summary>
        </member>
        <member name="P:Au.Types.DResult.Button">
            <summary>
            Gets selected button id.
            On timeout it is DResult.Timeout.
            </summary>
        </member>
        <member name="P:Au.Types.DResult.RadioButton">
            <summary>
            Gets selected (checked) radio button id.
            </summary>
        </member>
        <member name="P:Au.Types.DResult.IsChecked">
            <summary>
            Gets check box state.
            </summary>
        </member>
        <member name="P:Au.Types.DResult.EditText">
            <summary>
            Gets edit field text.
            </summary>
        </member>
        <member name="M:Au.Types.DResult.op_Implicit(Au.Types.DResult)~System.Int32">
            <summary>
            Converts DResult to int.
            Allows to use code <c>switch(AuDialog.ShowEx(...))</c> instead of <c>switch(AuDialog.ShowEx(...).Button)</c> .
            </summary>
        </member>
        <member name="M:Au.Types.DResult.ToString">
            <summary>
            Formats string $"Button={Button}, RadioButton={RadioButton}, IsChecked={IsChecked}, EditText={EditText}".
            </summary>
        </member>
        <member name="T:Au.Types.DEventArgs">
            <summary>
            Arguments for AuDialog event handlers.
            More info: <msdn>TaskDialogCallbackProc</msdn>.
            To return a non-zero value from the callback function, assign the value to the returnValue field.
            </summary>
        </member>
        <member name="P:Au.Types.DEventArgs.LinkHref">
            <summary>
            Clicked hyperlink href attribute value. Use in HyperlinkClicked event handler.
            </summary>
        </member>
        <member name="P:Au.Types.DEventArgs.Button">
            <summary>
            Clicked button id. Use in ButtonClicked event handler.
            </summary>
        </member>
        <member name="P:Au.Types.DEventArgs.TimerTimeMS">
            <summary>
            Dialog timer time in milliseconds. Use in Timer event handler.
            The event handler can set returnValue=1 to reset this.
            </summary>
        </member>
        <member name="P:Au.Types.DEventArgs.DoNotCloseDialog">
            <summary>
            Your ButtonClicked event handler function can use this to prevent closing the dialog.
            </summary>
        </member>
        <member name="P:Au.Types.DEventArgs.EditText">
            <summary>
            Gets or sets edit field text.
            </summary>
        </member>
        <member name="T:Au.Types.TDApi">
            <summary>
            Constants for task dialog API messages etc.
            Can be used with <see cref="T:Au.AuDialog"/>.
            </summary>
        </member>
        <member name="T:Au.Types.TDApi.TDM">
            <summary>
            Messages that your event handler can send to the dialog.
            Reference: <msdn>task dialog messages</msdn>.
            </summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.TDApi.TDN">
            <summary>
            Notification messages that your event handler receives.
            Reference: <msdn>task dialog notifications</msdn>.
            </summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.TDApi.TDE">
            <summary>
            Constants for TDApi.TDM.SET_ELEMENT_TEXT and TDApi.TDM.UPDATE_ELEMENT_TEXT messages and AuDialog.Send.Text().
            </summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.TDApi.TDIE">
            <summary>
            Constants for TDApi.TDM.UPDATE_ICON message.
            </summary>
            <tocexclude />
        </member>
        <member name="T:Au.Types.WProp">
            <summary>
            Sets, gets, removes and lists window properties using API <msdn>SetProp</msdn> and co.
            </summary>
        </member>
        <member name="P:Au.Types.WProp.Item(System.String)">
            <summary>
            Gets a window property.
            Calls API <msdn>GetProp</msdn> and returns its return value.
            </summary>
            <param name="name">Property name.</param>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Types.WProp.Item(System.UInt16)">
            <summary>
            Gets a window property.
            Calls API <msdn>GetProp</msdn> and returns its return value.
            </summary>
            <param name="atom">Property name atom in the global atom table.</param>
            <remarks>
            This overload uses atom instead of string. I's about 3 times faster. See API <msdn>GlobalAddAtom</msdn>, <msdn>GlobalDeleteAtom</msdn>.
            </remarks>
        </member>
        <member name="M:Au.Types.WProp.Set(System.String,Au.Types.LPARAM)">
            <summary>
            Sets a window property.
            Calls API <msdn>SetProp</msdn> and returns its return value.
            </summary>
            <param name="name">Property name.</param>
            <param name="value">Property value.</param>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            
            Later call <see cref="M:Au.Types.WProp.Remove(System.String)"/> to remove the property. If you use many unique property names and don't remove the properties, the property name strings can fill the global atom table which is of a fixed size (about 48000) and which is used by all processes for various purposes.
            </remarks>
        </member>
        <member name="M:Au.Types.WProp.Set(System.UInt16,Au.Types.LPARAM)">
            <summary>
            Sets a window property.
            Calls API <msdn>SetProp</msdn> and returns its return value.
            </summary>
            <param name="atom">Property name atom in the global atom table.</param>
            <param name="value">Property value.</param>
            <remarks>
            This overload uses atom instead of string. I's about 3 times faster. See API <msdn>GlobalAddAtom</msdn>, <msdn>GlobalDeleteAtom</msdn>.
            </remarks>
        </member>
        <member name="M:Au.Types.WProp.Remove(System.String)">
            <summary>
            Removes a window property.
            Calls API <msdn>RemoveProp</msdn> and returns its return value.
            </summary>
            <param name="name">Property name. Other overload allows to use global atom instead, which is faster.</param>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Types.WProp.Remove(System.UInt16)">
            <summary>
            Removes a window property.
            Calls API <msdn>RemoveProp</msdn> and returns its return value.
            </summary>
            <param name="atom">Property name atom in the global atom table.</param>
        </member>
        <member name="M:Au.Types.WProp.GetList">
            <summary>
            Gets list of window properties.
            Uses API <msdn>EnumPropsEx</msdn>.
            </summary>
            <remarks>
            Returns 0-length list if fails. Fails if invalid window or access denied (UAC). Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="M:Au.Types.WProp.ToString">
            <summary>
            Calls <see cref="M:Au.Types.WProp.GetList"/> and converts to string.
            </summary>
        </member>
        <member name="T:Au.Types.WCFlags">
            <summary>
            'flags' parameter of <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/>.
            <note>
            </note>
            </summary>
        </member>
        <member name="F:Au.Types.WCFlags.HiddenToo">
            <summary>Can find hidden controls.</summary>
        </member>
        <member name="F:Au.Types.WCFlags.DirectChild">
            <summary>Skip indirect descendant controls (children of children and so on).</summary>
        </member>
        <member name="T:Au.Types.WXYFlags">
            <summary>
            Flags for <see cref="M:Au.Wnd.FromXY(Au.Types.Coord,Au.Types.Coord,Au.Types.WXYFlags,Au.Types.CoordOptions)"/> and <see cref="M:Au.Wnd.FromMouse(Au.Types.WXYFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.WXYFlags.NeedWindow">
            <summary>
            Need top-level window. If at that point is a control, gets its top-level parent.
            Don't use together with NeedControl.
            If none of flags NeedWindow and NeedControl are specified, the function gets exactly what is at that point (control or top-level window).
            </summary>
        </member>
        <member name="F:Au.Types.WXYFlags.NeedControl">
            <summary>
            Need a control (child window). Returns default(Wnd) if there is no control at that point.
            Don't use together with NeedWindow.
            If none of flags NeedWindow and NeedControl are specified, the function gets exactly what is at that point (control or top-level window).
            </summary>
        </member>
        <member name="F:Au.Types.WXYFlags.Raw">
            <summary>
            Just call API <msdn>WindowFromPoint</msdn>.
            Faster but less accurate with controls. Does not see disabled controls, does not prefer non-transparent controls.
            Not used with flag NeedWindow.
            </summary>
        </member>
        <member name="T:Au.Types.WFFlags">
            <summary>
            'flags' parameter of <see cref="M:Au.Wnd.Find(System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.WFFlags.HiddenToo">
            <summary>
            Can find hidden windows. See <see cref="P:Au.Wnd.IsVisibleEx"/>.
            Use this carefully. Always use className, not just name, because there are many hidden tooltip windows etc that could match the name.
            </summary>
        </member>
        <member name="F:Au.Types.WFFlags.SkipCloaked">
            <summary>
            Skip cloaked windows. See <see cref="P:Au.Wnd.IsCloaked"/>.
            Cloaked are windows hidden not in the classic way, therefore Wnd.IsVisible does not detect it, but Wnd.IsCloaked detects. For example, windows on inactive Windows 10 virtual desktops; inactive Windows Store apps on Windows 8.
            </summary>
        </member>
        <member name="T:Au.Types.SpecHwnd">
            <summary>
            Contains static properties that return special window handle values that can be used with some API functions and with some Wnd functions too.
            </summary>
        </member>
        <member name="P:Au.Types.SpecHwnd.HWND_TOP">
            <summary>API HWND_TOP (0). Used with SetWindowPos.</summary>
        </member>
        <member name="P:Au.Types.SpecHwnd.HWND_BOTTOM">
            <summary>API HWND_BOTTOM (1). Used with SetWindowPos.</summary>
        </member>
        <member name="P:Au.Types.SpecHwnd.HWND_TOPMOST">
            <summary>API HWND_TOPMOST (-1). Used with SetWindowPos.</summary>
        </member>
        <member name="P:Au.Types.SpecHwnd.HWND_NOTOPMOST">
            <summary>API HWND_NOTOPMOST (-2). Used with SetWindowPos.</summary>
        </member>
        <member name="P:Au.Types.SpecHwnd.HWND_MESSAGE">
            <summary>API HWND_MESSAGE (-3). Used with API CreateWindowEx, Wnd.WndOwner etc.</summary>
        </member>
        <member name="P:Au.Types.SpecHwnd.HWND_BROADCAST">
            <summary>API HWND_BROADCAST (0xffff). Used with API SendMessage, Wnd.Send etc.</summary>
        </member>
        <member name="T:Au.Types.SUBCLASSPROC">
            <summary>API <msdn>SUBCLASSPROC</msdn></summary>
        </member>
        <member name="T:Au.Types.FileDir">
            <summary>
            File system entry type - file, directory, and whether it exists.
            Returned by <see cref="M:Au.Files.ExistsAs(System.String,System.Boolean)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.FileDir.NotFound">
            <summary>Does not exist, or failed to get attributes.</summary>
        </member>
        <member name="F:Au.Types.FileDir.File">
            <summary>Is file, or symbolic link to a file.</summary>
        </member>
        <member name="F:Au.Types.FileDir.Directory">
            <summary>Is directory, or symbolic link to a directory.</summary>
        </member>
        <member name="T:Au.Types.FileDir2">
            <summary>
            File system entry type - file, directory, symbolic link, whether it exists and is accessible.
            Returned by <see cref="M:Au.Files.ExistsAs2(System.String,System.Boolean)"/>.
            The enum value NotFound is 0; AccessDenied is negative ((int)0x80000000); other values are greater than 0.
            </summary>
        </member>
        <member name="F:Au.Types.FileDir2.NotFound">
            <summary>Does not exist.</summary>
        </member>
        <member name="F:Au.Types.FileDir2.File">
            <summary>Is file. Attributes: Directory no, ReparsePoint no.</summary>
        </member>
        <member name="F:Au.Types.FileDir2.Directory">
            <summary>Is directory. Attributes: Directory yes, ReparsePoint no.</summary>
        </member>
        <member name="F:Au.Types.FileDir2.SymLinkFile">
            <summary>Is symbolic link to a file. Attributes: Directory no, ReparsePoint yes.</summary>
        </member>
        <member name="F:Au.Types.FileDir2.SymLinkDirectory">
            <summary>Is symbolic link to a directory, or is a mounted folder. Attributes: Directory yes, ReparsePoint yes.</summary>
        </member>
        <member name="F:Au.Types.FileDir2.AccessDenied">
            <summary>Exists but this process cannot access it and get attributes.</summary>
        </member>
        <member name="T:Au.Types.FAFlags">
            <summary>
            Flags for <see cref="M:Au.Files.GetAttributes(System.String,System.IO.FileAttributes@,Au.Types.FAFlags)"/> and some other functions.
            </summary>
        </member>
        <member name="F:Au.Types.FAFlags.UseRawPath">
            <summary>Pass path to the API as it is, without any normalizing and validating.</summary>
        </member>
        <member name="F:Au.Types.FAFlags.DoNotThrow">
            <summary>
            If failed, return false and don't throw exception.
            Then, if you need error info, you can use <see cref="M:Au.Types.Native.GetError"/>. If the file/directory does not exist, it will return ERROR_FILE_NOT_FOUND or ERROR_PATH_NOT_FOUND or ERROR_NOT_READY.
            If failed and the native error code is ERROR_ACCESS_DENIED or ERROR_SHARING_VIOLATION, the returned attributes will be (FileAttributes)(-1). The file probably exists but is protected so that this process cannot access and use it. Else attributes will be 0.
            </summary>
        </member>
        <member name="T:Au.Types.FileProperties">
            <summary>
            File or directory properties. Used with <see cref="M:Au.Files.GetProperties(System.String,Au.Types.FileProperties@,Au.Types.FAFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.FileProperties.Attributes">
            
        </member>
        <member name="F:Au.Types.FileProperties.Size">
            <summary>File size. For directories it is usually 0.</summary>
        </member>
        <member name="F:Au.Types.FileProperties.LastWriteTimeUtc">
            
        </member>
        <member name="F:Au.Types.FileProperties.CreationTimeUtc">
            
        </member>
        <member name="F:Au.Types.FileProperties.LastAccessTimeUtc">
            <summary>Note: this is unreliable. The operating system may not record this time automatically.</summary>
        </member>
        <member name="T:Au.Types.FEFlags">
            <summary>
            flags for <see cref="M:Au.Files.EnumDirectory(System.String,Au.Types.FEFlags,System.Func{Au.Types.FEFile,System.Boolean},System.Action{System.String})"/>.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.AndSubdirectories">
            <summary>
            Enumerate subdirectories too.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.AndSymbolicLinkSubdirectories">
            <summary>
            Also enumerate symbolic link and mounted folder target directories. Use with AndSubdirectories.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.SkipHidden">
            <summary>
            Skip files and subdirectories that have Hidden attribute.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.SkipHiddenSystem">
            <summary>
            Skip files and subdirectories that have Hidden and System attributes (both).
            These files/directories usually are created and used only by the operating system. Drives usually have several such directories. Another example - thumbnail cache files.
            Without this flag the function skips only these hidden-system root directories when enumerating a drive: "$Recycle.Bin", "System Volume Information", "Recovery". If you want to include them too, use network path of the drive, for example @"\\localhost\D$\" for D drive.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.IgnoreAccessDeniedErrors">
            <summary>
            If fails to get contents of the directory or a subdirectory because of its security settings, assume that the [sub]directory is empty.
            Without this flag then throws exception or calls errorHandler.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.DisableRedirection">
            <summary>
            Temporarily disable file system redirection in this thread of this 32-bit process running on 64-bit Windows.
            Then you can enumerate the 64-bit System32 folder in your 32-bit process.
            Uses API <msdn>Wow64DisableWow64FsRedirection</msdn>.
            For vice versa (in 64-bit process enumerate the 32-bit System folder), instead use path Folders.SystemX86.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.UseRawPath">
            <summary>
            Don't call <see cref="M:Au.Path_.Normalize(System.String,System.String,Au.Types.PNFlags)"/>(directoryPath) and don't throw exception for non-full path.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.NeedRelativePaths">
            <summary>
            Let <see cref="P:Au.Types.FEFile.Name"/> be path relative to the specified directory path. Like @"\name.txt" or @"\subdirectory\name.txt" instead of "name.txt".
            </summary>
        </member>
        <member name="T:Au.Types.FCFlags">
            <summary>
            flags for <see cref="M:Au.Files.Copy(System.String,System.String,Au.Types.IfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})"/> and some other similar functions.
            Used only when copying directory.
            </summary>
        </member>
        <member name="F:Au.Types.FCFlags.SkipHiddenSystem">
            <summary>
            Skip descendant files and directories that have Hidden and System attributes (both).
            They usually are created and used only by the operating system. Drives usually have several such directories. Another example - thumbnail cache files.
            They often are protected and would fail to copy, ruining whole copy operation.
            Without this flag the function skips only these hidden-system root directories when enumerating a drive: "$Recycle.Bin", "System Volume Information", "Recovery".
            </summary>
        </member>
        <member name="F:Au.Types.FCFlags.IgnoreAccessDeniedErrors">
            <summary>
            If fails to get contents of the directory or a subdirectory because of its security settings, don't throw exception but assume that the [sub]directory is empty.
            </summary>
        </member>
        <member name="T:Au.Types.FEFile">
            <summary>
            Contains name and other main properties of a file or subdirectory retrieved by <see cref="M:Au.Files.EnumDirectory(System.String,Au.Types.FEFlags,System.Func{Au.Types.FEFile,System.Boolean},System.Action{System.String})"/>.
            The values are not changed after creating the variable.
            </summary>
        </member>
        <member name="M:Au.Types.FEFile.#ctor(System.String,System.String,Au.Types.Api.WIN32_FIND_DATA@,System.Int32)">
            
        </member>
        <member name="P:Au.Types.FEFile.Name">
            
        </member>
        <member name="P:Au.Types.FEFile.FullPath">
            
        </member>
        <member name="P:Au.Types.FEFile.Size">
            <summary>
            Returns file size. For directories it is usually 0.
            </summary>
        </member>
        <member name="P:Au.Types.FEFile.LastWriteTimeUtc">
            
        </member>
        <member name="P:Au.Types.FEFile.CreationTimeUtc">
            
        </member>
        <member name="P:Au.Types.FEFile.Attributes">
            
        </member>
        <member name="P:Au.Types.FEFile.IsDirectory">
            <summary>
            Returns true if is directory or symbolic link to a directory or mounted folder.
            </summary>
        </member>
        <member name="P:Au.Types.FEFile.Level">
            <summary>
            Descendant level.
            0 if direct child of directoryPath, 1 if child of child, an so on.
            </summary>
        </member>
        <member name="M:Au.Types.FEFile.SkipThisDirectory">
            <summary>
            Call this function if don't want to enumerate children of this subdirectory.
            </summary>
        </member>
        <member name="M:Au.Types.FEFile.ToString">
            <summary>
            Returns FullPath.
            </summary>
        </member>
        <member name="T:Au.Types.IfExists">
            <summary>
            What to do if the destination directory contains a file or directory with the same name as the source file or directory when copying, moving or renaming.
            Used with <see cref="M:Au.Files.Copy(System.String,System.String,Au.Types.IfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})"/>, <see cref="M:Au.Files.Move(System.String,System.String,Au.Types.IfExists)"/> and similar functions.
            When renaming or moving, if the destination is the same as the source, these options are ignored and the destination is simply renamed. For example when renaming "file.txt" to "FILE.TXT".
            </summary>
        </member>
        <member name="F:Au.Types.IfExists.Fail">
            <summary>Throw exception. Default.</summary>
        </member>
        <member name="F:Au.Types.IfExists.Delete">
            <summary>Delete destination.</summary>
        </member>
        <member name="F:Au.Types.IfExists.RenameExisting">
            <summary>Rename (backup) destination.</summary>
        </member>
        <member name="F:Au.Types.IfExists.MergeDirectory">
            <summary>
            If destination directory exists, merge the source directory into it, replacing existing files.
            If destination file exists, deletes it.
            If destination directory exists and source is file, fails.
            </summary>
        </member>
        <member name="T:Au.Types.GIFlags">
            <summary>
            Used with get-icon functions.
            </summary>
        </member>
        <member name="F:Au.Types.GIFlags.LiteralPath">
            <summary>
            The 'file' argument is literal full path. Don't parse "path,index", don't support ".ext" (file type icon), don't make fully-qualified, etc.
            </summary>
        </member>
        <member name="F:Au.Types.GIFlags.SearchPath">
            <summary>
            If file is not full path, call <see cref="M:Au.Files.SearchPath(System.String,System.String[])">Files.SearchPath</see>.
            Without this flag searches only in <see cref="P:Au.Folders.ThisAppImages"/>; with this flag also searches there first.
            </summary>
        </member>
        <member name="T:Au.Types.STIFlags">
            <summary>
            Flags for String_.ToIntX functions.
            </summary>
        </member>
        <member name="F:Au.Types.STIFlags.NoHex">
            <summary>
            Don't support hexadecimal numbers (numbers with prefix "0x").
            </summary>
        </member>
        <member name="F:Au.Types.STIFlags.IsHexWithout0x">
            <summary>
            The number in string is hexadecimal without a prefix, like "1A".
            </summary>
        </member>
        <member name="T:Au.Acc">
            <summary>
            Accessible object.
            </summary>
            <remarks>
            Accessible objects (AO) are various user interface (UI) objects in windows and controls. For example buttons, links, list items. This class can find them, get properties, click, etc. Especially useful with web pages, because there are no controls. And many other windows don't use controls but support AO. But not all UI objects are AO.
            
            An Acc instance holds an AO COM pointer (<msdn>IAccessible</msdn>) and a simple element id (int). Most Acc functions wrap IAccessible interface functions or/and related API.
            
            Acc functions that get properties don't throw exception when the wrapped IAccessible/etc function failed (returned an error code of HRESULT type). Then they return "" (string properties), 0, false, null or empty collection, dependin on return type. Applications implement AOs differently, often with bugs, and their IAccessible interface functions return a variety of error codes. It's impossible to reliably detect whether the error code means a serious error or the property is merely unavailable. These Acc functions also set the last error code of this thread = the return value (HRESULT) of the IAccessible function, and callers can use <see cref="M:Au.Types.Native.GetError"/> to get it. If Native.GetError returns 1 (S_FALSE), in most cases it's not an error, just the property is unavailable. On error it will probably be a negative error code.
            
            You can dispose Acc variables to release the COM object, but it is not necessary (GC will do it later).
            
            An Acc variable cannot be used in multiple threads. Only Dispose can be called in any thread.
            
            AOs are implemented and live in their applications. This class just communicates with them.
            
            Many applications have various problems with their AOs: bugs, incorrect/nonstandard/partial implementation, or initially disabled. This class implements workarounds for known problems, where possible.
            
            Known problematic applications:
            <list type="bullet">
            <item>
            Chrome web browser. Also Opera and other apps that use Chrome code; window class name is like "Chrome_WidgetWin_1".
            
            Web page AOs initially are disabled (missing). Workarounds:
            Functions Find, Wait and FindAll enable it if used role prefix "web:" or "chrome:". Functions FromXY, FromMouse and Focused enable it if window class name starts with "Chrome". However Chrome does it lazily, therefore first time the functions often get wrong AO. Note: this auto-enabing may fail with future Chrome versions.
            Other ways to enable Chrome AOs: 1. Start Chrome with command line --force-renderer-accessibility. 2. In the future the script editor will have an option to enable Chrome AOs when it starts.
            
            Some new web browser versions add new features or bugs that break something. AOs are especially vulnerable, because they are considered second-class citizens.
            </item>
            <item>
            Firefox web browser.
            
            By default, the Find function is 50-100 times slower than it could be. Also for this reason the Wait function consumes much CPU. And HTML attributes may be unavailable. See <see cref="F:Au.Types.AFFlags.NotInProc"/>. Workaround: disable the Firefox multiprocess feature: open URL about:config, find browser.tabs.remote.autostart, set it = false, restart Firefox. If there is no such option, right-click and create it, as Boolean. If there are more than one similar options, set them all = false. Note: Firefox may reset it when upgrading or reinstalling, or even remove it in the future. If this does not work, google how to disable Firefox multiprocess.
            
            When Firefox starts, its web page AOs are unavailable. It creates them only when somebody asks (eg function Find), but does it lazily, and Find at first fails. Workaround: use Wait, not Find.
            
            Ocassionally Firefox briefly turns off its web page AOs. Workaround: use Wait, not Find. With other web browsers also it's better to use Wait.
            
            Some new web browser versions add new features or bugs that break something. AOs are especially vulnerable, because they are considered second-class citizens.
            </item>
            <item>
            Edge web browser, JavaFX and other applications that don't have true accessible objects but have UI Automation elements.
            
            To find AOs in these applications, need flag <see cref="F:Au.Types.AFFlags.UIA"/>.
            </item>
            <item>
            Java applications that use AWT/Swing (window class name starts with "SunAwt").
            
            Not supported on 32-bit OS.
            
            Must be enabled Java Access Bridge (JAB).
            If JAB is disabled or does not work, the "Find accessible object" tool shows an "enable" link when you try to capture something in a Java window. The link calls Au.Tools.Form_Acc.Java.EnableDisableJabUI. Or you can enable JAB in Control Panel -> Ease of Access Center -> Use the computer without a display. Or use jabswitch.exe. Then restart Java apps. Also may need to restart apps that tried to use Java AOs.
            
            Your process must have the same 32/64 bitness as the installed Java. To remove this limitation, install Java 32-bit and 64-bit (they coexist).
            </item>
            <item>
            OpenOffice.
            
            Often crashes after using AOs, usually when closing. Noticed in OpenOffice 4.1.4; may be fixed in newer versions.
            </item>
            <item>
            LibreOffice.
            
            AOs are unavailable unless this process is 32-bit (when LibreOffice is 64-bit). Also need flag <see cref="F:Au.Types.AFFlags.NotInProc"/>.
            </item>
            <item>
            In some windows, AO of some controls are not connected to AO of parent control. Then Find cannot find them if searches in whole window.
            
            Workaround: search only in that control. For example, use prop "class" or id". If it's a web browser control, use role prefix "web:". Or find the control with <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/> and search in it. Or use <see cref="M:Au.Acc.Finder.Find(Au.Wnd,Au.Wnd.ChildFinder)"/>.
            </item>
            <item>
            AOs of many standard Windows controls have bugs when they are retrieved without loading dll into the target process (see <see cref="F:Au.Types.AFFlags.NotInProc"/>).
            Known bugs: 1. Toolbar buttons don't have Name in some cases. 2. <see cref="M:Au.Acc.Focus(System.Boolean)"/> and <see cref="M:Au.Acc.Select(Au.Types.AccSELFLAG)"/> often don't work properly.
            
            Workaround: don't use <see cref="F:Au.Types.AFFlags.NotInProc"/>, or use <see cref="F:Au.Types.AFFlags.UIA"/>.
            </item>
            <item>
            Function Find is much slower when cannot load dll into the target process. More info: <see cref="F:Au.Types.AFFlags.NotInProc"/>. Function Wait then consumes much more CPU.
            </item>
            <item>
            If the process has different 32/64 bitness than this process, to load the dll is launched rundll32.exe, which makes slower by about 50 ms first time.
            </item>
            <item>
            Currently this library does not support auto-scaled windows when using high DPI (text size 125%, 150% or more).
            If the target process is auto-scaled and this process isn't (or vice versa, or they have a different scaling factor), most coordinate-related functions don't work properly. For example, they get wrong AO rectangles.
            </item>
            </list>
            </remarks>
            <example>
            Click link "Example" in Chrome.
            <code><![CDATA[
            var w = +Wnd.Find("* Chrome");
            var a = +Acc.Find(w, "web:LINK", "Example");
            a.DoAction();
            ]]></code>
            Click a link, wait for new web page, click a link in it.
            <code><![CDATA[
            var w = +Wnd.Find("* Chrome");
            var a = Acc.Wait(1, w, "web:LINK", "Link 1");
            a.DoActionAndWaitForNewWebPage();
            a = Acc.Wait(10, w, "web:LINK", "Link 2");
            a.DoActionAndWaitForNewWebPage();
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Acc.WndContainer">
            <summary>
            Gets the container window or control of this accessible object.
            Uses API <msdn>WindowFromAccessibleObject</msdn>.
            </summary>
            <remarks>
            Returns default(Wnd) if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            All objects must support this property, but some have bugs and can fail (return default(Wnd)) or return a wrong window.
            </remarks>
        </member>
        <member name="P:Au.Acc.WndTopLevel">
            <summary>
            Gets the top-level window that contains this accessible object.
            Uses API <msdn>WindowFromAccessibleObject</msdn> and API <msdn>GetAncestor</msdn>.
            </summary>
            <remarks>
            Returns default(Wnd) if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            All objects must support this property, but some have bugs and can return default(Wnd).
            </remarks>
        </member>
        <member name="P:Au.Acc.Rect">
            <summary>
            Gets location of this accessible object in screen.
            </summary>
            <remarks>
            Calls <see cref="M:Au.Acc.GetRect(Au.Types.RECT@)"/>.
            Returns empty rectangle if failed or this property is unavailable. Supports <see cref="M:Au.Types.Native.GetError"/>.
            Most but not all objects support this property.
            </remarks>
        </member>
        <member name="M:Au.Acc.GetRect(Au.Types.RECT@)">
            <summary>
            Gets location of this accessible object in screen.
            Uses <msdn>IAccessible.accLocation</msdn>.
            </summary>
            <param name="r">Receives object rectangle in screen coordinates.</param>
            <remarks>
            Returns false if failed or this property is unavailable. Supports <see cref="M:Au.Types.Native.GetError"/>.
            Most but not all objects support this property.
            </remarks>
        </member>
        <member name="M:Au.Acc.GetRect(Au.Types.RECT@,Au.Wnd)">
            <summary>
            Gets location of this accessible object in the client area of window w.
            Uses <msdn>IAccessible.accLocation</msdn> and <see cref="M:Au.Wnd.MapScreenToClient(Au.Types.RECT@)"/>.
            </summary>
            <param name="r">Receives object rectangle in w client area coordinates.</param>
            <param name="w">Window or control.</param>
            <remarks>
            Returns false if failed or this property is unavailable. Supports <see cref="M:Au.Types.Native.GetError"/>.
            Most but not all objects support this property.
            </remarks>
        </member>
        <member name="P:Au.Acc.RoleInt">
            <summary>
            Gets standard non-string role, as enum AccROLE.
            Uses <msdn>IAccessible.get_accRole</msdn>.
            </summary>
            <remarks>
            Most objects have a standard role, as enum <see cref="T:Au.Types.AccROLE"/>. Some objects have a custom role, usually as string, for example in web pages in Firefox and Chrome.
            Returns 0 if role is string or if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            All objects must support this property. If failed, probably the object is invalid, for example its window was closed.
            </remarks>
        </member>
        <member name="P:Au.Acc.Role">
            <summary>
            Gets standard or custom role, as string.
            Uses <msdn>IAccessible.get_accRole</msdn>.
            </summary>
            <remarks>
            Most objects have a standard role, as enum <see cref="T:Au.Types.AccROLE"/>. Some objects have a custom role, usually as string, for example in web pages in Firefox and Chrome.
            For standard roles this function returns enum <see cref="T:Au.Types.AccROLE"/> member name. For string roles - the string. For unknown non-string roles - the int value like "0" or "500".
            Returns "" if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            All objects must support this property. If failed, probably the object is invalid, for example its window was closed.
            </remarks>
        </member>
        <member name="P:Au.Acc.State">
            <summary>
            Gets object state (flags).
            Uses <msdn>IAccessible.get_accState</msdn>.
            </summary>
            <remarks>
            Returns 0 if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
            <example>
            <code><![CDATA[
            if(a.State.Has_(AccSTATE.INVISIBLE)) Print("has state INVISIBLE");
            if(a.IsInvisible) Print("invisible");
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Acc.IsChecked">
            <summary> Calls <see cref="P:Au.Acc.State"/> and returns true if has state CHECKED. </summary>
        </member>
        <member name="P:Au.Acc.IsDisabled">
            <summary> Calls <see cref="P:Au.Acc.State"/> and returns true if has state UNAVAILABLE. </summary>
            <remarks>Does not check whether this object is in a disabled parent/ancestor object.</remarks>
        </member>
        <member name="P:Au.Acc.IsFocused">
            <summary> Calls <see cref="P:Au.Acc.State"/> and returns true if has state FOCUSED. </summary>
        </member>
        <member name="P:Au.Acc.IsInvisible">
            <summary> Calls <see cref="P:Au.Acc.State"/> and returns true if has state INVISIBLE and does not have state OFFSCREEN. </summary>
            <remarks>
            If the object has both INVISIBLE and OFFSCREEN states, it is either invisible or just offscreen, depending on application etc. Then this function works like Find and similar functions: for most objects returns false (is visible), but for objects that have these roles returns true (invisible): WINDOW, DOCUMENT, PROPERTYPAGE, GROUPING, ALERT, MENUPOPUP.
            Does not check whether this object is in an invisible parent/ancestor object.
            </remarks>
        </member>
        <member name="P:Au.Acc.IsOffscreen">
            <summary> Calls <see cref="P:Au.Acc.State"/> and returns true if has state OFFSCREEN. </summary>
        </member>
        <member name="P:Au.Acc.IsPassword">
            <summary> Calls <see cref="P:Au.Acc.State"/> and returns true if has state PROTECTED. </summary>
            <remarks>This state is used for password fields.</remarks>
        </member>
        <member name="P:Au.Acc.IsPressed">
            <summary> Calls <see cref="P:Au.Acc.State"/> and returns true if has state PRESSED. </summary>
        </member>
        <member name="P:Au.Acc.IsReadonly">
            <summary> Calls <see cref="P:Au.Acc.State"/> and returns true if has state READONLY. </summary>
        </member>
        <member name="P:Au.Acc.IsSelected">
            <summary> Calls <see cref="P:Au.Acc.State"/> and returns true if has state SELECTED. </summary>
        </member>
        <member name="M:Au.Acc._BstrToString(System.Int32,Au.Types.BSTR)">
            <summary>
            Converts BSTR to string and disposes the BSTR.
            If hr is not 0, returns "" (never null).
            </summary>
        </member>
        <member name="P:Au.Acc.Name">
            <summary>
            Gets name.
            Uses <msdn>IAccessible.get_accName</msdn>.
            </summary>
            <remarks>
            Object name usually is its read-only text (eg button text, link text), or its adjacent read-only text (eg text label by this edit box). It usually does not change, therefore can be used to find or identify the object.
            Returns "" if name is unavailable or if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="M:Au.Acc.LibNameOfWindow(Au.Wnd)">
            <summary>
            Gets <see cref="P:Au.Acc.Name"/> of window/control w.
            Returns null if w invalid. Returns "" if failed to get name.
            </summary>
        </member>
        <member name="P:Au.Acc.Value">
            <summary>
            Gets or sets value.
            Uses <msdn>IAccessible.get_accValue</msdn> or <msdn>IAccessible.put_accValue</msdn>.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to set value.</exception>
            <remarks>
            Object value usually is its editable text or some other value that can be changed at run time, therefore in most cases it cannot be used to find or identify the object reliably.
            The 'get' function returns "" if this property is unavailable or if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            Most objects don't support 'set'.
            </remarks>
        </member>
        <member name="P:Au.Acc.Description">
            <summary>
            Gets description.
            Uses <msdn>IAccessible.get_accDescription</msdn>.
            </summary>
            <remarks>
            Returns "" if this property is unavailable or if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="P:Au.Acc.Help">
            <summary>
            Gets help text.
            Uses <msdn>IAccessible.get_accHelp</msdn>.
            </summary>
            <remarks>
            Returns "" if this property is unavailable or if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="P:Au.Acc.UiaId">
            <summary>
            Gets UI Automation element AutomationId property.
            </summary>
            <remarks>
            Only objects found with flag <see cref="F:Au.Types.AFFlags.UIA"/> can have this property.
            Returns "" if this property is unavailable or if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="P:Au.Acc.KeyboardShortcut">
            <summary>
            Gets keyboard shortcut.
            Uses <msdn>IAccessible.get_accKeyboardShortcut</msdn>.
            </summary>
            <remarks>
            Returns "" if this property is unavailable or if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="P:Au.Acc.DefaultAction">
            <summary>
            Gets default action.
            Uses <msdn>IAccessible.get_accDefaultAction</msdn>.
            </summary>
            <remarks>
            Returns "" if this property is unavailable or if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            If this is a Java accessible object, returns all actions that can be used with <see cref="M:Au.Acc.DoJavaAction(System.String)"/>, like "action1, action2, action3", from which the first is considered default and is used by <see cref="M:Au.Acc.DoAction"/>.
            </remarks>
        </member>
        <member name="M:Au.Acc.DoAction">
            <summary>
            Performs the object's default action (see <see cref="P:Au.Acc.DefaultAction"/>). Usually it is 'click', 'press' or similar.
            Uses <msdn>IAccessible.accDoDefaultAction</msdn>.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Fails if the object does not have a default action. Then you can use <see cref="M:Au.Types.ExtensionMethods.MouseClick(Au.Acc,Au.Types.Coord,Au.Types.Coord,Au.Types.MButton)"/>, or try <see cref="M:Au.Acc.VirtualClick"/>, <see cref="M:Au.Acc.Select(Au.Types.AccSELFLAG)"/>, <see cref="M:Au.Acc.Focus(System.Boolean)"/> and keyboard functions.
            The action can take long time, for example show a dialog. This function normally does not wait. It allows the caller to automate the dialog. If it waits, try <see cref="M:Au.Acc.DoJavaAction(System.String)"/> or one of the above functions (MouseClick etc).
            </remarks>
        </member>
        <member name="M:Au.Acc.VirtualClick">
            <summary>
            Posts mouse-left-click message to the container window, using coordinates of this object.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to get rectangle, or the object is invisible/offscreen.</exception>
            <remarks>
            Does not move the mouse.
            Does not wait until the target application finishes processing the message.
            Works not with all objects.
            Use (try) this function when the object does not support <see cref="M:Au.Acc.DoAction"/>. When both don't work, use MouseClick.
            </remarks>
        </member>
        <member name="M:Au.Acc.VirtualRightClick">
            <summary>
            Posts mouse-right-click message to the container window, using coordinates of this object.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to get rectangle, or the object is invisible/offscreen.</exception>
            <remarks>
            Does not move the mouse.
            Does not wait until the target application finishes processing the message.
            Works not with all objects. When does not work, use MouseClick.
            </remarks>
        </member>
        <member name="M:Au.Acc.DoJavaAction(System.String)">
            <summary>
            Performs one of actions supported by this Java accessible object.
            </summary>
            <param name="action">
            Action name. See <see cref="P:Au.Acc.DefaultAction"/>.
            If null (default), performs default action (like <see cref="M:Au.Acc.DoAction"/>) or posts Space key message. More info in Remarks.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Read more about Java accessible objects in <see cref="T:Au.Acc">class help</see>.
            
            Problem: if the action opens a dialog, DoAction/DoJavaAction do not return until the dialog is closed (or fail after some time). The caller then waits and cannot automate the dialog. Also then this process cannot exit until the dialog is closed. If the action parameter is null and the object is focusable, this function tries a workaround: it makes the object (button etc) focused and posts Space key message, which should press the button; then this function does not wait.
            </remarks>
        </member>
        <member name="M:Au.Acc.DoActionAndWaitForNewWebPage(System.Double,System.Action{Au.Acc})">
            <summary>
            Calls <see cref="M:Au.Acc.DoAction"/> or <paramref name="action"/> and waits until window name changes and web page name changes.
            Returns true. On timeout returns false if <paramref name="secondsTimeout"/> is negative; else exception.
            </summary>
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits indefinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, after that time interval returns false.
            Default 60 seconds.
            </param>
            <param name="action">If used, calls it instead of <see cref="M:Au.Acc.DoAction"/>.</param>
            <exception cref="T:System.TimeoutException"><paramref name="secondsTimeout"/> time has expired (if &gt; 0).</exception>
            <exception cref="T:Au.Types.AuException">Failed. For example, when this object is invalid, or its top-level window does not contain a web page.</exception>
            <exception cref="T:Au.Types.WndException">The window was closed while waiting.</exception>
            <exception cref="T:System.Exception">Exceptions thrown by <see cref="M:Au.Acc.DoAction"/> or by the <paramref name="action"/> function.</exception>
            <remarks>
            This function is used to click a link in a web page and wait until current web page is gone. It prevents a following 'wait for object' function from finding a matching object in the old page, which would be bad.
            This function does not wait until the new page is completely loaded. There is no reliable/universal way for it. Instead, after calling it you can call a 'wait for object' function which waits for a known object that must be in the new page.
            This function cannot be used when the new page has the same title as current page. Then it waits until <paramref name="secondsTimeout"/> time or forever. The same if the action does not open a web page.
            </remarks>
        </member>
        <member name="M:Au.Acc.Select(Au.Types.AccSELFLAG)">
            <summary>
            Selects or deselects.
            </summary>
            <param name="how">Specifies whether to select, focus, add to selection etc. Can be two flags, for example <c>AccSELFLAG.TAKEFOCUS | AccSELFLAG.TAKESELECTION</c>.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <exception cref="T:Au.Types.WndException">Failed to activate the window (<see cref="M:Au.Wnd.Activate"/>) or focus the control (<see cref="M:Au.Wnd.Focus"/>).</exception>
            <remarks>
            Uses <msdn>IAccessible.accSelect</msdn>.
            Not all objects support it. Most objects support not all flags. It depends on object <see cref="T:Au.Types.AccSTATE">states</see> FOCUSABLE, SELECTABLE, MULTISELECTABLE, EXTSELECTABLE, DISABLED.
            Many object have bugs, especially with flag TAKEFOCUS. More bugs when the object found with flag NotInProc.
            </remarks>
        </member>
        <member name="M:Au.Acc.Focus(System.Boolean)">
            <summary>
            Makes this object focused for keyboard input.
            </summary>
            <param name="andSelect">Add flag TAKESELECTION. Note: it is for selecting a list item, not for selecting text in a text box.</param>
            <remarks>
            Calls <see cref="M:Au.Acc.Select(Au.Types.AccSELFLAG)"/> with flag TAKEFOCUS and optionally TAKESELECTION.
            Not all objects support this action and not all work correctly. More info in Select documentation.
            </remarks>
        </member>
        <member name="P:Au.Acc.SelectedChildren">
            <summary>
            Gets selected direct child items.
            Returns empty array if there are no selected items of if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
        </member>
        <member name="M:Au.Acc.GetProperties(System.String,Au.Types.AccProperties@)">
            <summary>
            Gets multiple properties.
            </summary>
            <param name="props">
            Which properties to get. Each character specifies a property:
            'R' - <see cref="P:Au.Acc.Role"/>.
            'n' - <see cref="P:Au.Acc.Name"/>.
            'v' - <see cref="P:Au.Acc.Value"/>.
            'd' - <see cref="P:Au.Acc.Description"/>.
            'h' - <see cref="P:Au.Acc.Help"/>.
            'a' - <see cref="P:Au.Acc.DefaultAction"/>.
            'k' - <see cref="P:Au.Acc.KeyboardShortcut"/>.
            'u' - <see cref="P:Au.Acc.UiaId"/>.
            's' - <see cref="P:Au.Acc.State"/>.
            'r' - <see cref="P:Au.Acc.Rect"/>.
            'w' - <see cref="P:Au.Acc.WndContainer"/>.
            'o' - <see cref="M:Au.Acc.Html(System.Boolean)"/> outer.
            'i' - <see cref="M:Au.Acc.Html(System.Boolean)"/> inner.
            '@' - <see cref="M:Au.Acc.HtmlAttributes"/>.
            </param>
            <param name="result">Receives results.</param>
            <exception cref="T:System.ArgumentException">Unknown property character.</exception>
            <remarks>
            The returned variable contains values of properties specified in <paramref name="props"/>. When a property is empty or failed to get, the member variable is "", empty dictionary or default value of that type; never null.
            
            Normally this function is faster than calling multiple property functions, because it makes single remote procedure call. But not if this accessible object was found with flag <see cref="F:Au.Types.AFFlags.NotInProc"/> etc.
            
            Returns false if fails, for example when the object's window is closed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="M:Au.Acc.Navigate(System.String,System.Double)">
            <summary>
            Gets an adjacent or related accessible object (AO) - next, child, parent, etc.
            Returns null if not found.
            </summary>
            <param name="navig">
            String consisting of one or more navigation direction strings separated by space, like "parent next child4 first".
            <list type="bullet">
            <item>"next" - next sibling AO in the same parent AO.</item>
            <item>"previous" - previous sibling AO in the same parent AO.</item>
            <item>"first" - first child AO.</item>
            <item>"last" - last child AO.</item>
            <item>"parent" - parent (container) AO.</item>
            <item>"child" - child AO by 1-based index. Example: "child3" (3-th child). Negative index means from end, for example -1 is the last child.</item>
            <item>"#N" - N is a numeric value to pass to <msdn>IAccessible.accNavigate</msdn> as navDir. Can be any standard or custom value supported by the AO.</item>
            </list>
            Can be only 2 letters, like "pr" for "previous".
            A string like "next3" or "next,3" is the same as "next next next". Except for "child".
            
            For "next", "previous", "firstchild", "lastchild", "#N" is used <msdn>IAccessible.accNavigate</msdn>. Not all AOs support it. Some AOs skip invisible siblings. Instead you can use "parent childN" or "childN".
            For "parent" is used <msdn>IAccessible.get_accParent</msdn>. Few AOs don't support. Some AOs return a different parent than in the AO tree.
            For "child" is used API <msdn>AccessibleChildren</msdn>.
            </param>
            <param name="secondsToWait">Wait for the wanted AO max this number of seconds. If negative, waits forever.</param>
            <exception cref="T:System.ArgumentException">Invalid navig string.</exception>
            <example>
            <code><![CDATA[
            a = +a.Navigate("parent next ch3", true);
            ]]></code>
            </example>
            <seealso cref="P:Au.Acc.Item(System.String,System.Double)"/>
        </member>
        <member name="P:Au.Acc.Item(System.String,System.Double)">
            <summary>
            Calls <see cref="M:Au.Acc.Navigate(System.String,System.Double)"/>.
            </summary>
        </member>
        <member name="M:Au.Acc.Html(System.Boolean)">
            <summary>
            Gets HTML.
            </summary>
            <param name="outer">If true, gets outer HTML (with tag and attributes), else inner HTML.</param>
            <remarks>
            Returns "" if this is not a HTML element or if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            Works with Firefox, Chrome, Internet Explorer and apps that use their code (Thunderbird, Opera, web browser controls...). This object must be found without flag NotInProc.
            If this is the root of web page (role DOCUMENT or PANE), gets web page body HTML.
            </remarks>
        </member>
        <member name="M:Au.Acc.HtmlAttribute(System.String)">
            <summary>
            Gets a HTML attribute.
            </summary>
            <param name="name">Attribute name, for example "href", "id", "class". Full, case-sensitive.</param>
            <remarks>
            Returns "" if this is not a HTML element or does not have the specified attribute or failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            Works with Firefox, Chrome, Internet Explorer and apps that use their code (Thunderbird, Opera, web browser controls...). This object must be found without flag NotInProc.
            </remarks>
            <exception cref="T:System.ArgumentException">name is null/""/invalid.</exception>
        </member>
        <member name="M:Au.Acc.HtmlAttributes">
            <summary>
            Gets all HTML attributes.
            </summary>
            <remarks>
            Returns empty dictionary if this is not a HTML element or does not have attributes or failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            Works with Firefox, Chrome, Internet Explorer and apps that use their code (Thunderbird, Opera, web browser controls...). This object must be found without flag NotInProc.
            </remarks>
        </member>
        <member name="M:Au.Acc.ScrollTo">
            <summary>
            Scrolls this accessible object into view.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to scroll, or the object does not support scrolling.</exception>
            <remarks>
            This function works with these objects:
            <list type="bullet">
            <item>Web page objects in Firefox, Chrome, Internet Explorer and apps that use their code (Thunderbird, Opera, web browser controls...). With Find use role prefix "web:", "firefox:" or "chrome:", and don't use flag <see cref="F:Au.Types.AFFlags.NotInProc"/>.</item>
            <item>Objects in Edge browser, standard treeview and listview controls, some other. With Find use flag <see cref="F:Au.Types.AFFlags.UIA"/>.</item>
            </list>
            </remarks>
        </member>
        <member name="T:Au.Acc.Finder">
            <summary>
            Contains accessible object (AO) properties and is used to find the AO.
            Can be used instead of <see cref="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,Au.Wnd.ChildFinder)"/>.
            </summary>
            <example>
            Find window that contains certain AO, and get the AO too.
            <code><![CDATA[
            var f = new Acc.Finder("BUTTON", "Apply"); //AO properties
            Wnd w = Wnd.Find(className: "#32770", also: t => f.Find(t));
            Print(w);
            Print(f.Result);
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Acc.Finder.Result">
            <summary>
            The found accessible object.
            null if not found. null if used <see cref="P:Au.Acc.Finder.ResultGetProperty"/>.
            </summary>
        </member>
        <member name="P:Au.Acc.Finder.ResultProperty">
            <summary>
            The requested propery of the found accessible object, depending on <see cref="P:Au.Acc.Finder.ResultGetProperty"/>.
            null if: 1. Object not found. 2. ResultGetProperty not used or is '-'. 3. Failed to get the property.
            </summary>
            <remarks>
            The type depends on the property. Most properties are String. Others: <see cref="P:Au.Acc.Rect"/>, <see cref="P:Au.Acc.State"/>, <see cref="P:Au.Acc.WndContainer"/>, <see cref="M:Au.Acc.HtmlAttributes"/>.
            </remarks>
        </member>
        <member name="P:Au.Acc.Finder.ResultGetProperty">
            <summary>
            Set this when you need only some property of the accessible object (name, etc) and not the object itself.
            The value is a character, the same as with <see cref="M:Au.Acc.GetProperties(System.String,Au.Types.AccProperties@)"/>, for example 'n' for Name. Use '-' if you don't need any property.
            </summary>
            <exception cref="T:System.ArgumentException">Parameter <i>also</i> was used.</exception>
            <remarks>
            ResultGetProperty cannot be used with parameter <i>also</i>.
            </remarks>
        </member>
        <member name="M:Au.Acc.Finder.#ctor(System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32)">
            <summary>
            Allows to specify accessible object properties, like with <see cref="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,Au.Wnd.ChildFinder)"/>.
            </summary>
        </member>
        <member name="M:Au.Acc.Finder.Find(Au.Wnd,Au.Wnd.ChildFinder)">
            <summary>
            Finds accessible object (AO) in the specified control of window w.
            Returns true if found. The <see cref="P:Au.Acc.Finder.Result"/> property will be the found AO.
            </summary>
            <param name="w">Window that contains the control.</param>
            <param name="controls">Control properties. This functions searches in all matching controls.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Acc.Finder.Find(Au.Wnd)"/>.</exception>
            <remarks>
            Alternatively you can specify control class name or id in role. How this function is different: 1. Allows to specify more control properties. 2. Works better/faster when the control is of a different process or thread than the parent window; else slightly slower.
            </remarks>
        </member>
        <member name="M:Au.Acc.Finder.Find(Au.Wnd)">
            <summary>
            Finds accessible object (AO) in window w, like <see cref="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,Au.Wnd.ChildFinder)"/>.
            Returns true if found. The <see cref="P:Au.Acc.Finder.Result"/> property will be the found AO.
            </summary>
            <param name="w">Window or control that contains the AO.</param>
            <exception cref="T:System.ArgumentException">
            <i>role</i> is "" or invalid.
            <i>name</i> is invalid wildcard expression ("**options " or regular expression).
            <i>prop</i> has invalid format or contains unknown property names or invalid wildcard expressions.
            Using flag <see cref="F:Au.Types.AFFlags.UIA"/> when searching in web page (role prefix "web:" etc).
            </exception>
            <exception cref="T:Au.Types.WndException">Invalid window.</exception>
            <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher UAC integrity level process.</exception>
        </member>
        <member name="M:Au.Acc.Finder.Find(Au.Acc)">
            <summary>
            Finds accessible object (AO) in another AO, like <see cref="M:Au.Acc.Find(System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32)"/>.
            Returns true if found. The <see cref="P:Au.Acc.Finder.Result"/> property will be the found AO.
            </summary>
            <param name="a">Direct or indirect parent AO.</param>
            <exception cref="T:System.ArgumentNullException">a is null.</exception>
            <exception cref="T:System.ArgumentException">
            <i>role</i> is "" or invalid or has a prefix ("web:" etc).
            <i>name</i> is invalid wildcard expression ("**options " or regular expression).
            <i>prop</i> has invalid format or contains unknown property names or invalid wildcard expressions.
            <see cref="P:Au.Acc.SimpleElementId"/> is not 0.
            Using flag <see cref="F:Au.Types.AFFlags.UIA"/>.
            </exception>
            <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher UAC integrity level process.</exception>
        </member>
        <member name="M:Au.Acc.Finder.Wait(System.Double,Au.Wnd)">
            <summary>
            Finds accessible object (AO) in window w.
            The same as <see cref="M:Au.Acc.Finder.Find(Au.Wnd)"/>, but waits until the AO is found or the given time expires.
            Returns true if found. On timeout returns false if <paramref name="secondsTimeout"/> is negative; else exception.
            Returns true if found. Else if <paramref name="secondsTimeout"/> is negative, returns false. Else exception.
            </summary>
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits indefinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, after that time interval returns false.
            </param>
            <param name="w">Window or control that contains the AO.</param>
            <exception cref="T:System.TimeoutException"><paramref name="secondsTimeout"/> time has expired (if &gt; 0).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Acc.Finder.Find(Au.Wnd)"/>.</exception>
        </member>
        <member name="M:Au.Acc.Finder.Wait(System.Double,Au.Acc)">
            <summary>
            Finds accessible object (AO) in another AO.
            The same as <see cref="M:Au.Acc.Finder.Find(Au.Acc)"/>, but waits until the AO is found or the given time expires.
            Returns true if found. On timeout returns false if <paramref name="secondsTimeout"/> is negative; else exception.
            </summary>
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits indefinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, after that time interval returns false.
            </param>
            <param name="a">Direct or indirect parent AO.</param>
            <exception cref="T:System.TimeoutException"><paramref name="secondsTimeout"/> time has expired (if &gt; 0).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Acc.Finder.Find(Au.Acc)"/>.</exception>
        </member>
        <member name="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,Au.Wnd.ChildFinder)">
             <summary>
             Finds accessible object (AO) in window.
             Returns the found AO. Returns null if not found. See examples.
             </summary>
             <param name="w">Window or control that contains the AO.</param>
             <param name="role">
             AO role, like "LINK". Or path, like "ROLE/ROLE/ROLE".
             See <see cref="P:Au.Acc.Role"/>. Can be used standard roles (see <see cref="T:Au.Types.AccROLE"/>) and custom roles (like "div" in Firefox).
             This parameter is string. If you want to use AccROLE: <c>nameof(AccROLE.CHECKBOX)</c>.
             Case-sensitive, not wildcard. Use null to match any role. Cannot be "".
             
             Role or path can have a prefix:
             <list type="bullet">
             <item>
             "web:" - search only in the visible web page, not in whole window.
             Examples: "web:LINK", "web:/LIST/LISTITEM/LINK".
             Supports Firefox, Chrome, Internet Explorer (IE) and apps that use their code. With other windows, searches in the first found visible AO that has DOCUMENT role.
             <note type="note">Chrome web page accessible objects normally are disabled (don't exist). Use prefix "web:" or "chrome:" to enable.</note>
             Tip: To search only NOT in web pages, use <paramref name="prop"/> "notin=DOCUMENT" (Chrome, Firefox) or "notin=PANE" (IE).
             </item>
             <item>"firefox:" - search only in the visible web page of Firefox or Firefox-based web browser. If w window class name starts with "Mozilla", can be used "web:" instead.</item>
             <item>"chrome:" - search only in the visible web page of Chrome or Chrome-based web browser. If w window class name starts with "Chrome", can be used "web:" instead.</item>
             </list>
             Cannot use prefix when <paramref name="prop"/> contains "id" or "class". Also with flag <see cref="F:Au.Types.AFFlags.UIA"/>. Also when searching in Acc (<see cref="M:Au.Acc.Find(System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32)"/>).
            
             Can be used path consisting of roles separated by "/". Examples:
             <list type="bullet">
             <item>"web:DOCUMENT/div/LIST/LISTITEM/LINK" - find LINK using its full path in web page.</item>
             <item>"web:/div/LIST//LINK" - the empty parts mean 'any role'. For example don't need to specify DOCUMENT because in web pages the first part is always DOCUMENT (Firefox, Chrome) or PANE (IE).</item>
             <item>"web:/div/LIST[4]/LISTITEM[-1]/LINK" - the 4 is 1-based index of div child from which to start searching (4-th, then 3-th, 5-th and so on). It can make faster. Negative means 'index from end', for example use -1 to search in reverse order. Flag <see cref="F:Au.Types.AFFlags.Reverse"/> is not applied to path parts with indexes. If index is invalid, will use the nearest valid index.</item>
             <item>"web:/div/LIST[4!]/LISTITEM[-1!]/LINK" - like the above, but the LIST must be exactly 4-th child (don't search 3-th, 5-th etc) and the LISTITEM must be the last child. This can be useful when waiting (uses less CPU), however useless if AO indices in the window or web page change often.</item>
             <item>"web://[4]/[-1!]/[2]" - index without role.</item>
             <item>"CLIENT/WINDOW/TREE/TREEITEM[-1]" - path in window or control. The first path part is a direct child AO of the WINDOW AO of the window/control. The WINDOW AO itself is not included in the search; if you need it, instead use <see cref="M:Au.Acc.FromWindow(Au.Wnd,Au.Types.AccOBJID,Au.Types.AWFlags)"/>.</item>
             </list>
             </param>
             <param name="name">
             AO name (<see cref="P:Au.Acc.Name"/>).
             String format: <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">wildcard expression</conceptualLink>.
             null means 'any'. "" means 'empty or unavailable'.
             </param>
             <param name="prop">
             Other AO properties and search settings.
             Format: one or more "name=value", separated with "\0" or "\0 ", like "description=xxx\0 @href=yyy". Names must match case. Values of string properties are wildcard expressions.
             
             <list type="bullet">
             <item>
             "class" - search only in child controls that have this class name (see <see cref="P:Au.Wnd.ClassName"/>).
             </item>
             <item>
             "id" - search only in child controls that have this id (see <see cref="P:Au.Wnd.ControlId"/>).
             </item>
             <item>
             "value" - <see cref="P:Au.Acc.Value"/>.
             </item>
             <item>
             "description" - <see cref="P:Au.Acc.Description"/>.
             </item>
             <item>
             "state" - <see cref="P:Au.Acc.State"/>. List of states that the AO must have and/or not have.
             Example: "state=CHECKED, FOCUSABLE, !DISABLED".
             Example: "state=0x100010, !0x1".
             Will find AO that has all states without "!" prefix and does not have any of states with "!" prefix.
             </item>
             <item>
             "rect" - <see cref="P:Au.Acc.Rect"/>. Can be specified left, top, width and/or height, using <see cref="M:Au.Types.RECT.ToString"/> format.
             Example: "rect={L=1155 T=1182 W=132 H=13}".
             Example: "rect={W=132 T=1182}".
             The L T coordinates are relative to the primary screen.
             </item>
             <item>
             "level" - level (see <see cref="P:Au.Acc.Level"/>) at which the AO can be found. Can be exact level, or minimal and maximal level separated by space.
             The default value is 0 1000.
             Alternatively you can use path in role, like "////LINK".
             </item>
             <item>
             "elem" - <see cref="P:Au.Acc.SimpleElementId"/>.
             </item>
             <item>
             "action" - <see cref="P:Au.Acc.DefaultAction"/>.
             </item>
             <item>
             "key" - <see cref="P:Au.Acc.KeyboardShortcut"/>.
             </item>
             <item>
             "help" - <see cref="P:Au.Acc.Help"/>.
             </item>
             <item>
             "uiaid" - <see cref="P:Au.Acc.UiaId"/>.
             </item>
             <item>
             "maxcc" - when searching, skip children of AO that have more than this number of direct children. It can make faster.
             The default value is 10000. It also prevents hanging or crashing when an AO in the object tree has large number of children. For example OpenOffice Calc TABLE has one billion children.
             </item>
             <item>
             "notin" - when searching, skip children of AO that have these roles. It can make faster.
             Example: "notin=TREE,LIST,TOOLBAR".
             Roles in the list must be separated with "," or ", ". Case-sensitive, not wildcard.
             See also: <see cref="F:Au.Types.AFFlags.MenuToo"/>.
             </item>
             <item>
             "@attr" - <see cref="M:Au.Acc.HtmlAttribute(System.String)"/>. Here "attr" is any attribute name.
             Example: "@id=example".
             </item>
             </list>
             </param>
             <param name="flags"></param>
             <param name="also">
             Lambda etc callback function to call for each matching AO. Let it return true if this is the wanted AO.
             Example, the AO must contain point x y: <c>o => o.GetRect(out var r, o.WndTopLevel) &amp;&amp; r.Contains(266, 33)</c>
             </param>
             <param name="skip">
             0-based index of matching AO.
             For example, if 1, the function skips the first matching AO and returns the second.
             </param>
             <param name="controls">
             Properties of child controls where to search.
             This is an alternative for class/id in <paramref name="prop"/>. Allows to specify more control properties. Works better/faster when the control is of a different process or thread than the parent window; else slightly slower.
             </param>
             <exception cref="T:System.ArgumentException">
             role is "" or invalid.
             name is invalid wildcard expression ("**options " or regular expression).
             prop has invalid format or contains unknown property names or invalid wildcard expressions.
             Using flag <see cref="F:Au.Types.AFFlags.UIA"/> when searching in web page (role prefix "web:" etc).
             </exception>
             <exception cref="T:Au.Types.WndException">Invalid w.</exception>
             <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher UAC integrity level process.</exception>
             <remarks>
             This function walks the tree of accessible objects of the window, control or web page, until it finds a matching AO.
             Uses <see cref="M:Au.Acc.Finder.Find(Au.Wnd)"/>. You can use it directly (see example).
             In wildcard expressions supports PCRE regular expressions (prefix "**r ") but not .NET regular expressions (prefix "**R "). They are similar.
             To find web page AOs usually it's better to use <see cref="M:Au.Acc.Wait(System.Double,Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32)"/> instead, it's more reliable.
             More info in <see cref="T:Au.Acc">class help</see>.
             </remarks>
             <example>
             Find link "Example" in web page, and click. Throw NotFoundException if not found.
             <code><![CDATA[
             var w = +Wnd.Find("* Chrome");
             var a = +Acc.Find(w, "web:LINK", "Example");
             a.DoAction();
             ]]></code>
             Try to find link "Example" in web page. Return if not found.
             <code><![CDATA[
             var w = +Wnd.Find("* Chrome");
             var a = Acc.Find(w, "web:LINK", "Example");
             if(a == null) { Print("not found"); return; }
             a.DoAction();
             ]]></code>
             Use a Finder.
             <code><![CDATA[
             var w = +Wnd.Find("* Chrome");
             var f = new Acc.Finder("BUTTON", "Example");
             if(!f.Find(w)) { Print("not found"); return; }
             Acc a = f.Result;
             a.DoAction();
             ]]></code>
             </example>
        </member>
        <member name="M:Au.Acc.Find(System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32)">
            <summary>
            Finds a descendant accessible object (AO) of this AO.
            Returns the found AO. Returns null if not found.
            Parameters etc are as with <see cref="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,Au.Wnd.ChildFinder)"/>.
            </summary>
            <exception cref="T:System.ArgumentException">
            <paramref name="role"/> is "" or invalid or has a prefix ("web:" etc).
            <paramref name="name"/> is invalid wildcard expression ("**options " or regular expression).
            <paramref name="prop"/> has invalid format or contains unknown property names or invalid wildcard expressions or "class", "id".
            <see cref="P:Au.Acc.SimpleElementId"/> is not 0.
            Using flag <see cref="F:Au.Types.AFFlags.UIA"/>.
            </exception>
            <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher UAC integrity level process.</exception>
        </member>
        <member name="M:Au.Acc.Wait(System.Double,Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32)">
            <summary>
            Finds accessible object (AO) in window. Waits until the AO is found or the given time expires.
            Returns the found AO. On timeout returns null if <paramref name="secondsTimeout"/> is negative; else exception.
            Parameters etc are as with <see cref="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,Au.Wnd.ChildFinder)"/>.
            </summary>
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits indefinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, after that time interval returns null.
            </param>
            <param name="w"></param>
            <param name="role"></param>
            <param name="name"></param>
            <param name="prop"></param>
            <param name="flags"></param>
            <param name="also"></param>
            <param name="skip"></param>
            <exception cref="T:System.TimeoutException"><paramref name="secondsTimeout"/> time has expired (if &gt; 0).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,Au.Wnd.ChildFinder)"/>.</exception>
        </member>
        <member name="M:Au.Acc.Wait(System.Double,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32)">
            <summary>
            Finds a descendant accessible object (AO) of this AO. Waits until the AO is found or the given time expires.
            Returns the found AO. On timeout returns null if <paramref name="secondsTimeout"/> is negative; else exception.
            Parameters etc are as with <see cref="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,Au.Wnd.ChildFinder)"/>.
            </summary>
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits indefinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, after that time interval returns null.
            </param>
            <param name="role"></param>
            <param name="name"></param>
            <param name="prop"></param>
            <param name="flags"></param>
            <param name="also"></param>
            <param name="skip"></param>
            <exception cref="T:System.TimeoutException"><paramref name="secondsTimeout"/> time has expired (if &gt; 0).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Acc.Find(System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32)"/>.</exception>
        </member>
        <member name="M:Au.Acc.FindAll(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean})">
            <summary>
            Finds all matching accessible objects in window.
            Returns array of 0 or more elements.
            Parameters etc are as with <see cref="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,Au.Wnd.ChildFinder)"/>.
            </summary>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,Au.Wnd.ChildFinder)"/>.</exception>
            <example>
            Get all taskbar buttons (Windows 10).
            <code><![CDATA[
            var w = +Wnd.Find(null, "Shell_TrayWnd");
            foreach(var a in Acc.FindAll(w, "BUTTON", prop: "level=7")) Print(a);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Acc.FindAll(System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean})">
            <summary>
            Finds all matching descendant accessible objects (AO) of this AO.
            Returns array of 0 or more elements.
            Parameters etc are as with <see cref="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,Au.Wnd.ChildFinder)"/>.
            </summary>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Acc.Find(System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32)"/>.</exception>
            <example>
            Get all taskbar buttons (Windows 10).
            <code><![CDATA[
            var w = +Wnd.Find(null, "Shell_TrayWnd");
            var atb = +Acc.Find(w, "TOOLBAR", "Running applications");
            foreach(var a in atb.FindAll("BUTTON", prop: "level=0")) Print(a);
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Acc.ChildCount">
            <summary>
            Gets the number of direct child objects.
            Uses <msdn>IAccessible.get_accChildCount</msdn>.
            </summary>
        </member>
        <member name="M:Au.Acc.#ctor(System.IntPtr,System.Int32,System.Boolean)">
            <summary>
            Creates Acc from IAccessible and child id.
            By default does not AddRef.
            iacc must not be Is0.
            </summary>
        </member>
        <member name="M:Au.Acc.#ctor(Au.Types.Cpp.Cpp_Acc,System.Boolean)">
            <summary>
            Creates Acc from Cpp_Acc.
            By default does not AddRef.
            x.acc must not be Is0.
            </summary>
        </member>
        <member name="M:Au.Acc._Set(System.IntPtr,System.Int32,Au.Acc._Misc,System.Boolean)">
            <summary>
            Sets fields.
            _iacc must be 0, iacc not 0.
            </summary>
        </member>
        <member name="M:Au.Acc.Dispose(System.Boolean)">
            
        </member>
        <member name="M:Au.Acc.Dispose">
            <summary>
            Releases IAccessible COM object and clears this variable.
            </summary>
        </member>
        <member name="M:Au.Acc.Finalize">
            
        </member>
        <member name="M:Au.Acc.op_UnaryPlus(Au.Acc)">
            <summary>
            If x is not null, returns x, else throws <see cref="T:Au.Types.NotFoundException"/>.
            Alternatively you can use <see cref="M:Au.Types.ExtensionMethods.OrThrow(Au.Acc)"/>. Examples are there.
            </summary>
            <exception cref="T:Au.Types.NotFoundException">x is null.</exception>
        </member>
        <member name="P:Au.Acc.SimpleElementId">
            <summary>
            Gets or changes simple element id, also known as child id.
            </summary>
            <remarks>
            Most accessible objects (AO) are not simple elements. Then this property is 0.
            Often (but not always) this property is the 1-based item index in parent AO. For example LISTITEM in LIST.
            The 'set' function sometimes can be used as a fast alternative to <see cref="M:Au.Acc.Navigate(System.String,System.Double)"/>. It modifies only this variable. It does not check whether the value is valid.
            Simple elements cannot have child AOs.
            </remarks>
        </member>
        <member name="P:Au.Acc.MiscFlags">
            <summary>
            Returns some additional info about this variable, such as how the accessible object was retrieved (inproc, UIA, Java).
            </summary>
        </member>
        <member name="P:Au.Acc.Level">
            <summary>
            Gets or sets indentation level for <see cref="M:Au.Acc.ToString"/>.
            </summary>
            <remarks>
            When Find or similar function finds an accessible object, it sets this property of the Acc variable.
            When searching in a window or control, at level 0 are direct children of the WINDOW object of the window or control. When searching in Acc, at level 0 are direct children of the Acc. When searching in web page (role prefix "web:" etc), at level 0 is the web page object (role DOCUMENT or PANE).
            </remarks>
        </member>
        <member name="P:Au.Acc._Disposed">
            <summary>
            Returns true if this variable is disposed.
            </summary>
        </member>
        <member name="M:Au.Acc.FromWindow(Au.Wnd,Au.Types.AccOBJID,Au.Types.AWFlags)">
            <summary>
            Gets accessible object of window or control or its standard part - client area, titlebar etc.
            Uses API <msdn>AccessibleObjectFromWindow</msdn>.
            </summary>
            <param name="w">Window or control.</param>
            <param name="objid">Window part id. Default AccOBJID.WINDOW. Also can be a custom id supported by that window, cast int to AccOBJID.</param>
            <param name="flags"></param>
            <exception cref="T:Au.Types.WndException">Invalid window.</exception>
            <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher UAC integrity level process.</exception>
        </member>
        <member name="M:Au.Acc.FromXY(System.Drawing.Point,Au.Types.AXYFlags)">
            <summary>
            Gets accessible object from point.
            Uses API <msdn>AccessibleObjectFromPoint</msdn>.
            </summary>
            <param name="p">Coordinates in screen.</param>
            <param name="flags"></param>
            <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher UAC integrity level process.</exception>
        </member>
        <member name="M:Au.Acc.FromXY(Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions,Au.Types.AXYFlags)">
            <summary>
            Gets accessible object from point.
            Uses API <msdn>AccessibleObjectFromPoint</msdn>.
            </summary>
            <param name="x">X coordinate in screen.</param>
            <param name="y">Y coordinate in screen.</param>
            <param name="co">Can be used to specify screen (see <see cref="M:Au.Screen_.FromObject(System.Object)"/>) and/or whether x y are relative to the work area.</param>
            <param name="flags"></param>
            <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher UAC integrity level process.</exception>
        </member>
        <member name="M:Au.Acc.FromMouse(Au.Types.AXYFlags)">
            <summary>
            Gets accessible object from mouse cursor (pointer) position.
            Uses API <msdn>AccessibleObjectFromPoint</msdn>.
            </summary>
            <param name="flags"></param>
            <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher UAC integrity level process.</exception>
        </member>
        <member name="M:Au.Acc.Focused(System.Boolean)">
            <summary>
            Gets the accessible object that has the keyboard focus.
            Returns null if fails.
            </summary>
            <param name="useUIAutomation">
            Use UI Automation API.
            Need this with windows that don't support accessible objects but support UI Automation elements. Can be used with most other windows too.
            More info: <see cref="F:Au.Types.AFFlags.UIA"/>.
            </param>
        </member>
        <member name="M:Au.Acc.FromEvent(Au.Wnd,System.Int32,System.Int32)">
            <summary>
            Gets the accessible object that generated the event that is currently being processed by the callback function used with API <msdn>SetWinEventHook</msdn>.
            Returns null if failed. Suports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <param name="w"></param>
            <param name="idObject"></param>
            <param name="idChild"></param>
            <remarks>
            The parameters are of the callback function.
            Uses API <msdn>AccessibleObjectFromEvent</msdn>.
            Often fails because the object already does not exist, because the callback function is called asynchronously, especially when the event is OBJECT_DESTROY, OBJECT_HIDE, SYSTEM_*END.
            Returns null if failed. Always check the return value, to avoid NullReferenceException. An exception in a callback function used with API <msdn>SetWinEventHook</msdn> kills this process.
            </remarks>
        </member>
        <member name="T:Au.Acc._FuncId">
            <summary>
            Used only for debug.
            </summary>
        </member>
        <member name="M:Au.Acc._Hresult(Au.Acc._FuncId,System.Int32)">
            <summary>
            Calls Native.SetError and returns hr.
            In Debug config also outputs error in red.
            If hr looks like not an error but just the property or action is unavailable, changes it to S_FALSE and does not show error. These are: S_FALSE, DISP_E_MEMBERNOTFOUND, E_NOTIMPL.
            _FuncId also can be char, like (_FuncId)'n' for name.
            </summary>
        </member>
        <member name="M:Au.Acc.ToString">
            <summary>
            Formats string from main properties of this accessible object.
            </summary>
            <remarks>
            The string starts with role. Other properties have format like x="value", where x is a property character like with <see cref="M:Au.Acc.GetProperties(System.String,Au.Types.AccProperties@)"/>; character e is <see cref="P:Au.Acc.SimpleElementId"/>. HTML attributes have format @name="value". In string values are used C# escape sequences, for example \r\n for new line.
            Indentation depends on <see cref="P:Au.Acc.Level"/>.
            </remarks>
            <seealso cref="M:Au.Acc.PrintAll(Au.Wnd,System.String,Au.Types.AFFlags,System.String)"/>
        </member>
        <member name="M:Au.Acc.PrintAll(Au.Wnd,System.String,Au.Types.AFFlags,System.String)">
            <summary>
            Displays properties of all found accessible objects of window w.
            </summary>
            <remarks>
            Uses <see cref="M:Au.Acc.ToString"/>.
            Catches exceptions. On exception prints $"!exception! exceptionType exceptionMessage".
            Parameters are of <see cref="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,Au.Wnd.ChildFinder)"/>.
            By default skips invisible objects and objects in menus. Use flags to include them.
            Chrome web page accessible objects normally are disabled (missing) when it starts. Use role prefix "web:" or "chrome:" to enable. See example.
            </remarks>
            <example>
            Displays visible accessible objects in Chrome web page.
            <code><![CDATA[
            Output.Clear();
            var w = +Wnd.Find("* Chrome");
            Print("---- all ----");
            Acc.PrintAll(w, "web:");
            Print("---- links ----");
            Acc.PrintAll(w, "web:LINK");
            ]]></code>
            </example>
        </member>
        <member name="T:Au.Input">
            <summary>
            Keyboard and clipboard functions.
            </summary>
        </member>
        <member name="P:Au.Input.IsAlt">
            <summary>
            Returns true if Alt key is pressed.
            See also: <see cref="P:System.Windows.Forms.Control.ModifierKeys"/> (gets Ctrl, Shift and Alt).
            </summary>
        </member>
        <member name="P:Au.Input.IsCtrl">
            <summary>
            Returns true if Ctrl key is pressed.
            See also: <see cref="P:System.Windows.Forms.Control.ModifierKeys"/> (gets Ctrl, Shift and Alt).
            </summary>
        </member>
        <member name="P:Au.Input.IsShift">
            <summary>
            Returns true if Shift key is pressed.
            See also: <see cref="P:System.Windows.Forms.Control.ModifierKeys"/> (gets Ctrl, Shift and Alt).
            </summary>
        </member>
        <member name="P:Au.Input.IsWin">
            <summary>
            Returns true if Win key is pressed (left or right).
            See also: <see cref="P:System.Windows.Forms.Control.ModifierKeys"/> (gets Ctrl, Shift and Alt).
            </summary>
        </member>
        <member name="M:Au.Input.IsModified(System.Windows.Forms.Keys)">
            <summary>
            Returns true if one or more of the specified modifier keys are pressed.
            See also: <see cref="P:System.Windows.Forms.Control.ModifierKeys"/> (gets Ctrl, Shift and Alt), <see cref="P:Au.Input.IsWin"/>.
            </summary>
            <param name="modifierKeys">Check only these keys. One or more of these flags: Keys.Control, Keys.Shift, Keys.Menu, Keys_.Windows. Default - all.</param>
            <exception cref="T:System.ArgumentException">modifierKeys contains non-modifier keys.</exception>
            <seealso cref="M:Au.WaitFor.NoModifierKeys(System.Double,System.Windows.Forms.Keys)"/>
        </member>
        <member name="P:Au.Input.IsCapsLock">
            <summary>
            Returns true if the Caps Lock key is in the locked statue.
            </summary>
        </member>
        <member name="P:Au.Input.IsNumLock">
            <summary>
            Returns true if the Num Lock key is in the locked statue.
            </summary>
        </member>
        <member name="P:Au.Input.IsScrollLock">
            <summary>
            Returns true if the Scroll Lock key is in the locked statue.
            </summary>
        </member>
        <member name="M:Au.Input.GetTextCursorRect(Au.Types.RECT@)">
            <summary>
            Gets current text cursor (caret) rectangle in screen coordinates.
            Returns the control that contains it.
            If there is no text cursor or cannot get it (eg it is not a standard text cursor), gets mouse pointer coodinates and returns default(Wnd).
            </summary>
        </member>
        <member name="P:Au.Input.Common">
            <summary>
            This static <see cref="T:Au.Input"/> instance is used by the static 'send keys' functions - <see cref="M:Au.NoClass.Key(System.Object[])"/>, <see cref="M:Au.NoClass.Text(System.String,System.String)"/>, <see cref="M:Au.NoClass.Paste(System.String,System.String)"/> and similar.
            Use it to set options for these functions, for example at the start of your script or in the static constructor of script's class. See the first example.
            Not used by other Input instances. See the second example.
            </summary>
            <example>
            Use static functions.
            <code><![CDATA[
            Input.Common.SleepAfter = 100;
            ...
            Key("Tab Ctrl+V");
            ]]></code>
            Use an Input instance.
            <code><![CDATA[
            var k = new Input();
            k.SleepAfter = 200;
            k.Key("Tab Ctrl+V");
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Input.SleepIn">
            <summary>
            Wait milliseconds after sending each key down and up event.
            Default: 0. Valid values: 0 - 1000 (1 second).
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            If 0 (default), just sleeps briefly after some keys.
            </remarks>
        </member>
        <member name="P:Au.Input.SleepAfter">
            <summary>
            Wait milliseconds when all keys have been sent (before the function returns).
            Default: 50. Valid values: 0 - 5000 (5 seconds).
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="P:Au.Input._KeyFunc.Plus">
            <summary>
            + operator.
            Presses the key and does not release. These keys are auto-released after next key or (keys) that is not followed by +. Also after next mouse click.
            Example: "Ctrl+Shift+A ...".
            Example: "Alt+(F O) ...".
            Example: "Ctrl+" ... Mouse.Click() //Ctrl auto-released here.
            </summary>
        </member>
        <member name="P:Au.Input._KeyFunc.Star">
            <summary>
            * operator.
            1. Repeats the preceding key.
            Example: "Tab*10" //press Tab 10 times.
            2. Just presses (without releasing) or just releases.
            Example: "Ctrl*down" ... "Ctrl*up".
            </summary>
        </member>
        <member name="P:Au.Input._KeyFunc.ParenStart">
            <summary>
            ( operator.
            1. Encloses function arguments.
            Example: SLEEP(500).
            2. Turns off auto-releasing keys pressed with operator +, until ")".
            Example: "Alt+(F O) ...".
            Example: "Ctrl+(" ... Mouse.Click(); Mouse.Click(); ... ")" //Ctrl released here.
            </summary>
        </member>
        <member name="P:Au.Input._KeyFunc.ParenEnd">
            <summary>
            ) operator.
            Releases keys pressed with operator +, when auto-releasing was turned off with operator (. See <see cref="P:Au.Input._KeyFunc.ParenStart"/>.
            </summary>
        </member>
        <member name="T:Au.Input.Misc">
            <summary>
            Less-often used functions related to keyboard input.
            </summary>
        </member>
        <member name="M:Au.Input.Misc.ReadKeyString(System.String)">
            <summary>
            Converts keys string to Keys[] array.
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:Au.Input.Misc.ReadHotkeyString(System.String,System.Windows.Forms.Keys@)">
            <summary>
            Converts hotkey string to Keys.
            For example, if s is "Ctrl+Left", hotkey will be Keys.Left with modifier flag Keys.Control.
            Must be single non-modifier key, preceded by zero or more of modifier keys Ctrl, Shift, Alt, Win, all joined with +.
            Named keys must match case. Keys A-Z don't have to match case.
            Valid hotkey examples: "A", "a", "7", "F12", ".", "End", "Ctrl+D", "Ctrl+Alt+Shift+Win+Left", " Ctrl + U ".
            Invalid hotkey examples: null, "", "A+B", "Ctrl+A+K", "A+Ctrl", "Ctrl+Shift", "Ctrl+", "NoSuchKey", "end".
            Returns false if the string is invalid.
            </summary>
        </member>
        <member name="M:Au.Input.Misc._KeyToModifier(System.Windows.Forms.Keys)">
            <summary>
            If k is Shift, Control, Alt or Win (including left and right), returns it as modifier flag, eg Keys.Shift from Keys.ShiftKey.
            Else returns 0.
            </summary>
        </member>
        <member name="M:Au.Input.Misc._KeynameToKey(System.String,System.Int32,System.Int32)">
            <summary>
            Converts part of string to Keys.
            The string should contain single key name, eg "Esc", "A", "=".
            Returns 0 if invalid key name.
            </summary>
        </member>
        <member name="T:Au.WinImage">
            <summary>
            Captures, finds and clicks images and colors in windows.
            An image is any visible rectangular part of window. A color is any visible pixel of window.
            A WinImage variable holds results of <see cref="M:Au.WinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,System.Boolean})"/> and similar functions (rectangle etc).
            </summary>
        </member>
        <member name="M:Au.WinImage.Capture(Au.Types.RECT)">
            <summary>
            Copies a rectangle of screen pixels to a new Bitmap object.
            </summary>
            <param name="rect">A rectangle in screen coordinates.</param>
            <exception cref="T:Au.Types.AuException">Failed. Probably there is not enough memory for bitmap of this size (with*height*4 bytes).</exception>
            <remarks>
            PixelFormat is always Format32bppRgb.
            </remarks>
            <example>
            <code><![CDATA[
            var file = Folders.Temp + "notepad.png";
            Wnd w = Wnd.Find("* Notepad");
            w.Activate();
            using(var b = WinImage.Capture(w.Rect)) { b.Save(file); }
            Shell.Run(file);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.WinImage.Capture(Au.Wnd,Au.Types.RECT)">
            <summary>
            Copies a rectangle of window client area pixels to a new Bitmap object.
            </summary>
            <param name="w">Window or control.</param>
            <param name="rect">A rectangle in w client area coordinates. Use <c>w.ClientRect</c> to get whole client area.</param>
            <exception cref="T:Au.Types.WndException">Invalid w.</exception>
            <exception cref="T:Au.Types.AuException">Failed. Probably there is not enough memory for bitmap of this size (with*height*4 bytes).</exception>
            <remarks>
            How this is different from <see cref="M:Au.WinImage.Capture(Au.Types.RECT)"/>:
            1. Gets pixels from window's device context (DC), not from screen DC, unless the Aero theme is turned off (on Windows 7). The window can be under other windows. 
            2. If the window is partially or completely transparent, gets non-transparent image.
            3. Does not work with Windows Store app windows (creates black image) and possibly with some other windows.
            4. If the window is DPI-scaled, captures its non-scaled view. And <paramref name="rect"/> must contain non-scaled coordinates.
            </remarks>
        </member>
        <member name="M:Au.WinImage.BitmapFromHbitmap(System.IntPtr)">
            <summary>
            Creates Bitmap from a GDI bitmap.
            </summary>
            <param name="hbitmap">GDI bitmap handle. This function makes its copy.</param>
            <remarks>
            How this function is different from <see cref="M:System.Drawing.Image.FromHbitmap(System.IntPtr)"/>:
            1. Image.FromHbitmap usually creates bottom-up bitmap, which is incompatible with <see cref="M:Au.WinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,System.Boolean})"/>. This function creates normal top-down bitmap, like <c>new Bitmap(...)</c>, <c>Bitmap.FromFile(...)</c> etc do.
            2. This function always creates bitmap of PixelFormat Format32bppRgb.
            </remarks>
            <exception cref="T:Au.Types.AuException">Failed. For example hbitmap is default(IntPtr).</exception>
            <exception cref="T:System.Exception">Exceptions of Bitmap(int, int, PixelFormat) constructor.</exception>
        </member>
        <member name="M:Au.WinImage.LoadImage(System.String)">
            <summary>
            Loads image from file, string or resource.
            <see cref="M:Au.WinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,System.Boolean})"/> uses this function when <i>image</i> argument type is string. More info there.
            </summary>
            <param name="file"></param>
            <exception cref="T:System.IO.FileNotFoundException">The specified file does not exist.</exception>
            <exception cref="T:System.Exception">Depending on <paramref name="file"/> string format, exceptions of <see cref="M:System.Drawing.Image.FromFile(System.String)"/>, <see cref="M:System.Drawing.Bitmap.#ctor(System.IO.Stream)"/>, <see cref="M:Au.Convert_.Decompress(System.Byte[],System.Int32,System.Int32)"/>.</exception>
            <exception cref="T:System.ArgumentException">Bad image format (the image cannot be loaded as Bitmap).</exception>
        </member>
        <member name="M:Au.WinImage.op_UnaryPlus(Au.WinImage)">
            <summary>
            If x is not null, returns x, else throws <see cref="T:Au.Types.NotFoundException"/>.
            Alternatively you can use <see cref="M:Au.Types.ExtensionMethods.OrThrow(Au.WinImage)"/>. Examples are there.
            </summary>
            <exception cref="T:Au.Types.NotFoundException">x is null.</exception>
        </member>
        <member name="F:Au.WinImage.Rect">
            <summary>
            Location of the found image.
            Relative to the window/control client area (if area type is Wnd), accessible object (if Acc), image (if Bitmap) or screen (if RECT).
            More info: <see cref="M:Au.WinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,System.Boolean})"/>.
            </summary>
        </member>
        <member name="P:Au.WinImage.MatchIndex">
            <summary>
            When there are multiple matching images, this is the 0-based index of current matching image.
            Can be used in callback function to create action "skip n matching images". Example: <c>also: t => t.MatchIndex==1</c>.
            When the <i>image</i> argument specifies multiple images, this will start from 0 for each image.
            </summary>
        </member>
        <member name="P:Au.WinImage.ListIndex">
            <summary>
            When the image argument specifies multiple images, this is the 0-based index of the found image in the list.
            </summary>
        </member>
        <member name="M:Au.WinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,System.Boolean})">
            <summary>
            Finds image(s) or color(s) displayed in window or other area.
            Returns <see cref="T:Au.WinImage"/> object containing the rectangle of the found image.
            Returns null if not found. To throw exception you can use operator +: <c>var r = +WinImage.Find(...);</c>
            </summary>
            <param name="area">
            Where to search. Can be a window/control, accessible object, another image or a rectangle in screen.
            <list type="bullet">
            <item><see cref="T:Au.Wnd"/> - window or control. The search area is its client area.</item>
            <item><see cref="T:Au.Acc"/> - accessible object.</item>
            <item><see cref="T:System.Drawing.Bitmap"/> - another image. These flags are invalid: <see cref="F:Au.Types.WIFlags.WindowDC"/>.</item>
            <item><see cref="T:Au.Types.RECT"/> - a rectangle area in screen. These flags are invalid: <see cref="F:Au.Types.WIFlags.WindowDC"/>.</item>
            <item><see cref="T:Au.Types.WIArea"/> - can contain Wnd, Acc or Bitmap. Also allows to specify a rectangle in it, which makes the search area smaller and the function faster. Example: <c>WinImage.Find(new WIArea(w, 100, 100, 100, 100), "image.png");</c>.</item>
            </list>
            </param>
            <param name="image">
            Image or color to find. Can be:
            string - path of .png or .bmp file. If not full path, uses <see cref="P:Au.Folders.ThisAppImages"/>. Also can use resources and embedded images; read in Remarks.
            Bitmap - image object in memory.
            int, ColorInt or Color - color. Int must be in 0xRRGGBB format. Alpha is not used.
            IEnumerable of string, Bitmap, int/ColorInt/Color or object - multiple images or colors. Default action - find any. If flag <see cref="F:Au.Types.WIFlags.AllMustExist"/> - must find all.
            </param>
            <param name="flags"></param>
            <param name="colorDiff">Maximal allowed color difference. Use to to find images that have slightly different colors than the specified image. Can be 0 - 250, but should be as small as possible. Applied to each color component (red, green, blue) of each pixel.</param>
            <param name="also">
            A callback function to call for each found image until it returns true.
            Can be used to create actions like "skip n matching images" (like <c>also: t => t.MatchIndex == 1</c>), "click all matching images" (<c>also: t => { t.MouseClick(); 0.5.s(); return false; }</c>), "get rectangles of all matching images" (<c>also: t => { rectList.Add(t.Rect); return false; }</c>), "ignore images that are or aren't in some custom areas", etc.
            When the callback function returns true, Find() returns result "found". Else Find() tries to find more matching images (towards the right and bottom) and calls the callback function again when found. If the callback function always returns false, Find() returns result "not found".
            </param>
            <exception cref="T:Au.Types.WndException">Invalid window handle (the area argument).</exception>
            <exception cref="T:System.ArgumentException">An argument is of unsupported type or is/contains a null/invalid value.</exception>
            <exception cref="T:System.IO.FileNotFoundException">The specified file does not exist.</exception>
            <exception cref="T:System.Exception">Depending on <paramref name="image"/> string format, exceptions of <see cref="M:System.Drawing.Image.FromFile(System.String)"/>, <see cref="M:System.Drawing.Bitmap.#ctor(System.IO.Stream)"/>, <see cref="M:Au.Convert_.Decompress(System.Byte[],System.Int32,System.Int32)"/>.</exception>
            <exception cref="T:Au.Types.AuException">Something failed.</exception>
            <remarks>
            If <paramref name="image"/> is file path, and the file does not exist, looks in resources of apdomain's entry assembly. For example, looks for Project.Properties.Resources.X if file @"C:\X.png" not found. Alternatively you can use code like <c>using(var b = Project.Properties.Resources.X) WinImage.Find(w, b);</c>.
            
            <paramref name="image"/> can be string containing Base-64 encoded .png image file data with prefix "image:" or compressed .bmp file data with prefix "~:". Created by Au.Controls.ImageUtil.ImageToString.
            
            Some pixels in image can be transparent or partially transparent (AA of 0xAARRGGBB is not 255). These pixels are not compared.
            
            The speed mostly depends on:
            1. The size of the search area. Use the smallest possible area (control or accessible object or rectangle in window like <c>new WIArea(w, rectangle)</c>).
            2. Flag <see cref="F:Au.Types.WIFlags.WindowDC"/>. Usually makes several times faster. With this flag the speed depends on window.
            3. Video driver. Can be eg 10 times slower if incorrect or generic driver is used, for example on a virtual PC. Flag <see cref="F:Au.Types.WIFlags.WindowDC"/> should help.
            4. <paramref name="colorDiff"/>. Should be as small as possible.
            
            If flag <see cref="F:Au.Types.WIFlags.WindowDC"/> is not used, the search area must be visible on the screen. If it is covered by other windows, the function will search in these windows.
            
            The function can only find images that exactly match the specified image. With <paramref name="colorDiff"/> it can find images with slightly different colors and brightness. It cannot find images with different shapes.
            
            This function is not the best way to find objects when the script is intended for long use or for use on multiple computers or must be very reliable. Because it may fail to find the image after are changed some settings - system theme, application theme, text size (DPI), font smoothing (if the image contains text), etc. Also are possible various unexpected temporary conditions that may distort or hide the image, for example adjacent window shadow, a tooltip or some temporary window. If possible, in such scripts instead use other functions, eg find control or accessible object.
            
            Throws ArgumentException if image or area is a bottom-up Bitmap object (see <see cref="P:System.Drawing.Imaging.BitmapData.Stride"/>). Such bitmaps are unusual in .NET (GDI+), but can be created by Image.FromHbitmap; instead use <see cref="M:Au.WinImage.BitmapFromHbitmap(System.IntPtr)"/>.
            </remarks>
        </member>
        <member name="M:Au.WinImage.Wait(System.Double,Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,System.Boolean})">
            <summary>
            Waits for image(s) or color(s) displayed in window or other area.
            Returns <see cref="T:Au.WinImage"/> object containing the rectangle of the found image.
            On timeout returns false if <paramref name="secondsTimeout"/> is negative (else exception).
            </summary>
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits indefinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, after that time interval returns null.
            </param>
            <param name="area"></param>
            <param name="image"></param>
            <param name="flags"></param>
            <param name="colorDiff"></param>
            <param name="also"></param>
            <exception cref="T:System.TimeoutException">Timeout. Thrown only when secondsTimeout is greater than 0.</exception>
            <remarks>
            Parameters and other info is the same as with <see cref="M:Au.WinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,System.Boolean})"/>.
            </remarks>
        </member>
        <member name="M:Au.WinImage.WaitNot(System.Double,Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,System.Boolean})">
            <summary>
            Waits until image(s) or color(s) is NOT displayed in window or other area.
            Returns true. On timeout returns false if <paramref name="secondsTimeout"/> is negative (else exception).
            </summary>
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits indefinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, after that time interval returns false.
            </param>
            <param name="area"></param>
            <param name="image"></param>
            <param name="flags"></param>
            <param name="colorDiff"></param>
            <param name="also"></param>
            <remarks>
            Parameters and other info is the same as with <see cref="M:Au.WinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,System.Boolean})"/>.
            </remarks>
        </member>
        <member name="M:Au.WinImage.WaitChanged(System.Double,Au.Types.WIArea,Au.Types.WIFlags,System.Int32)">
            <summary>
            Waits until something visually changes in window or other area.
            Returns true. On timeout returns false if <paramref name="secondsTimeout"/> is negative (else exception).
            </summary>
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits indefinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, after that time interval returns false.
            </param>
            <param name="area"></param>
            <param name="flags"></param>
            <param name="colorDiff"></param>
            <remarks>
            Parameters and other info is the same as with <see cref="M:Au.WinImage.WaitNot(System.Double,Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,System.Boolean})"/> and <see cref="M:Au.WinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,System.Boolean})"/>. Instead of <i>image</i> parameter, this function captures the area image at the beginning.
            </remarks>
        </member>
        <member name="T:Au.OnScreenRect">
            <summary>
            Shows a transparent rectangle on screen.
            For it creates a temporary partially transparent window.
            </summary>
        </member>
        <member name="M:Au.OnScreenRect.#ctor">
            
        </member>
        <member name="M:Au.OnScreenRect.Dispose">
            <summary>
            Destroys the rectangle window.
            </summary>
        </member>
        <member name="P:Au.OnScreenRect.Handle">
            <summary>
            Gets the rectangle window.
            </summary>
        </member>
        <member name="P:Au.OnScreenRect.Color">
            <summary>
            Gets or sets rectangle color.
            </summary>
            <remarks>
            Don't use white. It is used to create transparent interior when Opacity is 0 (default).
            </remarks>
            <example>
            <code><![CDATA[
            x.Color = 0xFF0000; //red
            x.Color = Color.Orange;
            ]]></code>
            </example>
        </member>
        <member name="P:Au.OnScreenRect.Thickness">
            <summary>
            Gets or sets rectangle frame width.
            Used only if Opacity is 0 (default).
            </summary>
        </member>
        <member name="P:Au.OnScreenRect.Opacity">
            <summary>
            Gets or sets the opacity of the rectangle, from 0 to 1.
            If 0 (default) draws opaque frame and completely transparent interior. Else draws filled rectangle.
            </summary>
        </member>
        <member name="P:Au.OnScreenRect.Rect">
            <summary>
            Gets or sets rectangle position in screen.
            If the rectangle window is already created, moves it.
            </summary>
        </member>
        <member name="P:Au.OnScreenRect.Visible">
            <summary>
            Gets or sets whether the rectangle is visible.
            The 'set' function calls <see cref="M:Au.OnScreenRect.Show(System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Au.OnScreenRect.Show(System.Boolean)">
            <summary>
            Shows or hides the rectangle.
            </summary>
            <param name="show">If true, creates the rectangle window or just makes visible. Else hides the window; does not destroy.</param>
        </member>
        <member name="T:Au.Screen_">
            <summary>
            Extends the .NET class Screen.
            </summary>
        </member>
        <member name="F:Au.Screen_.Primary">
            <summary>
            Screen index of the primary screen. Value 0.
            Values greater than 0 are used for non-primary screens: 1 - first non-primary, 2 second...
            </summary>
        </member>
        <member name="F:Au.Screen_.OfMouse">
            <summary>
            Special screen index to specify the screen of the mouse pointer. Value -1.
            </summary>
        </member>
        <member name="F:Au.Screen_.OfActiveWindow">
            <summary>
            Special screen index to specify the screen of the active window. Value -2.
            </summary>
        </member>
        <member name="M:Au.Screen_.FromIndex(System.Int32,System.Boolean)">
            <summary>
            Gets <see cref="T:System.Windows.Forms.Screen"/> object from screen index.
            </summary>
            <param name="index">
            Values greater than 0 are used for non-primary screens: 1 - first non-primary, 2 second...
            Also can be <see cref="F:Au.Screen_.Primary"/> (0), <see cref="F:Au.Screen_.OfMouse"/> (-1), <see cref="F:Au.Screen_.OfActiveWindow"/> (-2).
            </param>
            <param name="noThrow">Don't throw exception if index is invalid. Instead show warning and return null.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid screen index.</exception>
            <remarks>
            Uses <see cref="P:System.Windows.Forms.Screen.AllScreens"/> to get screen indices. They may not match the indices that you can see in Control Panel.
            </remarks>
        </member>
        <member name="M:Au.Screen_.GetIndex_(System.Windows.Forms.Screen)">
            <summary>
            Gets screen index that can be used with <see cref="M:Au.Screen_.FromIndex(System.Int32,System.Boolean)"/> (also with FromObject and some other functions of this library).
            Primary screen is 0. Values greater than 0 are used for non-primary screens: 1 - first non-primary, 2 second...
            </summary>
            <param name="t"></param>
            <exception cref="T:Au.Types.AuException">Failed (probably the Screen object is invalid).</exception>
        </member>
        <member name="M:Au.Screen_.FromWindow(Au.Wnd)">
            <summary>
            Gets <see cref="T:System.Windows.Forms.Screen"/> object of the screen that contains the specified window (the biggest part of it) or is nearest to it.
            If w handle is 0 or invalid, gets the primary screen (<see cref="M:System.Windows.Forms.Screen.FromHandle(System.IntPtr)"/> would return an invalid object if the window handle is invalid).
            </summary>
        </member>
        <member name="M:Au.Screen_.FromObject(System.Object)">
            <summary>
            Gets <see cref="T:System.Windows.Forms.Screen"/> object by index or of the screen that contains (or is nearest to) the specified window, rectangle or point.
            </summary>
            <param name="screen">
            Depends on type:
            <list type="bullet">
            <item>null - gets primary screen.</item>
            <item><see cref="T:System.Windows.Forms.Screen"/> - returns it if valid. If invalid, gets primary screen.</item>
            <item>int - 1-based non-primary screen index (see <see cref="M:Au.Screen_.FromIndex(System.Int32,System.Boolean)"/>), or Screen_.Primary (0), Screen_.OfMouse (-1), Screen_.OfActiveWindow (-2).</item>
            <item><see cref="T:Au.Wnd"/> - gets screen of this window or control (see <see cref="M:Au.Screen_.FromWindow(Au.Wnd)"/>). If invalid, gets primary screen.</item>
            <item><see cref="T:System.Windows.Forms.Control"/> - gets screen of this .NET form or control (see <see cref="M:System.Windows.Forms.Screen.FromControl(System.Windows.Forms.Control)"/>). If invalid, gets primary screen.</item>
            <item><see cref="T:System.Drawing.Point"/> - gets screen of this point (see <see cref="M:System.Windows.Forms.Screen.FromPoint(System.Drawing.Point)"/>).</item>
            <item><see cref="T:System.Drawing.Rectangle"/>, <see cref="T:Au.Types.RECT"/> - gets screen of this rectangle (see <see cref="M:System.Windows.Forms.Screen.FromRectangle(System.Drawing.Rectangle)"/>).</item>
            <item><see cref="T:Au.Acc"/> - gets screen of this accessible object (see <see cref="M:System.Windows.Forms.Screen.FromRectangle(System.Drawing.Rectangle)"/>).</item>
            </list>
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid screen index.</exception>
            <exception cref="T:System.ArgumentException">Bad object type (not one from the above list).</exception>
            <remarks>
            If something fails (except if invalid index), gets primary screen.
            Uses <see cref="P:System.Windows.Forms.Screen.AllScreens"/> to get screen indices. They may not match the indices that you can see in Control Panel.
            </remarks>
        </member>
        <member name="P:Au.Screen_.Width">
            <summary>
            Gets primary screen width.
            </summary>
        </member>
        <member name="P:Au.Screen_.Height">
            <summary>
            Gets primary screen height.
            </summary>
        </member>
        <member name="P:Au.Screen_.Rect">
            <summary>
            Gets primary screen rectangle.
            </summary>
        </member>
        <member name="M:Au.Screen_.GetRect(System.Object,System.Boolean)">
            <summary>
            Gets screen rectangle.
            </summary>
            <param name="screen">Screen index etc, see <see cref="M:Au.Screen_.FromObject(System.Object)"/>. If null - primary screen.</param>
            <param name="workArea">Get work area rectangle.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid screen index.</exception>
        </member>
        <member name="P:Au.Screen_.WorkArea">
            <summary>
            Gets primary screen work area.
            </summary>
        </member>
        <member name="M:Au.Screen_.IsInAnyScreen(System.Drawing.Point)">
            <summary>
            Returns true if point p is in some screen.
            </summary>
        </member>
        <member name="M:Au.Screen_.IsInAnyScreen(Au.Types.RECT)">
            <summary>
            Returns true if rectangle r intersects with some screen.
            </summary>
        </member>
        <member name="M:Au.Screen_.IsInAnyScreen(Au.Wnd)">
            <summary>
            Returns true if rectangle of window w intersects with some screen.
            </summary>
        </member>
        <member name="T:Au.Regex_">
            <summary>
            PCRE regular expression.
            </summary>
            <remarks>
              <para>PCRE is a regular expression library: <see href="https://www.pcre.org/" />.</para>
              <para>PCRE regular expression syntax: <see href="https://www.pcre.org/current/doc/html/pcre2pattern.html">full</see>, <see href="https://www.pcre.org/current/doc/html/pcre2syntax.html">short</see>.</para>
              <para>Recommended website: <see href="http://www.rexegg.com/" />.</para>
              <para>This class is an alternative to the .NET <see cref="T:System.Text.RegularExpressions.Regex" /> class. The regular expression syntax is similar. PCRE has some features unavailable in .NET, and vice versa. In most cases PCRE is about 2 times faster. You can use any of these classes. Functions of <see cref="T:Au.Acc" /> class support only PCRE.</para>
              <para>Terms used in this documentation and in names of functions and types: </para>
              <list type="bullet">
                <item>
                  <term>regular expression</term>
                  <description>Regular expression string. Also known as <i>pattern</i>.</description>
                </item>
                <item>
                  <term>subject string</term>
                  <description>The string in which to search for the regular expression. Also known as <i>input string</i>.</description>
                </item>
                <item>
                  <term>match</term>
                  <description>The part (substring) of the subject string that matches the regular expression.</description>
                </item>
                <item>
                  <term>group</term>
                  <description>Regular expression part enclosed in (). Except non-capturing parts, like (?:...) and (?options). Also known as <i>capturing group</i>, <i>capturing subpattern</i>. Often term <i>group</i> also is used for group matches.</description>
                </item>
                <item>
                  <term>group match</term>
                  <description>The part (substring) of the subject string that matches the group. Also known as <i>captured substring</i>.</description>
                </item>
              </list>
             This library uses an unmanaged code dll AuCpp.dll that contains PCRE code. This class is a managed wrapper for it. The main PCRE API functions used by this class are <see href="https://www.pcre.org/current/doc/html/pcre2api.html">pcre2_compile and pcre2_match</see>. The Regex_ constructor calls pcre2_compile and stores the compiled code in the variable. Other Regex_ functions call pcre2_match. Compiling to native code (JIT) is not supported. A Regex_ variable can be used by multiple threads simultaneously. Also there are several String extension methods that use this class. The string variable is the subject string. These methods create and use cached Regex_ instances for speed. The Regex_ constructor does not use caching.
            </remarks>
            <example>
              <code><![CDATA[
            var s = "one two22, three333,four"; //subject string
            var x = new Regex_(@"\b(\w+?)(\d+)\b"); //regular expression
             
             Print("//IsMatch:");
            Print(x.IsMatch(s));
             
             Print("//Match:");
            if(x.Match(s, out var m)) Print(m.Value, m[1].Value, m[2].Value);
             
             Print("//FindAll with foreach:");
            foreach(var v in x.FindAll(s)) Print(v.Value, v[1].Value, v[2].Value);
             Print("//FindAllS, get only strings of group 2:");
            Print(x.FindAllS(s, 2));
             
             Print("//Replace:");
            Print(x.Replace(s, "'$2$1'"));
             Print("//Replace with callback:");
            Print(x.Replace(s, o => o.Value.ToUpper_()));
             Print("//Replace with callback and ExpandReplacement:");
            Print(x.Replace(s, o => { if(o.Length > 5) return o.ExpandReplacement("'$2$1'"); else return o[1].Value; }));
             
             Print("//Split:");
            Print(new Regex_(@" *, *").Split(s));
            ]]></code>
             Examples with String extension methods. 
            <code><![CDATA[
            var s = "one two22, three333,four"; //subject string
            var rx = @"\b(\w+?)(\d+)\b"; //regular expression
             
             Print("//RegexIsMatch_:");
            Print(s.RegexIsMatch_(rx));
             
             Print("//RegexMatch_:");
            if(s.RegexMatch_(rx, out var m)) Print(m.Value, m[1].Value, m[2].Value);
             
             Print("//RegexMatch_, get only string:");
            if(s.RegexMatch_(rx, 0, out var s0)) Print(s0);
             Print("//RegexMatch_, get only string of group 1:");
            if(s.RegexMatch_(rx, 1, out var s1)) Print(s1);
             
             Print("//RegexFindAll_ with foreach:");
            foreach(var v in s.RegexFindAll_(rx)) Print(v.Value, v[1].Value, v[2].Value);
             
             Print("//RegexFindAll_ with foreach, get only strings:");
            foreach(var v in s.RegexFindAll_(rx, 0)) Print(v);
             Print("//RegexFindAll_ with foreach, get only strings of group 2:");
            foreach(var v in s.RegexFindAll_(rx, 2)) Print(v);
             
             Print("//RegexFindAll_, get array:");
            if(s.RegexFindAll_(rx, out var am)) foreach(var k in am) Print(k.Value, k[1].Value, k[2].Value);
             
             Print("//RegexFindAll_, get array of strings:");
            if(s.RegexFindAll_(rx, 0, out var av)) Print(av);
             Print("//RegexFindAll_, get array of group 2 strings:");
            if(s.RegexFindAll_(rx, 2, out var ag)) Print(ag);
             
             Print("//RegexReplace_:");
            Print(s.RegexReplace_(rx, "'$2$1'"));
             
             Print("//RegexReplace_ with callback:");
            Print(s.RegexReplace_(rx, o => o.Value.ToUpper_()));
             Print("//RegexReplace_ with callback and ExpandReplacement:");
            Print(s.RegexReplace_(rx, o => { if(o.Length > 5) return o.ExpandReplacement("'$2$1'"); else return o[1].Value; }));
             
             Print("//RegexReplace_, get replacement count:");
            if(0 != s.RegexReplace_(rx, "'$2$1'", out var s2)) Print(s2);
             
             Print("//RegexReplace_ with callback, get replacement count:");
            if(0 != s.RegexReplace_(rx, o => o.Value.ToUpper_(), out var s3)) Print(s3);
             
             Print("//RegexSplit_:");
            Print(s.RegexSplit_(@" *, *"));
            ]]></code></example>
        </member>
        <member name="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)">
            <summary>
            Compiles regular expression string.
            
            PCRE regular expression syntax: <see href="https://www.pcre.org/current/doc/html/pcre2pattern.html">full</see>, <see href="https://www.pcre.org/current/doc/html/pcre2syntax.html">short</see>.
            </summary>
            <param name="rx">
            Regular expression. Cannot be null.
            </param>
            <param name="flags">
            Options.
            Default 0. Flag <see cref="F:Au.Types.RXFlags.UTF"/> is implicitly added if <paramref name="rx"/> contains non-ASCII characters and <paramref name="flags"/> does not contain <see cref="F:Au.Types.RXFlags.NEVER_UTF"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or failed to compile it for some other reason (unlikely).</exception>
            <remarks>
            Calls PCRE API function <see href="https://www.pcre.org/current/doc/html/pcre2api.html">pcre2_compile</see>.
            
            Examples in class help: <see cref="T:Au.Regex_"/>.
            </remarks>
        </member>
        <member name="M:Au.Regex_.Finalize">
            
        </member>
        <member name="P:Au.Regex_.Callout">
            <summary>
            Sets callout callback function.
            </summary>
            <value>Callback delegate (eg lambda) or null.</value>
            <remarks>
            Callouts can be used to: 1. Track the matching progress. 2. Get all instances of a group that can match multiple times. 3. Evaluate and reject some matches or match parts. 4. Etc.
            The callback function is called by <see cref="M:Au.Regex_.IsMatch(System.String,Au.Types.RXMore)"/>, <see cref="M:Au.Regex_.Match(System.String,Au.Types.RXMatch@,Au.Types.RXMore)"/>, <see cref="M:Au.Regex_.FindAll(System.String,Au.Types.RXMore)"/>, <see cref="M:Au.Regex_.Replace(System.String,System.String,System.Int32,Au.Types.RXMore)"/>, <see cref="M:Au.Regex_.Split(System.String,System.Int32,Au.Types.RXMore)"/> and similar functions, when they reach callout points in regular expression. To insert callout points use (?C), (?C1), (?C2), (?C'name') etc or pass flag AUTO_CALLOUT to the constructor.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            See also: <see href="http://www.rexegg.com/pcre-callouts.html"/>
            </remarks>
            <example>
            Track the matching progress.
            <code><![CDATA[
            var s = "text <a href='url'>link</a> text";
            var rx = @"(?C1)<a (?C2)href='.+?'>(?C3)[^<]*(?C4)</a>";
            var x = new Regex_(rx);
            x.Callout = o => { Print(o.callout_number, o.current_position, s.Substring(o.start_match, o.current_position), rx.Substring(o.pattern_position, o.next_item_length)); };
            Print(x.IsMatch(s));
            ]]></code>
            Track the matching progress with flag AUTO_CALLOUT.
            <code><![CDATA[
            var s = "one 'two' three";
            var rx = @"'(.+?)'";
            var x = new Regex_(rx, RXFlags.AUTO_CALLOUT);
            x.Callout = o => Print(o.current_position, o.pattern_position, rx.Substring(o.pattern_position, o.next_item_length));
            Print(x.IsMatch(s));
            ]]></code>
            Get all instances of a group that can match multiple times.
            <code><![CDATA[
            var s = "BEGIN 111 2222 333 END";
            var x = new Regex_(@"^(\w+) (?:(\d+) (?C1))+(\w+)$");
            var a = new List<string>();
            x.Callout = o => a.Add(o.LastGroupValue);
            if(!x.Match(s, out var m)) { Print("no match"); return; }
            Print(m[1]);
            Print(a); //all numbers. m[2] contains only the last number.
            Print(m[3]);
            ]]></code>
            Evaluate and reject some matches or match parts. This code rejects matches longer than 5.
            <code><![CDATA[
            var s = "one 123-5 two 12-456 three 1-34 four";
            var x = new Regex_(@"\b\d+-\d+\b(?C1)");
            x.Callout = o => { int len = o.current_position - o.start_match; /*Print(len);*/ if(len > 5) o.Result = 1; };
            Print(x.FindAllS(s));
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.GroupNumberFromName(System.String)">
            <summary>
            Finds a named group and returns its 1-based index.
            Returns -1 if not found.
            </summary>
            <param name="name">Group name.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException">More than 1 group have this name.</exception>
            <seealso cref="M:Au.Types.RXMatch.GroupNumberFromName(System.String,System.Boolean@)"/>
        </member>
        <member name="M:Au.Regex_.IsMatch(System.String,Au.Types.RXMore)">
            <summary>
            Returns true if string <paramref name="s"/> matches this regular expression.
            </summary>
            <param name="s">
            Subject string.
            If null, always returns false, even if the regular expression matches empty string.
            </param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            If partial match, returns true too. Partial match is possible if used a PARTIAL_ flag.
            
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new Regex_(@"\b(\w+?)(\d+)\b");
            Print(x.IsMatch(s));
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.Match(System.String,Au.Types.RXMatch@,Au.Types.RXMore)">
            <summary>
            Returns true if string <paramref name="s"/> matches this regular expression.
            Gets match info as <see cref="T:Au.Types.RXMatch"/>.
            </summary>
            <param name="s">
            Subject string.
            If null, always returns false, even if the regular expression matches empty string.
            </param>
            <param name="result">Receives match info. Read more in Remarks.</param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            If full match, returns true, and <paramref name="result"/> contains the match and all groups that exist in the regular expressions.
            If partial match, returns true, and <paramref name="result"/> contains the match without groups. Partial match is possible if used a PARTIAL_ flag.
            If no match, returns false, and <paramref name="result"/> normally is null. But if a mark is available, <paramref name="result"/> is an object with two valid properties - <see cref="P:Au.Types.RXMatch.Exists"/> (false) and <see cref="P:Au.Types.RXMatch.Mark"/>; other properties have undefined values or throw exception.
            
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new Regex_(@"\b(\w+?)(\d+)\b");
            if(x.Match(s, out var m)) Print(m.Value, m[1].Value, m[2].Value);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.MatchG(System.String,Au.Types.RXGroup@,System.Int32,Au.Types.RXMore)">
            <summary>
            Returns true if string <paramref name="s"/> matches this regular expression.
            Gets whole match or some group, as <see cref="T:Au.Types.RXGroup"/> (index, length, value).
            </summary>
            <param name="s">
            Subject string.
            If null, always returns false, even if the regular expression matches empty string.
            </param>
            <param name="result">Receives match info.</param>
            <param name="group">
            Group number (1-based index) of result. If 0 (default) - whole match.
            See also <see cref="M:Au.Regex_.GroupNumberFromName(System.String)"/>.
            </param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="group"/> or from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            This function is a simplified version of <see cref="M:Au.Regex_.Match(System.String,Au.Types.RXMatch@,Au.Types.RXMore)"/>.
            If full match, returns true, and <paramref name="result"/> contains the match or the specifed group.
            If partial match, returns true too. Partial match is possible if used a PARTIAL_ flag. Then cannot get groups, therefore <paramref name="group"/> should be 0.
            If no match, returns false, and <paramref name="result"/> is empty.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new Regex_(@"\b(\w+?)(\d+)\b");
            if(x.MatchG(s, out var g)) Print(g.Value, g.Index);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.MatchS(System.String,System.String@,System.Int32,Au.Types.RXMore)">
            <summary>
            Returns true if string <paramref name="s"/> matches this regular expression.
            Gets whole match or some group, as string.
            </summary>
            <param name="s">
            Subject string.
            If null, always returns false, even if the regular expression matches empty string.
            </param>
            <param name="result">Receives the match value.</param>
            <param name="group">
            Group number (1-based index) of result. If 0 (default) - whole match.
            See also <see cref="M:Au.Regex_.GroupNumberFromName(System.String)"/>.
            </param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="group"/> or from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            This function is a simplified version of <see cref="M:Au.Regex_.Match(System.String,Au.Types.RXMatch@,Au.Types.RXMore)"/> and <see cref="M:Au.Regex_.MatchG(System.String,Au.Types.RXGroup@,System.Int32,Au.Types.RXMore)"/>.
            If full match, returns true, and <paramref name="result"/> contains the value of the match or of the specifed group.
            If partial match, returns true too. Partial match is possible if used a PARTIAL_ flag. Then cannot get groups, therefore <paramref name="group"/> should be 0.
            If no match, returns false, and <paramref name="result"/> is null.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new Regex_(@"\b(\w+?)(\d+)\b");
            if(x.MatchS(s, out var v)) Print(v);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.FindAll(System.String,Au.Types.RXMore)">
            <summary>
            Finds all match instances of the regular expression.
            Returns a lazy IEnumerable&lt;<see cref="T:Au.Types.RXMatch"/>&gt; object that can be used with foreach.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new Regex_(@"\b(\w+?)(\d+)\b");
            foreach(var m in x.FindAll(s)) Print(m.Value, m[1].Value, m[2].Value);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.FindAll(System.String,Au.Types.RXMatch[]@,Au.Types.RXMore)">
            <summary>
            Finds all match instances of the regular expression. Gets array of <see cref="T:Au.Types.RXMatch"/>.
            Returns true if found 1 or more matches.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="result">Receives all found matches.</param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new Regex_(@"\b(\w+?)(\d+)\b");
            if(!x.FindAll(s, out var a)) { Print("not found"); return; }
            foreach(var m in a) Print(m.Value, m[1].Value, m[2].Value);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.FindAllG(System.String,System.Int32,Au.Types.RXMore)">
            <summary>
            Finds all match instances of the regular expression.
            Returns a lazy IEnumerable&lt;<see cref="T:Au.Types.RXGroup"/>&gt; object that can be used with foreach.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="group">
            Group number (1-based index) of results. If 0 (default) - whole match.
            See also <see cref="M:Au.Regex_.GroupNumberFromName(System.String)"/>.
            </param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="group"/> or from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            This function is a simplified version of <see cref="M:Au.Regex_.FindAll(System.String,Au.Types.RXMore)"/>. Also it is similar to <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two three";
            var x = new Regex_(@"\b\w+\b");
            foreach(var g in x.FindAllG(s)) Print(g.Index, g.Value);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.FindAllG(System.String,Au.Types.RXGroup[]@,System.Int32,Au.Types.RXMore)">
            <summary>
            Finds all match instances of the regular expression. Gets array of <see cref="T:Au.Types.RXGroup"/> (index, length, value).
            Returns true if found 1 or more matches.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="result">Receives all found matches.</param>
            <param name="group">
            Group number (1-based index) of results. If 0 (default) - whole match.
            See also <see cref="M:Au.Regex_.GroupNumberFromName(System.String)"/>.
            </param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="group"/> or from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            This function is a simplified version of <see cref="M:Au.Regex_.FindAll(System.String,Au.Types.RXMatch[]@,Au.Types.RXMore)"/>. Also it is similar to <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two three";
            var x = new Regex_(@"\b\w+\b");
            if(!x.FindAllG(s, out var a)) { Print("not found"); return; }
            foreach(var g in a) Print(g.Index, g.Value);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.FindAllS(System.String,System.Int32,Au.Types.RXMore)">
            <summary>
            Finds all match instances of the regular expression.
            Returns a lazy IEnumerable&lt;string&gt; object that can be used with foreach.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="group">
            Group number (1-based index) of results. If 0 (default) - whole match.
            See also <see cref="M:Au.Regex_.GroupNumberFromName(System.String)"/>.
            </param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="group"/> or from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            This function is a simplified version of <see cref="M:Au.Regex_.FindAll(System.String,Au.Types.RXMore)"/> and <see cref="M:Au.Regex_.FindAllG(System.String,System.Int32,Au.Types.RXMore)"/>. Also it is similar to <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two three";
            var x = new Regex_(@"\b\w+\b");
            foreach(var v in x.FindAllS(s)) Print(v);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.FindAllS(System.String,System.String[]@,System.Int32,Au.Types.RXMore)">
            <summary>
            Finds all match instances of the regular expression. Gets array of strings.
            Returns true if found 1 or more matches.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="result">Receives all found matches.</param>
            <param name="group">
            Group number (1-based index) of results. If 0 (default) - whole match.
            See also <see cref="M:Au.Regex_.GroupNumberFromName(System.String)"/>.
            </param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="group"/> or from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            This function is a simplified version of <see cref="M:Au.Regex_.FindAll(System.String,Au.Types.RXMatch[]@,Au.Types.RXMore)"/> and <see cref="M:Au.Regex_.FindAllG(System.String,Au.Types.RXGroup[]@,System.Int32,Au.Types.RXMore)"/>. Also it is similar to <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two three";
            var x = new Regex_(@"\b\w+\b");
            if(!x.FindAllS(s, out var a)) { Print("not found"); return; }
            foreach(var v in a) Print(v);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.Replace(System.String,System.String,System.Int32,Au.Types.RXMore)">
            <summary>
            Finds and replaces all match instances of the regular expression.
            Returns the result string.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="repl">
            Replacement pattern.
            Can consist of any combination of literal text and substitutions like $1.
            Supports .NET regular expression substitution syntax. See <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)"/>. Also replaces $* with the name of the last encountered mark.
            </param>
            <param name="maxCount">The maximal count of replacements to make. If -1 (default), replaces all.</param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new Regex_(@"\b(\w+?)(\d+)\b");
            s = x.Replace(s, "'$2$1'");
            Print(s);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.Replace(System.String,System.String,System.String@,System.Int32,Au.Types.RXMore)">
            <summary>
            Finds and replaces all match instances of the regular expression.
            Returns the number of replacements made. Returns the result string through an out parameter.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="repl">
            Replacement pattern.
            Can consist of any combination of literal text and substitutions like $1.
            Supports .NET regular expression substitution syntax. See <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)"/>. Also replaces $* with the name of the last encountered mark.
            </param>
            <param name="result">The result string. Can be <paramref name="s"/>.</param>
            <param name="maxCount">The maximal count of replacements to make. If -1 (default), replaces all.</param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new Regex_(@"\b(\w+?)(\d+)\b");
            if(0 == x.Replace(s, "'$2$1'", out s)) Print("not found");
            else Print(s);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.Replace(System.String,System.Func{Au.Types.RXMatch,System.String},System.Int32,Au.Types.RXMore)">
            <summary>
            Finds and replaces all match instances of the regular expression. Uses a callback function.
            Returns the result string.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="replFunc">
            Callback function's delegate, eg lambda. Called for each found match. Returns the replacement.
            In the callback function you can use <see cref="M:Au.Types.RXMatch.ExpandReplacement(System.String)"/>.
            </param>
            <param name="maxCount">The maximal count of replacements to make. If -1 (default), replaces all.</param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new Regex_(@"\b(\w+?)(\d+)\b");
            s = x.Replace(s, o => o.Value.ToUpper_());
            Print(s);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.Replace(System.String,System.Func{Au.Types.RXMatch,System.String},System.String@,System.Int32,Au.Types.RXMore)">
            <summary>
            Finds and replaces all match instances of the regular expression. Uses a callback function.
            Returns the number of replacements made. Returns the result string through an out parameter.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="replFunc">
            Callback function's delegate, eg lambda. Called for each found match. Returns the replacement.
            In the callback function you can use <see cref="M:Au.Types.RXMatch.ExpandReplacement(System.String)"/>.
            </param>
            <param name="result">The result string. Can be <paramref name="s"/>.</param>
            <param name="maxCount">The maximal count of replacements to make. If -1 (default), replaces all.</param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new Regex_(@"\b(\w+?)(\d+)\b");
            if(0 == x.Replace(s, o => o.Value.ToUpper_(), out s)) Print("not found");
            else Print(s);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.Split(System.String,System.Int32,Au.Types.RXMore)">
            <summary>
            Returns array of substrings delimited by regular expression matches.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="maxCount">The maximal count of substrings to get. The last substring contains the unsplit remainder of the subject string. If 0 (default) or negative, gets all.</param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            Element 0 of the returned array is <paramref name="s"/> substring until the first match of the regular expression, element 1 is substring between the first and second match, and so on. If no matches, the array contains single element and it is <paramref name="s"/>.
            
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one, two,three , four";
            var x = new Regex_(@" *, *");
            var a = x.Split(s);
            for(int i = 0; i < a.Length; i++) Print(i, a[i]);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Regex_.SplitG(System.String,System.Int32,Au.Types.RXMore)">
            <summary>
            Returns <see cref="T:Au.Types.RXGroup"/> array of substrings delimited by regular expression matches.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="maxCount">The maximal count of substrings to get. The last substring contains the unsplit remainder of the subject string. If 0 (default) or negative, gets all.</param>
            <param name="more"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid from/to fields in <paramref name="more"/>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function pcre2_match failed. Unlikely.</exception>
            <remarks>
            Element 0 of the returned array is <paramref name="s"/> substring until the first match of the regular expression, element 1 is substring between the first and second match, and so on. If no matches, the array contains single element and it is <paramref name="s"/>.
            
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one, two,three , four";
            var x = new Regex_(@" *, *");
            var a = x.SplitG(s);
            foreach(var v in a) Print(v.Index, v.Value);
            ]]></code>
            </example>
        </member>
        <member name="T:Au.String_">
            <summary>
            Adds PCRE regular expression extension methods to String.
            </summary>
            <summary>
            Adds extension methods to System.String.
            Also adds StringComparison.Ordinal[IgnoreCase] versions of .NET String methods that use StringComparison.CurrentCulture by default. See https://msdn.microsoft.com/en-us/library/ms973919.aspx
            Extension method names have suffix _.
            Most of these extension methods throw NullReferenceException if called for a string variable that is null.
            </summary>
        </member>
        <member name="M:Au.String_.RegexIsMatch_(System.String,System.String,Au.Types.RXFlags)">
            <summary>
            Returns true if this string matches PCRE regular expression <paramref name="rx"/>.
            Parameters etc are of <see cref="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.Regex_.IsMatch(System.String,Au.Types.RXMore)"/>.
            Examples in <see cref="T:Au.Regex_"/> class help.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid regular expression.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.String_.RegexMatch_(System.String,System.String,Au.Types.RXMatch@,Au.Types.RXFlags)">
            <summary>
            Returns true if this string matches PCRE regular expression <paramref name="rx"/>.
            Gets match info as <see cref="T:Au.Types.RXMatch"/>.
            Parameters etc are of <see cref="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.Regex_.Match(System.String,Au.Types.RXMatch@,Au.Types.RXMore)"/>.
            Examples in <see cref="T:Au.Regex_"/> class help.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid regular expression.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.String_.RegexMatch_(System.String,System.String,System.Int32,System.String@,Au.Types.RXFlags)">
            <summary>
            Returns true if this string matches PCRE regular expression <paramref name="rx"/>.
            Gets whole match or some group, as string.
            Parameters etc are of <see cref="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.Regex_.MatchS(System.String,System.String@,System.Int32,Au.Types.RXMore)"/>.
            Examples in <see cref="T:Au.Regex_"/> class help.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid regular expression.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="group"/>.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.String_.RegexFindAll_(System.String,System.String,Au.Types.RXFlags)">
            <summary>
            Finds all match instances of PCRE regular expression <paramref name="rx"/>.
            Returns a lazy IEnumerable&lt;<see cref="T:Au.Types.RXMatch"/>&gt; object that can be used with foreach.
            Parameters etc are of <see cref="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.Regex_.FindAll(System.String,Au.Types.RXMore)"/>.
            Examples in <see cref="T:Au.Regex_"/> class help.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.String_.RegexFindAll_(System.String,System.String,Au.Types.RXMatch[]@,Au.Types.RXFlags)">
            <summary>
            Finds all match instances of PCRE regular expression <paramref name="rx"/>. Gets array of <see cref="T:Au.Types.RXMatch"/>.
            Returns true if found 1 or more matches.
            Parameters etc are of <see cref="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.Regex_.FindAll(System.String,Au.Types.RXMatch[]@,Au.Types.RXMore)"/>.
            Examples in <see cref="T:Au.Regex_"/> class help.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.String_.RegexFindAll_(System.String,System.String,System.Int32,Au.Types.RXFlags)">
            <summary>
            Finds all match instances of PCRE regular expression <paramref name="rx"/>.
            Returns a lazy IEnumerable&lt;<see cref="T:Au.Types.RXGroup"/>&gt; object that can be used with foreach.
            Parameters etc are of <see cref="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.Regex_.FindAllS(System.String,System.Int32,Au.Types.RXMore)"/>.
            Examples in <see cref="T:Au.Regex_"/> class help.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="group"/>.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.String_.RegexFindAll_(System.String,System.String,System.Int32,System.String[]@,Au.Types.RXFlags)">
            <summary>
            Finds all match instances of PCRE regular expression <paramref name="rx"/>. Gets array of strings.
            Returns true if found 1 or more matches.
            Parameters etc are of <see cref="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.Regex_.FindAllS(System.String,System.String[]@,System.Int32,Au.Types.RXMore)"/>.
            Examples in <see cref="T:Au.Regex_"/> class help.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="group"/>.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.String_.RegexReplace_(System.String,System.String,System.String,System.Int32,Au.Types.RXFlags)">
            <summary>
            Finds and replaces all match instances of PCRE regular expression <paramref name="rx"/>.
            Returns the result string.
            Parameters etc are of <see cref="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.Regex_.Replace(System.String,System.String,System.Int32,Au.Types.RXMore)"/>.
            Examples in <see cref="T:Au.Regex_"/> class help.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.String_.RegexReplace_(System.String,System.String,System.String,System.String@,System.Int32,Au.Types.RXFlags)">
            <summary>
            Finds and replaces all match instances of PCRE regular expression <paramref name="rx"/>.
            Returns the number of replacements made.
            Parameters etc are of <see cref="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.Regex_.Replace(System.String,System.String,System.String@,System.Int32,Au.Types.RXMore)"/>.
            Examples in <see cref="T:Au.Regex_"/> class help.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.String_.RegexReplace_(System.String,System.String,System.Func{Au.Types.RXMatch,System.String},System.Int32,Au.Types.RXFlags)">
            <summary>
            Finds and replaces all match instances of PCRE regular expression <paramref name="rx"/>. Uses a callback function.
            Returns the result string.
            Parameters etc are of <see cref="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.Regex_.Replace(System.String,System.Func{Au.Types.RXMatch,System.String},System.Int32,Au.Types.RXMore)"/>.
            Examples in <see cref="T:Au.Regex_"/> class help.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.String_.RegexReplace_(System.String,System.String,System.Func{Au.Types.RXMatch,System.String},System.String@,System.Int32,Au.Types.RXFlags)">
            <summary>
            Finds and replaces all match instances of PCRE regular expression <paramref name="rx"/>. Uses a callback function.
            Returns the number of replacements made.
            Parameters etc are of <see cref="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.Regex_.Replace(System.String,System.Func{Au.Types.RXMatch,System.String},System.String@,System.Int32,Au.Types.RXMore)"/>.
            Examples in <see cref="T:Au.Regex_"/> class help.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.String_.RegexSplit_(System.String,System.String,System.Int32,Au.Types.RXFlags)">
            <summary>
            Returns array of substrings delimited by PCRE regular expression <paramref name="rx"/> matches.
            Parameters etc are of <see cref="M:Au.Regex_.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.Regex_.Split(System.String,System.Int32,Au.Types.RXMore)"/>.
            Examples in <see cref="T:Au.Regex_"/> class help.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.String_._RegexCache.AddOrGet(System.String,Au.Types.RXFlags)">
            <summary>
            If rx/flags is in the cache, returns the cached code.
            Else compiles rx/flags, adds to the cache and returns the code.
            </summary>
            <param name="rx"></param>
            <param name="flags"></param>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or failed to compile it for some other reason.</exception>
        </member>
        <member name="M:Au.String_.Segments_(System.String,System.String,Au.Types.SegFlags)">
            <summary>
            This function can be used with foreach to split this string into substrings as StringSegment variables.
            Returns a SSegmenter object that implements IEnumerable&lt;StringSegment&gt;.
            </summary>
            <param name="t"></param>
            <param name="separators">A string containing characters that delimit the substrings in this string. Or one of <see cref="T:Au.Types.Separators"/> constants.</param>
            <param name="flags"></param>
            <example>
            <code><![CDATA[
            string s = "one * two three ";
            foreach(var t in s.Segments_(" ")) Print(t);
            foreach(var t in s.Segments_(Separators.Word, SegFlags.NoEmpty)) Print(t);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.String_.Segments_(System.String,System.Int32,System.Int32,System.String,Au.Types.SegFlags)">
            <summary>
            This function can be used with foreach to split the specified part of this string into substrings as StringSegment variables.
            Returns a SSegmenter object that implements IEnumerable&lt;StringSegment&gt;.
            </summary>
            <param name="t"></param>
            <param name="startIndex">Start of the part of this string.</param>
            <param name="length">Length of the part of this string.</param>
            <param name="separators">A string containing characters that delimit the substrings in this string. Or one of <see cref="T:Au.Types.Separators"/> constants.</param>
            <param name="flags"></param>
        </member>
        <member name="M:Au.String_.Like_(System.String,System.String,System.Boolean)">
            <summary>
            Compares this string with a string that possibly contains wildcard characters.
            Returns true if the strings match.
            
            Wildcard characters:
            * - zero or more of any characters.
            ? - any character.
            </summary>
            <param name="t">This string. If null, returns false. If "", returns true if pattern is "" or "*".</param>
            <param name="pattern">String that possibly contains wildcard characters. Cannot be null. If "", returns true if this string is "". If "*", always returns true except when this string is null.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <remarks>
            Like all String_ functions, performs ordinal comparison, ie does not depend on current culture.
            Much faster than Regex.IsMatch and not much slower than Equals_, EndsWith_, IndexOf_ etc.
            </remarks>
            <example>
            <code><![CDATA[
            string s = @"C:\abc\mno.xyz";
            if(s.Like_(@"C:\abc\mno.xyz")) Print("matches whole text (no wildcard characters)");
            if(s.Like_(@"C:\abc\*")) Print("starts with");
            if(s.Like_(@"*.xyz")) Print("ends with");
            if(s.Like_(@"*mno*")) Print("contains");
            if(s.Like_(@"C:\*.xyz")) Print("starts and ends with");
            if(s.Like_(@"?:*")) Print("any character, : and possibly more text");
            ]]></code>
            </example>
            <seealso cref="T:Au.Types.Wildex"/>
            <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">Wildcard expression</conceptualLink>
        </member>
        <member name="M:Au.String_.Like_(System.String,System.Boolean,System.String[])">
            <summary>
            Calls <see cref="M:Au.String_.Like_(System.String,System.String,System.Boolean)"/> for each wildcard pattern specified in the argument list until it returns true.
            Returns 1-based index of matching pattern, or 0 if none.
            </summary>
            <param name="t"></param>
            <param name="ignoreCase">Case-insensitive.</param>
            <param name="patterns">One or more wildcard strings. The array and strings cannot be null.</param>
        </member>
        <member name="M:Au.String_.Equals_(System.String,System.String,System.Boolean)">
            <summary>
            Calls <see cref="M:System.String.Equals(System.String,System.StringComparison)"/> with StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase.
            </summary>
        </member>
        <member name="M:Au.String_.Equals_(System.String,System.Boolean,System.String[])">
            <summary>
            Calls <see cref="M:Au.String_.Equals_(System.String,System.String,System.Boolean)"/> for each string specified in the argument list until it returns true.
            Returns 1-based index of matching string, or 0 if none.
            </summary>
        </member>
        <member name="M:Au.String_.EndsWith_(System.String,System.String,System.Boolean)">
            <summary>
            Calls <see cref="M:System.String.EndsWith(System.String,System.StringComparison)"/> with StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase.
            </summary>
        </member>
        <member name="M:Au.String_.EndsWith_(System.String,System.Boolean,System.String[])">
            <summary>
            Calls <see cref="M:Au.String_.EndsWith_(System.String,System.String,System.Boolean)"/> for each string specified in the argument list until it returns true.
            Returns 1-based index of matching string, or 0 if none.
            </summary>
        </member>
        <member name="M:Au.String_.EndsWith_(System.String,System.Char)">
            <summary>
            Returns true if ends with the specified character.
            Fast, case-sensitive.
            </summary>
        </member>
        <member name="M:Au.String_.StartsWith_(System.String,System.String,System.Boolean)">
            <summary>
            Calls <see cref="M:System.String.StartsWith(System.String,System.StringComparison)"/> with StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase.
            </summary>
        </member>
        <member name="M:Au.String_.StartsWith_(System.String,System.Boolean,System.String[])">
            <summary>
            Calls <see cref="M:Au.String_.StartsWith_(System.String,System.String,System.Boolean)"/> for each string specified in the argument list until it returns true.
            Returns 1-based index of matching string, or 0 if none.
            </summary>
        </member>
        <member name="M:Au.String_.StartsWith_(System.String,System.Char)">
            <summary>
            Returns true if starts with the specified character.
            Fast, case-sensitive.
            </summary>
        </member>
        <member name="M:Au.String_.EqualsAt_(System.String,System.Int32,System.String,System.Boolean)">
            <summary>
            Compares part of this string with another string and returns true if matches.
            Calls <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)"/> with StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase.
            </summary>
        </member>
        <member name="M:Au.String_.EqualsAt_(System.String,System.Int32,System.Boolean,System.String[])">
            <summary>
            Calls <see cref="M:Au.String_.EqualsAt_(System.String,System.Int32,System.String,System.Boolean)"/> for each string specified in the argument list until it returns true.
            Returns 1-based index of matching string, or 0 if none.
            </summary>
        </member>
        <member name="M:Au.String_.IndexOf_(System.String,System.String,System.Boolean)">
            <summary>
            Calls <see cref="M:System.String.IndexOf(System.String,System.StringComparison)"/> with StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase.
            </summary>
        </member>
        <member name="M:Au.String_.IndexOf_(System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            Calls <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)"/> with StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase.
            </summary>
        </member>
        <member name="M:Au.String_.IndexOf_(System.String,System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Calls <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)"/> with StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase.
            </summary>
        </member>
        <member name="M:Au.String_.IndexOfAny_(System.String,System.String)">
            <summary>
            Returns <c>IndexOfAny(anyOf.ToCharArray())</c>.
            </summary>
        </member>
        <member name="M:Au.String_.IndexOfAny_(System.String,System.String,System.Int32)">
            <summary>
            Returns <c>IndexOfAny(anyOf.ToCharArray(), startIndex)</c>.
            </summary>
        </member>
        <member name="M:Au.String_.IndexOfAny_(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Returns <c>IndexOfAny(anyOf.ToCharArray(), startIndex, count)</c>.
            </summary>
        </member>
        <member name="M:Au.String_.LastIndexOf_(System.String,System.String,System.Boolean)">
            <summary>
            Calls <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)"/> with StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase.
            </summary>
        </member>
        <member name="M:Au.String_.LastIndexOf_(System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            Calls <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)"/> with StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase.
            </summary>
        </member>
        <member name="M:Au.String_.LastIndexOf_(System.String,System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Calls <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)"/> with StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase.
            </summary>
        </member>
        <member name="M:Au.String_.Length_(System.String)">
            <summary>
            Returns <see cref="P:System.String.Length"/>. If this is null, returns 0.
            </summary>
        </member>
        <member name="M:Au.String_.Split_(System.String,System.String,System.Int32,Au.Types.SegFlags)">
            <summary>
            Splits this string into substrings using the specified separators.
            Returns string[].
            </summary>
            <param name="t"></param>
            <param name="separators">A string containing characters that delimit substrings. Or one of <see cref="T:Au.Types.Separators"/> constants.</param>
            <param name="maxCount">The maximum number of substrings to get. If negative, gets all.</param>
            <param name="flags"></param>
            <seealso cref="M:Au.String_.Segments_(System.String,System.String,Au.Types.SegFlags)"/>
            <seealso cref="M:Au.String_.SplitLines_(System.String,System.Boolean)"/>
        </member>
        <member name="M:Au.String_.Split_(System.String,System.String,Au.Types.SegFlags)">
            <summary>
            Splits this string into substrings using the specified separators.
            Returns string[].
            </summary>
            <param name="t"></param>
            <param name="separators">A string containing characters that delimit substrings. Or one of <see cref="T:Au.Types.Separators"/> constants.</param>
            <param name="flags"></param>
            <seealso cref="M:Au.String_.Segments_(System.String,System.String,Au.Types.SegFlags)"/>
            <seealso cref="M:Au.String_.SplitLines_(System.String,System.Boolean)"/>
        </member>
        <member name="M:Au.String_.SplitLines_(System.String,System.Boolean)">
            <summary>
            Splits this string into lines using separators "\r\n", "\n", "\r".
            Returns string[].
            </summary>
            <param name="t"></param>
            <param name="noEmptyLines">Don't get empty lines.</param>
            <remarks>
            Calls <see cref="M:Au.String_.Split_(System.String,System.String,System.Int32,Au.Types.SegFlags)"/> with separators = Separators.Line, maxCount = -1 (all lines), flags = noEmptyLines ? SegFlags.NoEmpty : 0.
            </remarks>
            <seealso cref="M:Au.String_.Segments_(System.String,System.String,Au.Types.SegFlags)"/>
        </member>
        <member name="M:Au.String_.CountLines_(System.String,System.Boolean)">
            <summary>
            Returns the number of lines.
            Counts line separators "\r\n", "\n", "\r".
            </summary>
            <param name="t"></param>
            <param name="preferMore">Add 1 if the string ends with a line separator or its length is 0.</param>
        </member>
        <member name="M:Au.String_.ToLower_(System.String)">
            <summary>
            Calls <see cref="M:System.String.ToLowerInvariant"/>.
            </summary>
        </member>
        <member name="M:Au.String_.ToUpper_(System.String)">
            <summary>
            Calls <see cref="M:System.String.ToUpperInvariant"/>.
            </summary>
        </member>
        <member name="M:Au.String_.Trim_(System.String,System.String)">
            <summary>
            Returns <c>Trim(trimChars.ToCharArray())</c>.
            </summary>
        </member>
        <member name="M:Au.String_.TrimEnd_(System.String,System.String)">
            <summary>
            Returns <c>TrimEnd(trimChars.ToCharArray())</c>.
            </summary>
        </member>
        <member name="M:Au.String_.TrimStart_(System.String,System.String)">
            <summary>
            Returns <c>TrimStart(trimChars.ToCharArray())</c>.
            </summary>
        </member>
        <member name="M:Au.String_.ToInt32_(System.String,System.Int32,System.Int32@,Au.Types.STIFlags)">
            <summary>
            Converts part of string to int.
            Returns the int value, or 0 if fails to convert.
            </summary>
            <param name="t"></param>
            <param name="startIndex">Offset in this string where to start parsing.</param>
            <param name="numberEndIndex">Receives offset in string where the number part ends. If fails to convert, receives 0.</param>
            <param name="flags"></param>
            <remarks>
            Fails to convert when string is null, "", does not begin with a number or the number is too big.
            
            Unlike int.Parse and Convert.ToInt32:
            	The number in string can be followed by more text, like "123text".
            	Has startIndex parameter that allows to get number from middle, like "text123text".
            	Gets the end of the number part.
            	No exception when cannot convert.
            	Supports hexadecimal format, like "0x1A", case-insensitive.
            	Much faster.
            
            The number in string can begin with ASCII spaces, tabs or newlines, like " 5".
            The number in string can be with "-" or "+", like "-5", but not like "- 5".
            Fails if the number is greater than +- uint.MaxValue (0xffffffff).
            The return value becomes negative if the number is greater than int.MaxValue, for example "0xffffffff" is -1, but it becomes correct if assigned to uint (need cast).
            Does not support non-integer numbers; for example, for "3.5E4" returns 3 and sets numberEndIndex=startIndex+1.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">startIndex is less than 0 or greater than string length.</exception>
        </member>
        <member name="M:Au.String_.ToInt32_(System.String,System.Int32,Au.Types.STIFlags)">
            <summary>
            This <see cref="M:Au.String_.ToInt32_(System.String,System.Int32,System.Int32@,Au.Types.STIFlags)"/> overload does not have parameter numberEndIndex.
            </summary>
        </member>
        <member name="M:Au.String_.ToInt32_(System.String)">
            <summary>
            This <see cref="M:Au.String_.ToInt32_(System.String,System.Int32,System.Int32@,Au.Types.STIFlags)"/> overload does not have parameters.
            </summary>
        </member>
        <member name="M:Au.String_.ToInt64_(System.String,System.Int32,System.Int32@,Au.Types.STIFlags)">
            <summary>
            Converts part of string to long.
            Returns the long value, or 0 if fails to convert.
            </summary>
            <param name="t"></param>
            <param name="startIndex">Offset in this string where to start parsing.</param>
            <param name="numberEndIndex">Receives offset in string where the number part ends. If fails to convert, receives 0.</param>
            <param name="flags"></param>
            <remarks>
            Fails to convert when string is null, "", does not begin with a number or the number is too big.
            
            Unlike long.Parse and Convert.ToInt64:
            	The number in string can be followed by more text, like "123text".
            	Has startIndex parameter that allows to get number from middle, like "text123text".
            	Gets the end of the number part.
            	No exception when cannot convert.
            	Supports hexadecimal format, like "0x1A", case-insensitive.
            	Much faster.
            
            The number in string can begin with ASCII spaces, tabs or newlines, like " 5".
            The number in string can be with "-" or "+", like "-5", but not like "- 5".
            Fails if the number is greater than +- ulong.MaxValue (0xffffffffffffffff).
            The return value becomes negative if the number is greater than long.MaxValue, for example "0xffffffffffffffff" is -1, but it becomes correct if assigned to ulong (need cast).
            Does not support non-integer numbers; for example, for "3.5E4" returns 3 and sets numberEndIndex=startIndex+1.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">startIndex is less than 0 or greater than string length.</exception>
        </member>
        <member name="M:Au.String_.ToInt64_(System.String,System.Int32,Au.Types.STIFlags)">
            <summary>
            This <see cref="M:Au.String_.ToInt64_(System.String,System.Int32,System.Int32@,Au.Types.STIFlags)"/> overload does not have parameter numberEndIndex.
            </summary>
        </member>
        <member name="M:Au.String_.ToInt64_(System.String)">
            <summary>
            This <see cref="M:Au.String_.ToInt64_(System.String,System.Int32,System.Int32@,Au.Types.STIFlags)"/> overload does not have parameters.
            </summary>
        </member>
        <member name="M:Au.String_.ToIntAndString_(System.String,System.Int32@,System.String@,System.Int32,Au.Types.STIFlags)">
            <summary>
            If this string contains a number at startIndex, gets that number as int, also gets the string part that follows it, and returns true.
            For example, for string "25text" or "25 text" gets num = 25, tail = "text".
            Everything else is the same as with <see cref="M:Au.String_.ToInt32_(System.String,System.Int32,System.Int32@,Au.Types.STIFlags)"/>.
            </summary>
            <param name="t"></param>
            <param name="num">Receives the number. Receives 0 if no number.</param>
            <param name="tail">Receives the string part that follows the number, or "". Receives null if no number. Can be this variable.</param>
            <param name="startIndex">Offset in this string where to start parsing.</param>
            <param name="flags"></param>
        </member>
        <member name="M:Au.String_.ToDouble_(System.String,System.Boolean)">
            <summary>
            Converts string to double.
            Calls <see cref="M:System.Double.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)"/> with CultureInfo.InvariantCulture and NumberStyles.Float|NumberStyles.AllowThousands.
            </summary>
            <param name="t"></param>
            <param name="canThrow">If true, exception if the string is not a valid number or is null. If false, then returns 0.</param>
        </member>
        <member name="M:Au.String_.ToFloat_(System.String,System.Boolean)">
            <summary>
            Converts string to float.
            Calls <see cref="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)"/> with CultureInfo.InvariantCulture and NumberStyles.Float|NumberStyles.AllowThousands.
            </summary>
            <param name="t"></param>
            <param name="canThrow">If true, exception if the string is not a valid number or is null. If false, then returns 0.</param>
        </member>
        <member name="M:Au.String_.ReplaceAt_(System.String,System.Int32,System.Int32,System.String)">
            <summary>
            Returns a new string in which a specified string replaces a specified count of characters at a specified position in this instance.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">startIndex or startIndex+count is outside of this string bounds.</exception>
        </member>
        <member name="M:Au.String_.Limit_(System.String,System.Int32)">
            <summary>
            If this string is longer than <paramref name="limit"/>, returns its substring 0 to <paramref name="limit"/>-3 with appended "...".
            Else returns this string.
            </summary>
        </member>
        <member name="M:Au.String_.Escape_(System.String,System.Int32,System.Boolean)">
            <summary>
            Replaces some characters to C# escape sequences.
            Replaces these characters: '\\', '\"', '\t', '\n', '\r' and all in range 0-31.
            If the string contains these characters, replaces and returns new string. Else returns this string.
            </summary>
            <param name="t">This string.</param>
            <param name="limit">If the final string is longer than <paramref name="limit"/>, get its substring 0 to <paramref name="limit"/>-3 with appended "...". The enclosing "" are not counted.</param>
            <param name="quote">Enclose in "".</param>
        </member>
        <member name="T:Au.StringSegment">
            <summary>
            An optimized representation of a substring.
            </summary>
            <remarks>
            A StringSegment variable holds a reference to the string containing the substring (<see cref="P:Au.StringSegment.Buffer"/>), the start index of the substring (<see cref="P:Au.StringSegment.Offset"/>) and substring length (<see cref="P:Au.StringSegment.Length"/>). A new string object is allocated only by functions that return a string, eg <see cref="P:Au.StringSegment.Value"/>.
            One of ways to create StringSegment instances is to split a string with <see cref="M:Au.String_.Segments_(System.String,System.String,Au.Types.SegFlags)"/>.
            Functions throw ArgumentOutOfRangeException, ArgumentNullException or NullReferenceException exception when an argument is invalid. The indexer throws IndexOutOfRangeException.
            Don't use the default constructor. Then Buffer is null and the behavior of functions is undefined. Other constructors throw exception if the string is null.
            </remarks>
        </member>
        <member name="M:Au.StringSegment.#ctor(System.String)">
            <summary>
            Initializes an instance of the StringSegment struct.
            The segment will be whole buffer.
            </summary>
            <param name="buffer">Cannot be null.</param>
        </member>
        <member name="M:Au.StringSegment.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Initializes an instance of the StringSegment struct.
            </summary>
            <param name="buffer">The string that contains this substring. Cannot be null.</param>
            <param name="offset">The offset of the segment within the buffer.</param>
            <param name="length">The length of the segment.</param>
        </member>
        <member name="M:Au.StringSegment.#ctor(System.String,System.Int32)">
            <summary>
            Initializes an instance of the StringSegment struct.
            The segment will be from offset to the end of buffer.
            </summary>
            <param name="buffer">The original string used as buffer.</param>
            <param name="offset">The offset of the segment within the buffer.</param>
        </member>
        <member name="P:Au.StringSegment.Buffer">
            <summary>
            Gets the string buffer of this StringSegment.
            See also <see cref="P:Au.StringSegment.Value"/>.
            </summary>
        </member>
        <member name="P:Au.StringSegment.Offset">
            <summary>
            Gets or sets the start index within the buffer of this StringSegment.
            The setter also changes <see cref="P:Au.StringSegment.Length"/>, so that <see cref="P:Au.StringSegment.EndOffset"/> remains unchanged.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">The setter throws if value is less than 0 or greater than <see cref="P:Au.StringSegment.EndOffset"/>.</exception>
        </member>
        <member name="M:Au.StringSegment.OffsetAdd(System.Int32)">
            <summary>
            Increments <see cref="P:Au.StringSegment.Offset"/>.
            Also changes <see cref="P:Au.StringSegment.Length"/>, so that <see cref="P:Au.StringSegment.EndOffset"/> remains unchanged.
            </summary>
            <param name="n">How much to increment. Can be negative.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">New <see cref="P:Au.StringSegment.Offset"/> would be less than 0 or greater than <see cref="P:Au.StringSegment.EndOffset"/>.</exception>
            <remarks>
            This method can be used instead of the <see cref="P:Au.StringSegment.Offset"/> setter when C# does not allow to call a property setter, for example with foreach variables.
            </remarks>
        </member>
        <member name="M:Au.StringSegment.OffsetSub(System.Int32)">
            <summary>
            Decrements <see cref="P:Au.StringSegment.Offset"/>.
            Also changes <see cref="P:Au.StringSegment.Length"/>, so that <see cref="P:Au.StringSegment.EndOffset"/> remains unchanged.
            </summary>
            <param name="n">How much to decrement. Can be negative.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">New <see cref="P:Au.StringSegment.Offset"/> would be less than 0 or greater than <see cref="P:Au.StringSegment.EndOffset"/>.</exception>
            <remarks>
            This method can be used instead of the <see cref="P:Au.StringSegment.Offset"/> setter when C# does not allow to call a property setter, for example with foreach variables.
            </remarks>
        </member>
        <member name="M:Au.StringSegment.OffsetSet(System.Int32)">
            <summary>
            Changes <see cref="P:Au.StringSegment.Offset"/>.
            Also changes <see cref="P:Au.StringSegment.Length"/>, so that <see cref="P:Au.StringSegment.EndOffset"/> remains unchanged.
            </summary>
            <param name="n">New value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">n is less than 0 or greater than <see cref="P:Au.StringSegment.EndOffset"/>.</exception>
            <remarks>
            This method can be used instead of the <see cref="P:Au.StringSegment.Offset"/> setter when C# does not allow to call a property setter, for example with foreach variables.
            </remarks>
        </member>
        <member name="P:Au.StringSegment.Length">
            <summary>
            Gets or sets the length of this StringSegment.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">The setter throws if value is less than 0 or new <see cref="P:Au.StringSegment.EndOffset"/> would be greater than buffer length.</exception>
        </member>
        <member name="M:Au.StringSegment.LengthAdd(System.Int32)">
            <summary>
            Increments <see cref="P:Au.StringSegment.Length"/>.
            </summary>
            <param name="n">How much to increment. Can be negative.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">New <see cref="P:Au.StringSegment.Length"/> would be less than 0 or new <see cref="P:Au.StringSegment.EndOffset"/> would be greater than buffer length.</exception>
            <remarks>
            This method can be used instead of the <see cref="P:Au.StringSegment.Length"/> setter when C# does not allow to call a property setter, for example with foreach variables.
            </remarks>
        </member>
        <member name="M:Au.StringSegment.LengthSub(System.Int32)">
            <summary>
            Decrements <see cref="P:Au.StringSegment.Length"/>.
            </summary>
            <param name="n">How much to decrement. Can be negative.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">New <see cref="P:Au.StringSegment.Length"/> would be less than 0 or new <see cref="P:Au.StringSegment.EndOffset"/> would be greater than buffer length.</exception>
            <remarks>
            This method can be used instead of the <see cref="P:Au.StringSegment.Length"/> setter when C# does not allow to call a property setter, for example with foreach variables.
            </remarks>
        </member>
        <member name="M:Au.StringSegment.LengthSet(System.Int32)">
            <summary>
            Changes <see cref="P:Au.StringSegment.Length"/>.
            </summary>
            <param name="n">New value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">n is less than 0 or new <see cref="P:Au.StringSegment.EndOffset"/> would be greater than buffer length.</exception>
            <remarks>
            This method can be used instead of the <see cref="P:Au.StringSegment.Length"/> setter when C# does not allow to call a property setter, for example with foreach variables.
            </remarks>
        </member>
        <member name="P:Au.StringSegment.EndOffset">
            <summary>
            Gets or sets the end index within the buffer of this StringSegment. It's Offset + Length.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">The setter throws if value is less than <see cref="P:Au.StringSegment.Offset"/> or greater than buffer length.</exception>
        </member>
        <member name="M:Au.StringSegment.EndAdd(System.Int32)">
            <summary>
            Increments <see cref="P:Au.StringSegment.EndOffset"/>.
            </summary>
            <param name="n">How much to increment. Can be negative.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">New <see cref="P:Au.StringSegment.EndOffset"/> would be less than <see cref="P:Au.StringSegment.Offset"/> or greater than buffer length.</exception>
            <remarks>
            This method can be used instead of the <see cref="P:Au.StringSegment.EndOffset"/> setter when C# does not allow to call a property setter, for example with foreach variables.
            </remarks>
        </member>
        <member name="M:Au.StringSegment.EndSub(System.Int32)">
            <summary>
            Decrements <see cref="P:Au.StringSegment.EndOffset"/>.
            </summary>
            <param name="n">How much to decrement. Can be negative.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">New <see cref="P:Au.StringSegment.EndOffset"/> would be less than <see cref="P:Au.StringSegment.Offset"/> or greater than buffer length.</exception>
            <remarks>
            This method can be used instead of the <see cref="P:Au.StringSegment.EndOffset"/> setter when C# does not allow to call a property setter, for example with foreach variables.
            </remarks>
        </member>
        <member name="M:Au.StringSegment.EndSet(System.Int32)">
            <summary>
            Changes <see cref="P:Au.StringSegment.EndOffset"/>.
            </summary>
            <param name="n">New value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">n is less than <see cref="P:Au.StringSegment.Offset"/> or greater than buffer length.</exception>
            <remarks>
            This method can be used instead of the <see cref="P:Au.StringSegment.EndOffset"/> setter when C# does not allow to call a property setter, for example with foreach variables.
            </remarks>
        </member>
        <member name="M:Au.StringSegment.IsEmpty">
            <summary>
            Returns true if Length == 0.
            </summary>
        </member>
        <member name="P:Au.StringSegment.Value">
            <summary>
            Gets the value of this segment as a string.
            </summary>
            <remarks>
            <note type="note">Always creates new string object (substring of <see cref="P:Au.StringSegment.Buffer"/>). See also <see cref="P:Au.StringSegment.ValueCached"/>.</note>
            </remarks>
        </member>
        <member name="P:Au.StringSegment.ValueCached">
            <summary>
            Gets the value of this segment as a cached string.
            </summary>
            <remarks>
            Uses an internal thread-specific <see cref="T:Au.Util.StringCache"/>. Use this function instead of <see cref="P:Au.StringSegment.Value"/> to avoid much garbage when identical substring values are frequent.
            </remarks>
        </member>
        <member name="M:Au.StringSegment.ToString">
            <summary>
            Returns <see cref="P:Au.StringSegment.Value"/>.
            </summary>
        </member>
        <member name="M:Au.StringSegment.GetHashCode">
            
        </member>
        <member name="P:Au.StringSegment.Item(System.Int32)">
            <summary>
            Gets the char at a specified position in the current StringSegment.
            </summary>
            <param name="index">Character index in this StringSegment.</param>
        </member>
        <member name="M:Au.StringSegment.Equals(System.Object)">
            <summary>
            Returns true if obj is StringSegment and its string value is equal to this variable.
            Compares only substrigs, not offsets. Uses StringComparison.Ordinal.
            </summary>
        </member>
        <member name="M:Au.StringSegment.Equals(Au.StringSegment)">
            <summary>
            Returns true if string values of this and other variable are equal.
            Compares only substrigs, not offsets. Uses StringComparison.Ordinal.
            </summary>
            <param name="other">A variable to compare with this variable.</param>
        </member>
        <member name="M:Au.StringSegment.EqualsI(Au.StringSegment)">
            <summary>
            Returns true if string values of this and other variable are equal, case insensitive.
            Compares only substrigs, not offsets. Uses StringComparison.OrdinalIgnoreCase.
            </summary>
            <param name="other">A variable to compare with this variable.</param>
        </member>
        <member name="M:Au.StringSegment.Equals(System.String)">
            <summary>
            Returns true if the specified string is equal to this StringSegment.
            Uses StringComparison.Ordinal.
            </summary>
            <param name="text">The string. Cannot be null.</param>
        </member>
        <member name="M:Au.StringSegment.EqualsI(System.String)">
            <summary>
            Returns true if the specified string is equal to this StringSegment, case-insensitive.
            Uses StringComparison.OrdinalIgnoreCase.
            </summary>
            <param name="text">The string. Cannot be null.</param>
        </member>
        <member name="M:Au.StringSegment.op_Equality(Au.StringSegment,Au.StringSegment)">
            <summary>
            Returns true if two specified StringSegment variables have the same string value.
            Compares only substrigs, not offsets. Uses StringComparison.Ordinal.
            </summary>
            <param name="left">The first StringSegment to compare.</param>
            <param name="right">The second StringSegment to compare.</param>
        </member>
        <member name="M:Au.StringSegment.op_Inequality(Au.StringSegment,Au.StringSegment)">
            <summary>
            Returns true if two specified StringSegment variables have different string values.
            Compares only substrigs, not offsets. Uses StringComparison.Ordinal.
            </summary>
            <param name="left">The first StringSegment to compare.</param>
            <param name="right">The second StringSegment to compare.</param>
        </member>
        <member name="M:Au.StringSegment.op_Implicit(System.String)~Au.StringSegment">
            <summary>
            Creates a new StringSegment from the given string.
            </summary>
            <param name="value">The string to convert to a StringSegment. Cannot be null.</param>
        </member>
        <member name="M:Au.StringSegment.StartsWith(System.String,System.Boolean)">
            <summary>
            Returns true if the beginning of this StringSegment matches the specified string.
            Uses StringComparison.Ordinal or OrdinalIgnoreCase.
            </summary>
            <param name="text">The string. Cannot be null.</param>
            <param name="ignoreCase">Case-insensitive.</param>
        </member>
        <member name="M:Au.StringSegment.EndsWith(System.String,System.Boolean)">
            <summary>
            Returns true if the end of this StringSegment matches the specified string.
            Uses StringComparison.Ordinal or OrdinalIgnoreCase.
            </summary>
            <param name="text">The string. Cannot be null.</param>
            <param name="ignoreCase">Case-insensitive.</param>
        </member>
        <member name="M:Au.StringSegment.Substring(System.Int32,System.Boolean)">
            <summary>
            Gets a substring from this StringSegment.
            The substring starts at the position specified by offset and has the remaining length.
            </summary>
            <param name="offset">The zero-based starting character position of a substring in this StringSegment.</param>
            <param name="cached">Use an internal thread-specific <see cref="T:Au.Util.StringCache"/>, to avoid much garbage when identical substring values are frequent.</param>
        </member>
        <member name="M:Au.StringSegment.Substring(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Gets a substring from this StringSegment.
            </summary>
            <param name="offset">The zero-based starting character position of a substring in this StringSegment.</param>
            <param name="length">The number of characters in the substring.</param>
            <param name="cached">Use an internal thread-specific <see cref="T:Au.Util.StringCache"/>, to avoid much garbage when identical substring values are frequent.</param>
        </member>
        <member name="M:Au.StringSegment.Subsegment(System.Int32)">
            <summary>
            Gets a StringSegment that represents a substring from this StringSegment.
            The StringSegment starts at the position specified by offset and has the remaining length.
            </summary>
            <param name="offset">The zero-based starting character position of a substring in this StringSegment.</param>
        </member>
        <member name="M:Au.StringSegment.Subsegment(System.Int32,System.Int32)">
            <summary>
            Gets a StringSegment that represents a substring from this StringSegment.
            </summary>
            <param name="offset">The zero-based starting character position of a substring in this StringSegment.</param>
            <param name="length">The number of characters in the substring.</param>
        </member>
        <member name="M:Au.StringSegment.IndexOf(System.Char,System.Int32,System.Int32)">
            <summary>
            Gets the zero-based index of the first occurrence of the character c in this StringSegment.
            Returns -1 if not found.
            </summary>
            <param name="c">The character.</param>
            <param name="startIndex">The zero-based index position at which the search starts.</param>
            <param name="count">The number of characters to examine.</param>
        </member>
        <member name="M:Au.StringSegment.IndexOf(System.Char,System.Int32)">
            <summary>
            Gets the zero-based index of the first occurrence of the character c in this StringSegment.
            Returns -1 if not found.
            </summary>
            <param name="c">The character.</param>
            <param name="startIndex">The zero-based index position at which the search starts.</param>
        </member>
        <member name="M:Au.StringSegment.IndexOf(System.Char)">
            <summary>
            Gets the zero-based index of the first occurrence of the character c in this StringSegment.
            Returns -1 if not found.
            </summary>
            <param name="c">The character.</param>
        </member>
        <member name="M:Au.StringSegment.IndexOfAny(System.Char[],System.Int32,System.Int32)">
            <summary>
            Gets the zero-based index of the first occurrence in this StringSegment of any specified characters.
            Returns -1 if not found.
            </summary>
            <param name="anyOf">One or more characters to seek.</param>
            <param name="startIndex">The search starting position.</param>
            <param name="count">The number of character positions to examine.</param>
        </member>
        <member name="M:Au.StringSegment.IndexOfAny(System.Char[],System.Int32)">
            <summary>
            Gets the zero-based index of the first occurrence in this StringSegment of any specified characters.
            Returns -1 if not found.
            </summary>
            <param name="anyOf">One or more characters to seek.</param>
            <param name="startIndex">The search starting position.</param>
        </member>
        <member name="M:Au.StringSegment.IndexOfAny(System.Char[])">
            <summary>
            Gets the zero-based index of the first occurrence in this StringSegment of any specified characters.
            Returns -1 if not found.
            </summary>
            <param name="anyOf">One or more characters to seek.</param>
        </member>
        <member name="M:Au.StringSegment.LastIndexOf(System.Char)">
            <summary>
            Gets the zero-based index of the last occurrence in this StringSegment of any specified characters.
            Returns -1 if not found.
            </summary>
            <param name="value">The character.</param>
        </member>
        <member name="M:Au.StringSegment.Trim">
            <summary>
            Removes all leading and trailing whitespaces.
            </summary>
        </member>
        <member name="M:Au.StringSegment.TrimStart">
            <summary>
            Removes all leading whitespaces (see <see cref="M:System.Char.IsWhiteSpace(System.Char)"/>).
            </summary>
        </member>
        <member name="M:Au.StringSegment.TrimEnd">
            <summary>
            Removes all trailing whitespaces (see <see cref="M:System.Char.IsWhiteSpace(System.Char)"/>).
            </summary>
        </member>
        <member name="M:Au.StringSegment.Split(System.String,Au.Types.SegFlags)">
            <summary>
            Returns a <see cref="T:Au.Types.SegParser"/> that will split this StringSegment into StringSegments when used with foreach.
            </summary>
            <param name="separators">A string containing characters that delimit the substrings in this StringSegment. Or one of <see cref="T:Au.Types.Separators"/> constants.</param>
            <param name="flags"></param>
            <seealso cref="M:Au.String_.Segments_(System.String,System.String,Au.Types.SegFlags)"/>
        </member>
        <member name="T:Au.InterDomainVariables">
            <summary>
            Inter-domain variables. Allows to share values by all app domains of this process.
            Similar to environment variables, but supports more types and does not inherit parent process variables; the speed is similar.
            Supports not all types. The type must have one of these properties:
            1. Derived from MarshalByRefObject. The stored value is a virtual reference (proxy), not a copy. The owner domain must be still alive when other domains access (call methods etc) the retrieved value, else AppDomainUnloadedException.
            2. Has [Serializable] attribute. The stored value is a copy, not reference. For example int, IntPtr, string, arrays, List, Dictionary.
            </summary>
        </member>
        <member name="M:Au.InterDomainVariables.SetVariable(System.String,System.Object)">
            <summary>
            Adds or modifies an inter-domain variable.
            </summary>
            <param name="name">Name. Can be any unique string, for example a GUID string. Case-sensitive.</param>
            <param name="value">Value.</param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The type is not supported because is neither serializable nor MarshalByRefObject-derived.</exception>
        </member>
        <member name="M:Au.InterDomainVariables.GetVariable(System.String)">
            <summary>
            Gets the value of an inter-domain variable.
            Returns null if the variable does not exist. Else returns the value as object; need a cast.
            </summary>
            <param name="name">Name. Case-sensitive.</param>
        </member>
        <member name="M:Au.InterDomainVariables.GetVariable``1(System.String,``0@)">
            <summary>
            Gets the value of an inter-domain variable.
            Returns true if the variable exists and is not null.
            </summary>
            <param name="name">Name. Case-sensitive.</param>
            <param name="value">Receives the value. If the variable does not exist, receives the default value of that type (for reference types it is null).</param>
            <exception cref="T:System.InvalidCastException">Bad value type.</exception>
        </member>
        <member name="M:Au.InterDomainVariables.GetVariable``1(System.String,System.Func{``0})">
            <summary>
            Gets the value of an inter-domain variable.
            If the variable does not exist or is null, calls a callback function that provides an initial value; then sets the variable = the initial value.
            Thread-safe.
            </summary>
            <param name="name">Name. Case-sensitive.</param>
            <param name="initValue">A callback function delegate (eg lambda) that is called when the variable does not exist or is null. It must return an initial value.</param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The type is not supported because is neither serializable nor MarshalByRefObject-derived.</exception>
            <exception cref="T:System.InvalidCastException">Bad value type.</exception>
            <remarks>
            Be careful with types derived from MarshalByRefObject. If the object does not exist, your callback function creates it in this appdomain. Maybe this appdomain is not where you want it to live. Instead use SetVariable and another overload of GetVariable.
            </remarks>
            <example><code>int test = InterDomainVariables.GetVariable("test", () => 10);</code></example>
        </member>
        <member name="M:Au.InterDomainVariables.DefaultDomainVariable``1(System.String,System.Boolean@)">
            <summary>
            Gets a reference to an object that lives in default appdomain. Auto-creates new object there if does not exist.
            The object can be used in any appdomain. When a non-default domain calls its methods, the call is marshaled to the default domain and executed there.
            </summary>
            <typeparam name="T">The type must be derived from MarshalByRefObject and have default constructor.</typeparam>
            <param name="name">Inter-domain variable name. Any unique string. Case-sensitive.</param>
            <param name="createdNew">Receives true if now created new object, false if the object alrady existed.</param>
            <remarks>
            Thread-safe.
            </remarks>
            <example>
            <code><![CDATA[
            static DefDomainVar s_idvTest = InterDomainVariables.DefaultDomainVariable<DefDomainVar>(nameof(s_idvTest));
            
            static void Main()
            {
            	s_idvTest.Method(7);
            }
            
            class DefDomainVar :MarshalByRefObject
            {
            	public void Method(int param)
            	{
            		Print(param, AppDomain.CurrentDomain.FriendlyName);
            	}
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.InterDomainVariables.DefaultDomainVariable``1(System.String)">
            <summary>
            The same as <see cref="M:Au.InterDomainVariables.DefaultDomainVariable``1(System.String,System.Boolean@)"/>, just does not have the bool parameter.
            </summary>
        </member>
        <member name="T:Au.AuScriptOptions">
            <summary>
            Options for some often used automation functions.
            </summary>
            <remarks>
            Used like this:
            
            
            
            
            
            Usually function options are specified using either function parameters or class properties.
            Many functions allow to adjust their behavior through some kind of options (aka settings, flags, parameters). There are two common ways to pass options to a function: 1. Function parameters, like <c>Class.Func(other parameters, option1, option2);</c> 2. Class properties, like <c>var x=new Class(); x.Option1=1; x.Option2=2; x.Func(parameters);</c>.
            
            </remarks>
        </member>
        <member name="M:Au.AuScriptOptions.#ctor(Au.AuScriptOptions)">
            <summary>
            Copies all options from another AuScriptOptions object.
            </summary>
            <param name="o">If null, sets default options (unchanged AuScriptOptions.Default).</param>
        </member>
        <member name="M:Au.AuScriptOptions.#ctor">
            <summary>
            Copies all options from <see cref="P:Au.AuScriptOptions.Default"/>.
            </summary>
        </member>
        <member name="P:Au.AuScriptOptions.Default">
            <summary>
            Initial options used for: <see cref="P:Au.AuScriptOptions.Options"/> of all threads of this appdomain; new AuScriptOptions objects created like <c>var o=new AuScriptOptions();</c>.
            </summary>
            <remarks>
            Why there are two static AuScriptOptions objects - Options and Default:
            Options - thread-scoped object. Functions of this library use it. You can change its properties in scripts where need. Initial property values are automatically copied from Default when the Options property is accessed first time in that thread.
            Default - appdomain-scoped object. Contains initial property values for Options and new AuScriptOptions objects. Normally you change its properties in script template, at the start of script execution.
            </remarks>
        </member>
        <member name="P:Au.AuScriptOptions.Options">
            <summary>
            Options of this thread.
            You can set and get its properties. Functions of this library use it.
            Initially it is a clone of <see cref="P:Au.AuScriptOptions.Default"/>.
            </summary>
        </member>
        <member name="P:Au.AuScriptOptions.MouseClickSleep">
            <summary>
            Wait milliseconds at the end of Mouse.Click() and other functions that generate mouse button or wheel events.
            Default: 50. Valid values: 0 - 60000 (1 minute).
            </summary>
            <remarks>
            This option also is applied to:
            The sleep time after mouse move events is Math.Min(7, MouseClickSleep).
            The sleep time between mouse button down and up events is Math.Min(20, MouseClickSleep).
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="P:Au.AuScriptOptions.MouseMoveSpeed">
            <summary>
            If not 0, makes mouse movements slower, not instant.
            Used by Mouse.Move, Mouse.Click and other functions that generate mouse movement events.
            Default: 0. Valid values: 0 (instant) - 60000 (slowest).
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            It is not milliseconds or some other unit. It adds intermediate mouse movements and small delays when moving the mouse cursor to the specified point. The speed also depends on the distance.
            Value 0 (default) does not add intermediate mouse movements. Adds at least 1 if some mouse buttons are pressed.
            Value 1 adds at least 1 intermediate mouse movement.
            Values 10-50 are good for visually slow movements.
            </remarks>
        </member>
        <member name="P:Au.AuScriptOptions.Relaxed">
            <summary>
            Make some functions less strict (less checking for possibly invalid conditions).
            Default: false.
            </summary>
            <remarks>
            This option is used by these functions:
            <list type="bullet">
            <item>Mouse.Move, Mouse.Click and other functions that move the cursor (mouse pointer):
            false - throw exception if cannot move the cursor to the specified x y. For example it the x y is not in screen.
            true - try to move anyway. Don't throw exception, regardless of the final cursor position (which probably will be at a screen edge).
            </item>
            <item>Mouse.Move, Mouse.Click and other functions that move the cursor (mouse pointer):
            false - before moving the cursor, wait while a mouse button is pressed by the user or another thread. It prevents an unintended drag-drop.
            true - do not wait.
            </item>
            <item>Mouse.Click and other functions that click or press a mouse button using window coordinates:
            false - don't allow to click in another window. If need, activate the specified window (or its top-level parent). If that does not help, throw exception. However if the window is a control, allow x y anywhere in its top-level parent window.
            true - allow to click in another window. Don't activate the window and don't throw exception.
            </item>
            <item></item>
            <item></item>
            <item></item>
            </list>
            </remarks>
        </member>
        <member name="P:Au.AuScriptOptions.Debug">
            <summary>
            If true, some library functions may display some debug info that is not displayed if this is false.
            If not explicitly set, the default value depends on the configuration of the entry assymbly: true if Debug, false if Release.
            </summary>
        </member>
        <member name="M:Au.AuScriptOptions.DisableWarnings(System.String[])">
            <summary>
            Disables one or more warnings.
            </summary>
            <param name="warningsWild">One or more warnings as case-insensitive wildcard strings. See <see cref="M:Au.String_.Like_(System.String,System.String,System.Boolean)"/>.</param>
            <remarks>
            Adds the strings to an internal list. When <see cref="M:Au.NoClass.PrintWarning(System.String,System.Int32,System.String)"/> is called, it looks in the list. If it finds the warning in the list, it does not show the warning.
            It's easy to auto-restore warnings with 'using', like in the second example. Restoring is optional.
            </remarks>
            <example>
            This code in script template disables two warnings for all new scripts.
            <code><![CDATA[
            AuScriptOptions.Default.DisableWarnings("*part of warning 1 text*", "*part of warning 2 text*");
            ]]></code>
            Temporarily disable all warnings for this thread.
            <code><![CDATA[
            using(Options.DisableWarnings("*")) {
            	...
            } //here warnings are automatically restored
            ]]></code>
            </example>
        </member>
        <member name="P:Au.AuScriptOptions.Temp">
            <summary>
            Saves current Options so that it will be automatically restored like in the example.
            </summary>
            <remarks>
            Multiple <c>using(AuScriptOptions.Temp)</c> can be nested.
            Note: Each thread has its own Options. This function saves/restores Options of this thread.
            </remarks>
            <example>
            <code><![CDATA[
            Print(Options.MouseClickSleep);
            using(AuScriptOptions.Temp) {
            	Options.MouseClickSleep = 1000;
            	Print(Options.MouseClickSleep);
            } //here Options is automatically restored
            Print(Options.MouseClickSleep);
            ]]></code>
            </example>
        </member>
        <member name="T:Au.Files">
            <summary>
            File system functions.
            Works with files and directories. Disk drives like @"C:\" or "C:" are directories too.
            Extends .NET file system classes such as File and Directory.
            Many functions of this class can be used instead of existing similar .NET functions that are slow, limited or unreliable.
            Most functions support only full path. Most of them throw ArgumentException if passed a filename or relative path, ie in "current directory". Using current directory is unsafe; it was relevant only in DOS era.
            Most functions support extended-length paths (longer than 259). Such local paths should have @"\\?\" prefix, like @"\\?\C:\...". Such network path should be like @"\\?\UNC\server\share\...". See <see cref="M:Au.Path_.PrefixLongPath(System.String)"/>, <see cref="M:Au.Path_.PrefixLongPathIfNeed(System.String)"/>. Many functions support long paths even without prefix.
            </summary>
        </member>
        <member name="T:Au.Files.Misc">
            <summary>
            Miscellaneous functions.
            </summary>
        </member>
        <member name="T:Au.Files.Misc.FileId">
            <summary>
            Contains file properties that can be used to uniquely identify the file on a single computer.
            Can be used with files and directories.
            To get it, use <see cref="M:Au.Files.Misc.GetFileId(System.String,Au.Files.Misc.FileId@)"/>.
            </summary>
            <remarks>
            Path to the same file or directory can be specified in many different ways. To determine whether two paths represent to the same file, get and compare FileId of them.
            </remarks>
            <tocexclude />
        </member>
        <member name="F:Au.Files.Misc.FileId.VolumeSerialNumber">
            <summary>The serial number of the volume (aka disk drive) that contains the file.</summary>
        </member>
        <member name="F:Au.Files.Misc.FileId.FileIndex">
            <summary>An identifier that is associated with the file. It is unique in that volume.</summary>
        </member>
        <member name="M:Au.Files.Misc.FileId.op_Equality(Au.Files.Misc.FileId,Au.Files.Misc.FileId)">
            
        </member>
        <member name="M:Au.Files.Misc.FileId.op_Inequality(Au.Files.Misc.FileId,Au.Files.Misc.FileId)">
            
        </member>
        <member name="M:Au.Files.Misc.GetFileId(System.String,Au.Files.Misc.FileId@)">
            <summary>
            Gets <see cref="T:Au.Files.Misc.FileId"/> of a file or directory.
            Returns false if fails. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <param name="path">Full path. Supports environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>).</param>
            <param name="fileId"></param>
        </member>
        <member name="M:Au.Files.Misc.LibIsSameFile(System.String,System.String)">
            <summary>
            Calls <see cref="M:Au.Files.Misc.GetFileId(System.String,Au.Files.Misc.FileId@)"/> for two paths and returns true if both calls succeed and the ids are equal.
            Paths should be normalized. They are passed to API unmodified.
            </summary>
            <param name="path1"></param>
            <param name="path2"></param>
        </member>
        <member name="T:Au.Files.Misc.DisableRedirection">
            <summary>
            Temporarily disables file system redirection, to allow this 32-bit process access the 64-bit System32 directory.
            </summary>
        </member>
        <member name="M:Au.Files.Misc.DisableRedirection.Disable">
            <summary>
            If Ver.Is32BitProcessOn64BitOS, calls API <msdn>Wow64DisableWow64FsRedirection</msdn>, which disables file system redirection.
            The caller can call this without checking OS and process bitness. This function checks it and it is fast.
            Always call <see cref="M:Au.Files.Misc.DisableRedirection.Revert"/> or Dispose, for example in finally{}, or use using (this struct implements IDisposable). Not calling it is more dangerous than a memory leak. It is not called by GC.
            </summary>
        </member>
        <member name="M:Au.Files.Misc.DisableRedirection.Revert">
            <summary>
            If redirected, calls API <msdn>Wow64RevertWow64FsRedirection</msdn>.
            </summary>
        </member>
        <member name="M:Au.Files.Misc.DisableRedirection.IsSystem64PathIn32BitProcess(System.String)">
            <summary>
            Returns true if Ver.Is32BitProcessOn64BitOS is true and path starts with Folders.System.
            Most such paths are redirected, therefore you may want to disable redirection with this class.
            </summary>
            <param name="path">Normalized path. This function does not normalize. Also it is unaware of @"\\?\".</param>
        </member>
        <member name="M:Au.Files.Misc.DisableRedirection.GetNonRedirectedSystemPath(System.String,System.Boolean)">
            <summary>
            If Ver.Is32BitProcessOn64BitOS is true and path starts with Folders.System, replaces that path part with <see cref="P:Au.Folders.SystemX64"/>.
            It disables redirection to Folders.SystemX32 for that path.
            </summary>
            <param name="path">Normalized path. This function does not normalize. Also it is unaware of @"\\?\".</param>
            <param name="ifExistsOnlyThere">Don't replace path if the file or directory exists in the redirected folder or does not exist in the non-redirected folder.</param>
        </member>
        <member name="M:Au.Files.Misc.DisableRedirection.Dispose">
            <summary>
            Calls <see cref="M:Au.Files.Misc.DisableRedirection.Revert"/>.
            </summary>
        </member>
        <member name="M:Au.Files._DisableDeviceNotReadyMessageBox">
            <summary>
            Adds SEM_FAILCRITICALERRORS to the error mode of this process, as MSDN recommends. Does this once in appdomain.
            It is to avoid unnecessary message boxes when an API tries to access an ejected CD/DVD etc.
            </summary>
        </member>
        <member name="M:Au.Files.GetProperties(System.String,Au.Types.FileProperties@,Au.Types.FAFlags)">
            <summary>
            Gets file or directory attributes, size and times.
            Returns false if the file/directory does not exist.
            Calls API <msdn>GetFileAttributesEx</msdn>.
            </summary>
            <param name="path">Full path. Supports @"\.." etc. If flag UseRawPath not used, supports environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>).</param>
            <param name="properties">Receives properties.</param>
            <param name="flags"></param>
            <exception cref="T:System.ArgumentException">Not full path (when not used flag UseRawPath).</exception>
            <exception cref="T:Au.Types.AuException">The file/directory exist but failed to get its properties. Not thrown if used flag DoNotThrow.</exception>
            <remarks>
            For symbolic links etc, gets properties of the link, not of its target.
            You can also get most of these properties with <see cref="M:Au.Files.EnumDirectory(System.String,Au.Types.FEFlags,System.Func{Au.Types.FEFile,System.Boolean},System.Action{System.String})"/>.
            </remarks>
        </member>
        <member name="M:Au.Files.GetAttributes(System.String,System.IO.FileAttributes@,Au.Types.FAFlags)">
            <summary>
            Gets file or directory attributes.
            Returns false if the file/directory does not exist.
            Calls API <msdn>GetFileAttributes</msdn>.
            </summary>
            <param name="path">Full path. Supports @"\.." etc. If flag UseRawPath not used, supports environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>).</param>
            <param name="attributes">Receives attributes, or 0 if failed.</param>
            <param name="flags"></param>
            <exception cref="T:System.ArgumentException">Not full path (when not used flag UseRawPath).</exception>
            <exception cref="T:Au.Types.AuException">Failed. Not thrown if used flag DoNotThrow.</exception>
            <remarks>
            For symbolic links etc, gets properties of the link, not of its target.
            </remarks>
        </member>
        <member name="M:Au.Files._GetAttributes(System.String,System.IO.FileAttributes@,System.Boolean)">
            <summary>
            Gets attributes.
            Returns false if INVALID_FILE_ATTRIBUTES or if relative path. No exceptions.
            </summary>
        </member>
        <member name="M:Au.Files.ExistsAs(System.String,System.Boolean)">
            <summary>
            Gets file system entry type - file, directory, and whether it exists.
            Returns NotFound (0) if does not exist or if fails to get attributes.
            Calls API <msdn>GetFileAttributes</msdn>.
            </summary>
            <param name="path">Full path. Supports @"\.." etc. If useRawPath is false (default), supports environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>). Can be null.</param>
            <param name="useRawPath">Pass path to the API as it is, without any normalizing and full-path checking.</param>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>. If you need exception when fails, instead call <see cref="M:Au.Files.GetAttributes(System.String,System.IO.FileAttributes@,Au.Types.FAFlags)"/> and check attribute Directory.
            Always use full path. If path is not full: if useRawPath is false (default) returns NotFound; if useRawPath is true, searches in "current directory".
            </remarks>
        </member>
        <member name="M:Au.Files.ExistsAs2(System.String,System.Boolean)">
            <summary>
            Gets file system entry type - file, directory, symbolic link, whether it exists and is accessible.
            Returns NotFound (0) if does not exist. Returns AccessDenied (&lt; 0) if exists but this process cannot access it and get attributes.
            Calls API <msdn>GetFileAttributes</msdn>.
            The same as <see cref="M:Au.Files.ExistsAs(System.String,System.Boolean)"/> but provides more complete result. In most cases you can use ExistsAs, it's simpler.
            </summary>
            <param name="path">Full path. Supports @"\.." etc. If useRawPath is false (default), supports environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>). Can be null.</param>
            <param name="useRawPath">Pass path to the API as it is, without any normalizing and full-path checking.</param>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>. If you need exception when fails, instead call <see cref="M:Au.Files.GetAttributes(System.String,System.IO.FileAttributes@,Au.Types.FAFlags)"/> and check attributes Directory and ReparsePoint.
            Always use full path. If path is not full: if useRawPath is false (default) returns NotFound; if useRawPath is true, searches in "current directory".
            </remarks>
        </member>
        <member name="M:Au.Files.ExistsAsAny(System.String,System.Boolean)">
            <summary>
            Returns true if file or directory exists.
            Calls <see cref="M:Au.Files.ExistsAs2(System.String,System.Boolean)"/>, which calls API <msdn>GetFileAttributes</msdn>.
            </summary>
            <param name="path">Full path. Supports @"\.." etc. If useRawPath is false (default), supports environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>). Can be null.</param>
            <param name="useRawPath">Pass path to the API as it is, without any normalizing and full-path checking.</param>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>. If you need exception when fails, instead call <see cref="M:Au.Files.GetAttributes(System.String,System.IO.FileAttributes@,Au.Types.FAFlags)"/>.
            Always use full path. If path is not full: if useRawPath is false (default) returns NotFound; if useRawPath is true, searches in "current directory".
            For symbolic links etc, returns true if the link exists. Does not care whether its target exists.
            Unlike <see cref="M:Au.Files.ExistsAsFile(System.String,System.Boolean)"/> and <see cref="M:Au.Files.ExistsAsDirectory(System.String,System.Boolean)"/>, this function returns true when the file exists but cannot get its attributes. Then <c>ExistsAsAny(path)</c> is not the same as <c>ExistsAsFile(path) || ExistsAsDirectory(path)</c>.
            </remarks>
        </member>
        <member name="M:Au.Files.ExistsAsFile(System.String,System.Boolean)">
            <summary>
            Returns true if file exists and is not a directory.
            Returns false if does not exist or if fails to get its attributes.
            Calls <see cref="M:Au.Files.ExistsAs(System.String,System.Boolean)"/>, which calls API <msdn>GetFileAttributes</msdn>.
            </summary>
            <param name="path">Full path. Supports @"\.." etc. If useRawPath is false (default), supports environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>). Can be null.</param>
            <param name="useRawPath">Pass path to the API as it is, without any normalizing and full-path checking.</param>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>. If you need exception when fails, instead call <see cref="M:Au.Files.GetAttributes(System.String,System.IO.FileAttributes@,Au.Types.FAFlags)"/> and check attribute Directory.
            Always use full path. If path is not full: if useRawPath is false (default) returns NotFound; if useRawPath is true, searches in "current directory".
            For symbolic links etc, returns true if the link exists and its target is not a directory. Does not care whether its target exists.
            </remarks>
        </member>
        <member name="M:Au.Files.ExistsAsDirectory(System.String,System.Boolean)">
            <summary>
            Returns true if directory (folder or drive) exists.
            Returns false if does not exist or if fails to get its attributes.
            Calls <see cref="M:Au.Files.ExistsAs(System.String,System.Boolean)"/>, which calls API <msdn>GetFileAttributes</msdn>.
            </summary>
            <param name="path">Full path. Supports @"\.." etc. If useRawPath is false (default), supports environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>). Can be null.</param>
            <param name="useRawPath">Pass path to the API as it is, without any normalizing and full-path checking.</param>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>. If you need exception when fails, instead call <see cref="M:Au.Files.GetAttributes(System.String,System.IO.FileAttributes@,Au.Types.FAFlags)"/> and check attribute Directory.
            Always use full path. If path is not full: if useRawPath is false (default) returns NotFound; if useRawPath is true, searches in "current directory".
            For symbolic links etc, returns true if the link exists and its target is a directory. Does not care whether its target exists.
            </remarks>
        </member>
        <member name="M:Au.Files.SearchPath(System.String,System.String[])">
            <summary>
            Finds file or directory and returns full path.
            Returns null if cannot be found.
            If the path argument is full path, calls <see cref="M:Au.Files.ExistsAsAny(System.String,System.Boolean)"/> and returns normalized path if exists, null if not.
            Else searches in these places:
            1. dirs, if used.
            2. <see cref="P:Au.Folders.ThisApp"/>.
            3. Calls API <msdn>SearchPath</msdn>, which searches in process directory, Windows system directories, current directory, PATH environment variable. The search order depends on API <msdn>SetSearchPathMode</msdn> or registry settings.
            4. If path ends with ".exe", tries to get path from registry "App Paths" keys.
            </summary>
            <param name="path">Full or relative path or just filename with extension. Supports network paths too.</param>
            <param name="dirs">0 or more directories where to search.</param>
        </member>
        <member name="M:Au.Files.EnumDirectory(System.String,Au.Types.FEFlags,System.Func{Au.Types.FEFile,System.Boolean},System.Action{System.String})">
            <summary>
            Gets names and other info of files and subdirectories in the specified directory.
            Returns an enumerable collection of <see cref="T:Au.Types.FEFile"/> objects containing the info.
            By default gets only direct children. Use flag <see cref="F:Au.Types.FEFlags.AndSubdirectories"/> to get all descendants.
            </summary>
            <param name="directoryPath">Full path of the directory.</param>
            <param name="flags"></param>
            <param name="filter">
            A callback function to call for each file and subdirectory.
            If it returns false, the file/subdirectory is not included in results.
            This can be useful when EnumDirectory is called indirectly, for example by the Copy method. If you call it directly, you can instead skip processing the file in your foreach loop.
            </param>
            <param name="errorHandler">
            A callback function to call when fails to get children of a subdirectory, when using flag <see cref="F:Au.Types.FEFlags.AndSubdirectories"/>.
            It receives the subdirectory path. It can call <see cref="M:Au.Types.Native.GetError"/> and throw an exception.
            If it does not throw an exception, the enumeration continues as if the directory is empty.
            If errorHandler not used, then throws exception.
            Read more in Remarks.
            </param>
            <exception cref="T:System.ArgumentException">directoryPath is invalid path or not full path.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">directoryPath directory does not exist.</exception>
            <exception cref="T:Au.Types.AuException">Failed to get children of directoryPath or of a subdirectory. Read more in Remarks.</exception>
            <remarks>
            Uses API <msdn>FindFirstFile</msdn>.
            
            The paths that this function gets are normalized, ie may not start with exact directoryPath string. Expanded environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>), "..", DOS path etc.
            Paths longer than <see cref="F:Au.Path_.MaxDirectoryPathLength"/> have @"\\?\" prefix (see <see cref="M:Au.Path_.PrefixLongPathIfNeed(System.String)"/>).
            For symbolic links and mounted folders, gets info of the link/folder and not of its target.
            
            These errors are ignored:
            1. Access denied (usually because of security permissions), unless used flag FailIfAccessDenied.
            2. Missing target directory of a symbolic link or mounted folder.
            When an error is ignored, the function works as if that [sub]directory is empty; does not throw exception and does not call errorHandler.
            
            Enumeration of a subdirectory starts immediately after the subdirectory itself is retrieved.
            </remarks>
        </member>
        <member name="M:Au.Files._SafeDeleteExistingDirectory.Rename(System.String,System.Boolean)">
            <summary>
            note: path must be normalized.
            </summary>
        </member>
        <member name="M:Au.Files.Rename(System.String,System.String,Au.Types.IfExists)">
            <summary>
            Renames file or directory.
            </summary>
            <param name="path">Full path.</param>
            <param name="newName">New name without path. Example: "name.txt".</param>
            <param name="ifExists"></param>
            <exception cref="T:System.ArgumentException">
            path is not full path (see <see cref="M:Au.Path_.IsFullPath(System.String)"/>).
            newName is invalid filename.
            </exception>
            <exception cref="T:System.IO.FileNotFoundException">The file (path) does not exist or cannot be found.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Uses API <msdn>MoveFileEx</msdn>.
            </remarks>
        </member>
        <member name="M:Au.Files.Move(System.String,System.String,Au.Types.IfExists)">
            <summary>
            Moves (changes path of) file or directory.
            </summary>
            <param name="path">Full path.</param>
            <param name="newPath">
            New full path.
            <note type="note">It is not the new parent directory. Use <see cref="M:Au.Files.MoveTo(System.String,System.String,Au.Types.IfExists)"/> for it.</note>
            </param>
            <param name="ifExists"></param>
            <exception cref="T:System.ArgumentException">path or newPath is not full path (see <see cref="M:Au.Path_.IsFullPath(System.String)"/>).</exception>
            <exception cref="T:System.IO.FileNotFoundException">The source file (path) does not exist or cannot be found.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            In most cases uses API <msdn>MoveFileEx</msdn>. It's fast, because don't need to copy files.
            In these cases copies/deletes: destination is on another drive; need to merge directories.
            When need to copy, does not copy the security properties; sets default security properties.
            
            Creates the destination directory if does not exist (see <see cref="M:Au.Files.CreateDirectory(System.String,System.String)"/>).
            If path and newPath share the same parent directory, just renames the file.
            </remarks>
        </member>
        <member name="M:Au.Files.MoveTo(System.String,System.String,Au.Types.IfExists)">
            <summary>
            Moves file or directory into another directory.
            </summary>
            <param name="path">Full path.</param>
            <param name="newDirectory">New parent directory.</param>
            <param name="ifExists"></param>
            <exception cref="T:System.ArgumentException">
            path or newDirectory is not full path (see <see cref="M:Au.Path_.IsFullPath(System.String)"/>).
            path is drive. To move drive content, use <see cref="M:Au.Files.Move(System.String,System.String,Au.Types.IfExists)"/>.
            </exception>
            <exception cref="T:System.IO.FileNotFoundException">The source file (path) does not exist or cannot be found.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            In most cases uses API <msdn>MoveFileEx</msdn>. It's fast, because don't need to copy files.
            In these cases copies/deletes: destination is on another drive; need to merge directories.
            When need to copy, does not copy the security properties; sets default security properties.
            
            Creates the destination directory if does not exist (see <see cref="M:Au.Files.CreateDirectory(System.String,System.String)"/>).
            </remarks>
        </member>
        <member name="M:Au.Files.Copy(System.String,System.String,Au.Types.IfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})">
            <summary>
            Copies file or directory.
            </summary>
            <param name="path">Full path.</param>
            <param name="newPath">
            New full path.
            <note type="note">It is not the new parent directory. Use <see cref="M:Au.Files.CopyTo(System.String,System.String,Au.Types.IfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})"/> for it.</note>
            </param>
            <param name="ifExists"></param>
            <param name="copyFlags">Options used when copying directory.</param>
            <param name="filter">
            This can be used when copying directory. A callback function to call for each descendant file and subdirectory.
            If it returns false, the file/subdirectory is not copied.
            </param>
            <exception cref="T:System.ArgumentException">path or newPath is not full path (see <see cref="M:Au.Path_.IsFullPath(System.String)"/>).</exception>
            <exception cref="T:System.IO.FileNotFoundException">The source file (path) does not exist or cannot be found.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Uses API <msdn>CopyFileEx</msdn>.
            On Windows 7 does not copy the security properties; sets default security properties.
            Does not copy symbolic links (silently skips, no exception) if this process is not admin.
            Creates the destination directory if does not exist (see <see cref="M:Au.Files.CreateDirectory(System.String,System.String)"/>).
            </remarks>
        </member>
        <member name="M:Au.Files.CopyTo(System.String,System.String,Au.Types.IfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})">
            <summary>
            Copies file or directory into another directory.
            </summary>
            <param name="path">Full path.</param>
            <param name="newDirectory">New parent directory.</param>
            <param name="ifExists"></param>
            <param name="copyFlags">Options used when copying directory.</param>
            <param name="filter">
            This can be used when copying directory. A callback function to call for each descendant file and subdirectory.
            If it returns false, the file/subdirectory is not copied.
            </param>
            <exception cref="T:System.ArgumentException">
            path or newDirectory is not full path (see <see cref="M:Au.Path_.IsFullPath(System.String)"/>).
            path is drive. To copy drive content, use <see cref="M:Au.Files.Copy(System.String,System.String,Au.Types.IfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})"/>.
            </exception>
            <exception cref="T:System.IO.FileNotFoundException">The source file (path) does not exist or cannot be found.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Uses API <msdn>CopyFileEx</msdn>.
            On Windows 7 does not copy the security properties; sets default security properties.
            Does not copy symbolic links (silently skips, no exception) if this process is not admin.
            Creates the destination directory if does not exist (see <see cref="M:Au.Files.CreateDirectory(System.String,System.String)"/>).
            </remarks>
        </member>
        <member name="M:Au.Files.Delete(System.String,System.Boolean)">
            <summary>
            Deletes file or directory.
            Does nothing if it does not exist (no exception).
            </summary>
            <param name="path">Full path.</param>
            <param name="tryRecycleBin">
            Send to the Recycle Bin. If not possible, delete anyway.
            Why could be not possible: 1. The file is in a removable drive (most removables don't have a recycle bin). 2. The file is too large. 3. The path is too long. 4. The Recycle Bin is not used on that drive (it can be set in the Recycle Bin Properties dialog). 5. This process is non-UI-interactive, eg a service. 6. Unknown reasons.
            Note: it is much slower. To delete multiple, use <see cref="M:Au.Files.Delete(System.Collections.Generic.IEnumerable{System.String},System.Boolean)"/>.
            </param>
            <exception cref="T:System.ArgumentException">path is not full path (see <see cref="M:Au.Path_.IsFullPath(System.String)"/>).</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            If directory, also deletes all its files and subdirectories. If fails to delete some, tries to delete as many as possible.
            Deletes read-only files too.
            Does not show any message boxes etc (confirmation, error, UAC consent, progress).
            
            Some reasons why this function can fail:
            1. The file is open (in any process). Or a file in the directory is open.
            2. This process does not have security permissions to access or delete the file or directory or some of its descendants.
            3. The directory is (or contains) the "current directory" (in any process).
            </remarks>
        </member>
        <member name="M:Au.Files.Delete(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Deletes multiple files or/and directories.
            The same as <see cref="M:Au.Files.Delete(System.String,System.Boolean)"/>, but faster when using Recycle Bin.
            </summary>
            <param name="paths">string array, List or other collection. Full paths.</param>
            <param name="tryRecycleBin"></param>
        </member>
        <member name="M:Au.Files._Delete(System.String,System.Boolean)">
            <summary>
            note: path must be normalized.
            </summary>
        </member>
        <member name="M:Au.Files.CalculateDirectorySize(System.String,Au.Types.FEFlags)">
            <summary>
            Calls <see cref="M:Au.Files.EnumDirectory(System.String,Au.Types.FEFlags,System.Func{Au.Types.FEFile,System.Boolean},System.Action{System.String})"/> and returns sum of all file sizes.
            With default flags, it includes sizes of all descendant files, in this directory and all subdirectories except in inaccessible [sub]directories.
            </summary>
            <param name="path">Full path.</param>
            <param name="flags">EnumDirectory flags.</param>
            <exception cref="T:System.Exception"><see cref="M:Au.Files.EnumDirectory(System.String,Au.Types.FEFlags,System.Func{Au.Types.FEFile,System.Boolean},System.Action{System.String})"/> exceptions. By default, no exceptions if used full path and the directory exists.</exception>
            <remarks>
            This function is slow if the directory is large.
            Don't use this function for files (throws exception) and drives (instead use <see cref="T:System.IO.DriveInfo"/>, it's fast and includes sizes of Recycle Bin and other protected hidden system directories).
            </remarks>
        </member>
        <member name="M:Au.Files.CreateDirectory(System.String,System.String)">
            <summary>
            Creates new directory if does not exists.
            If need, creates missing parent/ancestor directories.
            Returns true if created new directory, false if the directory already exists. Throws exception if fails.
            </summary>
            <param name="path">Path of new directory.</param>
            <param name="templateDirectory">Optional path of a template directory from which to copy some properties. See API <msdn>CreateDirectoryEx</msdn>.</param>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            If the directory already exists, this function does nothing, and returns false.
            Else, at first it creates missing parent/ancestor directories, then creates the specified (path) directory.
            To create the specified directory, calls API <msdn>CreateDirectory</msdn> or <msdn>CreateDirectoryEx</msdn> (if templateDirectory is not null).
            </remarks>
        </member>
        <member name="M:Au.Files.CreateDirectoryFor(System.String)">
            <summary>
            Creates parent directory for a new file, if does not exist.
            The same as <see cref="M:Au.Files.CreateDirectory(System.String,System.String)"/>, just removes filename from filePath.
            </summary>
            <param name="filePath">Path of new file.</param>
            <exception cref="T:System.ArgumentException">Not full path. No filename.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            string path = @"D:\Test\new\test.txt";
            Files.CreateDirectoryFor(path);
            File.WriteAllText(path, "text"); //would fail if directory @"D:\Test\new" does not exist
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Files._PreparePath(System.String)">
            <summary>
            Expands environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>). Throws ArgumentException if not full path. Normalizes. Removes or adds '\\' at the end.
            </summary>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
        </member>
        <member name="M:Au.Files._FindFilename(System.String,System.Boolean)">
            <summary>
            Finds filename, eg @"b.txt" in @"c:\a\b.txt".
            </summary>
            <exception cref="T:System.ArgumentException">'\\' not found or is at the end. If noException, instead returns -1.</exception>
        </member>
        <member name="M:Au.Files._RemoveFilename(System.String,System.Boolean)">
            <summary>
            Removes filename, eg @"c:\a\b.txt" -> @"c:\a".
            </summary>
            <exception cref="T:System.ArgumentException">'\\' not found or is at the end. If noException, instead returns null.</exception>
        </member>
        <member name="M:Au.Files._GetFilename(System.String,System.Boolean)">
            <summary>
            Gets filename, eg @"c:\a\b.txt" -> @"b.txt".
            </summary>
            <exception cref="T:System.ArgumentException">'\\' not found or is at the end. If noException, instead returns null.</exception>
        </member>
        <member name="M:Au.Files._IsSepChar(System.Char)">
            <summary>
            Returns true if character c == '\\' || c == '/'.
            </summary>
        </member>
        <member name="T:Au.Shell">
            <summary>
            Windows shell functions.
            Windows shell manages files, folders (directories), shortcuts and virtual objects such as Control Panel.
            </summary>
        </member>
        <member name="T:Au.Shell.Pidl">
            <summary>
            A Pidl variable holds and manages an ITEMIDLIST pointer. An ITEMIDLIST is a native variable-length structure that represents a file or other shell object and is used by Windows shell API instead of file-system path.
            With shell API is used ITEMIDLIST pointer (PIDL) as IntPtr. This class has an implicit Pidl-to-IntPtr cast operator and therefore a Pidl variable can be passed to shell API IntPtr parameters.
            The ITEMIDLIST is in unmanaged memory, therefore this class implements IDisposable.
            </summary>
            <remarks>
            When calling shell API, virtual objects can be identified only by ITEMIDLIST. Some API also support "parsing name", which usually looks like "::{CLSID-1}\::{CLSID-2}". File-system objects can be identified by path as well as by ITEMIDLIST. URLs can be identified by URL as well as by ITEMIDLIST.
            </remarks>
        </member>
        <member name="P:Au.Shell.Pidl.UnsafePtr">
            <summary>
            Gets the ITEMIDLIST pointer (PIDL).
            </summary>
            <remarks>
            The ITEMIDLIST memory is managed by this variable and will be freed when disposing or GC-collecting it. Use <see cref="M:System.GC.KeepAlive(System.Object)"/> where need.
            </remarks>
        </member>
        <member name="P:Au.Shell.Pidl.HandleRef">
            <summary>
            Gets the ITEMIDLIST pointer (PIDL).
            </summary>
            <remarks>
            Use to pass to API where the parameter type is HandlePtr. It is safer than <see cref="P:Au.Shell.Pidl.UnsafePtr"/> because ensures that this variable will not be GC-collected during API call even if not referenced after the call.
            </remarks>
        </member>
        <member name="P:Au.Shell.Pidl.IsNull">
            <summary>
            Returns true if the PIDL is default(IntPtr).
            </summary>
        </member>
        <member name="M:Au.Shell.Pidl.#ctor(System.IntPtr)">
            <summary>
            Assigns an ITEMIDLIST to this variable.
            </summary>
            <param name="pidl">
            ITEMIDLIST pointer (PIDL).
            It can be created by any API that creates ITEMIDLIST. They allocate the memory with API CoTaskMemAlloc.
            This variable will finally free it with Marshal.FreeCoTaskMem.
            </param>
        </member>
        <member name="M:Au.Shell.Pidl.Dispose">
            <summary>
            Frees the ITEMIDLIST with Marshal.FreeCoTaskMem and clears this variable.
            </summary>
        </member>
        <member name="M:Au.Shell.Pidl.Finalize">
            
        </member>
        <member name="M:Au.Shell.Pidl.Detach">
            <summary>
            Gets the ITEMIDLIST and clears this variable so that it cannot be used and will not free the ITEMIDLIST memory. To free it use Marshal.FreeCoTaskMem.
            </summary>
        </member>
        <member name="M:Au.Shell.Pidl.FromString(System.String,System.Boolean)">
            <summary>
            Converts string to ITEMIDLIST and creates new Pidl variable that holds it.
            Returns null if failed.
            Note: Pidl is disposable.
            </summary>
            <param name="s">A file-system path or URL or shell object parsing name (see <see cref="M:Au.Shell.Pidl.ToShellString(Au.Types.Native.SIGDN,System.Boolean)"/>) or ":: HexEncodedITEMIDLIST" (see <see cref="M:Au.Shell.Pidl.ToHexString"/>). Supports environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>).</param>
            <param name="throwIfFailed">If failed, throw AuException.</param>
            <exception cref="T:Au.Types.AuException">Failed, and throwIfFailed is true. Probably invalid s.</exception>
            <remarks>
            Calls <msdn>SHParseDisplayName</msdn>, except when string is ":: HexEncodedITEMIDLIST".
            Never fails if s is ":: HexEncodedITEMIDLIST", even if it creates an invalid ITEMIDLIST.
            </remarks>
        </member>
        <member name="M:Au.Shell.Pidl.LibFromString(System.String,System.Boolean)">
            <summary>
            The same as <see cref="M:Au.Shell.Pidl.FromString(System.String,System.Boolean)"/>, just returns unmanaged ITEMIDLIST pointer (PIDL).
            Later need to free it with Marshal.FreeCoTaskMem.
            </summary>
            <param name="s"></param>
            <param name="throwIfFailed"></param>
        </member>
        <member name="M:Au.Shell.Pidl.ToShellString(Au.Types.Native.SIGDN,System.Boolean)">
            <summary>
            Converts the ITEMIDLIST to file path or URL or shell object parsing name or display name, depending on stringType argument.
            Returns null if this variable does not have an ITEMIDLIST (eg disposed or detached).
            If failed, returns null or throws exception.
            </summary>
            <param name="stringType">
            String format.
            Often used:
            Native.SIGDN.SIGDN_NORMALDISPLAY - returns object name without path. It is best to display in UI but cannot be parsed to create ITEMIDLIST again.
            Native.SIGDN.SIGDN_FILESYSPATH - returns path if the ITEMIDLIST identifies a file system object (file or directory). Else returns null.
            Native.SIGDN.SIGDN_URL - if URL, returns URL. If file system object, returns its path like "file:///C:/a/b.txt". Else returns null.
            Native.SIGDN.SIGDN_DESKTOPABSOLUTEPARSING - returns path (if file system object) or URL (if URL) or shell object parsing name (if virtual object eg Control Panel). Note: not all returned parsing names can actually be parsed to create ITEMIDLIST again, therefore usually it's better to use <see cref="M:Au.Shell.Pidl.ToString"/> instead.
            </param>
            <param name="throwIfFailed">If failed, throw AuException.</param>
            <exception cref="T:Au.Types.AuException">Failed, and throwIfFailed is true.</exception>
            <remarks>
            Calls <msdn>SHGetNameFromIDList</msdn>.
            </remarks>
        </member>
        <member name="M:Au.Shell.Pidl.LibToShellString(System.IntPtr,Au.Types.Native.SIGDN,System.Boolean)">
            <summary>
            The same as <see cref="M:Au.Shell.Pidl.ToShellString(Au.Types.Native.SIGDN,System.Boolean)"/>, just uses an ITEMIDLIST pointer that is not stored in a Pidl variable.
            </summary>
        </member>
        <member name="M:Au.Shell.Pidl.ToString">
            <summary>
            Converts the ITEMIDLIST to string.
            If it identifies an existing file-system object (file or directory), returns path. If URL, returns URL. Else returns ":: HexEncodedITEMIDLIST" (see <see cref="M:Au.Shell.Pidl.ToHexString"/>).
            Returns null if this variable does not have an ITEMIDLIST (eg disposed or detached).
            </summary>
        </member>
        <member name="M:Au.Shell.Pidl.LibToString(System.IntPtr)">
            <summary>
            The same as <see cref="M:Au.Shell.Pidl.ToString"/>, just uses an ITEMIDLIST pointer that is not stored in a Pidl variable.
            </summary>
        </member>
        <member name="M:Au.Shell.Pidl.ToHexString">
            <summary>
            Returns string ":: HexEncodedITEMIDLIST".
            It can be used with some functions of this library, mostly of classes Shell, Shell.Pidl and Icons. Cannot be used with native and .NET functions.
            Returns null if this variable does not have an ITEMIDLIST (eg disposed or detached).
            </summary>
        </member>
        <member name="M:Au.Shell.Pidl.LibToHexString(System.IntPtr)">
            <summary>
            The same as <see cref="M:Au.Shell.Pidl.ToHexString"/>, just uses an ITEMIDLIST pointer that is not stored in a Pidl variable.
            </summary>
        </member>
        <member name="T:Au.Shell.Shortcut">
            <summary>
            Creates shell shortcuts (.lnk files) and gets shortcut properties.
            </summary>
        </member>
        <member name="M:Au.Shell.Shortcut.Dispose">
            <summary>
            Releases internally used COM objects (IShellLink, IPersistFile).
            </summary>
        </member>
        <member name="P:Au.Shell.Shortcut.IShellLink">
            <summary>
            Returns the internally used IShellLink COM interface.
            </summary>
        </member>
        <member name="M:Au.Shell.Shortcut.Open(System.String)">
            <summary>
            Creates a new instance of the Shortcut class that can be used to get shortcut properties.
            Exception if shortcut file does not exist or cannot open it for read access.
            </summary>
            <param name="lnkPath">Shortcut file (.lnk) path.</param>
            <exception cref="T:Au.Types.AuException">Failed to open .lnk file.</exception>
        </member>
        <member name="M:Au.Shell.Shortcut.Create(System.String)">
            <summary>
            Creates a new instance of the Shortcut class that can be used to create or replace a shortcut file.
            You can set properties and finally call <see cref="M:Au.Shell.Shortcut.Save"/>.
            If the shortcut file already exists, Save replaces it.
            </summary>
            <param name="lnkPath">Shortcut file (.lnk) path.</param>
        </member>
        <member name="M:Au.Shell.Shortcut.OpenOrCreate(System.String)">
            <summary>
            Creates a new instance of the Shortcut class that can be used to create or modify a shortcut file.
            Exception if file exists but cannot open it for read-write access.
            You can get and set properties and finally call <see cref="M:Au.Shell.Shortcut.Save"/>.
            If the shortcut file already exists, Save updates it.
            </summary>
            <param name="lnkPath">Shortcut file (.lnk) path.</param>
            <exception cref="T:Au.Types.AuException">Failed to open existing .lnk file.</exception>
        </member>
        <member name="M:Au.Shell.Shortcut.Save">
            <summary>
            Saves the Shortcut variable properties to the shortcut file.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to save .lnk file.</exception>
            <remarks>
            Creates parent folder if need.
            </remarks>
        </member>
        <member name="P:Au.Shell.Shortcut.TargetPath">
            <summary>
            Gets or sets shortcut target path.
            This property is null if target isn't a file system object, eg Control Panel or URL.
            </summary>
            <remarks>The 'get' function gets path with expanded environment variables. If possible, it corrects the target of MSI shortcuts and 64-bit Program Files shortcuts where IShellLink.GetPath() lies.</remarks>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.Shell.Shortcut.TargetPathRawMSI">
            <summary>
            Gets shortcut target path and does not correct wrong MSI shortcut target.
            </summary>
        </member>
        <member name="P:Au.Shell.Shortcut.TargetPidl">
            <summary>
            Gets or sets a non-file-system target (eg Control Panel) through its ITEMIDLIST.
            </summary>
            <remarks>
            Also can be used for any target type, but gets raw value, for example MSI shortcut target is incorrect.
            Most but not all shortcuts have this property; the 'get' function returns null if the shortcut does not have it.
            </remarks>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.Shell.Shortcut.TargetURL">
            <summary>
            Gets or sets a URL target.
            Note: it is a .lnk shortcut, not a .url shortcut.
            The 'get' function returns string "file:///..." if target is a file.
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.Shell.Shortcut.TargetAnyType">
            <summary>
            Gets or sets target of any type - file/folder, URL, virtual shell object (see <see cref="T:Au.Shell.Pidl"/>).
            The string can be used with <see cref="M:Au.Shell.Run(System.String,System.String,Au.Types.SRFlags,Au.Types.SRMore)"/>.
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="M:Au.Shell.Shortcut.GetIconLocation(System.Int32@)">
            <summary>
            Gets custom icon file path and icon index.
            Returns null if the shortcut does not have a custom icon (then you see its target icon).
            </summary>
            <param name="iconIndex">Receives 0 or icon index or negative icon resource id.</param>
        </member>
        <member name="M:Au.Shell.Shortcut.SetIconLocation(System.String,System.Int32)">
            <summary>
            Sets icon file path and icon index.
            </summary>
            <param name="path"></param>
            <param name="iconIndex">0 or icon index or negative icon resource id.</param>
            <exception cref="T:Au.Types.AuException"/>
        </member>
        <member name="P:Au.Shell.Shortcut.WorkingDirectory">
            <summary>
            Gets or sets the working directory path (Start in).
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.Shell.Shortcut.Arguments">
            <summary>
            Gets or sets the command-line arguments.
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.Shell.Shortcut.Description">
            <summary>
            Gets or sets the description text (Comment).
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.Shell.Shortcut.Hotkey">
            <summary>
            Gets or sets hotkey.
            Example: <c>x.Hotkey = Keys.Control | Keys.Alt | Keys.E;</c>
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.Shell.Shortcut.ShowState">
            <summary>
            Gets or sets the window show state.
            The value can be 1 (normal, default), 2 (minimized) or 3 (maximized).
            Most programs ignore it.
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="M:Au.Shell.Shortcut.GetTarget(System.String)">
            <summary>
            Gets shortcut target path or URL or virtual shell object ITEMIDLIST.
            Uses <see cref="M:Au.Shell.Shortcut.Open(System.String)"/> and <see cref="P:Au.Shell.Shortcut.TargetAnyType"/>.
            </summary>
            <param name="lnkPath">Shortcut file (.lnk) path.</param>
            <exception cref="T:Au.Types.AuException">Failed to open.</exception>
        </member>
        <member name="M:Au.Shell.Shortcut.Delete(System.String)">
            <summary>
            If shortcut file exists, unregisters its hotkey and deletes it.
            </summary>
            <param name="lnkPath">.lnk file path.</param>
            <exception cref="T:Au.Types.AuException">Failed to unregister hotkey.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Files.Delete(System.String,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.Shell.Shortcut._UnregisterHotkey(System.String)">
            <exception cref="T:Au.Types.AuException">Failed to open or save.</exception>
        </member>
        <member name="M:Au.Shell._Normalize(System.String)">
            <summary>
            The same as <see cref="M:Au.Path_.Normalize(System.String,System.String,Au.Types.PNFlags)"/>(CanBeUrlOrShell|DoNotPrefixLongPath), but ignores non-full path (returns s).
            </summary>
            <param name="s">File-system path or URL or "::...".</param>
        </member>
        <member name="M:Au.Shell.Run(System.String,System.String,Au.Types.SRFlags,Au.Types.SRMore)">
            <summary>
            Runs/opens a program, document, folder, URL, new email, Control Panel item etc.
            By default returns process id. If used flag WaitForExit, returns process exit code.
            Returns 0 if did not start new process or did not get process handle, usually because opened the document in an existing process.
            </summary>
            <param name="file">
            What to run. Can be:
            Full path of a file or folder. Examples: <c>@"C:\folder\file.txt"</c>, <c>Folders.System + "notepad.exe"</c>, <c>@"%Folders.System%\notepad.exe"</c>.
            Filename of a file or folder, like <c>"notepad.exe"</c>. The function calls <see cref="M:Au.Files.SearchPath(System.String,System.String[])"/>.
            Path relative to <see cref="P:Au.Folders.ThisApp"/>. Examples: <c>"x.exe"</c>, <c>@"subfolder\x.exe"</c>, <c>@".\subfolder\x.exe"</c>, <c>@"..\another folder\x.exe"</c>.
            URL. Examples: <c>"http://a.b.c/d"</c>, <c>"file:///path"</c>.
            Email, like <c>"mailto:a@b.c"</c>. Subject, body etc also can be specified, and Google knows how.
            Shell object's ITEMIDLIST like <c>":: HexEncodedITEMIDLIST"</c>. See <see cref="M:Au.Shell.Pidl.ToHexString"/>, <see cref="T:Au.Folders.Virtual"/>. Can be used to open virtual folders and items like Control Panel.
            Shell object's parsing name, like <c>@"::{CLSID}"</c>. See <see cref="M:Au.Shell.Pidl.ToShellString(Au.Types.Native.SIGDN,System.Boolean)"/>, <see cref="T:Au.Folders.VirtualPidl"/>. Can be used to open virtual folders and items like Control Panel.
            To run a Windows Store App, use <c>@"shell:AppsFolder\WinStoreAppId"</c> format. Examples: <c>@"shell:AppsFolder\Microsoft.WindowsCalculator_8wekyb3d8bbwe!App"</c>, <c>@"shell:AppsFolder\windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel"</c>. To discover the string use <see cref="M:Au.Wnd.Misc.GetWindowsStoreAppId(Au.Wnd,System.Boolean,System.Boolean)"/> or Google.
            Supports environment variables, like <c>@"%TMP%\file.txt"</c>. See <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>.
            </param>
            <param name="args">
            Command line arguments.
            This function expands environment variables if starts with "%" or "\"%".
            </param>
            <param name="flags"></param>
            <param name="more">Allows to specify more parameters.</param>
            <exception cref="T:Au.Types.AuException">Failed. For example, the file does not exist.</exception>
            <remarks>
            It works like when you double-click an icon. It may start new process or not. For example it may just activate window if the program is already running.
            Uses API <msdn>ShellExecuteEx</msdn>.
            Similar to <see cref="M:System.Diagnostics.Process.Start(System.String,System.String)"/>.
            The returned process id can be used to find a window of the new process. Example:
            <code><![CDATA[
            Wnd w = WaitFor.WindowActive(10, "*- Notepad", "Notepad", Shell.Run("notepad.exe"));
            ]]></code>
            </remarks>
            <example>
            <code><![CDATA[
            Wnd w = Wnd.Find("*- Notepad", "Notepad");
            if(w.Is0) { Shell.Run("notepad.exe"); w = WaitFor.WindowActive(Wnd.LastFind); }
            w.Activate();
            ]]></code>
            </example>
            <seealso cref="M:Au.Wnd.FindOrRun(System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object,System.Func{System.Int32},System.Double,System.Boolean)"/>
        </member>
        <member name="M:Au.Shell.TryRun(System.String,System.String,Au.Types.SRFlags,Au.Types.SRMore)">
            <summary>
            Calls <see cref="M:Au.Shell.Run(System.String,System.String,Au.Types.SRFlags,Au.Types.SRMore)"/> and handles exceptions. All parameters are the same.
            If Run throws exception, shows warning with its Message and returns int.MinValue.
            This is useful when you don't care whether Run succeeded, for example in AuMenu menu item command handlers. Using try/catch there would not look good.
            Handles only exception of type AuException. It is thrown when fails, usually when the file does not exist.
            </summary>
            <seealso cref="M:Au.NoClass.PrintWarning(System.String,System.Int32,System.String)"/>
            <seealso cref="M:Au.AuScriptOptions.DisableWarnings(System.String[])"/>
        </member>
        <member name="M:Au.Shell.RunConsole(System.String@,System.String,System.String,System.String,System.Text.Encoding)">
            <summary>
            Runs a console program, waits until its process ends, and gets its output text.
            Returns the process exit code. Usually a non-0 value means error.
            </summary>
            <param name="output">
            Receives the output text.
            Console programs have two output text streams - standard output and standard error. This function gets both, and the error text is always after the output text.
            </param>
            <param name="file">
            Path or name of an .exe or .bat file. Can be:
            Full path. Examples: <c>@"C:\folder\x.exe"</c>, <c>Folders.System + "x.exe"</c>, <c>@"%Folders.System%\x.exe"</c>.
            Filename, like <c>"x.exe"</c>. The function calls <see cref="M:Au.Files.SearchPath(System.String,System.String[])"/>.
            Path relative to <see cref="P:Au.Folders.ThisApp"/>. Examples: <c>"x.exe"</c>, <c>@"subfolder\x.exe"</c>, <c>@".\subfolder\x.exe"</c>, <c>@"..\another folder\x.exe"</c>.
            Supports environment variables, like <c>@"%TMP%\x.bat"</c>. See <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>.
            </param>
            <param name="args">
            Command line arguments.
            This function expands environment variables if starts with "%" or "\"%".
            </param>
            <param name="directory">Working directory. Default - <see cref="M:System.IO.Directory.GetCurrentDirectory"/> of this process.</param>
            <param name="textEncoding">Text encoding used to convert console's ANSI text to C# Unicode text.</param>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed, for example file not found.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.Diagnostics.Process.Start"/>, <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)"/>, <see cref="M:System.IO.StreamReader.ReadToEnd"/>.</exception>
            <remarks>
            Does not show the console window.
            Uses <see cref="M:System.Diagnostics.Process.Start"/>. Does not use Windows shell API.
            See also <see cref="M:Au.Shell.Run(System.String,System.String,Au.Types.SRFlags,Au.Types.SRMore)"/>.
            </remarks>
        </member>
        <member name="M:Au.Shell.RunConsole(System.String,System.String,System.String,System.Text.Encoding)">
            <summary>
            Runs a console program (hidden), waits until its process ends, and prints its output text.
            Calls <see cref="M:Au.Shell.RunConsole(System.String@,System.String,System.String,System.String,System.Text.Encoding)"/> and <see cref="M:Au.NoClass.Print(System.String)"/>.
            </summary>
            <param name="file"></param>
            <param name="args"></param>
            <param name="directory"></param>
            <param name="textEncoding"></param>
        </member>
        <member name="M:Au.Shell.SelectFileInExplorer(System.String)">
            <summary>
            Opens parent folder in Explorer and selects the file.
            Returns null if fails, for example if the file does not exist.
            </summary>
            <param name="path">
            Full path of a file or directory or other shell object.
            Supports @"%environmentVariable%\..." (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>) and "::..." (see <see cref="M:Au.Shell.Pidl.ToHexString"/>).
            </param>
        </member>
        <member name="T:Au.Path_">
            <summary>
            Extends the .NET class Path.
            </summary>
        </member>
        <member name="M:Au.Path_.ExpandEnvVar(System.String)">
             <summary>
             If path starts with "%" or "\"%", expands environment variables enclosed in %, else just returns path.
             Also supports known folder names, like "%Folders.Documents%". More info in Remarks.
             </summary>
             <param name="path">Any string. Can be null.</param>
             <remarks>
             Supports known folder names as you can get with <see cref="T:Au.Folders"/> class properties.
             Example: @"%Folders.Documents%\file.txt".
             Example: @"%Folders.Virtual.ControlPanel%" //gets ":: HexEncodedITEMIDLIST".
             Usually known folders are used like <c>string path = Folders.Documents + "file.txt"</c>. It's easier and faster. However it cannot be used when you want to store paths in text files, registry, etc. Then this feature is useful.
             To get known folder path, this function calls <see cref="M:Au.Folders.GetFolder(System.String)"/>.
            
             This function is called by many functions of classes Path_, Files, Shell, Icons, some others, therefore all they support environment variables and known folders in path string.
             </remarks>
        </member>
        <member name="M:Au.Path_.LibGetEnvVar(System.String)">
            <summary>
            Gets environment variable's value.
            Returns "" if variable not found.
            Does not support Folders.X.
            </summary>
            <param name="name">Case-insensitive name. Without %.</param>
            <remarks>
            Environment variable values cannot be "" or null. Setting empty value removes the variable.
            </remarks>
        </member>
        <member name="M:Au.Path_.LibEnvVarExists(System.String)">
            <summary>
            Returns true if environment variable exists.
            </summary>
            <param name="name">Case-insensitive name.</param>
            <returns></returns>
        </member>
        <member name="M:Au.Path_.IsFullPath(System.String)">
            <summary>
            Returns true if path matches one of these wildcard patterns:
            	@"?:\*" - local path, like @"C:\a\b.txt". Here ? is A-Z, a-z.
            	@"?:" - drive name, like @"C:". Here ? is A-Z, a-z. Note: it is considered full path in this library, but for .NET and Windows API it is not full path.
            	@"\\*" - network path, like @"\\server\share\...". Or has prefix @"\\?\".
            </summary>
            <param name="path">Any string. Can be null.</param>
            <remarks>
            Supports '/' characters too.
            Supports only file-system paths. Returns false if path is URL (use <see cref="M:Au.Path_.IsUrl(System.String)"/> instead) or starts with "::".
            If path starts with "%environmentVariable%", shows warning and returns false. You should at first expand environment variables with <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/> or instead use <see cref="M:Au.Path_.IsFullPathExpandEnvVar(System.String@)"/>.
            </remarks>
        </member>
        <member name="M:Au.Path_.IsFullPathExpandEnvVar(System.String@)">
            <summary>
            Expands environment variables and calls <see cref="M:Au.Path_.IsFullPath(System.String)"/>.
            Returns true if path matches one of these wildcard patterns:
            	@"?:\*" - local path, like @"C:\a\b.txt". Here ? is A-Z, a-z.
            	@"?:" - drive name, like @"C:". Here ? is A-Z, a-z. Note: it is considered full path in this library, but for .NET and Windows API it is not full path.
            	@"\\*" - network path, like @"\\server\share\...". Or has prefix @"\\?\".
            </summary>
            <param name="path">
            Any string. Can be null.
            If starts with '%' character, calls <see cref="M:Au.Path_.IsFullPath(System.String)"/> with expanded environment variables (<see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>). If it returns true, replaces the passed variable with the expanded path string.
            </param>
            <remarks>
            Supports '/' characters too.
            Supports only file-system paths. Returns false if path is URL (use <see cref="M:Au.Path_.IsUrl(System.String)"/> instead) or starts with "::".
            </remarks>
        </member>
        <member name="M:Au.Path_.GetRootLength(System.String)">
            <summary>
            Gets the length of the drive or network folder part in path, including its separator if any.
            If the string does not start with a drive or network folder path, returns 0 or prefix length (@"\\?\" or @"\\?\UNC\").
            </summary>
            <param name="path">Full path or any string. Can be null. Should not be "%environmentVariable%\...".</param>
            <remarks>
            Supports prefixes @"\\?\" and @"\\?\UNC\".
            Supports separators '\\' and '/'.
            </remarks>
        </member>
        <member name="M:Au.Path_.GetUrlProtocolLength(System.String)">
            <summary>
            Gets the length of the URL protocol name (also known as URI scheme) in string, including ':'.
            If the string does not start with a protocol name, returns 0.
            URL examples: "http:" (returns 5), "http://www.x.com" (returns 5), "file:///path" (returns 5), "shell:etc" (returns 6).
            The protocol can be unknown, the function just checks string format, which is an ASCII alpha character followed by one or more ASCII alpha-numeric, '.', '-', '+' characters, followed by ':' character.
            </summary>
            <param name="s">A URL or path or any string. Can be null.</param>
        </member>
        <member name="M:Au.Path_.IsUrl(System.String)">
            <summary>
            Returns true if the string starts with a URL protocol name (existing or not) and ':' character.
            URL examples: "http:", "http://www.x.com", "file:///path", "shell:etc".
            Calls <see cref="M:Au.Path_.GetUrlProtocolLength(System.String)"/> and returns true if it's not 0.
            </summary>
            <param name="s">A URL or path or any string. Can be null.</param>
        </member>
        <member name="M:Au.Path_.Combine(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Combines two path parts using character '\\'. For example directory path and file name.
            </summary>
            <param name="s1">First part. Usually a directory.</param>
            <param name="s2">Second part. Usually a filename or relative path.</param>
            <param name="s2CanBeFullPath">s2 can be full path. If it is, ignore s1 and return s2 with expanded environment variables. If false (default), simply combines s1 and s2.</param>
            <param name="prefixLongPath">Call <see cref="M:Au.Path_.PrefixLongPathIfNeed(System.String)"/> which may prepend @"\\?\" if the result path is very long. Default true.</param>
            <remarks>
            If s1 and s2 are null or "", returns "". Else if s1 is null or "", returns s2. Else if s2 is null or "", returns s1.
            Similar to System.IO.Path.Combine. Main differences: does not throw exceptions; has some options.
            Does not expand environment variables. For it use <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/> before, or <see cref="M:Au.Path_.Normalize(System.String,System.String,Au.Types.PNFlags)"/> instead. Path that starts with an environment variable is considerd not full path.
            </remarks>
            <seealso cref="M:Au.Path_.Normalize(System.String,System.String,Au.Types.PNFlags)"/>
        </member>
        <member name="M:Au.Path_.LibCombine(System.String,System.String,System.Boolean)">
            <summary>
            Combines two path parts.
            Unlike <see cref="M:Au.Path_.Combine(System.String,System.String,System.Boolean,System.Boolean)"/>, fails if some part is empty or @"\" or if s2 is @"\\". Also does not check s2 full path.
            If fails, throws exception or returns null (if noException).
            </summary>
        </member>
        <member name="M:Au.Path_.LibIsSepChar(System.Char)">
            <summary>
            Returns true if character c == '\\' || c == '/'.
            </summary>
        </member>
        <member name="M:Au.Path_._EndsWithDriveWithoutSep(System.String,System.Int32)">
            <summary>
            Returns true if ends with ':' preceded by a drive letter, like "C:" or "more\C:", but not like "moreC:".
            </summary>
            <param name="s">Can be null.</param>
            <param name="length">Use when want to check drive at a middle, not at the end. Eg returns true if s is @"C:\more" and length is 2.</param>
        </member>
        <member name="M:Au.Path_._AddRemoveSep(System.String)">
            <summary>
            Ensures that s either ends with a valid drive path (eg @"C:\" but not "C:") or does not end with '\\' or '/' (unless would become empty if removed).
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="M:Au.Path_.Normalize(System.String,System.String,Au.Types.PNFlags)">
            <summary>
            Makes normal full path from path that can contain special substrings etc.
            The sequence of actions:
            1. If path starts with '%' character, expands environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>).
            2. If path is not full path but looks like URL, and used flag CanBeUrl, returns path.
            3. If path is not full path, and defaultParentDirectory is not null/"", combines path with ExpandEnvVar(defaultParentDirectory).
            4. If path is not full path, throws exception.
            5. Calls API <msdn>GetFullPathName</msdn>. It replaces '/' to '\\', replaces multiple '\\' to single (where need), processes @"\.." etc, trims spaces, etc.
            6. If no flag DoNotExpandDosPath, if contains '~' character, calls API <msdn>GetLongPathName</msdn>. It converts short DOS path to normal path, if possible, for example @"c:\progra~1" to @"c:\program files". It is slow. It converts path only if the file exists.
            7. If no flag DoNotRemoveEndSeparator, removes '\\' character at the end, unless it is a drive path (eg @"C:\").
            8. Appends '\\' character if ends with a drive name (eg "C:" -> @"C:\").
            9. If no flag DoNotPrefixLongPath, calls <see cref="M:Au.Path_.PrefixLongPathIfNeed(System.String)"/>, which adds @"\\?\" etc prefix if path is very long.
            </summary>
            <param name="path">Any path.</param>
            <param name="defaultParentDirectory">If path is not full path, combine it with defaultParentDirectory to make full path.</param>
            <param name="flags"></param>
            <exception cref="T:System.ArgumentException">path is not full path, and defaultParentDirectory is not used or does not make it full path.</exception>
            <remarks>
            Similar to <see cref="M:System.IO.Path.GetFullPath(System.String)"/>. Main differences: this function expands environment variables, does not support relative paths, supports @"\\?\very long path", trims '\\' at the end if need, does not throw exceptions when [it thinks that] path is invalid (except when path is not full).
            </remarks>
        </member>
        <member name="M:Au.Path_.LibNormalize(System.String,Au.Types.PNFlags,System.Boolean)">
            <summary>
            Same as <see cref="M:Au.Path_.Normalize(System.String,System.String,Au.Types.PNFlags)"/>, but skips full-path checking.
            s should be full path. If not full and not null/"", combines with current directory.
            </summary>
        </member>
        <member name="M:Au.Path_.LibExpandDosPath(System.String)">
            <summary>
            Calls API GetLongPathName.
            Currently does not check whether s contains '~' character. Note: the API is slow.
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="M:Au.Path_.LibNormalizeMinimally(System.String,System.Boolean)">
            <summary>
            Prepares path for passing to API that support "..", DOS path etc.
            Calls ExpandEnvVar, _AddRemoveSep, PrefixLongPathIfNeed. Optionally throws if !IsFullPath(path).
            </summary>
            <exception cref="T:System.ArgumentException">Not full path (only if throwIfNotFullPath is true).</exception>
        </member>
        <member name="M:Au.Path_.LibIsShellPath(System.String)">
            <summary>
            Returns true if starts with "::".
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="M:Au.Path_.PrefixLongPath(System.String)">
            <summary>
            If path is full path (see <see cref="M:Au.Path_.IsFullPath(System.String)"/>) and does not start with @"\\?\", prepends @"\\?\".
            If path is network path (like @"\\computer\folder\..."), makes like @"\\?\UNC\computer\folder\...".
            </summary>
            <param name="path">
            Path. Can be null.
            Must not start with "%environmentVariable%", this function does not expand it. See <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>.
            </param>
            <remarks>
            Windows API kernel functions support extended-length paths, ie longer than 259 characters. But the path must have this prefix. Windows API shell functions don't support it.
            </remarks>
        </member>
        <member name="M:Au.Path_.PrefixLongPathIfNeed(System.String)">
            <summary>
            Calls <see cref="M:Au.Path_.PrefixLongPath(System.String)"/> if path is longer than <see cref="F:Au.Path_.MaxDirectoryPathLength"/> (247).
            </summary>
            <param name="path">
            Path. Can be null.
            Must not start with "%environmentVariable%", this function does not expand it. See <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>.
            </param>
        </member>
        <member name="M:Au.Path_.UnprefixLongPath(System.String)">
            <summary>
            If path starts with @"\\?\" prefix, removes it.
            If path starts with @"\\?\UNC\" prefix, removes @"?\UNC\".
            </summary>
            <param name="path">
            Path. Can be null.
            Must not start with "%environmentVariable%", this function does not expand it. See <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>.
            </param>
        </member>
        <member name="M:Au.Path_._GetPrefixLength(System.String)">
            <summary>
            If s starts with @"\\?\UNC\", returns 8.
            Else if starts with @"\\?\", returns 4.
            Else returns 0.
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="F:Au.Path_.MaxFilePathLength">
            <summary>
            Maximal file (not directory) path length supported by all functions (native, .NET and this library).
            For longer paths need @"\\?\" prefix. It is supported by most native kernel API (but not shell API) and by most functions of this library.
            </summary>
        </member>
        <member name="F:Au.Path_.MaxDirectoryPathLength">
            <summary>
            Maximal directory path length supported by all functions (native, .NET and this library).
            For longer paths need @"\\?\" prefix. It is supported by most native kernel API (but not shell API) and by most functions of this library.
            </summary>
        </member>
        <member name="M:Au.Path_.CorrectFileName(System.String,System.String)">
            <summary>
            Replaces characters that cannot be used in file names.
            Also corrects other forms of invalid or problematic filename: trims spaces and other blank characters; replaces "." at the end; prepends "@" if a reserved name like "CON" or "CON.txt"; returns "-" if name is null/empty/whitespace.
            Returns valid filename. However it can be too long (itself or when combined with a directory path).
            </summary>
            <param name="name">Initial filename.</param>
            <param name="invalidCharReplacement">A string that will replace each invalid character. Default "-".</param>
        </member>
        <member name="M:Au.Path_.IsInvalidFileName(System.String)">
            <summary>
            Returns true if name cannot be used for a file name, eg contains '\\' etc characters or is empty.
            More info: <see cref="M:Au.Path_.CorrectFileName(System.String,System.String)"/>.
            </summary>
            <param name="name">Any string. Can be null. Example: "name.txt".</param>
        </member>
        <member name="M:Au.Path_.GetFileName(System.String)">
            <summary>
            Gets filename with extension.
            Returns "" if there is no filename.
            Returns null if path is null.
            </summary>
            <param name="path">Path or filename.</param>
            <remarks>
            Similar to <see cref="M:System.IO.Path.GetFileName(System.String)"/>. Some diferences: does not throw exceptions; if ends with '\\' or '/', gets part before it, eg "B" from @"C:\A\B\".
            Supports separators '\\' and '/'.
            Also supports URL and shell parsing names like @"::{CLSID-1}\0\::{CLSID-2}".
            Example paths and results:
            <code>
            @"C:\A\B\file.txt" -> "file.txt".
            "file.txt" -> "file.txt".
            "file" -> "file".
            @"C:\A\B" -> "B".
            @"C:\A\B\" -> "B".
            @"C:\A\/B\/" -> "B".
            @"C:\" -> "".
            @"C:" -> "".
            @"\\network\share" -> "share".
            @"C:\aa\file.txt:alt.stream" -> "file.txt:alt.stream".
            "http://a.b.c" -> "a.b.c".
            "::{A}\::{B}" -> "::{B}".
            "" -> "".
            null -> null.
            </code>
            </remarks>
        </member>
        <member name="M:Au.Path_.GetFileNameWithoutExtension(System.String)">
            <summary>
            Gets filename without extension.
            Returns "" if there is no filename.
            Returns null if path is null.
            </summary>
            <param name="path">Path or filename.</param>
            <remarks>
            Similar to <see cref="M:System.IO.Path.GetFileNameWithoutExtension(System.String)"/> Some diferences: does not throw exceptions; if ends with '\\' or '/', gets part before it, eg "B" from @"C:\A\B\" (then does not remove extension from it because it is a directory name).
            Supports separators '\\' and '/'.
            Also supports URL and shell parsing names like @"::{CLSID-1}\0\::{CLSID-2}".
            Example paths and results:
            <code>
            @"C:\A\B\file.txt" -> "file".
            "file.txt" -> "file".
            "file" -> "file".
            @"C:\A\B" -> "B".
            @"C:\A\B\" -> "B".
            @"C:\A\B.B\" -> "B.B".
            @"C:\" -> "".
            @"C:" -> "".
            @"\\network\share" -> "share".
            @"C:\aa\file.txt:alt.stream" -> "file.txt:alt".
            "http://a.b.c" -> "a.b".
            "::{A}\::{B}" -> "::{B}".
            "" -> "".
            null -> null.
            </code>
            </remarks>
        </member>
        <member name="M:Au.Path_.GetExtension(System.String)">
            <summary>
            Gets filename extension, like ".txt".
            Returns "" if there is no extension.
            Returns null if path is null.
            </summary>
            <param name="path">Path or filename.</param>
            <remarks>
            Supports separators '\\' and '/'.
            Like <see cref="M:System.IO.Path.GetExtension(System.String)"/>, but does not throw exceptions.
            </remarks>
        </member>
        <member name="M:Au.Path_.GetExtension(System.String,System.String@)">
            <summary>
            Gets filename extension and path part without the extension.
            More info: <see cref="M:Au.Path_.GetExtension(System.String)"/>.
            </summary>
            <param name="path">Path or filename.</param>
            <param name="pathWithoutExtension">Receives path part without the extension. Can be the same variable as path.</param>
        </member>
        <member name="M:Au.Path_.GetDirectoryPath(System.String,System.Boolean)">
            <summary>
            Removes filename part from path. By default also removes separator ('\\' or '/') if it is not after drive name (eg "C:").
            Returns "" if the string is a filename.
            Returns null if the string is a root (like @"C:\" or "C:" or @"\\server\share" or "http:").
            Returns null if the string is null.
            </summary>
            <param name="path">Path or filename.</param>
            <param name="withSeparator">
            Don't remove the separator character(s) ('\\' or '/').
            Examples: from @"C:\A\B" gets @"C:\A\", not @"C:\A"; from "http://x.y" gets "http://", not "http:".</param>
            <remarks>
            Similar to <see cref="M:System.IO.Path.GetDirectoryName(System.String)"/>. Some diferences: does not throw exceptions; skips '\\' or '/' at the end (eg from @"C:\A\B\" gets @"C:\A", not @"C:\A\B"); does not expand DOS path; much faster.
            Parses raw string. You may want to <see cref="M:Au.Path_.Normalize(System.String,System.String,Au.Types.PNFlags)"/> it at first.
            Supports separators '\\' and '/'.
            Also supports URL and shell parsing names like @"::{CLSID-1}\0\::{CLSID-2}".
            Example paths and results (withSeparator=false):
            <code>
            @"C:\A\B\file.txt" -> @"C:\A\B".
            "file.txt" -> "".
            @"C:\A\B\" -> @"C:\A".
            @"C:\A\/B\/" -> @"C:\A".
            @"C:\" -> null.
            @"\\network\share" -> null.
            "http:" -> null.
            @"C:\aa\file.txt:alt.stream" -> "C:\aa".
            "http://a.b.c" -> "http:".
            "::{A}\::{B}" -> "::{A}".
            "" -> "".
            null -> null.
            </code>
            </remarks>
        </member>
        <member name="M:Au.Path_.LibIsExtension(System.String)">
            <summary>
            Returns true if s is like ".ext" and the ext part does not contain characters ".\\/:".
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="M:Au.Path_.LibIsProtocol(System.String)">
            <summary>
            Returns true if s is like "protocol:" and not like "c:" or "protocol:more".
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="M:Au.Path_.MakeUnique(System.String,System.Boolean)">
            <summary>
            Gets path with unique filename for a new file or directory. 
            If the specified path is of an existing file or directory, returns path where the filename part is modified like "file 2.txt", "file 3.txt" etc. Else returns unchanged path.
            </summary>
            <param name="path">Suggested full path.</param>
            <param name="isDirectory">The path is for a directory. The number is always appended at the very end, not before .extension.</param>
        </member>
        <member name="T:Au.Ver">
            <summary>
            Provides various version info, for example Windows OS version.
            The Windows version properties return true Windows version. If you need version that depends on manifest and debugger, instead use Environment.OSVersion.
            </summary>
        </member>
        <member name="P:Au.Ver.WinVer">
            <summary>
            Gets classic Windows major+minor version value:
            Win7 (0x601), Win8 (0x602), Win8_1 (0x603), Win10 (0xA00).
            Example: <c>if(Ver.WinVer >= Ver.Win8) ...</c>
            </summary>
        </member>
        <member name="F:Au.Ver.Win7">
            <summary>
            Classic Windows version major+minor values that can be used with <see cref="P:Au.Ver.WinVer"/>.
            Example: <c>if(Ver.WinVer >= Ver.Win8) ...</c>
            </summary>
        </member>
        <member name="F:Au.Ver.Win8">
            <summary>
            Classic Windows version major+minor values that can be used with <see cref="P:Au.Ver.WinVer"/>.
            Example: <c>if(Ver.WinVer >= Ver.Win8) ...</c>
            </summary>
        </member>
        <member name="F:Au.Ver.Win8_1">
            <summary>
            Classic Windows version major+minor values that can be used with <see cref="P:Au.Ver.WinVer"/>.
            Example: <c>if(Ver.WinVer >= Ver.Win8) ...</c>
            </summary>
        </member>
        <member name="F:Au.Ver.Win10">
            <summary>
            Classic Windows version major+minor values that can be used with <see cref="P:Au.Ver.WinVer"/>.
            Example: <c>if(Ver.WinVer >= Ver.Win8) ...</c>
            </summary>
        </member>
        <member name="P:Au.Ver.MinWin8">
            <summary>
            true if Windows 8.0 or later.
            </summary>
        </member>
        <member name="P:Au.Ver.MinWin8_1">
            <summary>
            true if Windows 8.1 or later.
            </summary>
        </member>
        <member name="P:Au.Ver.MinWin10">
            <summary>
            true if Windows 10 or later.
            </summary>
        </member>
        <member name="P:Au.Ver.Is64BitProcess">
            <summary>
            true if this process is 64-bit, false if 32-bit.
            The same as <see cref="P:System.Environment.Is64BitProcess"/>.
            </summary>
        </member>
        <member name="P:Au.Ver.Is64BitOS">
            <summary>
            true if Windows is 64-bit, false if 32-bit.
            The same as <see cref="P:System.Environment.Is64BitOperatingSystem"/>, but fast. The .NET function is slow in 32-bit process; they forgot to optimize it.
            </summary>
        </member>
        <member name="P:Au.Ver.Is32BitProcessOn64BitOS">
            <summary>
            Returns true if this process is a 32-bit process running on 64-bit Windows. Also known as WOW64 process.
            </summary>
        </member>
        <member name="T:Au.Math_">
            <summary>
            Simple calculation functions.
            </summary>
        </member>
        <member name="M:Au.Math_.MakeUint(System.UInt32,System.UInt32)">
            <summary>
            Creates uint by placing (ushort)loWord in bits 1-16 and (ushort)hiWord in bits 17-32.
            Like C macro MAKELONG, MAKEWPARAM, MAKELPARAM, MAKELRESULT.
            </summary>
        </member>
        <member name="M:Au.Math_.MakeUint(System.Int32,System.Int32)">
            <summary>
            Creates uint by placing (ushort)loWord in bits 1-16 and (ushort)hiWord in bits 17-32.
            Like C macro MAKELONG, MAKEWPARAM, MAKELPARAM, MAKELRESULT.
            </summary>
        </member>
        <member name="M:Au.Math_.MakeUshort(System.UInt32,System.UInt32)">
            <summary>
            Creates ushort by placing (byte)loByte in bits 1-8 and (byte)hiByte in bits 9-16.
            Like C macro MAKEWORD.
            </summary>
        </member>
        <member name="M:Au.Math_.MakeUshort(System.Int32,System.Int32)">
            <summary>
            Creates ushort by placing (byte)loByte in bits 1-8 and (byte)hiByte in bits 9-16.
            Like C macro MAKEWORD.
            </summary>
        </member>
        <member name="M:Au.Math_.LoUshort(Au.Types.LPARAM)">
            <summary>
            Gets bits 1-16 as ushort.
            Like C macro LOWORD.
            </summary>
            <remarks>
            The parameter is interpreted as uint. Its declared type is LPARAM because it allows to avoid explicit casting from other integer types and IntPtr (casting from IntPtr to uint could throw OverflowException).
            </remarks>
        </member>
        <member name="M:Au.Math_.HiUshort(Au.Types.LPARAM)">
            <summary>
            Gets bits 17-32 as ushort.
            Like C macro HIWORD.
            </summary>
            <remarks>
            The parameter is interpreted as uint. Its declared type is LPARAM because it allows to avoid explicit casting from other integer types and IntPtr (casting from IntPtr to uint could throw OverflowException).
            </remarks>
        </member>
        <member name="M:Au.Math_.LoShort(Au.Types.LPARAM)">
            <summary>
            Gets bits 1-16 as short.
            Like C macro GET_X_LPARAM.
            </summary>
            <remarks>
            The parameter is interpreted as uint. Its declared type is LPARAM because it allows to avoid explicit casting from other integer types and IntPtr (casting from IntPtr to uint could throw OverflowException).
            </remarks>
        </member>
        <member name="M:Au.Math_.HiShort(Au.Types.LPARAM)">
            <summary>
            Gets bits 17-32 as short.
            Like C macro GET_Y_LPARAM.
            </summary>
            <remarks>
            The parameter is interpreted as uint. Its declared type is LPARAM because it allows to avoid explicit casting from other integer types and IntPtr (casting from IntPtr to uint could throw OverflowException).
            </remarks>
        </member>
        <member name="M:Au.Math_.LoByte(System.UInt16)">
            <summary>
            Gets bits 1-8 as byte.
            Like C macro LOBYTE.
            </summary>
        </member>
        <member name="M:Au.Math_.HiByte(System.UInt16)">
            <summary>
            Gets bits 9-16 as byte.
            Like C macro HIBYTE.
            </summary>
        </member>
        <member name="M:Au.Math_.MulDiv(System.Int32,System.Int32,System.Int32)">
            <summary>
            Multiplies number and numerator without overflow, and divides by denominator.
            The return value is rounded up or down to the nearest integer.
            If either an overflow occurred or denominator was 0, the return value is –1.
            </summary>
        </member>
        <member name="M:Au.Math_.Percent(System.Int32,System.Int32)">
            <summary>
            Returns percent of part in whole.
            </summary>
        </member>
        <member name="M:Au.Math_.Percent(System.Double,System.Double)">
            <summary>
            Returns percent of part in whole.
            </summary>
        </member>
        <member name="M:Au.Math_.AlignUp(System.UInt32,System.UInt32)">
            <summary>
            If value is divisible by alignment, returns value. Else returns nearest bigger number that is divisible by alignment.
            </summary>
            <param name="value">An integer value.</param>
            <param name="alignment">Alignment. Must be a power of two (2, 4, 8, 16...).</param>
            <remarks>For example if alignment is 4, returns 4 if value is 1-4, returns 8 if value is 5-8, returns 12 if value is 9-10, and so on.</remarks>
        </member>
        <member name="M:Au.Math_.AlignUp(System.Int32,System.UInt32)">
            <summary>
            If value is divisible by alignment, returns value. Else returns nearest bigger number that is divisible by alignment.
            </summary>
            <param name="value">An integer value.</param>
            <param name="alignment">Alignment. Must be a power of two (2, 4, 8, 16...).</param>
            <remarks>For example if alignment is 4, returns 4 if value is 1-4, returns 8 if value is 5-8, returns 12 if value is 9-10, and so on.</remarks>
        </member>
        <member name="M:Au.Math_.MinMax(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns value but not less than min and not greater than max.
            If value is less than min, returns min.
            If value is greater than max, returns max.
            </summary>
        </member>
        <member name="M:Au.Math_.Swap``1(``0@,``0@)">
            <summary>
            Swaps values of variables a and b: <c>T t = a; a = b; b = t;</c>
            </summary>
        </member>
        <member name="M:Au.Math_.AngleFromXY(System.Int32,System.Int32)">
            <summary>
            Calculates angle degrees from coordinates x and y.
            </summary>
        </member>
        <member name="M:Au.Math_.SetFlag``1(``0@,``0,System.Boolean)">
            <summary>
            Adds or removes an enum flag.
            </summary>
            <typeparam name="T">enum. Must be of size 4 (default).</typeparam>
            <param name="enumVariable">Enum variable to modify.</param>
            <param name="flag">One or more flags to add or remove.</param>
            <param name="add">If true, adds flag to enumVariable, else removes flag from enumVariable.</param>
        </member>
        <member name="T:Au.Folders">
             <summary>
             Gets known/special folder paths (Desktop, Temp, etc).
             </summary>
             <remarks>
             For return values is used type <see cref="T:Au.Folders.FolderPath"/>, not string. It is implicitly convertible to string. Its operator + appends a filename or relative path string, with @"\" separator if need. Example: <c>string s = Folders.Desktop + "file.txt"; //C:\Users\Name\Desktop\file.txt</c>
             If a function cannot get folder path, the return value contains null string. Then the + operator would throw AuException.
            
             Some folders are known only on newer Windows versions or only on some computers. Some property-get functions have a suffix like "_Win8" which means that the folder is unavailable on older Windows.
             Some known folders, although supported and registerd, may be still not created.
             
             Some folders are virtual, for example Control Panel. They don't have a file system path, but can be identified by an unmanaged array called "ITEMIDLIST" or "PIDL". Functions of the nested class <see cref="T:Au.Folders.VirtualPidl"/> return it as <see cref="T:Au.Shell.Pidl"/>. Functions of the nested class <see cref="T:Au.Folders.Virtual"/> return it as string <c>":: HexEncodedITEMIDLIST"</c> that can be used with some functions of this library (of classes Shell, Shell.Pidl, Icons) but not with .NET or native functions.
            
             Most functions use Windows "Known Folders" API, such as <msdn>SHGetKnownFolderPath</msdn>.
             The list of Windows predefined known folders: <msdn>KNOWNFOLDERID</msdn>.
             Names of folders specific to this application have "This" prefix, like ThisApp.
             
             Some paths depend on the bitness (32 or 64 bit) of the OS and this process.
             The example paths below are for English versions of Windows on most computers.
             <list type="definition">
             <item>
             <term>32-bit Windows</term>
             <description>
             System, SystemX86, SystemX64: <c>@"C:\WINDOWS\system32"</c>
             ProgramFiles, ProgramFilesX86, ProgramFilesX64: <c>@"C:\Program Files"</c>
             ProgramFilesCommon, ProgramFilesCommonX86, ProgramFilesCommonX64: <c>@"C:\Program Files\Common Files"</c>
             </description>
             </item>
             <item>
             <term>64-bit Windows, 64-bit process</term>
             <description>
             System, SystemX64: <c>@"C:\WINDOWS\system32"</c>
             SystemX86: <c>@"C:\WINDOWS\SysWOW64"</c>
             ProgramFiles, ProgramFilesX64: <c>@"C:\Program Files"</c>
             ProgramFilesX86: <c>@"C:\Program Files (x86)"</c>
             ProgramFilesCommon, ProgramFilesCommonX64: <c>@"C:\Program Files\Common Files"</c>
             ProgramFilesCommonX86: <c>@"C:\Program Files (x86)\Common Files"</c>
             </description>
             </item>
             <item>
             <term>64-bit Windows, 32-bit process</term>
             <description>
             System: <c>@"C:\WINDOWS\system32"</c>. However the OS in most cases redirects this path to <c>@"C:\WINDOWS\SysWOW64"</c>.
             SystemX86: <c>@"C:\WINDOWS\SysWOW64"</c>
             SystemX64: <c>@"C:\WINDOWS\Sysnative"</c>. The OS redirects it to the true <c>@"C:\WINDOWS\system32"</c>. It is a special path that you don't see in Explorer.
             ProgramFiles, ProgramFilesX86: <c>@"C:\Program Files (x86)"</c>
             ProgramFilesX64: <c>@"C:\Program Files"</c>
             ProgramFilesCommon, ProgramFilesCommonX86: <c>@"C:\Program Files (x86)\Common Files"</c>
             ProgramFilesCommonX64: <c>@"C:\Program Files\Common Files"</c>
             </description>
             </item>
             </list>
             </remarks>
        </member>
        <member name="P:Au.Folders.ProgramFiles">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.Folders.ProgramFilesX86">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.Folders.ProgramFilesCommon">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.Folders.ProgramFilesCommonX86">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.Folders.System">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.Folders.SystemX86">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.Folders.Temp">
            <summary>
            Temp folder (temporary files) of this user account.
            </summary>
        </member>
        <member name="P:Au.Folders.ThisApp">
            <summary>
            Folder containing assemblies of this appdomain.
            Calls <see cref="P:System.AppDomain.BaseDirectory"/>.
            </summary>
            <remarks>
            Unlike <see cref="P:Au.Folders.ThisProcess"/>, this path can be different for each appdomain; it is set when creating the AppDomain.
            See also <see cref="P:System.Windows.Forms.Application.ExecutablePath"/>, it gets full path (with file name) of appdomain's entry assembly.
            </remarks>
        </member>
        <member name="P:Au.Folders.ThisAppTemp">
            <summary>
            Gets or sets path of the temporary files folder of this application.
            Default is Folders.Temp + Application.ProductName.
            The 'set' function does not change system settings, it just remembers a string that will be later returned by the 'get' function in this appdomain.
            The 'get' function creates the folder if does not exist.
            </summary>
        </member>
        <member name="P:Au.Folders.ThisAppDocuments">
            <summary>
            Gets or sets path of user document files folder of this application.
            Default is Folders.Documents + Application.ProductName.
            The 'set' function does not change system settings, it just remembers a string that will be later returned by the 'get' function in this appdomain.
            The 'get' function creates the folder if does not exist.
            </summary>
        </member>
        <member name="P:Au.Folders.ThisAppData">
            <summary>
            Gets or sets path of private files folder of this application on this user account.
            Default is Folders.RoamingAppData + Application.ProductName.
            The 'set' function does not change system settings, it just remembers a string that will be later returned by the 'get' function in this appdomain.
            The 'get' function creates the folder if does not exist.
            </summary>
        </member>
        <member name="P:Au.Folders.ThisAppDataLocal">
            <summary>
            Gets or sets path of local (non-roaming) private files folder of this application on this user account.
            Default is Folders.LocalAppData + Application.ProductName.
            The 'set' function does not change system settings, it just remembers a string that will be later returned by the 'get' function in this appdomain.
            The 'get' function creates the folder if does not exist.
            </summary>
        </member>
        <member name="P:Au.Folders.ThisAppDataCommon">
            <summary>
            Gets or sets path of common (all users) private files folder of this application.
            Default is Folders.ProgramData + Application.ProductName.
            The 'set' function does not change system settings, it just remembers a string that will be later returned by the 'get' function in this appdomain.
            Note: the ProgramData folder has special permissions. Programs running not as administrator usually cannot write there.
            This function does not auto-create the folder; usually it is created when installing the application.
            </summary>
        </member>
        <member name="P:Au.Folders.ThisProcess">
            <summary>
            Folder containing the program file of this process.
            Calls <see cref="P:System.Windows.Forms.Application.StartupPath"/>.
            Unlike <see cref="P:Au.Folders.ThisApp"/>, this path is the same for all app domains of this process.
            </summary>
        </member>
        <member name="P:Au.Folders.ThisAppImages">
            <summary>
            Gets or sets path of images (icons etc) folder of this application.
            Default is ThisApp + "Images".
            Functions of these classes will look for image there: Icons, AuMenu, AuToolbar, WinImage, possibly some other.
            </summary>
        </member>
        <member name="P:Au.Folders.SystemX64">
            <summary>
            Gets non-redirected path of the System32 folder.
            </summary>
            <remarks>
            If this process is 32-bit and OS is 64-bit, when it uses the <see cref="P:Au.Folders.System"/> folder path (@"C:\WINDOWS\system32"), the OS in most cases redirects it to @"C:\Windows\SysWOW64", which contains 32-bit versions of program files. Use SystemX64 when you want to avoid the redirection and access the true System32 folder which on 64-bit OS contains 64-bit program files.
            More info in class help.
            </remarks>
            <seealso cref="T:Au.Files.Misc.DisableRedirection"/>
            <seealso cref="P:Au.Ver.Is32BitProcessOn64BitOS"/>
        </member>
        <member name="P:Au.Folders.ProgramFilesX64">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.Folders.ProgramFilesCommonX64">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.Folders.CdDvdDrive">
            <summary>
            Gets CD/DVD drive path, like @"D:\".
            Returns null if unavailable.
            </summary>
        </member>
        <member name="P:Au.Folders.RemovableDrive0">
            <summary>Calls <see cref="M:Au.Folders.RemovableDrive(System.Int32)"/>(0).</summary>
        </member>
        <member name="P:Au.Folders.RemovableDrive1">
            <summary>Calls <see cref="M:Au.Folders.RemovableDrive(System.Int32)"/>(1).</summary>
        </member>
        <member name="P:Au.Folders.RemovableDrive2">
            <summary>Calls <see cref="M:Au.Folders.RemovableDrive(System.Int32)"/>(2).</summary>
        </member>
        <member name="P:Au.Folders.RemovableDrive3">
            <summary>Calls <see cref="M:Au.Folders.RemovableDrive(System.Int32)"/>(3).</summary>
        </member>
        <member name="M:Au.Folders.RemovableDrive(System.Int32)">
            <summary>
            Gets removable/external/USB drive path, like @"F:\".
            Returns null if unavailable.
            </summary>
            <param name="driveIndex">0-based removable drive index.</param>
            <remarks>Uses <see cref="M:System.IO.DriveInfo.GetDrives"/> and counts only drives of type DriveType.Removable.</remarks>
        </member>
        <member name="M:Au.Folders.RemovableDrive(System.String)">
            <summary>
            Gets removable/external/USB drive name (like @"F:\") by its volume label.
            Returns null if unavailable.
            </summary>
            <param name="volumeLabel">Volume label. You can see it in drive Properties dialog; it is not the drive name that is displayed in File Explorer.</param>
        </member>
        <member name="M:Au.Folders.EnvVar(System.String)">
            <summary>
            Gets the value of an environment variable.
            Returns null if unavailable.
            </summary>
        </member>
        <member name="M:Au.Folders.GetKnownFolders">
            <summary>
            Gets canonical names and paths of all known folders, including custom known folders registerd by applications.
            Can be useful for information. These names then can be used with <see cref="M:Au.Folders.GetFolder(System.String)"/>.
            Example: <c>Print(Folders.GetKnownFolders());</c>
            </summary>
        </member>
        <member name="M:Au.Folders.GetFolder(System.String)">
            <summary>
            Gets path of a known folder by its name as string.
            Returns null if unavailable.
            </summary>
            <param name="folderName">
            A property name of this class. Examples: "Documents", "Temp", "ThisApp".
            Or a property name of the nested class Virtual, like "Virtual.ControlPanel". Gets ":: HexEncodedITEMIDLIST".
            Or known folder canonical name. See <see cref="M:Au.Folders.GetKnownFolders"/>. If has prefix "Virtual.", gets ":: HexEncodedITEMIDLIST". Much slower, but allows to get paths of folders registered by applications.
            </param>
        </member>
        <member name="M:Au.Folders.FolderPath.op_Addition(Au.Folders.FolderPath,System.String)">
            <summary>
            Calls <see cref="M:Au.Path_.Combine(System.String,System.String,System.Boolean,System.Boolean)"/>(fp, append).
            Example: <c>string s = Folders.Desktop + "file.txt";</c>
            </summary>
            <exception cref="T:Au.Types.AuException">f is empty. Most likely, used code <c>Folders.X + "append"</c> and failed to get X.</exception>
        </member>
        <member name="T:Au.AuToolbar">
            <summary>
            TODO
            </summary>
        </member>
        <member name="P:Au.AuToolbar.Ex">
            <summary>
            Gets ToolStrip.
            </summary>
        </member>
        <member name="P:Au.AuToolbar.MainToolStrip">
            <summary>Infrastructure.</summary>
        </member>
        <member name="P:Au.AuToolbar.Item(System.String,System.Object)">
            <summary>
            Adds new button as ToolStripButton.
            Sets its text, icon and Click event handler delegate. Other properties can be specified later. See example.
            Code <c>t.Add("text", o => Print(o));</c> is the same as <c>t["text"] = o => Print(o);</c> .
            </summary>
            <param name="text">Text.</param>
            <param name="icon">Can be:
            string - icon file, as with <see cref="M:Au.Icons.GetFileIconHandle(System.String,System.Int32,Au.Types.GIFlags)"/>.
            string - image name (key) in the ImageList (<see cref="P:System.Windows.Forms.ToolStripItem.ImageKey"/>).
            int - image index in the ImageList (<see cref="P:System.Windows.Forms.ToolStripItem.ImageIndex"/>).
            IntPtr - unmanaged icon handle (the function makes its own copy).
            Icon, Image, Folders.FolderPath.
            </param>
            <example><code>
            var t = new AuToolbar();
            t["One"] = o => Print(o);
            t["Two", @"icon file path"] = o => { Print(o); AuDialog.Show(o.ToString()); };
            t.LastItem.ToolTipText = "tooltip";
            </code></example>
        </member>
        <member name="M:Au.AuToolbar.Add(System.String,System.Action{Au.Types.MTClickArgs},System.Object)">
            <summary>
            Adds new button as ToolStripButton.
            Sets its text, icon and Click event handler delegate. Other properties can be specified later. See example.
            Code <c>t.Add("text", o => Print(o));</c> is the same as <c>t["text"] = o => Print(o);</c> .
            </summary>
            <param name="text">Text.</param>
            <param name="onClick">Lambda etc function to be called when the button clicked.</param>
            <param name="icon">Can be:
            string - icon file, as with <see cref="M:Au.Icons.GetFileIconHandle(System.String,System.Int32,Au.Types.GIFlags)"/>.
            string - image name (key) in the ImageList (<see cref="P:System.Windows.Forms.ToolStripItem.ImageKey"/>).
            int - image index in the ImageList (<see cref="P:System.Windows.Forms.ToolStripItem.ImageIndex"/>).
            IntPtr - unmanaged icon handle (the function makes its own copy).
            Icon, Image, Folders.FolderPath.
            </param>
            <example><code>
            var m = new AuToolbar();
            t.Add("One", o => Print(o), @"icon file path");
            t.LastItem.ToolTipText = "tooltip";
            t.Add("Two", o => { Print(o.MenuItem.Checked); });
            </code></example>
        </member>
        <member name="M:Au.AuToolbar.Add(System.Windows.Forms.ToolStripItem,System.Object,System.Action{Au.Types.MTClickArgs})">
            <summary>
            Adds item of any supported type, for example ToolStripLabel, ToolStripTextBox, ToolStripComboBox, ToolStripProgressBar.
            Supports types derived from ToolStripItem.
            </summary>
            <param name="item">An already created item of any supported type.</param>
            <param name="icon">The same as with other overload.</param>
            <param name="onClick">Lambda etc function to be called when the item clicked. Not useful for most item types.</param>
        </member>
        <member name="M:Au.AuToolbar.Separator">
            <summary>
            Adds separator.
            </summary>
        </member>
        <member name="P:Au.AuToolbar.LastButton">
            <summary>
            Gets the last added item as ToolStripButton.
            Returns null if it is not a ToolStripButton.
            The item can be added with m.Add(...) and m[...]=.
            </summary>
            <remarks>
            You can instead use LastItem, which gets ToolStripItem, which is the base class of all supported item types; cast it to a derived type if need.
            </remarks>
        </member>
        <member name="P:Au.AuToolbar.MainWnd">
            <summary>
            Gets the main toolbar window.
            </summary>
        </member>
        <member name="T:Au.AuMenu">
            <summary>
            TODO
            </summary>
        </member>
        <member name="P:Au.AuMenu.CMS">
            <summary>
            Gets ContextMenuStrip that is used to show the main drop-down menu.
            You can use all its properties, methods and events. You can assign it to a control or toolstrip's drop-down button etc.
            </summary>
        </member>
        <member name="P:Au.AuMenu.MainToolStrip">
            <summary>Infrastructure.</summary>
        </member>
        <member name="M:Au.AuMenu.#ctor">
            
        </member>
        <member name="M:Au.AuMenu.Dispose">
            
        </member>
        <member name="P:Au.AuMenu.IsDisposed">
            
        </member>
        <member name="P:Au.AuMenu.Item(System.String,System.Object)">
            <summary>
            Adds new item as ToolStripMenuItem.
            Sets its text, icon and Click event handler delegate. Other properties can be specified later. See example.
            Code <c>m.Add("text", o => Print(o));</c> is the same as <c>m["text"] = o => Print(o);</c> .
            </summary>
            <param name="text">Text. If contains a tab character, like "Open\tCtrl+O", displays text after it as shortcut keys (right-aligned).</param>
            <param name="icon">Can be:
            string - path of .ico or any other file or folder or non-file object. See <see cref="M:Au.Icons.GetFileIconHandle(System.String,System.Int32,Au.Types.GIFlags)"/>. If not full path, searches in <see cref="P:Au.Folders.ThisAppImages"/>; see also <see cref="P:Au.Types.AuMTBase.IconFlags"/>.
            string - image name (key) in the ImageList (<see cref="P:System.Windows.Forms.ToolStripItem.ImageKey"/>).
            int - image index in the ImageList (<see cref="P:System.Windows.Forms.ToolStripItem.ImageIndex"/>).
            IntPtr - unmanaged icon handle (the function makes its own copy).
            Icon, Image, Folders.FolderPath.
            </param>
            <example><code>
            var m = new AuMenu();
            m["One"] = o => Print(o);
            m["Two", @"icon file path"] = o => { Print(o); AuDialog.Show(o.ToString()); };
            m.LastItem.ToolTipText = "tooltip";
            m["Three"] = o => { Print(o.MenuItem.Checked); };
            m.LastMenuItem.Checked = true;
            m.Show();
            </code></example>
        </member>
        <member name="M:Au.AuMenu.Add(System.String,System.Action{Au.Types.MTClickArgs},System.Object)">
            <summary>
            Adds new item as ToolStripMenuItem.
            Sets its text, icon and Click event handler delegate. Other properties can be specified later. See example.
            Code <c>m.Add("text", o => Print(o));</c> is the same as <c>m["text"] = o => Print(o);</c> .
            </summary>
            <param name="text">Text. If contains a tab character, like "Open\tCtrl+O", displays text after it as shortcut keys (right-aligned).</param>
            <param name="onClick">Lambda etc function to be called when the menu item clicked.</param>
            <param name="icon">Can be:
            string - path of .ico or any other file or folder or non-file object. See <see cref="M:Au.Icons.GetFileIconHandle(System.String,System.Int32,Au.Types.GIFlags)"/>. If not full path, searches in <see cref="P:Au.Folders.ThisAppImages"/>; see also <see cref="P:Au.Types.AuMTBase.IconFlags"/>.
            string - image name (key) in the ImageList (<see cref="P:System.Windows.Forms.ToolStripItem.ImageKey"/>).
            int - image index in the ImageList (<see cref="P:System.Windows.Forms.ToolStripItem.ImageIndex"/>).
            IntPtr - unmanaged icon handle (the function makes its own copy).
            Icon, Image, Folders.FolderPath.
            </param>
            <example><code>
            var m = new AuMenu();
            m.Add("One", o => Print(o), @"icon file path");
            m.Add("Two", o => { Print(o.MenuItem.Checked); });
            m.LastMenuItem.Checked = true;
            m.Show();
            </code></example>
        </member>
        <member name="M:Au.AuMenu.Add(System.Windows.Forms.ToolStripItem,System.Object,System.Action{Au.Types.MTClickArgs})">
            <summary>
            Adds item of any supported type, for example ToolStripLabel, ToolStripTextBox, ToolStripComboBox, ToolStripProgressBar, ToolStripButton.
            Supports types derived from ToolStripItem.
            </summary>
            <param name="item">An already created item of any supported type.</param>
            <param name="icon">The same as with other overload.</param>
            <param name="onClick">Lambda etc function to be called when the item clicked. Not useful for most item types.</param>
        </member>
        <member name="M:Au.AuMenu.Separator">
            <summary>
            Adds separator.
            </summary>
        </member>
        <member name="M:Au.AuMenu.Submenu(System.String,System.Object,System.Action{Au.Types.MTClickArgs})">
            <summary>
            Adds new item (ToolStripMenuItem) that will open a submenu.
            Then the add-item functions will add items to its submenu.
            Can be used in 2 ways:
            1. <c>using(m.Submenu(...)) { add items; }</c>. See example.
            2. <c>m.Submenu(...); add items; m.EndSubmenu();</c>. See <see cref="M:Au.AuMenu.EndSubmenu"/>.
            </summary>
            <param name="text">Text.</param>
            <param name="icon">The same as with <see cref="M:Au.AuMenu.Add(System.String,System.Action{Au.Types.MTClickArgs},System.Object)"/>.</param>
            <param name="onClick">Lambda etc function to be called when the menu item clicked. Rarely used.</param>
            <remarks>
            Submenus inherit these properties of the main menu, set before adding submenus (see example):
            BackgroundImage, BackgroundImageLayout, ContextMenu, Cursor, Font, ForeColor, ImageList, ImageScalingSize, Renderer, ShowCheckMargin, ShowImageMargin.
            </remarks>
            <example><code>
            var m = new AuMenu();
            m.CMS.BackColor = Color.PaleGoldenrod;
            m["One"] = o => Print(o);
            m["Two"] = o => Print(o);
            using(m.Submenu("Submenu")) {
            	m["Three"] = o => Print(o);
            	m["Four"] = o => Print(o);
            	using(m.Submenu("Submenu")) {
            		m["Five"] = o => Print(o);
            		m["Six"] = o => Print(o);
            	}
            	m["Seven"] = o => Print(o);
            }
            m["Eight"] = o => Print(o);
            m.Show();
            </code></example>
        </member>
        <member name="M:Au.AuMenu.EndSubmenu">
            <summary>
            Call this to end adding items to the current submenu if Submenu() was called without 'using' and without a callback function that adds submenu items.
            </summary>
            <example><code>
            var m = new AuMenu();
            m["One"] = o => Print(o);
            m["Two"] = o => Print(o);
            m.Submenu("Submenu");
            	m["Three"] = o => Print(o);
            	m["Four"] = o => Print(o);
            	m.EndSubmenu();
            m["Five"] = o => Print(o);
            m.Show();
            </code></example>
        </member>
        <member name="T:Au.AuMenu.UsingSubmenu">
            <summary>
            Allows to use code: <c>using(m.Submenu("Name")) { add items; }</c> .
            </summary>
            <tocexclude />
        </member>
        <member name="P:Au.AuMenu.UsingSubmenu.MenuItem">
            <summary>
            Gets ToolStripMenuItem of the submenu-item.
            </summary>
        </member>
        <member name="M:Au.AuMenu.UsingSubmenu.Dispose">
            <summary>
            Calls m.EndSubmenu().
            </summary>
        </member>
        <member name="M:Au.AuMenu.Submenu(System.String,System.Action{Au.AuMenu},System.Object,System.Action{Au.Types.MTClickArgs})">
            <summary>
            Adds new item (ToolStripMenuItem) that will open a submenu.
            When showing the submenu first time, your callback function will be called and can add submenu items.
            </summary>
            <param name="text">Text.</param>
            <param name="onOpening">Lambda etc callback function that should add submenu items.</param>
            <param name="icon">The same as with <see cref="M:Au.AuMenu.Add(System.String,System.Action{Au.Types.MTClickArgs},System.Object)"/>.</param>
            <param name="onClick">Lambda etc function to be called when the menu item clicked. Rarely used.</param>
            <example><code>
            var m = new AuMenu();
            m["One"] = o => Print(o);
            m["Two"] = o => Print(o);
            m.Submenu("Submenu 1", m1 =>
            {
            	Print("adding items of " + m.CurrentAddMenu.OwnerItem);
            	m["Three"] = o => Print(o);
            	m["Four"] = o => Print(o);
            	m.Submenu("Submenu 2", m2 =>
            	{
            		Print("adding items of " + m.CurrentAddMenu.OwnerItem);
            		m["Five"] = o => Print(o);
            		m["Six"] = o => Print(o);
            	});
            	m["Seven"] = o => Print(o);
            });
            m["Eight"] = o => Print(o);
            m.Show();
            </code></example>
        </member>
        <member name="P:Au.AuMenu.CurrentAddMenu">
            <summary>
            Gets ToolStripDropDownMenu of the main menu or submenu where currently m.Add(...), m[...]=, m.Separator() and m.Submenu(...) would add new item.
            </summary>
            <remarks>
            Initially it is the main menu.
            In code of <c>using(m.Submenu(...)) { code; }</c>, <c>m.Submenu(...); code; m.EndSubmenu();</c> and <c>m.Submenu(..., m1 => { code; });</c> it is that submenu.
            </remarks>
        </member>
        <member name="P:Au.AuMenu.LastMenuItem">
            <summary>
            Gets the last added item as ToolStripMenuItem.
            Returns null if it is not a ToolStripMenuItem, eg a button or separator.
            The item can be added with m.Add(...), m[...]= and m.Submenu(...).
            </summary>
            <remarks>
            You can instead use LastItem, which gets ToolStripItem, which is the base class of all supported item types; cast it to a derived type if need.
            </remarks>
        </member>
        <member name="M:Au.AuMenu.Show">
            <summary>
            Shows the menu at the mouse cursor position.
            </summary>
        </member>
        <member name="M:Au.AuMenu.Show(System.Int32,System.Int32,System.Windows.Forms.ToolStripDropDownDirection)">
            <summary>
            Shows the menu at the specified position.
            </summary>
            <param name="x">X position in screen.</param>
            <param name="y">Y position in screen.</param>
            <param name="direction">Menu drop direction.</param>
        </member>
        <member name="M:Au.AuMenu.Show(System.Windows.Forms.Control,System.Int32,System.Int32,System.Windows.Forms.ToolStripDropDownDirection)">
            <summary>
            Shows the menu on a form or control.
            </summary>
            <param name="owner">A control or form that will own the menu.</param>
            <param name="x">X position in control's client area.</param>
            <param name="y">Y position in control's client area.</param>
            <param name="direction">Menu drop direction.</param>
            <remarks>
            Alternatively you can assign the context menu to a control or toolstrip's drop-down button etc, then don't need to call Show(). Use the <see cref="P:Au.AuMenu.CMS"/> property, which gets <see cref="T:System.Windows.Forms.ContextMenuStrip"/>.
            </remarks>
        </member>
        <member name="M:Au.AuMenu.Show(System.Windows.Forms.Control,System.Windows.Forms.ToolStripDropDownDirection)">
            <summary>
            Shows the menu at the mouse cursor position.
            </summary>
            <param name="owner">A control or form that will own the menu.</param>
            <param name="direction">Menu drop direction.</param>
            <remarks>
            Alternatively you can assign the context menu to a control or toolstrip's drop-down button etc, then don't need to call Show(). Use the <see cref="P:Au.AuMenu.CMS"/> property, which gets <see cref="T:System.Windows.Forms.ContextMenuStrip"/>.
            </remarks>
        </member>
        <member name="P:Au.AuMenu.MultiShow">
            <summary>
            If false, calls Dispose() when the menu is closed.
            If true, does not call Dispose(); then you can call Show() multiple times for the same object.
            Default is false, but is automatically set to true when showing the menu not with AuMenu.Show(), eg when assigned to a control.
            </summary>
            <seealso cref="P:Au.AuMenu.DefaultMultiShow"/>
        </member>
        <member name="P:Au.AuMenu.DefaultMultiShow">
            <summary>
            Default MultiShow value for all new AuMenu instances.
            </summary>
        </member>
        <member name="P:Au.AuMenu.ModalAlways">
            <summary>
            If true, Show() always waits until the menu is closed.
            If false, does not wait if the thread has a message loop (Application.MessageLoop==true).
            </summary>
        </member>
        <member name="P:Au.AuMenu.ActivateMenuWindow">
            <summary>
            Activate the menu window.
            It enables selecting menu items with the keyboard (arrows, Tab, Enter, etc).
            If false, only Esc works, it closes the menu.
            If the menu is owned by a control or toolbar button, keyboard navigation works in any case, don't need this property to enable it.
            </summary>
            <seealso cref="P:Au.AuMenu.DefaultActivateMenuWindow"/>
        </member>
        <member name="P:Au.AuMenu.DefaultActivateMenuWindow">
            <summary>
            Default ActivateMenuWindow value for AuMenu instances.
            A AuMenu instance inherits this at the moment it is created.
            </summary>
        </member>
        <member name="P:Au.AuMenu.MouseClosingDistance">
            <summary>
            Close the menu when the mouse cursor moves away from it to this distance, pixels.
            At first the mouse must be or move at less than half of the distance.
            Default is equal to AuMenu.DefaultMouseClosingDistance, default 200.
            </summary>
            <seealso cref="P:Au.AuMenu.DefaultMouseClosingDistance"/>
        </member>
        <member name="P:Au.AuMenu.DefaultMouseClosingDistance">
            <summary>
            Default MouseClosingDistance value of AuMenu instances.
            A AuMenu instance inherits this at the moment it is created.
            </summary>
        </member>
        <member name="M:Au.AuMenu.Close">
            <summary>
            Closes the menu and its submenus.
            Also closes its context menu (CMS.ContextMenu).
            </summary>
        </member>
        <member name="T:Au.Mouse">
            <summary>
            Mouse functions.
            </summary>
        </member>
        <member name="P:Au.Mouse.XY">
            <summary>
            Gets cursor (mouse pointer) position.
            </summary>
        </member>
        <member name="P:Au.Mouse.X">
            <summary>
            Gets cursor (mouse pointer) X coordinate (Mouse.XY.X).
            </summary>
        </member>
        <member name="P:Au.Mouse.Y">
            <summary>
            Gets cursor (mouse pointer) Y coordinate (Mouse.XY.Y).
            </summary>
        </member>
        <member name="M:Au.Mouse.Move(System.Drawing.Point)">
            <summary>
            Moves the cursor (mouse pointer) to the specified position in screen.
            </summary>
            <param name="p">Coordinates in screen.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The specified x y is not in screen. No exception if Options.Relaxed is true (then moves to a screen edge).</exception>
            <exception cref="T:Au.Types.AuException">Failed to move to the specified x y. Some reasons: 1. Another thread blocks or modifies mouse input (API BlockInput, mouse hooks, frequent API SendInput etc); 2. The active window belongs to a process of higher UAC integrity level; 3. Some application called API ClipCursor. No exception if Options.Relaxed is true (then final cursor position is undefined).</exception>
            <remarks>
            Uses <see cref="P:Au.AuScriptOptions.MouseMoveSpeed">Options.MouseMoveSpeed</see>, <see cref="P:Au.AuScriptOptions.MouseClickSleep">Options.MouseClickSleep</see> (sleeps Math.Min(Options.MouseClickSleep, 7)), <see cref="P:Au.AuScriptOptions.Relaxed">Options.Relaxed</see>.
            </remarks>
            <example>
            Save-restore mouse position.
            <code><![CDATA[
            var p = Mouse.XY;
            //...;
            Mouse.Move(p);
            ]]></code>
            Use coodinates in the first non-primary screen.
            <code><![CDATA[
            Mouse.Move(Coord.Normalize(10, 10, screen: 1));
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Mouse.Move(Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)">
            <summary>
            Moves the cursor (mouse pointer) to the position x y in screen.
            Returns the final cursor position in primary screen coordinates.
            </summary>
            <param name="x">X coordinate relative to screen.</param>
            <param name="y">Y coordinate relative to screen.</param>
            <param name="co">Can be used to specify screen (see <see cref="M:Au.Screen_.FromObject(System.Object)"/>) and/or whether x y are relative to the work area.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            1. The specified x y is not in screen (any screen). No exception if Options.Relaxed is true (then moves to a screen edge).
            2. Invalid screen index.
            </exception>
            <exception cref="T:Au.Types.AuException">Failed to move the cursor to x y. Some reasons: 1. Another thread blocks or modifies mouse input (API BlockInput, mouse hooks, frequent API SendInput etc); 2. The active window belongs to a process of higher UAC integrity level; 3. Some application called API ClipCursor. No exception if Options.Relaxed is true (then final cursor position is undefined).</exception>
            <remarks>
            Uses <see cref="P:Au.AuScriptOptions.MouseMoveSpeed">Options.MouseMoveSpeed</see>, <see cref="P:Au.AuScriptOptions.MouseClickSleep">Options.MouseClickSleep</see> (sleeps Math.Min(Options.MouseClickSleep, 7)), <see cref="P:Au.AuScriptOptions.Relaxed">Options.Relaxed</see>.
            </remarks>
        </member>
        <member name="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Moves the cursor (mouse pointer) to the position x y relative to window w.
            Returns the final cursor position in primary screen coordinates.
            </summary>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle. If false (default), they are relative to the client area.</param>
            <exception cref="T:Au.Types.WndException">
            Invalid window.
            The top-level window is hidden. No exception if just cloaked, for example in another desktop; then on click will activate, which usually uncloaks.
            Other window-related failures.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The specified x y is not in screen. No exception if Options.Relaxed is true (then moves to a screen edge).</exception>
            <exception cref="T:Au.Types.AuException">Failed to move the cursor to x y. Some reasons: 1. Another thread blocks or modifies mouse input (API BlockInput, mouse hooks, frequent API SendInput etc); 2. The active window belongs to a process of higher UAC integrity level; 3. Some application called API ClipCursor. No exception if Options.Relaxed is true (then final cursor position is undefined).</exception>
            <remarks>
            Uses <see cref="P:Au.AuScriptOptions.MouseMoveSpeed">Options.MouseMoveSpeed</see>, <see cref="P:Au.AuScriptOptions.MouseClickSleep">Options.MouseClickSleep</see> (sleeps Math.Min(Options.MouseClickSleep, 7)), <see cref="P:Au.AuScriptOptions.Relaxed">Options.Relaxed</see>.
            </remarks>
        </member>
        <member name="M:Au.Mouse.Save">
            <summary>
            Remembers current mouse cursor position to be later restored with <see cref="M:Au.Mouse.Restore"/>.
            </summary>
        </member>
        <member name="M:Au.Mouse.Restore">
            <summary>
            Moves the mouse cursor where it was at the time of the last <see cref="M:Au.Mouse.Save"/> call in this thread. If Save was not called - of the first 'mouse move' or 'mouse move and click' function call in this thread. Does nothing if these functions were not called.
            </summary>
        </member>
        <member name="P:Au.Mouse.LastMoveXY">
            <summary>
            Mouse cursor position of the most recent successful 'mouse move' or 'mouse move and click' function call in this thread.
            If such functions are still not called in this thread, returns <see cref="P:Au.Mouse.XY"/>.
            </summary>
        </member>
        <member name="M:Au.Mouse.MoveRelative(System.Int32,System.Int32)">
            <summary>
            Moves the cursor (mouse pointer) relative to <see cref="P:Au.Mouse.LastMoveXY"/>.
            Returns the final cursor position in primary screen coordinates.
            </summary>
            <param name="dx">X offset from LastMoveXY.X.</param>
            <param name="dy">Y offset from LastMoveXY.Y.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The calculated x y is not in screen. No exception if Options.Relaxed is true (then moves to a screen edge).</exception>
            <exception cref="T:Au.Types.AuException">Failed to move to the calculated x y. Some reasons: 1. Another thread blocks or modifies mouse input (API BlockInput, mouse hooks, frequent API SendInput etc); 2. The active window belongs to a process of higher UAC integrity level; 3. Some application called API ClipCursor. No exception if Options.Relaxed is true (then final cursor position is undefined).</exception>
            <remarks>
            Uses <see cref="P:Au.AuScriptOptions.MouseMoveSpeed">Options.MouseMoveSpeed</see>, <see cref="P:Au.AuScriptOptions.MouseClickSleep">Options.MouseClickSleep</see> (sleeps Math.Min(Options.MouseClickSleep, 7)), <see cref="P:Au.AuScriptOptions.Relaxed">Options.Relaxed</see>.
            </remarks>
        </member>
        <member name="M:Au.Mouse.MoveRecorded(System.String,System.Double)">
            <summary>
            Plays recorded mouse movements, relative to <see cref="P:Au.Mouse.LastMoveXY"/>.
            Returns the final cursor position in primary screen coordinates.
            </summary>
            <param name="recordedString">String containing mouse movement data recorded by a recorder tool that uses <see cref="M:Au.Util.Recording.MouseToString(System.Collections.Generic.IEnumerable{System.UInt32},System.Boolean)"/>.</param>
            <param name="speedFactor">Speed factor. For example, 0.5 makes 2 times faster.</param>
            <exception cref="T:System.ArgumentException">The string is not compatible with this library version (recorded with a newer version and has additional options).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The last x y is not in screen. No exception if Options.Relaxed is true (then moves to a screen edge).</exception>
            <exception cref="T:Au.Types.AuException">Failed to move to the last x y. Some reasons: 1. Another thread blocks or modifies mouse input (API BlockInput, mouse hooks, frequent API SendInput etc); 2. The active window belongs to a process of higher UAC integrity level; 3. Some application called API ClipCursor. No exception if Options.Relaxed is true (then final cursor position is undefined).</exception>
            <remarks>
            Uses <see cref="P:Au.AuScriptOptions.MouseClickSleep">Options.MouseClickSleep</see> (sleeps Math.Min(Options.MouseClickSleep, 7) after each movement, except if recorded with sleep times), <see cref="P:Au.AuScriptOptions.Relaxed">Options.Relaxed</see> (for the last movement; does not care about intermediate movements). Does not use <see cref="P:Au.AuScriptOptions.MouseMoveSpeed">Options.MouseMoveSpeed</see>.
            </remarks>
        </member>
        <member name="M:Au.Mouse._SendMove(System.Drawing.Point)">
            <summary>
            Sends single mouse movement event.
            x y are normal absolute coordinates.
            </summary>
        </member>
        <member name="M:Au.Mouse._SendButton(Au.Types.MButton,System.Boolean,System.Nullable{System.Drawing.Point})">
            <summary>
            Sends single mouse button down or up event.
            Does not use the action flags of button.
            Applies SM_SWAPBUTTON.
            If pMoved!=null, also moves to pMoved in the same API SendInput call.
            </summary>
        </member>
        <member name="M:Au.Mouse._SendRaw(Au.Types.Api.IMFlag,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calls Api.SendInput to send single mouse movement or/and button down or up or wheel event.
            Converts x, y and wheelTicks as need for MOUSEINPUT.
            For X buttons use Api.IMFlag.XDown|Api.IMFlag.X1 etc.
            If Api.IMFlag.Move, adds Api.IMFlag.Absolute.
            </summary>
        </member>
        <member name="M:Au.Mouse._SleepMax(System.Int32)">
            <summary>
            Calls Time.SleepDoEvents().
            If ms is less than 0 or greater than Options.MouseClickSleep, uses Options.MouseClickSleep.
            </summary>
        </member>
        <member name="M:Au.Mouse._SleepExact(System.Int32)">
            <summary>
            Calls Time.SleepDoEvents().
            </summary>
        </member>
        <member name="M:Au.Mouse.ClickEx(Au.Types.MButton,System.Boolean)">
            <summary>
            Clicks, double-clicks, presses or releases a mouse button.
            By default does not move the mouse cursor.
            </summary>
            <param name="button">Button and action. Default: left click.</param>
            <param name="useLastMoveXY">
            Use <see cref="P:Au.Mouse.LastMoveXY"/>. It is the mouse cursor position set by the most recent 'mouse move' or 'mouse move and click' function called in this thread. Use this option for reliability. Example: <c>Mouse.Move(100, 100); Mouse.ClickEx(..., true);</c>. The click is always at 100 100, even if somebody changes cursor position between Mouse.Move sets it and Mouse.ClickEx uses it. In such case this option atomically moves the cursor to LastMoveXY. This movement is instant and does not use Options.MouseMoveSpeed and Options.MouseClickSleep.
            If false (default), clicks at the current cursor position (does not move it).
            </param>
            <exception cref="T:System.ArgumentException">Invalid button flags (multiple buttons or actions specified).</exception>
            <remarks>
            The return value can be used to auto-release pressed button. See example with <see cref="M:Au.Mouse.LeftDown(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)">
            <summary>
            Clicks, double-clicks, presses or releases a mouse button at position x y in screen.
            To move the mouse cursor, calls <see cref="M:Au.Mouse.Move(Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)"/>.
            </summary>
            <param name="button">Button and action.</param>
            <param name="x">X coordinate relative to screen.</param>
            <param name="y">Y coordinate relative to screen.</param>
            <param name="co">Can be used to specify screen (see <see cref="M:Au.Screen_.FromObject(System.Object)"/>) and/or whether x y are relative to the work area.</param>
            <exception cref="T:System.ArgumentException">Invalid button flags (multiple buttons or actions specified).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)"/>.</exception>
            <remarks>
            The return value can be used to auto-release pressed button. See example with <see cref="M:Au.Mouse.LeftDown(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Clicks, double-clicks, presses or releases a mouse button at position x y relative to window w.
            To move the mouse cursor, calls <see cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <param name="button">Button and action.</param>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle. If false (default), they are relative to the client area.</param>
            <exception cref="T:System.ArgumentException">Invalid button flags (multiple buttons or actions specified).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <exception cref="T:Au.Types.WndException">x y is not in the window (read more in Remarks).</exception>
            <remarks>
            If after moving the cursor it is not in window w or a window of its thread, activates w (or its top-level parent window). Throws exception if then x y is still not in w. Skips all this when just releasing button or if <see cref="P:Au.AuScriptOptions.Relaxed">Options.Relaxed</see> is true. Also, if w is a control, x y can be somewhere else in its top-level parent window.
            The return value can be used to auto-release pressed button. See example with <see cref="M:Au.Mouse.LeftDown(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:Au.Mouse.Click(System.Boolean)">
            <summary>
            Left click.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <param name="useLastMoveXY">Use <see cref="P:Au.Mouse.LastMoveXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.Mouse.Click(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Left click at position x y.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)"/>. More info there.
            </summary>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)"/>.</exception>
        </member>
        <member name="M:Au.Mouse.Click(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Left click at position x y relative to window w.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle. If false (default), they are relative to the client area.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <exception cref="T:Au.Types.AuException">x y is not in the window. More info: <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.Mouse.RightClick(System.Boolean)">
            <summary>
            Right click.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <param name="useLastMoveXY">Use <see cref="P:Au.Mouse.LastMoveXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.Mouse.RightClick(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Right click at position x y.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)"/>. More info there.
            </summary>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)"/>.</exception>
        </member>
        <member name="M:Au.Mouse.RightClick(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Right click at position x y relative to window w.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle. If false (default), they are relative to the client area.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <exception cref="T:Au.Types.AuException">x y is not in the window. More info: <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.Mouse.DoubleClick(System.Boolean)">
            <summary>
            Double left click.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <param name="useLastMoveXY">Use <see cref="P:Au.Mouse.LastMoveXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.Mouse.DoubleClick(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Double left click at position x y.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)"/>. More info there.
            </summary>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)"/>.</exception>
        </member>
        <member name="M:Au.Mouse.DoubleClick(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Double left click at position x y relative to window w.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle. If false (default), they are relative to the client area.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <exception cref="T:Au.Types.AuException">x y is not in the window. More info: <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.Mouse.LeftDown(System.Boolean)">
            <summary>
            Left down (press and don't release).
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <param name="useLastMoveXY">Use <see cref="P:Au.Mouse.LastMoveXY"/>, not current cursor position.</param>
            <remarks>
            The return value can be used to auto-release pressed button. See example with <see cref="M:Au.Mouse.LeftDown(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:Au.Mouse.LeftDown(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Left down (press and don't release) at position x y.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)"/>. More info there.
            </summary>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)"/>.</exception>
            <remarks>
            The return value can be used to auto-release pressed button. See example with <see cref="M:Au.Mouse.LeftDown(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:Au.Mouse.LeftDown(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Left down (press and don't release) at position x y relative to window w.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle. If false (default), they are relative to the client area.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <exception cref="T:Au.Types.AuException">x y is not in the window. More info: <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <remarks>
            The return value can be used to auto-release pressed button. Example: <c>using(Mouse.LeftDown(w, 8, 8)) Mouse.MoveRelative(20, 0);</c>. The button is auto-released when the 'using' block ends, even on exception. This can be used to drag-drop or drag-select.
            </remarks>
        </member>
        <member name="M:Au.Mouse.LeftUp(System.Boolean)">
            <summary>
            Left up (release pressed button).
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <param name="useLastMoveXY">Use <see cref="P:Au.Mouse.LastMoveXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.Mouse.LeftUp(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Left up (release pressed button) at position x y.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)"/>. More info there.
            </summary>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)"/>.</exception>
        </member>
        <member name="M:Au.Mouse.LeftUp(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Left up (release pressed button) at position x y relative to window w.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle. If false (default), they are relative to the client area.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.Mouse.RightDown(System.Boolean)">
            <summary>
            Right down (press and don't release).
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <param name="useLastMoveXY">Use <see cref="P:Au.Mouse.LastMoveXY"/>, not current cursor position.</param>
            <remarks>
            The return value can be used to auto-release pressed button. See example with <see cref="M:Au.Mouse.LeftDown(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:Au.Mouse.RightDown(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Right down (press and don't release) at position x y.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)"/>. More info there.
            </summary>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)"/>.</exception>
            <remarks>
            The return value can be used to auto-release pressed button. See example with <see cref="M:Au.Mouse.LeftDown(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:Au.Mouse.RightDown(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Right down (press and don't release) at position x y relative to window w.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle. If false (default), they are relative to the client area.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <exception cref="T:Au.Types.AuException">x y is not in the window. More info: <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <remarks>
            The return value can be used to auto-release pressed button. See example with <see cref="M:Au.Mouse.LeftDown(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:Au.Mouse.RightUp(System.Boolean)">
            <summary>
            Right up (release pressed button).
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <param name="useLastMoveXY">Use <see cref="P:Au.Mouse.LastMoveXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.Mouse.RightUp(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Right up (release pressed button) at position x y.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)"/>. More info there.
            </summary>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)"/>.</exception>
        </member>
        <member name="M:Au.Mouse.RightUp(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Right up (release pressed button) at position x y relative to window w.
            Calls <see cref="M:Au.Mouse.ClickEx(Au.Types.MButton,Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to (but not limited to) the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle. If false (default), they are relative to the client area.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Mouse.Move(Au.Wnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.Mouse.Wheel(System.Int32,System.Boolean)">
            <summary>
            Mouse wheel forward or backward.
            </summary>
            <param name="ticks">Number of wheel ticks forward (positive) or backward (negative).</param>
            <param name="horizontal">Horizontal wheel.</param>
        </member>
        <member name="M:Au.Mouse.IsPressed(System.Windows.Forms.MouseButtons)">
            <summary>
            Returns true if one or more of the specified mouse buttons are pressed.
            See also: <see cref="P:System.Windows.Forms.Control.MouseButtons"/>.
            </summary>
            <param name="buttons">Check only these buttons. Default - all.</param>
            <exception cref="T:System.ArgumentException">modifierKeys is 0 or contains non-modifier keys.</exception>
            <seealso cref="M:Au.WaitFor.NoMouseButtons(System.Double,System.Windows.Forms.MouseButtons)"/>
        </member>
        <member name="M:Au.Mouse.LibWaitWhileButtonsPressed">
            <summary>
            Waits while some buttons are in pressed state, except those pressed by a Mouse class function in this thread.
            Does nothing if Options.Relaxed == true.
            </summary>
        </member>
        <member name="T:Au.Util.Recording">
            <summary>
            Functions for keyboard/mouse/etc recorder tools.
            </summary>
        </member>
        <member name="M:Au.Util.Recording.MouseToString(System.Collections.Generic.IEnumerable{System.UInt32},System.Boolean)">
            <summary>
            Converts multiple recorded mouse movements to string for <see cref="M:Au.Mouse.MoveRecorded(System.String,System.Double)"/>.
            </summary>
            <param name="recorded">
            List of x y distances from previous.
            The first distance is from the mouse position before the first movement; at run time it will be distance from <see cref="P:Au.Mouse.LastMoveXY"/>.
            To create uint value from distance dx dy use this code: <c>Math_.MakeUint(dx, dy)</c>.
            </param>
            <param name="withSleepTimes">
            <paramref name="recorded"/> also contains sleep times (milliseconds) alternating with distances.
            It must start with a sleep time. Example: {time1, dist1, time2, dist2}. Another example: {time1, dist1, time2, dist2, time3}. This is invalid: {dist1, time1, dist2, time2}.
            </param>
        </member>
        <member name="T:Au.Util.LibCharPtr">
            <summary>
            String functions that work with char* and ANSI byte* strings.
            </summary>
        </member>
        <member name="M:Au.Util.LibCharPtr.Length(System.Char*)">
            <summary>
            Finds unmanaged UTF-16 string length (number of characters).
            Scans the string until '\0' character found.
            </summary>
            <param name="p">'\0'-terminated UTF-16 string. Can be null.</param>
        </member>
        <member name="M:Au.Util.LibCharPtr.Length(System.Char*,System.Int32)">
            <summary>
            Finds unmanaged UTF-16 string length (number of characters).
            Scans the string until '\0' character found, but not exceeding the specified length.
            </summary>
            <param name="p">'\0'-terminated UTF-16 string. Can be null.</param>
            <param name="nMax">Max allowed string length. The function returns nMax if does not find '\0' character within first nMax characters.</param>
        </member>
        <member name="M:Au.Util.LibCharPtr.Length(System.Byte*)">
            <summary>
            Finds unmanaged ANSI string length (number of bytes).
            Scans the string until '\0' character found.
            </summary>
            <param name="p">'\0'-terminated ANSI string. Can be any ANSI encoding, for example UTF8; this function counts bytes, not multi-byte characters. Can be null.</param>
        </member>
        <member name="M:Au.Util.LibCharPtr.Length(System.Byte*,System.Int32)">
            <summary>
            Finds unmanaged ANSI string length (number of bytes).
            Scans the string until '\0' character found, but not exceeding the specified length.
            </summary>
            <param name="p">'\0'-terminated ANSI string. Can be any encoding, for example UTF8; this function counts bytes, not multi-byte characters. Can be null.</param>
            <param name="nMax">Max allowed string length. The function returns nMax if does not find '\0' character within first nMax characters.</param>
        </member>
        <member name="M:Au.Util.LibCharPtr.EndsWith(System.Char*,System.Int32,System.String,System.Boolean)">
            <summary>
            Returns true if unmanaged UTF-16 string p ends with string s.
            </summary>
            <param name="p">UTF-16 string. Can be null.</param>
            <param name="len">p length.</param>
            <param name="s">Cannot be null.</param>
            <param name="ignoreCase">Case-insensitive.</param>
        </member>
        <member name="M:Au.Util.LibCharPtr.AsciiStartsWith(System.Byte*,System.String)">
            <summary>
            Returns true if unmanaged ANSI string p starts with string s. Case-sensitive.
            </summary>
            <param name="p">'\0'-terminated ANSI string. Can be null.</param>
            <param name="s">Must contain only ASCII characters. Cannot be null.</param>
        </member>
        <member name="M:Au.Util.LibCharPtr.AsciiStartsWithI(System.Byte*,System.String)">
            <summary>
            Returns true if unmanaged ANSI string p starts with string s. Case-insensitive.
            </summary>
            <param name="p">'\0'-terminated ANSI string. Can be null.</param>
            <param name="s">Must contain only ASCII characters. Cannot be null.</param>
        </member>
        <member name="M:Au.Util.LibCharPtr.AsciiFindChar(System.Byte*,System.Int32,System.Byte)">
            <summary>
            Finds character in unmanaged ANSI string which can be binary.
            </summary>
            <param name="p">ANSI string. Can be null.</param>
            <param name="len">Length of p to search in.</param>
            <param name="ch">ASCII character.</param>
        </member>
        <member name="M:Au.Util.LibCharPtr.AsciiFindString(System.Byte*,System.Int32,System.String)">
            <summary>
            Finds substring in unmanaged ANSI string which can be binary.
            Returns -1 if not found or if s is null/"" or s2 is "".
            </summary>
            <param name="p">ANSI string. Can be null.</param>
            <param name="len">Length of p to search in.</param>
            <param name="s">Substring to find. Must contain only ASCII characters. Cannot be null.</param>
        </member>
        <member name="M:Au.Util.LibCharPtr.Equals(System.Char*,System.Int32,System.String)">
            <summary>
            Case-sensitive compares native string with managed string and returns true if they are equal.
            </summary>
            <param name="p">Native string.</param>
            <param name="len">p length. Returns false if it is != s.Length.</param>
            <param name="s">Managed string.</param>
        </member>
        <member name="T:Au.Util.LibArrayBuilder`1">
            <summary>
            Like List or StringBuilder, used as a temporary variable-size array to create final fixed-size array.
            To avoid much garbage (and many reallocations when growing), uses native memory heap. See <see cref="T:Au.Util.NativeHeap"/>.
            Must be explicitly disposed to free the native memory. Does not have a finalizer because is struct (to avoid garbage).
            Does not support reference types. Does not call Dispose.
            </summary>
        </member>
        <member name="P:Au.Util.LibArrayBuilder`1.Ptr">
            <summary>
            Gets array memory address (address of element 0).
            </summary>
        </member>
        <member name="P:Au.Util.LibArrayBuilder`1.Count">
            <summary>
            Gets the number of elements.
            </summary>
        </member>
        <member name="P:Au.Util.LibArrayBuilder`1.ByteCount">
            <summary>
            Gets the number of bytes in the array (Count*sizeof(T)).
            </summary>
        </member>
        <member name="P:Au.Util.LibArrayBuilder`1.Capacity">
            <summary>
            Gets or sets the total number of elements (not bytes) the internal memory can hold without resizing.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">(the 'set' function) value less than Count. Instead use ReAlloc or Free.</exception>
        </member>
        <member name="M:Au.Util.LibArrayBuilder`1.Alloc(System.Int32,System.Boolean)">
            <summary>
            Allocates count elements. Sets Count=count.
            Frees previously allocated memory.
            Returns memory address (address of element 0).
            </summary>
            <param name="count">Element count.</param>
            <param name="zeroInit">Set all bytes = 0. If false, the memory is uninitialized, ie random byte values. Default true. Slower when true.</param>
        </member>
        <member name="M:Au.Util.LibArrayBuilder`1.ReAlloc(System.Int32,System.Boolean)">
            <summary>
            Adds or removes elements at the end. Sets Count=count.
            Preserves Math.Min(Count, count) existing elements.
            Returns memory address (address of element 0).
            </summary>
            <param name="count">New element count.</param>
            <param name="zeroInit">Set all added bytes = 0. If false, the added memory is uninitialized, ie random byte values. Default true. Slower when true.</param>
            <remarks>
            The new memory usually is at a new location. The preserved elements are copied there.
            Sets Count=count. To allocate more memory without changing Count, change Capacity instead.
            </remarks>
        </member>
        <member name="M:Au.Util.LibArrayBuilder`1.Free">
            <summary>
            Frees memory. Sets Count and Capacity = 0.
            </summary>
        </member>
        <member name="M:Au.Util.LibArrayBuilder`1.AddR(`0@)">
            <summary>
            Adds one element.
            Uses ref to avoid copying when T size is big. Does not modify the passed variable.
            </summary>
        </member>
        <member name="M:Au.Util.LibArrayBuilder`1.Add(`0)">
            <summary>
            Adds one element.
            </summary>
        </member>
        <member name="M:Au.Util.LibArrayBuilder`1.Add">
            <summary>
            Adds one zero-inited element and returns its reference.
            </summary>
        </member>
        <member name="M:Au.Util.LibArrayBuilder`1._EnsureCapacity">
            <summary>
            Capacity = Math.Max(_cap * 2, s_minCap).
            </summary>
        </member>
        <member name="P:Au.Util.LibArrayBuilder`1.Item(System.Int32)">
            <summary>
            Gets element reference.
            </summary>
            <param name="i">Element index.</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:Au.Util.LibArrayBuilder`1.ToArray">
            <summary>
            Copies elements to a new managed array.
            </summary>
        </member>
        <member name="T:Au.Util.StringCache">
            <summary>
            Caches managed strings created from unmanaged char* buffers.
            </summary>
            <remarks>
            Can be used in possibly very frequently called functions to avoid much string garbage and frequent garbage collections.
            For example, Wnd.ClassName and Wnd.Name use this. They are called by Wnd.Find for each window (can be hundreds of them). And WaitFor.WindowExists calls Wnd.Find every 30 or so milliseconds. It could create megabytes of garbage (window classname and name strings) in a few seconds. Every Wnd.Find call creates almost the same set of strings, therefore it makes sense to cache them.
            To allow GC free the cached strings, use a WeakReferenc&lt;StringCache&gt; object. See example.
            </remarks>
            <example>
            <code><![CDATA[
            internal static unsafe string GetCachedString(char* p, int len)
            {
            	lock(_cacheWR) {
            		if(!_cacheWR.TryGetTarget(out var cache)) _cacheWR.SetTarget(cache = new StringCache());
            		return cache.Add(p, len);
            	}
            }
            static WeakReference<StringCache> _cacheWR = new WeakReference<StringCache>(null);
            
            //When char[] is used as text buffer.
            internal static unsafe string GetCachedString(char[] a, int len)
            {
            	Debug.Assert(len < a.Length);
            	fixed (char* p = a) return GetCachedString(p, len);
            }
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Util.StringCache.Count">
            <summary>
            Number of elements in this cache.
            </summary>
        </member>
        <member name="M:Au.Util.StringCache.Add(System.Char*,System.Int32)">
            <summary>
            Searches in the cache for a managed string that matches unmanaged string p of length len.
            If finds, returns it. Else adds <c>new string(p, 0, len)</c> to the cache and returns it.
            </summary>
            <param name="p">Unmanaged string.</param>
            <param name="len">p length.</param>
            <remarks>
            speed when found in cache: similar to <c>new string(p, 0, len)</c>.
            </remarks>
        </member>
        <member name="M:Au.Util.StringCache.LibAdd(System.Char*,System.Int32,System.Boolean)">
            <summary>
            Gets string cached in a weak-referenced internal static LibStringCache object.
            Locks and calls <see cref="M:Au.Util.StringCache.Add(System.Char*,System.Int32)"/>.
            </summary>
            <param name="p">Unmanaged string.</param>
            <param name="len">p length.</param>
            <param name="lenIsMaxLen">Call <c>len = LibCharPtr.Length(p, len)</c>.</param>
        </member>
        <member name="M:Au.Util.StringCache.LibAdd(System.Char[],System.Int32)">
            <summary>
            Gets string cached in a weak-referenced internal static LibStringCache object.
            Locks and calls <see cref="M:Au.Util.StringCache.Add(System.Char*,System.Int32)"/>.
            </summary>
            <param name="a">Text buffer.</param>
            <param name="len">Length of valid text in a.</param>
        </member>
        <member name="M:Au.Util.StringCache.LibAdd(System.Char*)">
            <summary>
            This overload calls LibCharPtr.Length.
            </summary>
        </member>
        <member name="M:Au.Util.StringCache.LibAdd(System.Char[])">
            <summary>
            This overload calls LibCharPtr.Length.
            </summary>
        </member>
        <member name="M:Au.Util.StringCache.LibAdd(System.String,System.Int32,System.Int32)">
            <summary>
            Gets substring of string s as a string cached in a weak-referenced internal static LibStringCache object.
            Locks and calls <see cref="M:Au.Util.StringCache.Add(System.Char*,System.Int32)"/>.
            </summary>
            <param name="s">The string containing the substring. Can be null/"" if other parameters are 0.</param>
            <param name="startIndex">Start of substring in s.</param>
            <param name="count">Length of substring.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="T:Au.Util.LibTables">
            <summary>
            Lookup tables for various functions of this library.
            Multiple appdomains share the same tables.
            </summary>
        </member>
        <member name="F:Au.Util.LibTables._lowerCaseTable">
            <summary>
            Gets native-memory char[0x10000] containing lower-case versions of the first 0x10000 characters.
            Auto-creates when called first time. The memory is shared by appdomains.
            </summary>
        </member>
        <member name="P:Au.Util.LibTables.Base64">
            <summary>
            Gets table for <see cref="M:Au.Convert_.Base64Decode(System.Char*,System.Int32,System.Void*,System.Int32)"/> and co.
            Auto-creates when called first time. The memory is shared by appdomains.
            </summary>
        </member>
        <member name="P:Au.Util.LibTables.Hex">
            <summary>
            Gets table for <see cref="M:Au.Convert_.HexDecode(System.String,System.Void*,System.Int32,System.Int32)"/> and co.
            Auto-creates when called first time. The memory is shared by appdomains.
            </summary>
        </member>
        <member name="T:Au.Util.AppDomain_">
            <summary>
            Extends the .NET AppDomain class.
            </summary>
        </member>
        <member name="M:Au.Util.AppDomain_.GetDefaultDomain(System.Boolean@)">
            <summary>
            Gets default appdomain.
            </summary>
            <param name="isCurrentDomain">Receives true if called from default appdomain.</param>
        </member>
        <member name="M:Au.Util.AppDomain_.GetDefaultDomain">
            <summary>
            Gets default appdomain.
            </summary>
        </member>
        <member name="E:Au.Util.AppDomain_.Exit">
            <summary>
            Occurs when current appdomain exits.
            </summary>
            <remarks>
            The event handler is called when one of these AppDomain events occur, with their parameters:
            <see cref="E:System.AppDomain.ProcessExit"/> (in default domain);
            <see cref="E:System.AppDomain.DomainUnload"/> (in non-default domain);
            <see cref="E:System.AppDomain.UnhandledException"/>.
            The event handler is called before static object finalizers.
            </remarks>
        </member>
        <member name="T:Au.Util.SharedMemory">
            <summary>
            Memory that can be used by multiple processes and app domains.
            Faster and more raw/unsafe than System.IO.MemoryMappedFiles.MemoryMappedFile.
            </summary>
            <seealso cref="M:Au.Wnd.Misc.InterProcessSendData(Au.Wnd,System.Int32,System.String,Au.Wnd)"/>
        </member>
        <member name="M:Au.Util.SharedMemory.CreateOrGet(System.String,System.UInt32,System.Boolean@)">
            <summary>
            Creates named shared memory of specified size. Opens if already exists.
            Returns shared memory address in this process.
            Calls API <msdn>CreateFileMapping</msdn> and API <msdn>MapViewOfFile</msdn>.
            </summary>
            <param name="name">Shared memory name. Case-insensitive.</param>
            <param name="size">Shared memory size. Ignored if the shared memory already exists.</param>
            <param name="created">Receives true if created and not opened.</param>
            <exception cref="T:Au.Types.AuException">The API failed.</exception>
            <remarks>
            Once the memory is created, it is alive at least until this process ends. Other processes can keep the memory alive even after that.
            There is no Close function to close the native shared memory object handle. The OS closes it when this process ends.
            </remarks>
        </member>
        <member name="T:Au.Util.LibSharedMemory">
            <summary>
            Memory shared by all appdomains and by other related processes.
            </summary>
        </member>
        <member name="F:Au.Util.LibSharedMemory.Size">
            <summary>
            Shared memory size.
            </summary>
        </member>
        <member name="F:Au.Util.LibSharedMemory._sm">
            <summary>
            Creates or opens shared memory on demand in a thread-safe and process-safe way.
            </summary>
        </member>
        <member name="P:Au.Util.LibSharedMemory.Ptr">
            <summary>
            Gets pointer to the shared memory.
            </summary>
        </member>
        <member name="T:Au.Util.LibProcessMemory">
            <summary>
            Memory shared by all appdomains of current process.
            Size 0x10000 (64 KB). Initially zero.
            </summary>
            <remarks>
            When need to prevent simultaneous access of the memory by multiple threads, use <c>lock("uniqueString"){...}</c> .
            It locks in all appdomains, because literal strings are interned, ie shared by all appdomains.
            Using some other object with 'lock' would lock only in that appdomain. Maybe except Type.
            Use this only in single module, because ngened modules have own interned strings.
            </remarks>
        </member>
        <member name="P:Au.Util.LibProcessMemory.Ptr">
            <summary>
            Gets pointer to the memory.
            </summary>
        </member>
        <member name="F:Au.Util.LibProcessMemory.Size">
            <summary>
            Memory size.
            </summary>
        </member>
        <member name="T:Au.Util.NativeHeap">
            <summary>
            Allocates memory from native heap of this process using heap API.
            Uses the common heap of this process, API <msdn>GetProcessHeap</msdn>.
            Usually slightly faster than Marshal class functions.
            </summary>
        </member>
        <member name="M:Au.Util.NativeHeap.Alloc(Au.Types.LPARAM,System.Boolean)">
            <summary>
            Allocates new memory block and returns its address.
            Calls API <msdn>HeapAlloc</msdn>.
            </summary>
            <param name="size">Byte count.</param>
            <param name="zeroInit">Set all bytes = 0. If false (default), the memory is uninitialized, ie random byte values. Slower when true.</param>
            <exception cref="T:System.OutOfMemoryException">Failed. Probably size is too big.</exception>
            <remarks>The memory is unmanaged and will not be freed automatically. Always call <see cref="M:Au.Util.NativeHeap.Free(System.Void*)"/> when done or <see cref="M:Au.Util.NativeHeap.ReAlloc(System.Void*,Au.Types.LPARAM,System.Boolean)"/> if need to resize it without losing data.</remarks>
        </member>
        <member name="M:Au.Util.NativeHeap.ReAlloc(System.Void*,Au.Types.LPARAM,System.Boolean)">
            <summary>
            Reallocates a memory block to make it bigger or smaller.
            Returns its address, which in most cases is different than the old memory block address.
            Preserves data in Math.Min(old size, new size) bytes of old memory (copies from old memory if need).
            Calls API <msdn>HeapReAlloc</msdn> or <msdn>HeapAlloc</msdn>.
            </summary>
            <param name="mem">Old memory address. If null, allocates new memory like Alloc.</param>
            <param name="size">New byte count.</param>
            <param name="zeroInit">When size is growing, set all added bytes = 0. If false (default), the added memory is uninitialized, ie random byte values. Slower when true.</param>
            <exception cref="T:System.OutOfMemoryException">Failed. Probably size is too big.</exception>
            <remarks>The memory is unmanaged and will not be freed automatically. Always call <see cref="M:Au.Util.NativeHeap.Free(System.Void*)"/> when done or ReAlloc if need to resize it without losing data.</remarks>
        </member>
        <member name="M:Au.Util.NativeHeap.Free(System.Void*)">
            <summary>
            Frees a memory block.
            Does nothing if mem is null.
            Calls API <msdn>HeapFree</msdn>.
            </summary>
        </member>
        <member name="T:Au.Util.Buffers">
            <summary>
            Allocates memory buffers that can be used with API functions and not only.
            Can allocate arrays of any value type - char[], byte[] etc.
            </summary>
            <example>
            <code><![CDATA[
            class Example
            {
            	public static void Test()
            	{
            		Wnd w = Wnd.FindFast(null, "Notepad");
            		string s = GetWndText(w);
            		Print(s);
            	}
            
            	public static string GetWndText(Wnd w)
            	{
            		for(int na = 300; ; na *= 2) {
            			var b = _GetCharBuffer(ref na);
            			int nr = GetWindowText(w, b, na);
            			if(nr < na - 1) return (nr > 0) ? b.ToString(nr) : "";
            		}
            	}
            
            	//this variable manages the buffer
            	[ThreadStatic] static WeakReference<char[]> t_char;
            
            	//a helper method
            	static Au.Util.Buffers.CharBuffer _GetCharBuffer(ref int n) { var r = Au.Util.Buffers.Get(n, ref t_char); n = r.Length - 1; return r; }
            
            	//we'll use this API in this example
            	[DllImport("user32.dll", EntryPoint = "GetWindowTextW")]
            	static extern int GetWindowText(Wnd hWnd, [Out] char[] lpString, int nMaxCount);
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Util.Buffers.Get``1(System.Int32,System.WeakReference{``0[]}@)">
            <summary>
            Allocates new or gets "cached" array of type T of length n or more.
            The returned array is managed by a WeakReference&lt;T[]&gt; variable provided by the caller. Its contents is undefined.
            </summary>
            <typeparam name="T">Any value type, for example char, byte, RECT.</typeparam>
            <param name="n">
            How many elements you need.
            If array in the WeakReference variable is null or too small, creates new array and stores it there.
            For byte[] and char[] types actually allocates Math.Max(n, 300)+1 elements. The 300 is to avoid future reallocations. The +1 can be used for example for '\0' character at the end of string.</param>
            <param name="weakReference">
            A reference to a WeakReference variable that manages the returned array. If null, this function will create it.
            The variable should be [ThreadStatic] static. Or can be a non-static field of a long-living object. Must not be simply static, it's not thread-safe (unless locked).
            </param>
            <remarks>
            Used to avoid creating much garbage when array allocations are needed frequently. Also is faster than code like <c>var b=new byte[1000]</c> or StringBuilder.
            The WeakReference variable allows the array to be garbage-collected if it is not used when GC runs. It is automatic and safe. Next time this function will create new array.
            Actually this function is a wrapper for WeakReference&lt;T[]&gt; functions TryGetTarget/SetTarget. Makes it easier to use.
            </remarks>
        </member>
        <member name="T:Au.Util.Buffers.CharBuffer">
            <summary>
            Provides functions to convert char[] to string easily.
            Assign char[] and call the ToString functions. Example: <see cref="T:Au.Util.Buffers"/>.
            </summary>
        </member>
        <member name="F:Au.Util.Buffers.CharBuffer.A">
            <summary>
            The array that is stored in this variable.
            </summary>
        </member>
        <member name="M:Au.Util.Buffers.CharBuffer.op_Implicit(Au.Util.Buffers.CharBuffer)~System.Char[]">
            
        </member>
        <member name="M:Au.Util.Buffers.CharBuffer.op_Implicit(System.Char[])~Au.Util.Buffers.CharBuffer">
            
        </member>
        <member name="M:Au.Util.Buffers.CharBuffer.ToString">
            <summary>
            Converts the array, which contains native '\0'-terminated UTF-16 string, to String.
            Unlike code <c>new string(charArray)</c>, gets array part until '\0' character, not whole array.
            </summary>
        </member>
        <member name="M:Au.Util.Buffers.CharBuffer.ToString(System.Int32)">
            <summary>
            Converts the array, which contains native UTF-16 string of n length, to String.
            Uses <c>new string(A, 0, n)</c>, which throws exception if the array is null or n is invalid.
            </summary>
            <param name="n">String length.</param>
        </member>
        <member name="M:Au.Util.Buffers.CharBuffer.LibToStringCached">
            <summary>
            The same as <see cref="M:Au.Util.Buffers.CharBuffer.ToString"/>, but uses our StringCache.
            </summary>
        </member>
        <member name="M:Au.Util.Buffers.CharBuffer.LibToStringCached(System.Int32)">
            <summary>
            The same as <see cref="M:Au.Util.Buffers.CharBuffer.ToString(System.Int32)"/>, but uses our StringCache.
            </summary>
            <param name="n">String length.</param>
        </member>
        <member name="M:Au.Util.Buffers.CharBuffer.LibToStringFromAnsi(System.Int32,System.Text.Encoding)">
            <summary>
            Converts the buffer, which contains native ANSI string of n length, to String.
            </summary>
            <param name="n">String length.</param>
            <param name="enc">If null, uses system's default ANSI encoding.</param>
        </member>
        <member name="T:Au.Util.LibStringBuilder">
            <summary>
            Provides a cached reusable instance of StringBuilder per thread. It's an optimisation that reduces the number of instances constructed and collected.
            Used like <c>using(new Au.Util.LibStringBuilder(out var b)) { b.Append("example"); var s = b.ToString(); }</c>.
            </summary>
            <remarks>
            This is a modified copy of the .NET internal StringBuilderCache class.
            The cache uses 2 [ThreadLocal] StringBuilder instances, which allows 1 nesting level. Not error to use deeper nesting level, but then gets new StringBuilder, not from the cache.
            </remarks>
        </member>
        <member name="F:Au.Util.LibStringBuilder.MAX_BUILDER_SIZE">
            <summary>
            2000. The cache is not used if capacity is bigger.
            </summary>
        </member>
        <member name="M:Au.Util.LibStringBuilder.#ctor(System.Text.StringBuilder@,System.Int32)">
            <summary>
            Gets a new or cached/cleared StringBuilder of the specified capacity, min 200.
            </summary>
        </member>
        <member name="M:Au.Util.LibStringBuilder.Dispose">
            <summary>
            Releases the StringBuilder to the cache.
            </summary>
        </member>
        <member name="T:Au.Util.MessageLoop">
            <summary>
            A message loop, alternative to Application.Run which does not support nested loops.
            </summary>
        </member>
        <member name="M:Au.Util.MessageLoop.Loop">
            <summary>
            Runs a message loop.
            </summary>
        </member>
        <member name="M:Au.Util.MessageLoop.Stop">
            <summary>
            Ends the message loop, causing Loop() to return.
            </summary>
        </member>
        <member name="T:Au.Util.LibEnsureWindowsFormsSynchronizationContext">
            <summary>
            Constructor ensures that current SynchronizationContext of this thread is WindowsFormsSynchronizationContext.
            Also sets WindowsFormsSynchronizationContext.AutoInstall=false to prevent Application.DoEvents etc setting wrong context.
            Dispose() restores both if need. Does not restore context if was null.
            Example: using(new Util.LibEnsureWindowsFormsSynchronizationContext()) { ... }
            </summary>
        </member>
        <member name="M:Au.Util.LibEnsureWindowsFormsSynchronizationContext.#ctor(System.Boolean)">
            <summary>
            See class help.
            </summary>
            <param name="onlyIfAutoInstall">Do nothing if WindowsFormsSynchronizationContext.AutoInstall==false. Normally WindowsFormsSynchronizationContext.AutoInstall is true (default).</param>
        </member>
        <member name="M:Au.Util.LibEnsureWindowsFormsSynchronizationContext.EnsurePermanently">
            <summary>
            If synchronization context of this thread is null or not WindowsFormsSynchronizationContext, makes it WindowsFormsSynchronizationContext.
            Use this instead of creating instance when will not need to restore previous synchronization context.
            </summary>
            <exception cref="T:System.InvalidOperationException">This thread has a synchronization context other than WindowsFormsSynchronizationContext or null. Or it is null and thread's GetApartmentState is not STA.</exception>
        </member>
        <member name="T:Au.Util.DragDrop">
            <summary>
            Drag-drop functions.
            </summary>
        </member>
        <member name="M:Au.Util.DragDrop.SimpleDragDrop(Au.Wnd,System.Windows.Forms.MouseButtons,System.Action{Au.Util.DragDrop.MsgArgs})">
            <summary>
            Simple non-OLE drag operation.
            Returns true if dropped, false if cancelled.
            </summary>
            <param name="w">Window or control that owns the drag operation.</param>
            <param name="mouseButton">Mouse button that is used for the drag operation: Left, Right.</param>
            <param name="onMouseKeyMessage">Callback function, called on each received mouse/key message. Optional.</param>
        </member>
        <member name="M:Au.Util.DragDrop.SimpleDragDrop(System.Windows.Forms.Control,System.Windows.Forms.MouseButtons,System.Action{Au.Util.DragDrop.MsgArgs})">
            <summary>
            Simple non-OLE drag operation.
            Returns true if dropped, false if cancelled.
            </summary>
            <param name="c">Window or control that owns the drag operation.</param>
            <param name="mouseButton">Mouse button that is used for the drag operation: Left, Right.</param>
            <param name="onMouseKeyMessage">Callback function, called on each received mouse/key message. Optional.</param>
        </member>
        <member name="T:Au.Util.DragDrop.MsgArgs">
            <summary>
            <see cref="M:Au.Util.DragDrop.SimpleDragDrop(System.Windows.Forms.Control,System.Windows.Forms.MouseButtons,System.Action{Au.Util.DragDrop.MsgArgs})"/> callback function arguments.
            </summary>
        </member>
        <member name="F:Au.Util.DragDrop.MsgArgs.Msg">
            <summary>
            Current message retrieved by API <msdn>GetMessage</msdn>.
            </summary>
        </member>
        <member name="F:Au.Util.DragDrop.MsgArgs.Cursor">
            <summary>
            The callback function can set this to temporarily set cursor.
            </summary>
        </member>
        <member name="M:Au.Util.DragDrop.MsgArgs.Stop">
            <summary>
            The callback function can call this to end the operation.
            </summary>
        </member>
        <member name="T:Au.Util.ThreadPoolSTA">
            <summary>
            Thread pool where COM can be used. Initializes thread COM as single-thread-apartment.
            </summary>
        </member>
        <member name="T:Au.Util.ThreadPoolSTA.WorkCallbackData">
            <summary>
            Work callback function parameter type.
            More info: <see cref="T:Au.Util.ThreadPoolSTA.WorkCallback"/>.
            </summary>
        </member>
        <member name="F:Au.Util.ThreadPoolSTA.WorkCallbackData.state">
            
        </member>
        <member name="F:Au.Util.ThreadPoolSTA.WorkCallbackData.completionCallback">
            
        </member>
        <member name="T:Au.Util.ThreadPoolSTA.WorkCallback">
            <summary>
            Work callback function type.
            </summary>
            <param name="d">
            Contains state and completionCallback that were passed to the submit function.
            Your work callback function can change completionCallback and/or state. For example it can set completionCallback = null to prevent calling it (the call is expensive); or change state, if want to pass another object to the completion function.
            Note that the completion function is never called if initially it was null.
            </param>
        </member>
        <member name="M:Au.Util.ThreadPoolSTA.SubmitCallback(System.Object,Au.Util.ThreadPoolSTA.WorkCallback,System.Threading.SendOrPostCallback)">
            <summary>
            Requests that a thread pool thread call the callback function.
            </summary>
            <param name="state">Something to pass to the callback functions.</param>
            <param name="workCallback">Callback function to call in a thread pool thread.</param>
            <param name="completionCallback">Optional callback function to call in this thread after workCallback.</param>
            <exception cref="T:System.ComponentModel.Win32Exception"/>
            <exception cref="T:System.InvalidOperationException">(only when completionCallback is used) This thread has a synchronization context other than WindowsFormsSynchronizationContext or null; or it is null and thread's GetApartmentState is not STA.</exception>
        </member>
        <member name="M:Au.Util.ThreadPoolSTA.CreateWork(System.Object,Au.Util.ThreadPoolSTA.WorkCallback,System.Threading.SendOrPostCallback)">
            <summary>
            Creates a <see cref="T:Au.Util.ThreadPoolSTA.Work"/> object that can be used when need more options than <see cref="M:Au.Util.ThreadPoolSTA.SubmitCallback(System.Object,Au.Util.ThreadPoolSTA.WorkCallback,System.Threading.SendOrPostCallback)">SubmitCallback</see> has.
            </summary>
            <param name="state">Something to pass to the callback functions.</param>
            <param name="workCallback">Callback function to call in a thread pool thread.</param>
            <param name="completionCallback">Optional callback function to call in this thread after workCallback.</param>
            <remarks>
            Call Dispose() to avoid memory leaks. If not called, the object and related OS object remain in memory until this appdomain ends.
            </remarks>
            <exception cref="T:System.ComponentModel.Win32Exception"/>
            <exception cref="T:System.InvalidOperationException">(only when completionCallback is used) This thread has a synchronization context other than WindowsFormsSynchronizationContext or null; or it is null and thread's GetApartmentState is not STA.</exception>
        </member>
        <member name="T:Au.Util.ThreadPoolSTA.Work">
            <summary>
            Allows to submit a callback function (one or more times) to be called in thread pool threads, then optionally wait and cancel.
            Can be used when need more options than <see cref="M:Au.Util.ThreadPoolSTA.SubmitCallback(System.Object,Au.Util.ThreadPoolSTA.WorkCallback,System.Threading.SendOrPostCallback)">SubmitCallback</see> has.
            </summary>
            <example><code>
            using(var work = Util.ThreadPoolSTA.CreateWork(null, o =&gt; { Thread.Sleep(100); })) {
            	work.Submit();
            	work.Wait();
            }
            </code></example>
        </member>
        <member name="M:Au.Util.ThreadPoolSTA.Work.#ctor(System.Object,Au.Util.ThreadPoolSTA.WorkCallback,System.Threading.SendOrPostCallback,System.Boolean)">
            <exception cref="T:System.ComponentModel.Win32Exception"/>
            <exception cref="T:System.InvalidOperationException">(only when completionCallback is used) This thread has a synchronization context other than WindowsFormsSynchronizationContext or null; or it is null and thread's GetApartmentState is not STA.</exception>
        </member>
        <member name="M:Au.Util.ThreadPoolSTA.Work.Submit">
            <summary>
            Requests that a thread pool thread call the callback function.
            This function can be called multiple times.
            </summary>
        </member>
        <member name="M:Au.Util.ThreadPoolSTA.Work.Wait">
            <summary>
            Waits until all submitted instances of the callback function finish their work.
            While waiting, this thread cannot dispatch events and Windows messages.
            </summary>
        </member>
        <member name="M:Au.Util.ThreadPoolSTA.Work.Cancel">
            <summary>
            Waits until all running instances of the callback function finish their work, and cancels pending (still not running) instances.
            While waiting, this thread cannot dispatch events and Windows messages.
            </summary>
        </member>
        <member name="M:Au.Util.ThreadPoolSTA.Work.Dispose">
            <summary>
            Calls <see cref="M:Au.Util.ThreadPoolSTA.Work.Cancel"/>, releases all resources used by this object and allows this object to be garbage-collected.
            Call this to avoid memory leaks. If not called, the object and related OS object remain in memory until this appdomain ends.
            </summary>
        </member>
        <member name="T:Au.Util.NamespaceDoc">
            <summary>
            Miscellaneous classes and functions used in this library. Can be used outside it too.
            </summary>
        </member>
        <member name="T:Au.Util.LibScreenDC">
            <summary>
            Helps to get and release screen DC with the 'using(...){...}' pattern.
            Uses API GetDC and ReleaseDC.
            </summary>
        </member>
        <member name="T:Au.Util.LibWindowDC">
            <summary>
            Helps to get and release window DC with the 'using(...){...}' pattern.
            Uses API GetDC and ReleaseDC.
            If w is default(Wnd), gets screen DC.
            </summary>
        </member>
        <member name="T:Au.Util.LibCompatibleDC">
            <summary>
            Helps to create and delete screen DC with the 'using(...){...}' pattern.
            Uses API CreateCompatibleDC and DeleteDC.
            </summary>
        </member>
        <member name="T:Au.Util.MemoryBitmap">
            <summary>
            Creates and manages native bitmap handle and memory DC (GDI device context).
            The bitmap is selected in the DC.
            </summary>
        </member>
        <member name="P:Au.Util.MemoryBitmap.Hdc">
            <summary>
            DC handle.
            </summary>
        </member>
        <member name="P:Au.Util.MemoryBitmap.Hbitmap">
            <summary>
            Bitmap handle.
            </summary>
        </member>
        <member name="M:Au.Util.MemoryBitmap.#ctor">
            <summary>
            Does nothing. Later you can call Create or Attach.
            </summary>
        </member>
        <member name="M:Au.Util.MemoryBitmap.#ctor(System.Int32,System.Int32)">
            <summary>
            Calls <see cref="M:Au.Util.MemoryBitmap.Create(System.Int32,System.Int32)"/>.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed. Probably there is not enough memory for bitmap of specified size (need with*height*4 bytes).</exception>
        </member>
        <member name="M:Au.Util.MemoryBitmap.Dispose">
            <summary>
            Deletes the bitmap and DC.
            </summary>
        </member>
        <member name="M:Au.Util.MemoryBitmap.Finalize">
            
        </member>
        <member name="M:Au.Util.MemoryBitmap.Delete">
            <summary>
            Deletes the bitmap and DC.
            </summary>
        </member>
        <member name="M:Au.Util.MemoryBitmap.Create(System.Int32,System.Int32)">
            <summary>
            Creates new memory DC and bitmap of specified size and selects it into the DC.
            Returns false if failed.
            In any case deletes previous bitmap and DC.
            </summary>
            <param name="width">Width, pixels.</param>
            <param name="height">Height, pixels.</param>
        </member>
        <member name="M:Au.Util.MemoryBitmap.Attach(System.IntPtr)">
            <summary>
            Sets this variable to manage an existing bitmap.
            Selects the bitmap into a memory DC.
            Deletes previous bitmap and DC.
            </summary>
            <param name="hBitmap">Native bitmap handle.</param>
        </member>
        <member name="M:Au.Util.MemoryBitmap.Detach">
            <summary>
            Deletes memory DC, clears this variable and returns its bitmap (native bitmap handle).
            The returned bitmap is not selected into a DC. Will need to delete it with API DeleteObject.
            </summary>
        </member>
        <member name="T:Au.Util.LibNativeFont">
            <summary>
            Creates and manages native font handle.
            </summary>
        </member>
        <member name="T:Au.Util.ModuleHandle">
            <summary>
            Gets native module handle.
            </summary>
        </member>
        <member name="M:Au.Util.ModuleHandle.OfType(System.Type)">
            <summary>
            Gets native module handle of type's assembly.
            </summary>
        </member>
        <member name="M:Au.Util.ModuleHandle.OfAssembly(System.Reflection.Assembly)">
            <summary>
            Gets native module handle of an assembly.
            If the assembly consists of multiple modules, gets its first loaded module.
            </summary>
        </member>
        <member name="M:Au.Util.ModuleHandle.OfAppDomainEntryAssembly">
            <summary>
            Gets native module handle of the entry assembly of this appdomain.
            If the assembly consists of multiple modules, gets its first loaded module.
            </summary>
        </member>
        <member name="M:Au.Util.ModuleHandle.OfAuDll">
            <summary>
            Gets native module handle of Au.dll.
            </summary>
        </member>
        <member name="M:Au.Util.ModuleHandle.OfProcessExe">
            <summary>
            Gets native module handle of the program file of this process.
            </summary>
        </member>
        <member name="T:Au.Util.Assembly_">
            <summary>
            Assembly functions.
            </summary>
        </member>
        <member name="P:Au.Util.Assembly_.EntryAssembly">
            <summary>
            Gets the entry assembly of this appdomain.
            Normally instead can be used <see cref="M:System.Reflection.Assembly.GetEntryAssembly"/>, but it returns null if appdomain launched through <see cref="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)">AppDomain.DoCallBack</see>.
            </summary>
        </member>
        <member name="P:Au.Util.Assembly_.LibIsAuInGAC">
            <summary>
            Returns true if Au.dll is installed in the global assembly cache.
            </summary>
        </member>
        <member name="P:Au.Util.Assembly_.LibIsAuNgened">
            <summary>
            Returns true if Au.dll is compiled to native code using ngen.exe.
            It means - no JIT-compiling delay when its functions are called first time in process or appdomain.
            </summary>
        </member>
        <member name="M:Au.Util.Assembly_.IsAssemblyNgened(System.Reflection.Assembly)">
            <summary>
            Returns true if assembly asm is compiled to native code using ngen.exe.
            It means - no JIT-compiling delay when its functions are called first time in process or appdomain.
            </summary>
        </member>
        <member name="T:Au.Util.Resources_">
            <summary>
            Functions to work with managed resources.
            </summary>
        </member>
        <member name="M:Au.Util.Resources_.GetAppResource(System.String)">
            <summary>
            Gets an Image or other object from managed resources of appdomain's entry assembly.
            Returns null if not found.
            </summary>
            <param name="name">Resource name, like "example", not like "Project.Properties.Resources.example".</param>
            <remarks>
            Uses <see cref="M:System.Resources.ResourceManager.GetObject(System.String,System.Globalization.CultureInfo)"/>.
            The Image is not cached. Will need to Dispose.
            </remarks>
        </member>
        <member name="M:Au.Util.Resources_.LibGetAppResourceManager(System.Globalization.CultureInfo@)">
            <summary>
            Gets ResourceManager of appdomain's entry assembly.
            Returns null if the assembly does not have resources or if fails.
            </summary>
        </member>
        <member name="T:Au.Util.Dpi">
            <summary>
            Functions for high-DPI screen support.
            High DPI means when in Control Panel is set screen text size other than 100%.
            </summary>
        </member>
        <member name="P:Au.Util.Dpi.BaseDPI">
            <summary>
            Gets DPI of the primary screen.
            On newer Windows versions, users can change DPI without logoff-logon. This function gets the setting that was after logon.
            </summary>
        </member>
        <member name="P:Au.Util.Dpi.SmallIconSize">
            <summary>
            Gets small icon size that depends on DPI of the primary screen.
            Width and Height are <see cref="P:Au.Util.Dpi.BaseDPI"/>/6, which is 16 if DPI is 96 (100%).
            </summary>
        </member>
        <member name="M:Au.Util.Dpi.ScaleInt(System.Int32)">
            <summary>
            If <see cref="P:Au.Util.Dpi.BaseDPI"/> is more than 96, returns stretched i.
            Else returns i.
            </summary>
            <param name="i"></param>
        </member>
        <member name="M:Au.Util.Dpi.ScaleSize(System.Drawing.Size)">
            <summary>
            If <see cref="P:Au.Util.Dpi.BaseDPI"/> is more than 96, returns scaled (stretched) z.
            Else returns z.
            Note: for images use <see cref="M:Au.Util.Dpi.ImageSize(System.Drawing.Image)"/>.
            </summary>
            <param name="z"></param>
        </member>
        <member name="M:Au.Util.Dpi.ImageSize(System.Drawing.Image)">
            <summary>
            If <see cref="P:Au.Util.Dpi.BaseDPI"/> is more than 96 and image resolution is different, returns scaled (stretched) image.Size.
            Else returns image.Size.
            </summary>
            <param name="image"></param>
        </member>
        <member name="T:Au.Util.WaitableTimer">
            <summary>
            Wraps a waitable timer handle. Allows to create, open, set and wait.
            More info: API <msdn>CreateWaitableTimer</msdn>.
            Note: will need to dispose.
            </summary>
        </member>
        <member name="M:Au.Util.WaitableTimer.Create(System.Boolean,System.String)">
            <summary>
            Calls API <msdn>CreateWaitableTimer</msdn> and creates a WaitableTimer object that wraps the timer handle.
            </summary>
            <param name="manualReset"></param>
            <param name="timerName">Timer name. If a timer with this name already exists, opens it if possible. If null, creates unnamed timer.</param>
            <exception cref="T:Au.Types.AuException">Failed. For example, a non-timer kernel object with this name already exists.</exception>
        </member>
        <member name="M:Au.Util.WaitableTimer.Open(System.String,System.UInt32,System.Boolean,System.Boolean)">
            <summary>
            Calls API <msdn>OpenWaitableTimer</msdn> and creates a WaitableTimer object that wraps the timer handle.
            </summary>
            <param name="timerName">Timer name. Fails if it does not exist; to open-or-create use <see cref="M:Au.Util.WaitableTimer.Create(System.Boolean,System.String)"/>.</param>
            <param name="access">.See <msdn>Synchronization Object Security and Access Rights</msdn>. The default value TIMER_MODIFY_STATE|SYNCHRONIZE allows to set and wait.</param>
            <exception cref="T:Au.Types.AuException">Failed. For example, a non-timer kernel object with this name already exists.</exception>
            <param name="inheritHandle"></param>
            <param name="noException">If fails, return null, don't throw exception. Supports <see cref="M:Au.Types.Native.GetError"/>.</param>
            <exception cref="T:Au.Types.AuException">Failed. For example, the timer does not exist.</exception>
        </member>
        <member name="M:Au.Util.WaitableTimer.Set(System.Int64,System.Int32)">
            <summary>
            Calls API <msdn>SetWaitableTimer</msdn>.
            Returns false if fails. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <param name="dueTime">
            The time after which the state of the timer is to be set to signaled. It is relative time (from now).
            If positive, in milliseconds. If negative, in 100 nanosecond intervals (microseconds*10), see <msdn>FILETIME</msdn>.
            Also can be 0, to set minimal time.</param>
            <param name="period">The period of the timer, in milliseconds. If 0, the timer is signaled once. If greater than 0, the timer is periodic.</param>
            <exception cref="T:System.OverflowException">dueTime*10000 is greater than long.MaxValue.</exception>
        </member>
        <member name="M:Au.Util.WaitableTimer.SetAbsolute(System.DateTime,System.Int32)">
            <summary>
            Calls API <msdn>SetWaitableTimer</msdn>.
            Returns false if fails. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <param name="dueTime">The UTC date/time at which the state of the timer is to be set to signaled.</param>
            <param name="period">The period of the timer, in milliseconds. If 0, the timer is signaled once. If greater than 0, the timer is periodic.</param>
        </member>
        <member name="T:Au.Util.Help">
            <summary>
            Static functions to open a help topic etc.
            </summary>
        </member>
        <member name="M:Au.Util.Help.AuHelp(System.String)">
            <summary>
            Opens file "Au Help.chm" and a help topic in it.
            The file must be in <see cref="P:Au.Folders.ThisApp"/>.
            </summary>
            <param name="topic">Topic file name, like "M_Au_Acc_Find" or "0248143b-a0dd-4fa1-84f9-76831db6714a".</param>
        </member>
        <member name="M:Au.Util.LibWorkarounds.WaitCursorWhenShowingMenuEtc">
            <summary>
            A workaround for:
            	When showing a ContextMenuStrip menu or a submenu, something briefly sets the AppStarting cursor.
            	Only if this process does/did not have active windows.
            	Only if current cursor is arrow. Works well if eg I or hand.
            	Starts before first WM_NCPAINT (after WM_SHOWWINDOW+WM_WINDOWPOSCHANGING) and stops before WM_PAINT.
            Call this before showing a menu. Possibly also will need for some other windows.
            </summary>
        </member>
        <member name="T:Au.Util.LibActCtx">
            <summary>
            Activates our manifest which tells to use comctl32.dll version 6.
            The manifest is embedded in this dll, resource id 2.
            This code is from .NET MessageBox.Show.
            </summary>
        </member>
        <member name="T:Au.NoClass">
            <summary>
            Often-used static functions, to be used like Func instead of Class.Func.
            Mostly aliases of functions of this library.
            In C# source files add <c>using static Au.NoClass;</c>. Then you can use:
            	<c>Print</c> instead of <c>Output.Write</c>;
            	<c>Empty</c> instead of <c>string.IsNullOrEmpty</c>;
            	and more.
            </summary>
        </member>
        <member name="M:Au.NoClass.Print(System.String)">
            <summary>
            Calls <see cref="M:Au.Output.Write(System.String)" qualifyHint="true"/>. It writes string + "\r\n" to the output.
            </summary>
        </member>
        <member name="M:Au.NoClass.Print(System.Object)">
            <summary>
            Writes value of any type to the output.
            </summary>
            <param name="value">Value of any type. Can be null.</param>
            <remarks>
            Calls <see cref="M:System.Object.ToString"/> and <see cref="M:Au.Output.Write(System.String)" qualifyHint="true"/>.
            If the type implements IEnumerable (non-generic), writes list like <see cref="M:Au.NoClass.Print``1(System.Collections.Generic.IEnumerable{``0})"/>.
            This overload is used for value types (int, Point) etc and other types except strings, arrays and generic collections (they have own overloads).
            </remarks>
        </member>
        <member name="M:Au.NoClass.Print``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Writes array, List, Dictionary or other generic collection to the output, as a list of item values separated by "\r\n".
            </summary>
            <param name="value">Array or generic collection of any type. Can be null.</param>
            <remarks>
            Calls <see cref="M:Au.NoClass.PrintListEx``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Int32)"/>, which calls <see cref="M:Au.Output.Write(System.String)" qualifyHint="true"/>.
            </remarks>
        </member>
        <member name="M:Au.NoClass.PrintListEx``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Int32)">
            <summary>
            Writes array, List, Dictionary or other generic collection to the output, as a list of item values.
            </summary>
            <param name="value">Array or generic collection of any type. Can be null.</param>
            <param name="format">
            Item format string.
            
            These special substrings are replaced with:
            {0} - item index, starting from 0.
            {1} - item index, starting from 1.
            {2} - item string value, or empty string if null.
            {3} - item string value, or "null" if null. Strings are escaped (<see cref="M:Au.String_.Escape_(System.String,System.Int32,System.Boolean)"/>) and enclosed in "".
            
            If this parameter is null or omitted, uses "{3}\r\n". It works like <see cref="M:Au.NoClass.Print``1(System.Collections.Generic.IEnumerable{``0})"/>.
            </param>
            <param name="trimEnd">
            How many characters to remove from the end of the result string.
            Default 2 (removes the default "\r\n" separator from the last item).
            </param>
            <remarks>
            Calls <see cref="M:System.Object.ToString"/> and <see cref="M:Au.Output.Write(System.String)" qualifyHint="true"/>.
            </remarks>
        </member>
        <member name="M:Au.NoClass.Print(System.Object,System.Object,System.Object[])">
            <summary>
            Writes multiple arguments of any type to the output, using separator ", ".
            </summary>
            <remarks>
            Calls <see cref="M:System.Object.ToString"/> and <see cref="M:Au.Output.Write(System.String)" qualifyHint="true"/>.
            If a value is null, writes "null".
            If a value is string, escapes it (<see cref="M:Au.String_.Escape_(System.String,System.Int32,System.Boolean)"/>), limits to 250 characters (<see cref="M:Au.String_.Limit_(System.String,System.Int32)"/>) and encloses in "".
            </remarks>
        </member>
        <member name="M:Au.NoClass.PrintHex(System.Object)">
            <summary>
            Writes integer number to the output (<see cref="M:Au.Output.Write(System.String)" qualifyHint="true"/>), in hexadecimal format like "0x5A".
            </summary>
            <param name="value">Value of an integer type (int, uint, long, etc).</param>
        </member>
        <member name="M:Au.NoClass.PrintWarning(System.String,System.Int32,System.String)">
            <summary>
            Writes warning text to the output.
            By default appends the stack trace.
            </summary>
            <param name="text">Warning text.</param>
            <param name="showStackFromThisFrame">If &gt;= 0, appends the stack trace, skipping this number of frames. Default 0.</param>
            <param name="prefix">Text before <paramref name="text"/>. Default "Warning: ".</param>
            <remarks>
            Calls <see cref="M:Au.Output.Write(System.String)" qualifyHint="true"/>.
            If <see cref="P:Au.AuScriptOptions.Debug">Options.Debug</see> is false, does not show more that 1 warning/second.
            To disable some warnings, use <see cref="M:Au.AuScriptOptions.DisableWarnings(System.String[])">Options.DisableWarnings</see>.
            </remarks>
        </member>
        <member name="P:Au.NoClass.Options">
            <summary>
            Gets AuScriptOptions object of this thread.
            Alias of <see cref="P:Au.AuScriptOptions.Options" qualifyHint="true"/>.
            </summary>
        </member>
        <member name="M:Au.NoClass.Empty(System.String)">
            <summary>
            Returns true if the string is null or "".
            The same as string.IsNullOrEmpty.
            </summary>
        </member>
        <member name="M:Au.NoClass.Key(System.Object[])">
            
        </member>
        <member name="M:Au.NoClass.Text(System.String,System.String)">
            
        </member>
        <member name="M:Au.NoClass.Paste(System.String,System.String)">
            
        </member>
        <member name="T:Au.Char_">
            <summary>
            Provides function to get ASCII character type (is digit etc) etc.
            Unlike Char.IsDigit etc, these functions never return true for non-ASCII characters. Also they are faster.
            </summary>
        </member>
        <member name="M:Au.Char_.IsAsciiDigit(System.Char)">
            <summary>
            Returns true if character is '0' to '9'.
            </summary>
        </member>
        <member name="M:Au.Char_.IsAsciiDigit(System.Byte)">
            <summary>
            Returns true if character is '0' to '9'.
            </summary>
        </member>
        <member name="M:Au.Char_.IsAsciiAlpha(System.Char)">
            <summary>
            Returns true if character is 'A' to 'Z' or 'a' to 'z'.
            </summary>
        </member>
        <member name="M:Au.Char_.IsAsciiAlpha(System.Byte)">
            <summary>
            Returns true if character is 'A' to 'Z' or 'a' to 'z'.
            </summary>
        </member>
        <member name="T:Au.Convert_">
            <summary>
            Data conversion functions - hash, compress, hex-encode, Base64, UTF8.
            </summary>
        </member>
        <member name="M:Au.Convert_.HashFnv1(System.String)">
            <summary>
            32-bit FNV-1 hash.
            Useful for fast hash table and checksum use, not cryptography. Similar to CRC32; faster but creates more collisions.
            </summary>
        </member>
        <member name="M:Au.Convert_.HashFnv1(System.Char*,System.Int32)">
            <summary>
            32-bit FNV-1 hash.
            Useful for fast hash table and checksum use, not cryptography. Similar to CRC32; faster but creates more collisions.
            </summary>
        </member>
        <member name="M:Au.Convert_.HashFnv1(System.Byte[])">
            <summary>
            32-bit FNV-1 hash.
            Useful for fast hash table and checksum use, not cryptography. Similar to CRC32; faster but creates more collisions.
            </summary>
        </member>
        <member name="M:Au.Convert_.HashFnv1(System.Byte*,System.Int32)">
            <summary>
            32-bit FNV-1 hash.
            Useful for fast hash table and checksum use, not cryptography. Similar to CRC32; faster but creates more collisions.
            </summary>
        </member>
        <member name="M:Au.Convert_.HashFnv1_64(System.String)">
            <summary>
            64-bit FNV-1 hash.
            </summary>
        </member>
        <member name="M:Au.Convert_.HashFnv1_64(System.Char*,System.Int32)">
            <summary>
            64-bit FNV-1 hash.
            </summary>
        </member>
        <member name="M:Au.Convert_.HashFnv1_64(System.Byte[])">
            <summary>
            64-bit FNV-1 hash.
            </summary>
        </member>
        <member name="M:Au.Convert_.HashFnv1_64(System.Byte*,System.Int32)">
            <summary>
            64-bit FNV-1 hash.
            </summary>
        </member>
        <member name="M:Au.Convert_.HashFast(System.Char*,System.Int32)">
            <summary>
            FNV-1 hash, modified to make faster with long strings (then takes every n-th character).
            </summary>
        </member>
        <member name="M:Au.Convert_.HashFast(System.String)">
            <summary>
            FNV-1 hash, modified to make faster with long strings (then takes every n-th character).
            </summary>
            <param name="s">The string to hash. Can be null.</param>
        </member>
        <member name="M:Au.Convert_.HashFast(System.String,System.Int32,System.Int32)">
            <summary>
            FNV-1 hash, modified to make faster with long strings (then takes every n-th character).
            This overload hashes a substring.
            </summary>
            <param name="s">The string containing the substring. Can be null/"" if other parameters are 0.</param>
            <param name="startIndex">Start of substring in s.</param>
            <param name="count">Length of substring.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.Convert_.HashMD5(System.Byte[])">
            <summary>
            Computes MD5 hash of binary data.
            The same as Hash(..., "MD5") but much faster.
            </summary>
        </member>
        <member name="M:Au.Convert_.HashMD5(System.String)">
            <summary>
            Computes MD5 hash of string.
            The same as Hash(..., "MD5") but much faster.
            </summary>
            <remarks>The hash is of UTF8 bytes, not of UTF16 bytes.</remarks>
        </member>
        <member name="M:Au.Convert_.HashMD5Hex(System.Byte[],System.Boolean)">
            <summary>
            Computes MD5 hash of binary data and converts to hex string.
            The same as Hash(..., "MD5") but much faster.
            </summary>
        </member>
        <member name="M:Au.Convert_.HashMD5Hex(System.String,System.Boolean)">
            <summary>
            Computes MD5 hash of string and converts to hex string.
            The same as Hash(..., "MD5") but much faster.
            </summary>
            <remarks>The hash is of UTF8 bytes, not of UTF16 bytes.</remarks>
        </member>
        <member name="M:Au.Convert_.Hash(System.Byte[],System.String)">
            <summary>
            Computes binary data hash using a specified cryptographic algorithm.
            </summary>
            <param name="a"></param>
            <param name="algorithm">Algorithm name, eg "SHA256". <see cref="T:System.Security.Cryptography.CryptoConfig"/></param>
        </member>
        <member name="M:Au.Convert_.Hash(System.String,System.String)">
            <summary>
            Computes string hash using a specified cryptographic algorithm.
            </summary>
            <param name="s"></param>
            <param name="algorithm">Algorithm name, eg "SHA256". <see cref="T:System.Security.Cryptography.CryptoConfig"/></param>
            <remarks>The hash is of UTF8 bytes, not of UTF16 bytes.</remarks>
        </member>
        <member name="M:Au.Convert_.HashHex(System.Byte[],System.String,System.Boolean)">
            <summary>
            Computes binary data hash using a specified cryptographic algorithm and converts to hex string.
            </summary>
            <param name="a"></param>
            <param name="algorithm">Algorithm name, eg "SHA256". <see cref="T:System.Security.Cryptography.CryptoConfig"/></param>
            <param name="upperCase">Let the hex string contain A-F, not a-f.</param>
        </member>
        <member name="M:Au.Convert_.HashHex(System.String,System.String,System.Boolean)">
            <summary>
            Computes string hash using a specified cryptographic algorithm and converts to hex string.
            </summary>
            <param name="s"></param>
            <param name="algorithm">Algorithm name, eg "SHA256". <see cref="T:System.Security.Cryptography.CryptoConfig"/></param>
            <param name="upperCase">Let the hex string contain A-F, not a-f.</param>
            <remarks>The hash is of UTF8 bytes, not of UTF16 bytes.</remarks>
        </member>
        <member name="M:Au.Convert_.HexEncode(System.Byte[],System.Boolean)">
            <summary>
            Converts binary data stored in byte[] to hex-encoded string.
            </summary>
            <param name="a">The data. Can be null, then returns null.</param>
            <param name="upperCase">Let the hex string contain A-F, not a-f.</param>
            <remarks>
            The result string length is 2 * array length.
            In most cases it's better to use <see cref="M:System.Convert.ToBase64String(System.Byte[])"/>, then result is 4/3 of array length. Both functions are fast.
            </remarks>
        </member>
        <member name="M:Au.Convert_.HexEncode(System.Void*,System.Int32,System.Boolean)">
            <summary>
            Converts binary data stored in any memory to hex-encoded string.
            </summary>
            <param name="data">The data. Can be any valid memory of specified size, for example a struct address. Can be null, then returns null.</param>
            <param name="size">data memory size (bytes).</param>
            <param name="upperCase">Let the hex string contain A-F, not a-f.</param>
        </member>
        <member name="M:Au.Convert_.HexDecode(System.String)">
            <summary>
            Converts hex-encoded string to binary data. Stores it in byte[].
            </summary>
            <param name="s">Hex-encoded string. Can be null, then returns null.</param>
            <remarks>
            Skips spaces and other non-hex-digit characters. Example: "01 23 46 67" is the same as "01234667".
            The number of hex-digit characters should be divisible by 2, else the last character is ignored.
            </remarks>
            <seealso cref="M:Au.Convert_.Base64Decode(System.String)"/>
        </member>
        <member name="M:Au.Convert_.HexDecode(System.String,System.Void*,System.Int32,System.Int32)">
            <summary>
            Converts hex-encoded string to binary data. Stores it in caller's memory buffer.
            Returns the number of bytes stored in resultBuffer memory. It is equal or less than Math.Min(bufferSize, (s.Length - stringStartIndex) / 2).
            </summary>
            <param name="s">Hex-encoded string. Can be null.</param>
            <param name="resultBuffer">Where to write the data. Can be any valid memory of specified size, for example a struct address.</param>
            <param name="bufferSize">resultBuffer memory size. Note: this function will damage process memory if using bad resultBuffer or bufferSize.</param>
            <param name="stringStartIndex">0 or index of first character of hex-encoded substring in s.</param>
            <remarks>
            Skips spaces and other non-hex-digit characters. Example: "01 23 46 67" is the same as "01234667".
            The number of hex-digit characters should be divisible by 2, else the last character is ignored.
            </remarks>
        </member>
        <member name="M:Au.Convert_.HexDecode(System.Char*,System.Int32,System.Void*,System.Int32)">
            <summary>
            The same as <see cref="M:Au.Convert_.HexDecode(System.String,System.Void*,System.Int32,System.Int32)"/> but the string can be an unmanaged UTF-16 string.
            </summary>
            <param name="s">UTF-16 string.</param>
            <param name="length">s length (characters).</param>
            <param name="resultBuffer"></param>
            <param name="bufferSize"></param>
        </member>
        <member name="M:Au.Convert_.Base64Decode(System.Byte*,System.Int32,System.Void*,System.Int32)">
            <summary>
            Converts Base64 ANSI string to binary data (bytes). Stores it in caller's memory buffer.
            Returns the number of bytes stored in resultBuffer.
            </summary>
            <param name="s">Base64 string. Can be null if len is 0.</param>
            <param name="len">s length (bytes).</param>
            <param name="resultBuffer">A memory buffer for the result bytes. Must be of at least bufferSize size, else this function will damage process memory.</param>
            <param name="bufferSize">resultBuffer buffer length (bytes). Must be at least (int)(len * 3L / 4), else exception.</param>
            <remarks>
            Allows (discards) non-base64 characters.
            Supports URL-safe characters: '-' for '+' and '_' for '/'.
            </remarks>
            <exception cref="T:System.ArgumentException">bufferSize too small.</exception>
        </member>
        <member name="M:Au.Convert_.Base64Decode(System.Char*,System.Int32,System.Void*,System.Int32)">
            <summary>
            Converts Base64 UTF-16 string to binary data (bytes). Stores it in caller's memory buffer.
            Returns the number of bytes stored in resultBuffer.
            </summary>
            <param name="s">Base64 string. Can be null if len is 0.</param>
            <param name="len">s length (characters).</param>
            <param name="resultBuffer">A memory buffer for the result bytes. Must be of at least bufferSize size, else this function will damage process memory.</param>
            <param name="bufferSize">resultBuffer buffer size (bytes). Must be at least (int)(len * 3L / 4), else exception.</param>
            <remarks>
            How it is different than Convert.FromBase64String:
            1. Allows (discards) non-base64 characters.
            2. Supports URL-safe characters: '-' for '+' and '_' for '/'.
            3. No exception when string length is not multiple of 4, eg if does not contain '=' characters for padding. 
            4. Faster.
            </remarks>
            <exception cref="T:System.ArgumentException">bufferSize too small.</exception>
        </member>
        <member name="M:Au.Convert_.Base64Decode(System.String,System.Void*,System.Int32,System.Int32)">
            <summary>
            Converts Base64 UTF-16 string to binary data (bytes). Stores it in caller's memory buffer.
            Returns the number of bytes stored in resultBuffer.
            The same as <see cref="M:Au.Convert_.Base64Decode(System.Char*,System.Int32,System.Void*,System.Int32)"/>, just different input string type.
            </summary>
            <param name="s">Base64 string. Can be null, then returns null.</param>
            <param name="resultBuffer">A memory buffer for the result bytes. Must be of at least bufferSize size, else this function will damage process memory.</param>
            <param name="bufferSize">resultBuffer buffer size (bytes). Must be at least (int)(len * 3L / 4), else exception.</param>
            <param name="stringStartIndex">0 or index of first character of Base64 substring in s.</param>
        </member>
        <member name="M:Au.Convert_.Base64Decode(System.String)">
            <summary>
            Converts Base64 string to binary data (bytes).
            Returns byte[] containing the data.
            </summary>
            <param name="s">Base64 string. Can be null, then returns null.</param>
            <remarks>
            How it is different than Convert.FromBase64String:
            1. Allows (discards) non-base64 characters.
            2. Supports URL-safe characters: '-' for '+' and '_' for '/'.
            3. No exception when string length is not multiple of 4, eg if does not contain '=' characters for padding. 
            4. Faster.
            
            This library does not have Base64-encode functions. Use <see cref="M:System.Convert.ToBase64String(System.Byte[])"/>.
            See also <see cref="M:System.Convert.FromBase64String(System.String)"/>. It does the same, but does not support some parameter types (char*, ANSI string, byte* buffer) that are used internally in this libray and related software, that is why these library functions were created.
            </remarks>
        </member>
        <member name="M:Au.Convert_.Compress(System.Byte[])">
            <summary>
            Compresses data using <see cref="T:System.IO.Compression.DeflateStream"/>.
            </summary>
            <param name="data"></param>
            <exception cref="T:System.Exception">Exceptions of DeflateStream.</exception>
        </member>
        <member name="M:Au.Convert_.Decompress(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decompresses data using <see cref="T:System.IO.Compression.DeflateStream"/>.
            Returns byte[] containing decompressed data.
            </summary>
            <param name="compressedData">Compressed data.</param>
            <param name="index">Start index of compressed data in the compressedData array.</param>
            <param name="count">Length of compressed data in the compressedData array.</param>
            <exception cref="T:System.Exception">Exceptions of DeflateStream.</exception>
        </member>
        <member name="M:Au.Convert_.Decompress(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decompresses data using <see cref="T:System.IO.Compression.DeflateStream"/>.
            Writes the decompressed data to a caller-provided memory stream.
            </summary>
            <param name="streamForDecompressedData">A memory stream where this function will write decompressed data. See example.</param>
            <param name="compressedData">Compressed data.</param>
            <param name="index">Start index of compressed data in the compressedData array.</param>
            <param name="count">Length of compressed data in the compressedData array.</param>
            <exception cref="T:System.Exception">Exceptions of DeflateStream.</exception>
            <example>
            This code is used by the other Decompress overload.
            <code><![CDATA[
            using(var stream = new MemoryStream()) {
            	Decompress(stream, compressedData, index, count);
            	return stream.ToArray();
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Convert_.Utf8LengthFromString(System.String)">
            <summary>
            Returns the number of bytes that would by produced by converting C# string to UTF8, not including the terminating '\0' character.
            </summary>
            <param name="s">C# string (UTF16). Can be null.</param>
        </member>
        <member name="M:Au.Convert_.Utf8FromString(System.String,System.Byte*,System.Int32)">
            <summary>
            Converts C# string to '\0'-terminated UTF8 string. Stores the UTF8 string in caller's buffer.
            Returns UTF8 string length in bytes, not including the terminating '\0' character.
            If fails (unlikely if passed correct arguments), returns 0 and sets buffer="".
            </summary>
            <param name="s">C# string (UTF16). Can be null.</param>
            <param name="buffer">Caller-allocated memory of bufLen length.</param>
            <param name="bufLen">buffer length in bytes. Should be at least <see cref="M:Au.Convert_.Utf8LengthFromString(System.String)"/>+1, else converts only part of string. The maximal possible required buffer length for whole string can be s.Length*3+1.</param>
            <remarks>
            Calls API <msdn>WideCharToMultiByte</msdn>.
            This is the most low-level and therefore fastest overload. Does not allocate any memory. With big strings much faster than .NET Encoding class functions.
            Use buffer/bufLen carefully. If bufLen is greater that the memory buffer length, other memory will be overwritten/damaged.
            </remarks>
        </member>
        <member name="M:Au.Convert_.Utf8FromString(System.String)">
            <summary>
            Converts C# string to '\0'-terminated UTF8 string.
            </summary>
            <param name="s">C# string (UTF16). If null, returns null.</param>
            <remarks>
            How this is different from .NET Encoding class functions: 1. Uses <msdn>WideCharToMultiByte</msdn>. 2. Faster with big strings. 3. The returned string is '\0'-terminated. 4. No exceptions (unless the string is so large that fails to allocate so much memory).
            </remarks>
        </member>
        <member name="M:Au.Convert_.LibUtf8FromString(System.String,System.WeakReference{System.Byte[]}@,System.Int32*,System.Int32)">
            <summary>
            Converts C# string to '\0'-terminated UTF8 string managed by a WeakReference variable.
            </summary>
            <param name="s">C# string (UTF16). If null, returns null, unless allocExtraBytes is not 0.</param>
            <param name="buffer">A WeakReference variable (probably [ThreadStatic]) that manages the returned array. If null, this function will create it.</param>
            <param name="utf8Length">If not null, receives UTF8 text length, not including '\0' and allocExtraBytes.</param>
            <param name="allocExtraBytes">Allocate this number of extra bytes after the string.</param>
        </member>
        <member name="M:Au.Convert_.Utf8ToStringLength(System.Byte*,System.Int32)">
            <summary>
            Returns the number of characters that would by produced by converting UTF8 to C# string.
            The terminating '\0' character is not included in the return value.
            </summary>
            <param name="utf8">UTF8 string. Can be null.</param>
            <param name="lengthBytes">Length of utf8 or part of it. If negative, the function finds utf8 length; then utf8 must be '\0'-terminated.</param>
            <remarks>
            Uses API <msdn>MultiByteToWideChar</msdn>.
            There is no overload that takes byte[], because for it can be used .NET Encoding class functions.
            </remarks>
        </member>
        <member name="M:Au.Convert_.Utf8ToString(System.Byte*,System.Int32)">
            <summary>
            Converts UTF8 string to C# string (which is UTF16).
            The terminating '\0' character is not included in the returned string.
            </summary>
            <param name="utf8">UTF8 string. If null, returns null.</param>
            <param name="lengthBytes">Length of utf8 or part of it. If negative, the function finds utf8 length; then utf8 must be '\0'-terminated.</param>
            <remarks>
            Uses API <msdn>MultiByteToWideChar</msdn>.
            There is no overload that takes byte[], because for it can be used .NET Encoding class functions. The speed is similar; this is slower with short strings but faster with long strings.
            </remarks>
        </member>
        <member name="T:Au.Debug_">
            <summary>
            Functions useful to debug code.
            </summary>
            <remarks>
            The Debug_.PrintX functions write to the same output as <see cref="M:Au.Output.Write(System.String)"/>, not to the trace listeners like <see cref="M:System.Diagnostics.Debug.Print(System.String)"/> etc do. Also they add caller's name, file and line number.
            Functions Print, PrintIf, PrintFunc and Dialog work only if DEBUG is defined, which normally is when the caller project is in Debug configuration. Else they are not called, and arguments not evaluated at run time. This is because they have [<see cref="T:System.Diagnostics.ConditionalAttribute"/>("DEBUG")].
            Note: when used in a library, the above functions depend on DEBUG of the library project and not on DEBUG of the consumer project of the library. For example, the library may be in Release configuration even if its consumer project is in Debug configuration. If your library wants to show some info only if its consumer project is in Debug config, instead you can use code like <c>if(Options.Debug) PrintWarning("text");</c>; see <see cref="M:Au.NoClass.PrintWarning(System.String,System.Int32,System.String)"/>, <see cref="P:Au.AuScriptOptions.Debug"/>.
            </remarks>
        </member>
        <member name="P:Au.Debug_.TextPrefix">
            <summary>
            Prefix for Debug_.Print, Debug_.PrintIf, Debug_.PrintHex.
            Default is "Debug: ".
            </summary>
            <example>
            Blue text.
            <code><![CDATA[
            Debug_.TextPrefix = "<><c 0xff0000>"; Debug_.TextSuffix = "</c>";
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Debug_.TextSuffix">
            <summary>
            Suffix for Debug_.Print, Debug_.PrintIf, Debug_.PrintHex.
            </summary>
            <seealso cref="P:Au.Debug_.TextPrefix"/>
        </member>
        <member name="M:Au.Debug_.Print(System.Object,System.String,System.Int32,System.String)">
            <summary>
            Calls <see cref="M:Au.Output.Write(System.String)"/> to show some debug info. Also shows current function name/file/line.
            Works only if DEBUG is defined. Read more in class help.
            The 3 optional parameters are not used explicitly.
            </summary>
        </member>
        <member name="M:Au.Debug_.PrintIf(System.Boolean,System.Object,System.String,System.Int32,System.String)">
            <summary>
            If condition is true, calls <see cref="M:Au.Output.Write(System.String)"/> to show some debug info. Also shows current function name/file/line.
            Works only if DEBUG is defined. Read more in class help.
            The 3 optional parameters are not used explicitly.
            </summary>
        </member>
        <member name="M:Au.Debug_.PrintHex(System.Object,System.String,System.Int32,System.String)">
            <summary>
            Calls <see cref="M:Au.Output.Write(System.String)"/> to show some integer value in hex format. Also shows current function name/file/line.
            Works only if DEBUG is defined. Read more in class help.
            The 3 optional parameters are not used explicitly.
            </summary>
        </member>
        <member name="M:Au.Debug_.PrintFunc(System.String)">
            <summary>
            Calls <see cref="M:Au.Output.Write(System.String)"/> with current function name.
            Works only if DEBUG is defined. Read more in class help.
            The optional parameter is not used explicitly.
            </summary>
        </member>
        <member name="M:Au.Debug_.Dialog(System.Object,System.String,System.Int32,System.String)">
            <summary>
            Calls <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String)"/> to show some debug info.
            Works only if DEBUG is defined. Read more in class help.
            The 3 optional parameters are not used explicitly.
            </summary>
        </member>
        <member name="M:Au.Debug_.LibCheckFlagsOpt``1(``0,``0)">
            <summary>
            Checks flags and throws ArgumentException if some flags are invalid. The message includes valid flag names.
            Can be used in functions that have an enum flags parameter but not all passed flags are valid for that function or object state.
            Does nothing if <see cref="P:Au.AuScriptOptions.Debug">Options.Debug</see> is false.
            </summary>
            <param name="flags">Flags to check.</param>
            <param name="goodFlags">Valid flags.</param>
            <typeparam name="T">The enum type used for flags.</typeparam>
            <remarks>
            When flags are valid, this function is very fast (inline, no calls).
            </remarks>
        </member>
        <member name="P:Au.Debug_.IsAuDebugConfiguration">
            <summary>
            Returns true if using Debug configuration of Au.dll.
            </summary>
        </member>
        <member name="F:Au.Debug_.s_mem0">
            <summary>
            Prints managed memory size. Uses GC.GetTotalMemory.
            Works in Release too.
            </summary>
        </member>
        <member name="T:Au.Output">
            <summary>
            Writes text to the output window, console or log file.
            </summary>
        </member>
        <member name="P:Au.Output.IsConsoleProcess">
            <summary>
            Returns true if this is a console process.
            </summary>
        </member>
        <member name="P:Au.Output.IsWritingToConsole">
            <summary>
            Returns true if is writing to console, false if to the output window or log file. Assuming that <see cref="P:Au.Output.Writer"/> is not changed.
            Does not write to console in these cases: <see cref="P:Au.Output.IsConsoleProcess"/> is false. <see cref="P:Au.Output.IgnoreConsole"/> is true. <see cref="P:Au.Output.LogFile"/> is not null. The startup info of this process tells to not show console window and to not redirect the standard output.
            </summary>
        </member>
        <member name="P:Au.Output.IgnoreConsole">
            <summary>
            If true, Write and related functions in console process don't not use the console window. Then everything is like in non-console process.
            </summary>
            <seealso cref="P:Au.Output.RedirectConsoleOutput"/>
            <seealso cref="P:Au.Output.RedirectDebugOutput"/>
        </member>
        <member name="M:Au.Output.Clear">
            <summary>
            Clears the output window or console text (if <see cref="P:Au.Output.IsWritingToConsole"/>) or log file (if <see cref="P:Au.Output.LogFile"/> not null).
            </summary>
        </member>
        <member name="M:Au.Output.Write(System.String)">
            <summary>
            Writes string + "\r\n" to the output window or console (if <see cref="P:Au.Output.IsWritingToConsole"/>) or log file (if <see cref="P:Au.Output.LogFile"/> not null).
            </summary>
            <seealso cref="M:Au.NoClass.Print(System.String)"/>
            <seealso cref="M:Au.NoClass.Print(System.Object)"/>
            <seealso cref="M:Au.NoClass.Print``1(System.Collections.Generic.IEnumerable{``0})"/>
            <seealso cref="M:Au.NoClass.Print(System.Object,System.Object,System.Object[])"/>
            <seealso cref="M:Au.NoClass.PrintListEx``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Int32)"/>
            <seealso cref="M:Au.NoClass.PrintHex(System.Object)"/>
        </member>
        <member name="P:Au.Output.Writer">
            <summary>
            Gets or sets object that actually writes text when is called Output.Write, Print and similar functions.
            </summary>
            <remarks>
            If you want to redirect, modify or just monitor output text, use code like in the example. It is known as "output redirection".
            Redirection is applied to whole appdomain, and does not affect other appdomains.
            Redirection affects Output.Write, Print and similar functions, also Output.RedirectConsoleOutput and Output.RedirectDebugOutput. It does not affect Output.WriteDirectly and Output.Clear.
            Don't call Output.Write, Print etc in method WriteLine(string) of your writer class. It would call itself and create stack overflow. But you can call Output.WriteDirectly.
            </remarks>
            <example>
            <code><![CDATA[
            [STAThread]
            static void Main()
            {
            	Output.Writer = new TestOutputWriter();
            
            	Print("test");
            }
            
            class TestOutputWriter :TextWriter
            {
            	public override void WriteLine(string value) { Output.WriteDirectly("redir: " + value); }
            	public override Encoding Encoding => Encoding.Unicode;
            }
            ]]></code>
            </example>
        </member>
        <member name="T:Au.Output._OutputWriter">
            <summary>
            Our default writer class for the Writer property.
            </summary>
        </member>
        <member name="M:Au.Output.WriteDirectly(System.String)">
            <summary>
            Writes string value + "\r\n" to the output window or console (if <see cref="P:Au.Output.IsWritingToConsole"/>) or log file (if <see cref="P:Au.Output.LogFile"/> not null).
            Unlike Output.Write, Print etc, the string is not passed to <see cref="P:Au.Output.Writer"/>.
            </summary>
        </member>
        <member name="P:Au.Output.RedirectConsoleOutput">
            <summary>
            Let Console.WriteX methods in non-console process write to the same destination as Output.Write etc.
            </summary>
            <remarks>
            Console.Write will write line, like Console.WriteLine.
            Console.Clear will not clear output; it will throw exception.
            </remarks>
        </member>
        <member name="P:Au.Output.RedirectDebugOutput">
            <summary>
            Let Debug.WriteX and Trace.WriteX methods write to the same destination as Output.Write etc.
            </summary>
            <remarks>
            Tip: To write to the output window even in console process, set <c>Output.IgnoreConsole=true;</c> before calling this method first time.
            </remarks>
        </member>
        <member name="P:Au.Output.LogFile">
            <summary>
            Sets log file path.
            When set (not null), text passed to Output.Write, Print and similar functions will be written to the file. Assuming that <see cref="P:Au.Output.Writer"/> is not changed.
            If value is null - restores default behavior.
            </summary>
            <remarks>
            The first Write etc call (in this appdomain) creates or opens the file and deletes old content if the file already exists.
            Multiple appdomains cannot use the same file. If the file is open for writing, Write makes unique filename and changes LogFile value.
            
            Also supports mailslots. For LogFile use mailslot name, as documented in <msdn>CreateMailslot</msdn>. Multiple appdomains and processes can use the same mailslot.
            </remarks>
            <exception cref="T:System.ArgumentException">The 'set' function throws this exception if the value is not full path and not null.</exception>
        </member>
        <member name="P:Au.Output.LogFileTimestamp">
            <summary>
            Let Write etc also add current time when using log file (see <see cref="P:Au.Output.LogFile"/>).
            The time is local, not UTC.
            </summary>
        </member>
        <member name="P:Au.Output.LibWriteToQM2">
            <summary>
            Sets to use QM2 as the output server.
            Eg can be used to debug the Output class itself. Although can instead use console.
            </summary>
        </member>
        <member name="M:Au.Output._WriteToQM2(System.String)">
            <param name="s">If null, clears output.</param>
        </member>
        <member name="M:Au.Output._CreateFile(System.String,System.Boolean)">
            <summary>
            Calls Api.CreateFile to open file or mailslot.
            </summary>
            <param name="name">File path or mailslot name.</param>
            <param name="openExisting">Use OPEN_EXISTING. If false, uses CREATE_ALWAYS.</param>
        </member>
        <member name="M:Au.Output._LogFile.Open">
            <summary>
            Opens LogFile file handle for writing.
            Uses CREATE_ALWAYS, GENERIC_WRITE, FILE_SHARE_READ.
            </summary>
            <remarks>
            Multiple appdomains cannot use the same file. Each appdomain overwrites it when opens first time.
            </remarks>
        </member>
        <member name="M:Au.Output._LogFile.WriteLine(System.String)">
            <summary>
            Writes s + "\r\n" and optionally timestamp.
            </summary>
            <remarks>
            If fails to write to file: Sets LogFile=null, which closes file handle. Writes a warning and s to the output window or console.
            </remarks>
        </member>
        <member name="M:Au.Output._LogFile.Clear">
            <summary>
            Sets file size = 0.
            </summary>
        </member>
        <member name="M:Au.Output._LogFile.Close">
            <summary>
            Closes file handle.
            </summary>
        </member>
        <member name="T:Au.Output.Server">
            <summary>
            Receives messages sent from clients when they call Output.Write and related methods.
            If server is global, clients can be multiple appdomains and processes, including this. Else only this appdomain.
            </summary>
            <remarks>
            Works asynchronously, to make writing messages faster.
            When a client writes a message, the message arrives to the server with some delay and is placed in the <see cref="P:Au.Output.Server.Messages"/> queue.
            You then can get/remove messages (call Messages.TryDequeue) and display them in a window (for example).
            You can be notified about new messages.
            
            Recommended setup (see example):
            1. When your application starts, create an Output.Server instance and assign to a static variable. Call Start.
            2. When your application creates its output window, call <see cref="M:Au.Output.Server.SetNotifications(System.Action,System.Windows.Forms.Control)"/> to register callback function.
            3. In the callback function get/remove/display all new messages.
            4. Call Stop when closing the window. Optional but recommended.
            </remarks>
            <example>
            Simple program with output window.
            <code><![CDATA[
            class OutputFormExample :Form
            {
            	TextBox _tb;
            
            	public OutputFormExample()
            	{
            		_tb = new TextBox();
            		_tb.ReadOnly = true;
            		_tb.Multiline = true;
            		_tb.ScrollBars = ScrollBars.Both;
            		_tb.WordWrap = false;
            		_tb.Dock = DockStyle.Fill;
            		_tb.TabStop = false;
            		this.Controls.Add(_tb);
            
            		_os.SetNotifications(_ProcessMessages, this);
            	}
            
            	void _ProcessMessages()
            	{
            		while(_os.Messages.TryDequeue(out var m)) {
            			switch(m.Type) {
            			case Output.Server.MessageType.Clear:
            				_tb.Clear();
            				break;
            			case Output.Server.MessageType.Write:
            				//_tb.AppendText(m.Text);
            				_tb.AppendText($"{DateTime.FromFileTimeUtc(m.TimeUtc).ToLocalTime()}  {m.Domain}  {m.Text}");
            				break;
            			}
            		}
            	}
            
            	static Output.Server _os = new Output.Server(false);
            
            	[STAThread]
            	public static void Main()
            	{
            		_os.Start();
            
            		//test Print and Clear, before and after creating window
            		Output.IgnoreConsole = true;
            		Print("test before setting notifications");
            		Task.Run(() => { 1.s(); Print("test after"); 1.s(); Output.Clear(); 1.s(); Print("test after Clear"); });
            
            		var f = new OutputFormExample();
            		f.ShowDialog();
            		_os.Stop();
            	}
            }
            ]]></code>
            </example>
        </member>
        <member name="T:Au.Output.Server.MessageType">
            <summary>
            See <see cref="P:Au.Output.Server.Message.Type"/>.
            </summary>
            <tocexclude />
        </member>
        <member name="F:Au.Output.Server.MessageType.Write">
            <summary>
            Add line to the output window.
            All Message members can be used.
            </summary>
        </member>
        <member name="F:Au.Output.Server.MessageType.Clear">
            <summary>
            Clear the output window.
            Other Message members are not used.
            </summary>
        </member>
        <member name="T:Au.Output.Server.Message">
            <summary>
            Contains message text and/or related info.
            See <see cref="P:Au.Output.Server.Messages"/>.
            </summary>
            <tocexclude />
        </member>
        <member name="P:Au.Output.Server.Message.Type">
            <summary>
            Message type.
            Currently there are 2 types - Write and Clear.
            </summary>
        </member>
        <member name="P:Au.Output.Server.Message.Text">
            <summary>
            Message text.
            Used with MessageType.Write.
            </summary>
        </member>
        <member name="P:Au.Output.Server.Message.TimeUtc">
            <summary>
            Message time in FILETIME format, UTC.
            Used with MessageType.Write.
            To convert to string: <c>DateTime.FromFileTimeUtc(m.TimeUtc).ToLocalTime().ToString()</c>.
            </summary>
        </member>
        <member name="P:Au.Output.Server.Message.Domain">
            <summary>
            The name of the appdomain that called the Write/Print/etc method.
            Used with MessageType.Write.
            </summary>
        </member>
        <member name="P:Au.Output.Server.Messages">
            <summary>
            Contains all received and still not removed messages that were sent by clients when they call Output.Write etc.
            Call TryDequeue to get/remove them.
            </summary>
        </member>
        <member name="M:Au.Output.Server.#ctor(System.Boolean)">
            <param name="isGlobal">Serve all appdomains and processes that don't have local server.</param>
        </member>
        <member name="M:Au.Output.Server.Start">
            <summary>
            Starts server.
            Returns false if server already exists (if global - in any process).
            </summary>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
        </member>
        <member name="M:Au.Output.Server.Stop">
            <summary>
            Stops server.
            </summary>
        </member>
        <member name="M:Au.Output.Server.Finalize">
            <summary>
            Calls Stop.
            </summary>
        </member>
        <member name="M:Au.Output.Server.SetNotifications(System.Action,System.Windows.Forms.Control)">
            <summary>
            Sets callback function, to be notified about server events.
            </summary>
            <param name="cbFunc">
            Callback function's delegate. Called when one or more messages are available.
            It should get/remove messages from <see cref="P:Au.Output.Server.Messages"/> queue (call TryDequeue).
            See example in class help.
            </param>
            <param name="c">A control or form. The callback function will be called in its thread (<see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)"/>). If null, the callback function will be called in other thread.</param>
        </member>
        <member name="M:Au.Output.Server.LocalWrite(System.String,System.Int64,System.String)">
            <summary>
            Adds s directly to Messages and sets timer.
            If s is null, it is 'Clear' command.
            Else if !NoNewline, appends "\r\n".
            Used with local server only.
            </summary>
        </member>
        <member name="P:Au.Output.Server.NoNewline">
            <summary>
            Let messages don't end with "\r\n".
            </summary>
            <remarks>
            This can be used for performance, to avoid string copying when using local server. Does not affect performance of global server.
            </remarks>
        </member>
        <member name="P:Au.Output.Server.LibMailslotName">
            <summary>
            Gets mailslot name like @"\\.\mailslot\Au.Output\" + sessionId.
            </summary>
        </member>
        <member name="P:Au.Output.Server.LibTimerName">
            <summary>
            Gets waitable timer name like "timer.Au.Output".
            </summary>
        </member>
        <member name="T:Au.Output.Server.LibSharedMemoryData">
            <summary>
            Shared memory variables. Used with global server only.
            </summary>
        </member>
        <member name="T:Au.Process_">
            <summary>
            Extends the .NET class Process.
            Also has some thread functions.
            </summary>
        </member>
        <member name="M:Au.Process_.GetProcessName(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Gets process executable file name without ".exe", or full path.
            Returns null if fails.
            </summary>
            <param name="processId">Process id. If you have a window, use its <see cref="P:Au.Wnd.ProcessId">ProcessId</see> property.</param>
            <param name="fullPath">Get full path. Note: Fails to get full path if the process belongs to another user session, unless current process is admin; also fails to get full path of some system processes.</param>
            <param name="noSlowAPI">When the fast API QueryFullProcessImageName fails, don't try to use another much slower API WTSEnumerateProcesses. Not used if fullPath is true.</param>
        </member>
        <member name="P:Au.Process_.ProcessInfoInternal.ProcessName">
            <summary>
            Process executable file name without ".exe". Not full path.
            If contains '~', tries to unexpand DOS path.
            Don't call multiple times, because always converts from raw char*.
            </summary>
        </member>
        <member name="T:Au.Process_.ProcessInfo">
            <summary>
            Contains process id, name and session id.
            </summary>
            <tocexclude />
        </member>
        <member name="F:Au.Process_.ProcessInfo.SessionId">
            <summary>User session id.</summary>
        </member>
        <member name="F:Au.Process_.ProcessInfo.ProcessId">
            <summary>Process id.</summary>
        </member>
        <member name="F:Au.Process_.ProcessInfo.ProcessName">
            <summary>Process executable file name without ".exe". Not full path.</summary>
        </member>
        <member name="M:Au.Process_.ProcessInfo.#ctor(System.Int32,System.Int32,System.String)">
            
        </member>
        <member name="M:Au.Process_.ProcessInfo.ToString">
            
        </member>
        <member name="M:Au.Process_.GetProcesses(System.Boolean)">
            <summary>
            Gets processes array that contains process name, id and session id.
            </summary>
            <param name="ofThisSession">Get processes only of this user session (skip services etc).</param>
            <exception cref="T:Au.Types.AuException">Failed. Unlikely.</exception>
        </member>
        <member name="M:Au.Process_.GetProcessesByName(System.String,System.Boolean,System.Boolean)">
            <summary>
            Gets array of process id of all processes whose names match processName.
            Returns empty array if there are no matching processes.
            </summary>
            <param name="processName">
            Process name.
            String format: <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">wildcard expression</conceptualLink>.
            </param>
            <param name="fullPath">If false, processName is filename without ".exe". If true, processName is full path. Note: Fails to get full path if the process belongs to another user session, unless current process is admin; also fails to get full path of some system processes.</param>
            <param name="ofThisSession">Get processes only of this user session (skip services etc).</param>
            <exception cref="T:System.ArgumentException">
            processName is "" or null.
            Invalid wildcard expression ("**options " or regular expression).
            </exception>
        </member>
        <member name="T:Au.Process_.LibProcessHandle">
            <summary>
            Opens and manages a process handle.
            Must be disposed.
            </summary>
        </member>
        <member name="P:Au.Process_.LibProcessHandle.Handle">
            
        </member>
        <member name="P:Au.Process_.LibProcessHandle.Is0">
            
        </member>
        <member name="M:Au.Process_.LibProcessHandle.Dispose">
            
        </member>
        <member name="M:Au.Process_.LibProcessHandle.#ctor(System.IntPtr)">
            <summary>
            Attaches a kernel handle to this new variable.
            No exception when handle is invalid.
            </summary>
            <param name="handle"></param>
        </member>
        <member name="M:Au.Process_.LibProcessHandle.FromId(System.Int32,System.UInt32)">
            <summary>
            Opens process handle.
            Calls API OpenProcess.
            Returns null if fails. Supports Native.GetError().
            </summary>
            <param name="processId">Process id.</param>
            <param name="desiredAccess">Desired access (Api.PROCESS_), as documented in MSDN -> OpenProcess.</param>
        </member>
        <member name="M:Au.Process_.LibProcessHandle.FromWnd(Au.Wnd,System.UInt32)">
            <summary>
            Opens window's process handle.
            This overload is more powerful: if API OpenProcess fails, it tries GetProcessHandleFromHwnd, which can open higher integrity level processes, but only if current process is uiAccess and desiredAccess includes only PROCESS_DUP_HANDLE, PROCESS_VM_OPERATION, PROCESS_VM_READ, PROCESS_VM_WRITE, SYNCHRONIZE.
            Returns null if fails. Supports Native.GetError().
            </summary>
            <param name="w"></param>
            <param name="desiredAccess">Desired access (Api.PROCESS_), as documented in MSDN -> OpenProcess.</param>
        </member>
        <member name="T:Au.Process_.LibProcessWaitHandle">
            <summary>
            Process handle that is derived from WaitHandle.
            When don't need to wait, use LibProcessHandle, it's more lightweight and has more creation methods.
            </summary>
        </member>
        <member name="T:Au.Process_.Memory">
            <summary>
            Allocates, writes and reads memory in other process.
            </summary>
            <remarks>
            Objects of this class must be disposed. Example: <c>using(var pm=new Process_.Memory(...)) { ... }</c>.
            </remarks>
        </member>
        <member name="M:Au.Process_.Memory.Finalize">
            
        </member>
        <member name="M:Au.Process_.Memory.Dispose">
            
        </member>
        <member name="P:Au.Process_.Memory.ProcessHandle">
            <summary>
            Process handle.
            Opened with access PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE.
            </summary>
        </member>
        <member name="P:Au.Process_.Memory.Mem">
            <summary>
            Address of memory allocated in that process.
            </summary>
            <remarks>
            The address is invalid in this process.
            </remarks>
        </member>
        <member name="M:Au.Process_.Memory.SetMem(System.IntPtr,System.Boolean)">
            <summary>
            Sets an address of memory in that process that is to be used by the read and write functions.
            </summary>
            <param name="mem">A memory address in that process.</param>
            <param name="freeWhenDisposing">
            Let the Dispose method (or finalizer) call API <msdn>VirtualFreeEx</msdn> to free mem. The memory must be allocated with API <msdn>VirtualAllocEx</msdn> (by any process) or <msdn>VirtualAlloc</msdn> (by that process).
            If false, mem can be any memory in that process, and this variable will not free it. Alternatively you can use <see cref="M:Au.Process_.Memory.ReadOther(System.IntPtr,System.Void*,System.Int32)"/> and <see cref="M:Au.Process_.Memory.WriteOther(System.IntPtr,System.Void*,System.Int32)"/>.</param>
            <exception cref="T:System.InvalidOperationException">This variable already has Mem, unless it was set by this function with <paramref name="freeWhenDisposing"/> = false.</exception>
            <remarks>
            This function can be used if this variable was created with <i>nBytes</i> = 0. Else exception. Also exception if this function previously called with <paramref name="freeWhenDisposing"/> = true.
            </remarks>
        </member>
        <member name="M:Au.Process_.Memory.#ctor(Au.Wnd,System.Int32)">
            <summary>
            Opens window's process handle and optionally allocates memory in that process.
            </summary>
            <param name="w">A window in that process.</param>
            <param name="nBytes">If not 0, allocates this number of bytes of memory in that process.</param>
            <remarks>This is the preferred constructor when the process has windows. It works with windows of UAC High integrity level when this process is Medium+uiAccess.</remarks>
            <exception cref="T:Au.Types.WndException">w invalid.</exception>
            <exception cref="T:Au.Types.AuException">Failed to open process handle (usually because of UAC) or allocate memory.</exception>
        </member>
        <member name="M:Au.Process_.Memory.#ctor(System.Int32,System.Int32)">
            <summary>
            Opens window's process handle and optionally allocates memory in that process.
            </summary>
            <param name="processId">Process id.</param>
            <param name="nBytes">If not 0, allocates this number of bytes of memory in that process.</param>
            <exception cref="T:Au.Types.AuException">Failed to open process handle (usually because of UAC) or allocate memory.</exception>
        </member>
        <member name="M:Au.Process_.Memory.WriteUnicodeString(System.String,System.Int32)">
            <summary>
            Copies a string from this process to the memory allocated in that process by the constructor.
            In that process the string is written as '\0'-terminated UTF-16 string. For it is used (s.Length+1)*2 bytes of memory in that process (+1 for the '\0', *2 because UTF-16 character size is 2 bytes).
            Returns false if fails.
            </summary>
            <param name="s">A string in this process.</param>
            <param name="offsetBytes">Offset in the memory allocated by the constructor.</param>
        </member>
        <member name="M:Au.Process_.Memory.WriteAnsiString(System.String,System.Int32,System.Text.Encoding)">
            <summary>
            Copies a string from this process to the memory allocated in that process by the constructor.
            In that process the string is written as '\0'-terminated ANSI string, in default or specified encoding.
            Returns false if fails.
            </summary>
            <param name="s">A string in this process. Normal C# string (UTF-16), not ANSI.</param>
            <param name="offsetBytes">Offset in the memory allocated by the constructor.</param>
            <param name="enc">If null, uses system's default ANSI encoding.</param>
        </member>
        <member name="M:Au.Process_.Memory.ReadUnicodeString(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Copies a string from the memory in that process allocated by the constructor to this process.
            Returns the copied string, or null if fails.
            In that process the string must be in Unicode UTF-16 format (ie not ANSI).
            </summary>
            <param name="nChars">Number of characters to copy. In both processes a character is 2 bytes.</param>
            <param name="offsetBytes">Offset in the memory allocated by the constructor.</param>
            <param name="findLength">Find true string length by searching for '\0' character in nChars range. If false, the returned string is of nChars length even if contains '\0' characters.</param>
        </member>
        <member name="M:Au.Process_.Memory.LibReadUnicodeStringCached(System.Int32,System.Int32,System.Boolean)">
            <summary>
            The same as <see cref="M:Au.Process_.Memory.ReadUnicodeString(System.Int32,System.Int32,System.Boolean)"/> but uses our StringCache.
            </summary>
        </member>
        <member name="M:Au.Process_.Memory.ReadAnsiString(System.Int32,System.Int32,System.Boolean,System.Text.Encoding)">
            <summary>
            Copies a string from the memory in that process allocated by the constructor to this process.
            Returns the copies string, or null if fails.
            In that process the string must be in ANSI format (ie not Unicode UTF-16).
            </summary>
            <param name="nBytes">Number bytes to copy. In that process a character is 1 or more bytes (depending on encoding). In this process will be 2 bytes (normal C# string).</param>
            <param name="offsetBytes">Offset in the memory allocated by the constructor.</param>
            <param name="findLength">Find true string length by searching for '\0' character in nBytes range of the ANSI string.</param>
            <param name="enc">If null, uses system's default ANSI encoding.</param>
        </member>
        <member name="M:Au.Process_.Memory.Write(System.Void*,System.Int32,System.Int32)">
            <summary>
            Copies a value-type variable or other memory from this process to the memory in that process allocated by the constructor.
            Returns false if fails.
            </summary>
            <param name="ptr">Unsafe address of a value type variable or other memory in this process.</param>
            <param name="nBytes">Number of bytes to copy.</param>
            <param name="offsetBytes">Offset in the memory allocated by the constructor.</param>
        </member>
        <member name="M:Au.Process_.Memory.WriteOther(System.IntPtr,System.Void*,System.Int32)">
            <summary>
            Copies a value-type variable or other memory from this process to a known memory address in that process.
            Returns false if fails.
            </summary>
            <param name="ptrDestinationInThatProcess">Memory address in that process where to copy memory from this process.</param>
            <param name="ptr">Unsafe address of a value type variable or other memory in this process.</param>
            <param name="nBytes">Number of bytes to copy.</param>
            <seealso cref="M:Au.Process_.Memory.SetMem(System.IntPtr,System.Boolean)"/>
        </member>
        <member name="M:Au.Process_.Memory.Read(System.Void*,System.Int32,System.Int32)">
            <summary>
            Copies from the memory in that process allocated by the constructor to a value-type variable or other memory in this process.
            Returns false if fails.
            </summary>
            <param name="ptr">Unsafe address of a value type variable or other memory in this process.</param>
            <param name="nBytes">Number of bytes to copy.</param>
            <param name="offsetBytes">Offset in the memory allocated by the constructor.</param>
        </member>
        <member name="M:Au.Process_.Memory.ReadOther(System.IntPtr,System.Void*,System.Int32)">
            <summary>
            Copies from a known memory address in that process to a value-type variable or other memory in this process.
            Returns false if fails.
            </summary>
            <param name="ptrSourceInThatProcess">Memory address in that process from where to copy memory.</param>
            <param name="ptr">Unsafe address of a value type variable or other memory in this process.</param>
            <param name="nBytes">Number of bytes to copy.</param>
            <seealso cref="M:Au.Process_.Memory.SetMem(System.IntPtr,System.Boolean)"/>
        </member>
        <member name="T:Au.Process_.UacInfo">
            <summary>
            Holds access token (security info) of a process and provides various security info, eg UAC integrity level.
            </summary>
        </member>
        <member name="M:Au.Process_.UacInfo.Finalize">
            
        </member>
        <member name="M:Au.Process_.UacInfo.Dispose">
            
        </member>
        <member name="P:Au.Process_.UacInfo.UnsafeTokenHandle">
            <summary>
            Access token handle.
            </summary>
            <remarks>
            The handle is managed by this variable and will be closed when disposing or GC-collecting it. Use <see cref="M:System.GC.KeepAlive(System.Object)"/> where need.
            </remarks>
        </member>
        <member name="P:Au.Process_.UacInfo.Failed">
            <summary>
            Gets true if the last called property function failed.
            Normally getting properties should never fail. Only the GetOfProcess method can fail, then it returns null.
            </summary>
        </member>
        <member name="T:Au.Process_.UacInfo.IL">
            <summary>
            <see cref="P:Au.Process_.UacInfo.IntegrityLevel"/>.
            </summary>
            <tocexclude />
        </member>
        <member name="T:Au.Process_.UacInfo.ElevationType">
            <summary>
            <see cref="P:Au.Process_.UacInfo.Elevation"/>.
            </summary>
            <tocexclude />
        </member>
        <member name="P:Au.Process_.UacInfo.Elevation">
            <summary>
            Gets process UAC elevation type.
            Elevation types:
            Full - runs as administrator (High or System integrity level).
            Limited - runs as standard user (Medium, Medium+UIAccess or Low integrity level) on administrator user session.
            Default - all processes in this user session run as admin, or all as standard user. Can be: non-administrator user session; service session; UAC is turned off.
            Unknown - failed to get. Normally it never happens; only GetOfProcess can fail, then it returns null.
            This property is rarely useful. Instead use other properties of this class.
            </summary>
        </member>
        <member name="P:Au.Process_.UacInfo.IsUIAccess">
            <summary>
            Returns true if the process has uiAccess property.
            A uiAccess process can access/automate all windows of processes running in the same user session.
            Most processes don't have this property and cannot access/automate windows of higher integrity level (High, System, Middle+uiAccess) processes and Windows 8 store apps. For example, cannot send keys and Windows messages.
            Note: High IL (admin) processes also can have this property, therefore IsUIAccess is not the same as IntegrityLevelAndUIAccess==IL.UIAccess (IntegrityLevelAndUIAccess returns IL.UIAccess only for Medium+uiAccess processes; for High+uiAccess processes it returns IL.High). Some Windows API work slightly differently with uiAccess and non-uiAccess admin processes.
            This property is rarely useful. Instead use other properties of this class.
            </summary>
        </member>
        <member name="P:Au.Process_.UacInfo.IntegrityLevel">
            <summary>
            Gets process UAC integrity level (IL).
            IL from lowest to highest value:
            	Untrusted - the most limited rights. Very rare.
            	Low - very limited rights. Used by Internet Explorer tab processes, Windows Store apps.
            	Medium - limited rights. Most processes (unless UAC turned off).
            	UIAccess - Medium IL + can access/automate High IL windows (user interface).
            		Note: Only the <see cref="P:Au.Process_.UacInfo.IntegrityLevelAndUIAccess"/> property can return UIAccess. This property returns High instead (the same as in Process Explorer).
            	High - most rights. Processes that run as administrator.
            	System - almost all rights. Services, some system processes.
            	Protected - undocumented. Never seen.
            	Unknown - failed to get IL. Never seen.
            The IL enum member values can be used like <c>if(x.IntegrityLevel > IL.Medium) ...</c> .
            If UAC is turned off, most non-service processes on administrator account have High IL; on non-administrator - Medium.
            </summary>
        </member>
        <member name="P:Au.Process_.UacInfo.IntegrityLevelAndUIAccess">
            <summary>
            The same as IntegrityLevel, but can return UIAccess.
            </summary>
        </member>
        <member name="M:Au.Process_.UacInfo.GetOfProcess(System.Int32)">
            <summary>
            Opens process access token and creates UacInfo object that holds it.
            Returns UacInfo object. Then you can use its properties.
            Returns null if failed. For example fails for services and some other processes if current process is not administrator.
            To get UacInfo of this process, instead use UacInfo.ThisProcess.
            </summary>
            <param name="processId">Process id. If you have a window, use its <see cref="P:Au.Wnd.ProcessId">ProcessId</see> property.</param>
        </member>
        <member name="P:Au.Process_.UacInfo.ThisProcess">
            <summary>
            Gets UacInfo object of current process.
            </summary>
        </member>
        <member name="P:Au.Process_.UacInfo.IsAdmin">
            <summary>
            Returns true if current process is running as administrator, ie if the user belongs to the local Administrators group and the process is not limited by UAC.
            This function for example can be used to check whether you can write to protected locations in the file system and registry.
            </summary>
        </member>
        <member name="P:Au.Process_.UacInfo.IsUacDisabled">
            <summary>
            Returns true if UAC is disabled (turned off) on this Windows 7 computer.
            On Windows 8 and 10 UAC cannot be disabled, although you can disable UAC elevation consent dialogs.
            </summary>
        </member>
        <member name="P:Au.Process_.CurrentThreadId">
            <summary>
            Calls API <msdn>GetCurrentThreadId</msdn>.
            </summary>
        </member>
        <member name="P:Au.Process_.CurrentProcessId">
            <summary>
            Calls API <msdn>GetCurrentProcessId</msdn>.
            </summary>
        </member>
        <member name="P:Au.Process_.CurrentThreadHandle">
            <summary>
            Returns current thread handle.
            Calls API <msdn>GetCurrentThread</msdn>.
            Don't need to close the handle.
            </summary>
        </member>
        <member name="P:Au.Process_.CurrentProcessHandle">
            <summary>
            Returns current process handle.
            Calls API <msdn>GetCurrentProcess</msdn>.
            Don't need to close the handle.
            </summary>
        </member>
        <member name="M:Au.Process_.GetProcessId(System.IntPtr)">
            <summary>
            Gets process id from handle.
            Returns 0 if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            Calls API <msdn>GetProcessId</msdn>.
            </summary>
            <param name="processHandle">Process handle.</param>
        </member>
        <member name="M:Au.Process_.GetSessionId(System.Int32)">
            <summary>
            Gets user session id of a process.
            Returns -1 if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            Calls API <msdn>ProcessIdToSessionId</msdn>.
            </summary>
            <param name="processId">Process id.</param>
        </member>
        <member name="M:Au.Process_.GetSessionId">
            <summary>
            Gets user session id of this process.
            Calls API <msdn>ProcessIdToSessionId</msdn> and <msdn>GetCurrentProcessId</msdn>.
            </summary>
        </member>
        <member name="T:Au.AuDialog">
            <summary>
            Standard dialogs to show information or get user input.
            You can use static functions (less code) or create class instances (more options).
            More info: <see cref="M:Au.AuDialog.ShowEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </summary>
            <remarks>
            Uses task dialog API <msdn>TaskDialogIndirect</msdn>.
            
            Cannot be used in services. Instead use <see cref="M:System.Windows.Forms.MessageBox.Show(System.String,System.String,System.Windows.Forms.MessageBoxButtons,System.Windows.Forms.MessageBoxIcon,System.Windows.Forms.MessageBoxDefaultButton,System.Windows.Forms.MessageBoxOptions)"/> with option ServiceNotification or DefaultDesktopOnly, or API <msdn>MessageBox</msdn> with corresponding flags.
            </remarks>
            <example>
            This example creates a class instance, sets properties, shows dialog, uses events, uses result.
            <code><![CDATA[
            var d = new AuDialog(); //info: another constructor has the same parameters as ShowEx
            d.SetText("Main text.", "More text.\nSupports &lt;A HREF=\"link data\"&gt;links&lt;/A&gt; if you subscribe to HyperlinkClicked event.");
            d.SetButtons("1 OK|2 Cancel|3 Custom|4 Custom2");
            d.SetIcon(DIcon.Warning);
            d.SetExpandedText("Expanded info\nand more info.", true);
            d.FlagCanBeMinimized = true;
            d.SetRadioButtons("1 r1|2 r2");
            d.SetCheckbox("Check");
            d.SetTimeout(30, "OK");
            d.HyperlinkClicked += e =&gt; { AuDialog.Show("link clicked", e.LinkHref, owner: e.hwnd); };
            d.ButtonClicked += e =&gt; { Print(e.Button); if(e.Button == 4) e.DoNotCloseDialog = true; };
            d.FlagShowProgressBar = true; d.Timer += e =&gt; { e.dialog.Send.Progress(e.TimerTimeMS / 100); };
            var r = d.ShowDialog();
            Print(r);
            switch(r.Button) { case 1: Print("OK"); break; case DResult.Timeout: Print("timeout"); break; }
            ]]></code>
            </example>
        </member>
        <member name="T:Au.AuDialog.Options">
            <summary>
            Default options used by AuDialog class functions called in this appdomain.
            </summary>
        </member>
        <member name="P:Au.AuDialog.Options.DefaultTitle">
            <summary>
            Default title bar text.
            Default value - current appdomain name. In exe it is exe file name like "example.exe".
            </summary>
        </member>
        <member name="P:Au.AuDialog.Options.RtlLayout">
            <summary>
            Right-to-left layout.
            </summary>
            <seealso cref="P:Au.AuDialog.FlagRtlLayout"/>
        </member>
        <member name="P:Au.AuDialog.Options.TopmostIfNoOwnerWindow">
            <summary>
            If there is no owner window, let the dialog be always on top of most other windows.
            </summary>
            <seealso cref="P:Au.AuDialog.FlagTopmost"/>
        </member>
        <member name="P:Au.AuDialog.Options.DefaultScreen">
            <summary>
            Show dialogs on this screen when screen is not explicitly specified (<see cref="P:Au.AuDialog.Screen"/>) and there is no owner window.
            If screen index is invalid, the 'show' method shows warning, no exception.
            </summary>
        </member>
        <member name="P:Au.AuDialog.Options.UseAppIcon">
            <summary>
            If icon not specified, use <see cref="F:Au.Types.DIcon.App"/>.
            </summary>
        </member>
        <member name="P:Au.AuDialog.Options.AutoOwnerWindow">
            <summary>
            If owner window not specified, use the active window of current thread as owner window (disable it, etc).
            </summary>
            <seealso cref="M:Au.AuDialog.SetOwnerWindow(Au.Types.DOwner,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.AuDialog.#ctor">
            
        </member>
        <member name="M:Au.AuDialog.#ctor(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})">
            <summary>
            Initializes a new <see cref="T:Au.AuDialog"/> instance and sets main properties.
            Parameters etc are of <see cref="M:Au.AuDialog.ShowEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </summary>
        </member>
        <member name="M:Au.AuDialog.SetTitleBarText(System.String)">
            <summary>
            Changes title bar text.
            If you don't call this method or title is null or "", dialogs will use <see cref="P:Au.AuDialog.Options.DefaultTitle"/>.
            </summary>
        </member>
        <member name="M:Au.AuDialog.SetText(System.String,System.String)">
            <summary>
            Sets text.
            </summary>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Text below main instruction.</param>
        </member>
        <member name="M:Au.AuDialog.SetIcon(Au.Types.DIcon)">
            <summary>
            Sets common icon.
            </summary>
            <param name="icon"></param>
        </member>
        <member name="M:Au.AuDialog.SetIcon(System.Drawing.Icon)">
            <summary>
            Sets custom icon.
            </summary>
            <param name="icon">
            Icon of size 32 or 16.
            If you have native handle (see <see cref="M:Au.Icons.GetFileIconHandle(System.String,System.Int32,Au.Types.GIFlags)"/>), use Icon.FromHandle.
            In any case, the icon must remain valid until the dialog is closed. Then you can dispose/destroy it.
            This AuDialog variable keeps icon reference to protect it from GC.
            </param>
        </member>
        <member name="M:Au.AuDialog._Buttons.MarshalButtons(Au.AuDialog.TASKDIALOGCONFIG@)">
            <summary>
            Sets c.pButtons, c.cButtons, c.pRadioButtons and c.cRadioButtons.
            Later call MarshalFreeButtons.
            </summary>
        </member>
        <member name="M:Au.AuDialog._Buttons.MarshalFreeButtons(Au.AuDialog.TASKDIALOGCONFIG@)">
            <summary>
            Frees memory allocated by MarshalButtons and sets the c members to null/0.
            </summary>
        </member>
        <member name="M:Au.AuDialog.SetButtons(System.String,System.Boolean,System.Object)">
            <summary>
            Sets common and/or custom buttons and custom buttons style.
            </summary>
            <param name="buttons">
            Common and/or custom buttons, like with <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String)"/>.
            These ids should be negative if you use <paramref name="customButtons"/> too, because ids of <paramref name="customButtons"/> are 1, 2, ... .
            </param>
            <param name="asCommandLinks">Custom buttons style. If false - row of classic buttons. If true - column of command-link buttons that can have multiline text.</param>
            <param name="customButtons">
            Additional custom buttons. All will be custom, even if named "OK" etc.
            List of labels without ids. Can be string like "One|Two|..." or string array/List/IEnumerable.
            Button ids will be 1, 2, ... .
            <see cref="P:Au.AuDialog.DefaultButton"/> will be 1. You can change it later.
            </param>
        </member>
        <member name="P:Au.AuDialog.DefaultButton">
            <summary>
            Specifies which button responds to the Enter key.
            If 0 or not set, auto-selects.
            </summary>
            <value>Button id.</value>
        </member>
        <member name="M:Au.AuDialog.SetRadioButtons(System.String,System.Int32)">
            <summary>
            Adds radio buttons.
            To get selected radio button id after closing the dialog, use the RadioButton property of the <see cref="T:Au.Types.DResult"/> variable returned by <see cref="M:Au.AuDialog.ShowDialog"/> or the <see cref="P:Au.AuDialog.Result"/> property.
            </summary>
            <param name="buttons">A list of strings "id text" separated by |, like "1 One|2 Two|3 Three".</param>
            <param name="defaultId">Check the radio button that has this id. If omitted or 0, checks the first. If negative, does not check.</param>
        </member>
        <member name="M:Au.AuDialog.SetCheckbox(System.String,System.Boolean)">
            <summary>
            Adds check box (if text is not null/empty).
            To get check box state after closing the dialog, use the IsChecked property of the <see cref="T:Au.Types.DResult"/> variable returned by <see cref="M:Au.AuDialog.ShowDialog"/> or the <see cref="P:Au.AuDialog.Result"/> property.
            </summary>
        </member>
        <member name="M:Au.AuDialog.SetExpandedText(System.String,System.Boolean)">
            <summary>
            Adds text that the user can show and hide.
            </summary>
            <param name="text">Text.</param>
            <param name="showInFooter">Show the text at the bottom of the dialog.</param>
        </member>
        <member name="M:Au.AuDialog.SetExpandControl(System.Boolean,System.String,System.String)">
            <summary>
            Set properties of the control that shows and hides text added by <see cref="M:Au.AuDialog.SetExpandedText(System.String,System.Boolean)">SetExpandedText</see>.
            </summary>
            <param name="defaultExpanded"></param>
            <param name="collapsedText"></param>
            <param name="expandedText"></param>
        </member>
        <member name="M:Au.AuDialog.SetFooterText(System.String)">
            <summary>
            Adds text and common icon at the bottom of the dialog.
            </summary>
            <param name="text">Text, optionally preceded by an icon character and |, like "i|Text". Icons: x error, ! warning, i info, v shield, a app.</param>
        </member>
        <member name="M:Au.AuDialog.SetFooterText(System.String,Au.Types.DIcon)">
            <summary>
            Adds text and common icon at the bottom of the dialog.
            </summary>
            <param name="text">Text.</param>
            <param name="icon"></param>
        </member>
        <member name="M:Au.AuDialog.SetFooterText(System.String,System.Drawing.Icon)">
            <summary>
            Adds text and custom icon at the bottom of the dialog.
            </summary>
            <param name="text">Text.</param>
            <param name="icon">Icon of size 16. Read more: <see cref="M:Au.AuDialog.SetIcon(System.Drawing.Icon)"/>.</param>
        </member>
        <member name="M:Au.AuDialog.SetEditControl(Au.Types.DEdit,System.Object)">
            <summary>
            Adds Edit or Combo control (if editType is not DEdit.None (0)).
            To get its text after closing the dialog, use the EditText property of the <see cref="T:Au.Types.DResult"/> variable returned by <see cref="M:Au.AuDialog.ShowDialog"/> or the <see cref="P:Au.AuDialog.Result"/> property.
            </summary>
            <param name="editType">Control type/style.</param>
            <param name="editText">Initial text. If editType is DEdit.Combo, it can be a string array, List or IEnumerable; the first item sets combo-box editable text, other items - combo box drop-down list items.</param>
            <remarks>
            The API TaskDialogIndirect does not have an option to add an edit control. This class itself creates it.
            Does not support progress bar.
            </remarks>
        </member>
        <member name="P:Au.AuDialog.Width">
            <summary>
            Sets the width of the dialog's client area.
            The actual width will depend on DPI (the Windows "text size" setting).
            If less than default width, will be used default width.
            </summary>
            <seealso cref="F:Au.Types.DFlags.Wider"/>
        </member>
        <member name="M:Au.AuDialog.SetOwnerWindow(Au.Types.DOwner,System.Boolean,System.Boolean)">
            <summary>
            Sets owner window.
            The owner window will be disabled, and this dialog will be on top of it.
            This window will be in owner's screen, if screen was not explicitly specified with the <see cref="P:Au.AuDialog.Screen"/> property. <see cref="P:Au.AuDialog.Options.DefaultScreen"/> is ignored.
            </summary>
            <param name="owner">Owner window, or one of its child/descendant controls. Can be Control (eg Form) or Wnd (window handle). Can be null.</param>
            <param name="ownerCenter">Show the dialog in the center of the owner window. <see cref="M:Au.AuDialog.SetXY(Au.Types.Coord,Au.Types.Coord,System.Boolean)">SetXY</see> and <see cref="P:Au.AuDialog.Screen">Screen</see> are ignored.</param>
            <param name="doNotDisable">Don't disable the owner window. If false, disables if it belongs to this thread.</param>
            <seealso cref="P:Au.AuDialog.Options.AutoOwnerWindow"/>
        </member>
        <member name="M:Au.AuDialog.SetXY(Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Sets dialog position in screen.
            </summary>
            <param name="x">X position in <see cref="P:Au.AuDialog.Screen"/>. If null - screen center. You also can use Coord.Reverse etc.</param>
            <param name="y">Y position in <see cref="P:Au.AuDialog.Screen"/>. If null - screen center. You also can use Coord.Reverse etc.</param>
            <param name="rawXY">x y are relative to the primary screen (ignore <see cref="P:Au.AuDialog.Screen"/> etc). Don't ensure thet entire window is in screen.</param>
        </member>
        <member name="P:Au.AuDialog.Screen">
            <summary>
            Sets the screen (display monitor) where to show the dialog in multi-screen environment.
            If null or not set, will be used owner window's screen or <see cref="P:Au.AuDialog.Options.DefaultScreen"/>.
            If screen index is invalid, the 'show' method shows warning, no exception.
            More info: <see cref="M:Au.Screen_.FromObject(System.Object)"/>, <see cref="M:Au.Wnd.MoveInScreen(Au.Types.Coord,Au.Types.Coord,System.Object,System.Boolean,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Au.AuDialog.SetTimeout(System.Int32,System.String,System.Boolean)">
            <summary>
            Let the dialog close itself after closeAfterS seconds.
            On timeout ShowDialog returns DResult.Timeout.
            Example: <c>d.SetTimeout(30, "OK");</c>
            </summary>
        </member>
        <member name="P:Au.AuDialog.FlagXCancel">
            <summary>
            Allow to cancel even if there is no Cancel button.
            It adds X (Close) button to the title bar, and also allows to close the dialog with the Esc key.
            When the dialog is closed with the X button or Esc, the returned result button id is 0 if there is no Cancel button; else the same as when clicked the Cancel button.
            The same as <see cref="F:Au.Types.DFlags.XCancel"/>.
            </summary>
        </member>
        <member name="P:Au.AuDialog.FlagRtlLayout">
            <summary>
            Right-to left layout.
            Default is AuDialog.Options.RtlLayout.
            </summary>
        </member>
        <member name="P:Au.AuDialog.FlagCanBeMinimized">
            <summary>
            Add 'Minimize' button to the title bar.
            </summary>
        </member>
        <member name="P:Au.AuDialog.FlagShowProgressBar">
            <summary>
            Show progress bar.
            </summary>
        </member>
        <member name="P:Au.AuDialog.FlagShowMarqueeProgressBar">
            <summary>
            Show progress bar that just plays an animation but does not indicate which part of the work is already done.
            </summary>
        </member>
        <member name="P:Au.AuDialog.FlagTopmost">
            <summary>
            Makes the dialog window topmost or non-topmost.
            If true, will set topmost style when creating the dialog. If false, will not set.
            If null (default), the dialog will be topmost if both these are true: no owner window, AuDialog.Options.TopmostIfNoOwnerWindow is true.
            </summary>
        </member>
        <member name="P:Au.AuDialog.FlagEndThread">
            <summary>
            Call <see cref="M:System.Threading.Thread.Abort"/> if selected OK button when there are no other buttons. Also when selected Cancel, No, and on timeout.
            </summary>
        </member>
        <member name="M:Au.AuDialog.ShowDialog">
            <summary>
            Shows the dialog.
            Returns selected button id and other results packed in a <see cref="T:Au.Types.DResult"/> variable.
            Call this method after setting text and other properties.
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="E:Au.AuDialog.Created">
            <summary>
            AuDialog events.
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="E:Au.AuDialog.Destroyed">
            <summary>
            AuDialog events.
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="E:Au.AuDialog.Timer">
            <summary>
            AuDialog events.
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="E:Au.AuDialog.ButtonClicked">
            <summary>
            AuDialog events.
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="E:Au.AuDialog.HyperlinkClicked">
            <summary>
            AuDialog events.
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="E:Au.AuDialog.HelpF1">
            <summary>
            AuDialog events.
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="E:Au.AuDialog.OtherEvents">
            <summary>
            AuDialog events.
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="M:Au.AuDialog.ShowDialogNoWait">
            <summary>
            Shows the dialog in new thread and returns without waiting until it is closed.
            </summary>
            <remarks>
            Calls <see cref="M:Au.AuDialog.ThreadWaitForOpen"/>, therefore the dialog is already open when this function returns.
            More info: <see cref="M:Au.AuDialog.ShowNoWaitEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>
            </remarks>
            <exception cref="T:System.AggregateException">Failed to show dialog.</exception>
        </member>
        <member name="P:Au.AuDialog.Result">
            <summary>
            Gets selected button id and other results packed in a DResult variable.
            It is the same variable as the ShowDialog return value.
            If the result is still unavailable (eg the dialog still not closed):
            	If called from the same thread that called ShowDialog, returns null.
            	If called from another thread, waits until the dialog is closed and the return value is available.
            	Note that ShowDialogNoWait calls ShowDialog in another thread.
            </summary>
        </member>
        <member name="M:Au.AuDialog.ThreadWaitForOpen">
            <summary>
            Can be used by other threads to wait until the dialog is open.
            If returns true, the dialog is open and you can send messages to it.
            If returns false, the dialog is already closed or failed to show.
            </summary>
        </member>
        <member name="M:Au.AuDialog.ThreadWaitForClosed">
            <summary>
            Can be used by other threads to wait until the dialog is closed.
            </summary>
        </member>
        <member name="P:Au.AuDialog.IsOpen">
            <summary>
            Returns true if the dialog is open and your code can send messages to it.
            </summary>
        </member>
        <member name="P:Au.AuDialog.DialogWindow">
            <summary>
            Gets dialog window handle as Wnd.
            Returns default(Wnd) if the dialog is not open.
            </summary>
        </member>
        <member name="P:Au.AuDialog.Send">
            <summary>
            Allows to modify dialog controls while it is open, and close the dialog.
            Example: <c>d.Send.Close();</c> .
            Example: <c>d.Send.ChangeText2("new text", false);</c> .
            Example: <c>d.Send.Message(TDApi.TDM.CLICK_VERIFICATION, 1);</c> .
            </summary>
            <remarks>
            Can be used only while the dialog is open. Before showing the dialog returns null. After closing the dialog the returned variable is deactivated; its method calls are ignored.
            Can be used in dialog event handlers. Also can be used in another thread, for example with <see cref="M:Au.AuDialog.ShowNoWaitEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})">ShowNoWaitEx</see> and <see cref="M:Au.AuDialog.ShowProgressEx(System.Boolean,System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.String,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})">ShowProgressEx</see>.
            </remarks>
        </member>
        <member name="T:Au.AuDialog.TDMessageSender">
            <summary>
            Sends task dialog API messages, like <c>d.Send.Message(TDApi.TDM.CLICK_VERIFICATION, 1);</c> .
            </summary>
            <tocexclude />
        </member>
        <member name="M:Au.AuDialog.TDMessageSender.Message(Au.Types.TDApi.TDM,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>
            Sends a message to the dialog.
            Call this method while the dialog is open, eg in an event handler.
            Example (in an event handler): <c>e.dialog.Send.Message(TDApi.TDM.CLICK_VERIFICATION, 1);</c>
            Also there are several other functions to send some messages: change text, close dialog, enable/disable buttons, set progress.
            Reference: <msdn>task dialog messages</msdn>.
            NAVIGATE_PAGE currently not supported.
            </summary>
        </member>
        <member name="M:Au.AuDialog.TDMessageSender.ChangeText1(System.String,System.Boolean)">
            <summary>
            Changes the main big-font text.
            Call this method while the dialog is open, eg in an event handler.
            </summary>
        </member>
        <member name="M:Au.AuDialog.TDMessageSender.ChangeText2(System.String,System.Boolean)">
            <summary>
            Changes the main small-font text.
            Call this method while the dialog is open, eg in an event handler.
            </summary>
        </member>
        <member name="M:Au.AuDialog.TDMessageSender.ChangeFooterText(System.String,System.Boolean)">
            <summary>
            Changes the footer text.
            Call this method while the dialog is open, eg in an event handler.
            </summary>
        </member>
        <member name="M:Au.AuDialog.TDMessageSender.ChangeExpandedText(System.String,System.Boolean)">
            <summary>
            Changes the expanded area text.
            Call this method while the dialog is open, eg in an event handler.
            </summary>
        </member>
        <member name="M:Au.AuDialog.TDMessageSender.Close(System.Int32)">
            <summary>
            Clicks a button. Normally it closes the dialog.
            Call this method while the dialog is open, eg in an event handler.
            Sends message TDApi.TDM.CLICK_BUTTON.
            </summary>
            <param name="buttonId">A button id or some other number that will be returned by ShowDialog.</param>
        </member>
        <member name="M:Au.AuDialog.TDMessageSender.EnableButton(System.Int32,System.Boolean)">
            <summary>
            Enables or disables a button.
            Call this method while the dialog is open, eg in an event handler.
            Example: <c>d.Created += e => { e.dialog.Send.EnableButton(4, false); };</c>
            Sends message TDApi.TDM.ENABLE_BUTTON.
            </summary>
        </member>
        <member name="M:Au.AuDialog.TDMessageSender.Progress(System.Int32)">
            <summary>
            Sets progress bar value, 0 to 100.
            Call this method while the dialog is open, eg in an event handler.
            Sends message TDApi.TDM.SET_PROGRESS_BAR_POS.
            </summary>
        </member>
        <member name="P:Au.AuDialog.EditControl">
            <summary>
            Gets edit control handle as Wnd.
            </summary>
        </member>
        <member name="M:Au.AuDialog.ShowEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})">
            <summary>
            Shows dialog.
            Returns selected button id and other results packed in a <see cref="T:Au.Types.DResult"/> variable.
            </summary>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Text below main instruction.</param>
            <param name="buttons">See <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String)"/>. Examples: "OK|Cancel", "1 OK|2 Cancel|5 Save|4 Don't Save".</param>
            <param name="icon"></param>
            <param name="flags"></param>
            <param name="owner">Owner window or null. See <see cref="M:Au.AuDialog.SetOwnerWindow(Au.Types.DOwner,System.Boolean,System.Boolean)"/>.</param>
            <param name="expandedText">Text that the user can show and hide.</param>
            <param name="footerText">Text at the bottom of the dialog. Icon can be specified like "i|Text", where i is: x error, ! warning, i info, v shield, a app.</param>
            <param name="title">Title bar text. If omitted, null or "", uses <see cref="P:Au.AuDialog.Options.DefaultTitle"/>.</param>
            <param name="radioButtons">Adds radio buttons. A list of strings "id text" separated by |, like "1 One|2 Two|3 Three".</param>
            <param name="checkBox">If not null/"", shows a check box with this text. To make it checked, append "|true", "|check" or "|checked".</param>
            <param name="defaultButton">id of button that responds to the Enter key.</param>
            <param name="x">X position in <see cref="P:Au.AuDialog.Screen"/>. If null (default) - screen center. You also can use Coord.Reverse etc.</param>
            <param name="y">Y position in <see cref="P:Au.AuDialog.Screen"/>. If null (default) - screen center. You also can use Coord.Reverse etc.</param>
            <param name="secondsTimeout">If not 0, auto-close the dialog after this time (seconds) and set result's Button property = <see cref="F:Au.Types.DResult.Timeout"/>.</param>
            <param name="onLinkClick">
            A link-clicked event handler function, eg lambda. Enables hyperlinks in small-font text.
            Example:
            <code><![CDATA[
            AuDialog.ShowEx("", "Text <a href=\"example\">link</a>.", onLinkClick: e => { Print(e.LinkHref); });
            ]]></code>
            </param>
            <remarks>
            The returned DResult variable has these properties: selected button id, selected radio button id, check box state.
            Tip: DResult supports implicit cast to int. You can use code <c>switch(AuDialog.ShowEx(...))</c> instead of <c>switch(AuDialog.ShowEx(...).Button)</c> .
            Tip: For optional parameters use named arguments. Example: <c>AuDialog.ShowEx("Text.", icon: DIcon.Info, title: "Title")</c> .
            This function allows you to use most of the dialog features, but not all. Alternatively you can create a AuDialog class instance, set properties and call ShowDialog. Example in <see cref="T:Au.AuDialog"/> class help.
            </remarks>
            <example>
            <code><![CDATA[
            var r = AuDialog.ShowEx("Main text", "More text.", "1 OK|2 Cancel", expandedText: "Expanded text", radioButtons: "1 One|2 Two|3 Three", checkBox: "Check", secondsTimeout: 30);
            Print(r);
            switch(r) {
            case 1: Print("OK"); break;
            case DResult.Timeout: Print("timeout"); break;
            default: Print("Cancel"); break;
            }
            ]]></code>
            </example>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String)">
            <summary>
            Shows dialog.
            Returns selected button id.
            </summary>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Text below main instruction.</param>
            <param name="buttons">
            Button ids and labels, like "1 OK|2 Cancel|5 Save|4 Don't Save".
            Missing ids are auto-generated, for example "OK|Cancel|100 Custom1|Custom2" is the same as "1 OK|2 Cancel|100 Custom1|101 Custom2".
            The first in the list button is <i>default</i>, ie responds to the Enter key. For example, "2 No|1 Yes" adds Yes and No buttons and makes No default.
            Trims newlines around ids and labels. For example, "\r\n1 One\r\n|\r\n2\r\nTwo\r\n\r\n" is the same as "1 One|2 Two".
            
            To create keyboard shortcuts, use &amp; character in custom button labels. Use &amp;&amp; for literal &amp;. Example: "1 &amp;Tuesday[]2 T&amp;hursday[]3 Saturday &amp;&amp; Sunday".
            
            There are 6 <i>common buttons</i>: OK, Yes, No, Retry, Cancel, Close. Buttons that have other labels are <i>custom buttons</i>.
            How common buttons are different:
            	1. DFlags.CommandLinks does not change their style.
            	2. They have keyboard shortcuts that cannot be changed. Inserting &amp; in a label makes it a custom button.
            	3. Button Cancel can be selected with the Esc key. It also adds X (Close) button in title bar, which selects Cancel.
            	4. Always displayed in standard order (eg Yes No, never No Yes). But you can for example use "2 No|1 Yes" to set default button = No.
            	5. The displayed button label is localized, ie different when the Windows UI language is not English.
            
            If omitted, null or "", the dialog will have OK button, id 1.
            You can use <see cref="F:Au.Types.DFlags.CommandLinks"/> in flags to change the style of custom buttons.
            See also: <see cref="M:Au.AuDialog.SetButtons(System.String,System.Boolean,System.Object)"/>.
            </param>
            <param name="icon"></param>
            <param name="flags"></param>
            <param name="owner">Owner window or null. See <see cref="M:Au.AuDialog.SetOwnerWindow(Au.Types.DOwner,System.Boolean,System.Boolean)"/>.</param>
            <param name="expandedText">Text that the user can show and hide.</param>
            <remarks>
            Calls <see cref="M:Au.AuDialog.ShowEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            Tip: For optional parameters use named arguments. Example: <c>AuDialog.Show("Text.", icon: DIcon.Info)</c> .
            </remarks>
            <seealso cref="M:Au.AuDialog.ShowInfo(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DOwner,System.String)"/>
            <seealso cref="M:Au.AuDialog.ShowWarning(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DOwner,System.String)"/>
            <seealso cref="M:Au.AuDialog.ShowError(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DOwner,System.String)"/>
            <seealso cref="M:Au.AuDialog.ShowOKCancel(System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String)"/>
            <seealso cref="M:Au.AuDialog.ShowYesNo(System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String)"/>
            <seealso cref="M:Au.Debug_.Dialog(System.Object,System.String,System.Int32,System.String)"/>
            <example>
            <code><![CDATA[
            if(AuDialog.Show("Show another example?", null, "1 OK|2 Cancel", DIcon.Info) != 1) return;
            Print("OK");
            
            switch(AuDialog.Show("Save changes?", "More info.", "1 Save|2 Don't Save|Cancel")) {
            case 1: Print("save"); break;
            case 2: Print("don't"); break;
            default: Print("cancel"); break;
            }
            ]]></code>
            </example>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowInfo(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DOwner,System.String)">
            <summary>
            Shows dialog with DIcon.Info icon.
            Calls <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String)"/>.
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowWarning(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DOwner,System.String)">
            <summary>
            Shows dialog with DIcon.Warning icon.
            Calls <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String)"/>.
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowError(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DOwner,System.String)">
            <summary>
            Shows dialog with DIcon.Error icon.
            Calls <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String)"/>.
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowOKCancel(System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String)">
            <summary>
            Shows dialog with OK and Cancel buttons.
            Returns true if selected OK.
            Calls <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String)"/>.
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowYesNo(System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String)">
            <summary>
            Shows dialog with Yes and No buttons.
            Returns true if selected Yes.
            Calls <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String)"/>.
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowTextInputEx(System.String,System.String,Au.Types.DEdit,System.Object,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.String,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs},System.String,System.Action{Au.Types.DEventArgs})">
            <summary>
            Shows dialog with a text edit field, buttons OK and Cancel, optionally check box, radio buttons and custom buttons.
            Returns results packed in a DResult variable: selected button id (1 for OK, 2 for Cancel), text and check box state.
            </summary>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Read-only text below main instruction, above the edit field.</param>
            <param name="editType">Edit field type. It can be simple text (DEdit.Text, default), multiline, number, password or combo box.</param>
            <param name="editText">Initial edit field text. If editType is Combo, it can be a string array, List or IEnumerable; the first item sets combo-box editable text, other items - combo box drop-down list items.</param>
            <param name="flags"></param>
            <param name="owner">Owner window or null. See <see cref="M:Au.AuDialog.SetOwnerWindow(Au.Types.DOwner,System.Boolean,System.Boolean)"/>.</param>
            <param name="expandedText">Text that the user can show and hide.</param>
            <param name="footerText">Text at the bottom of the dialog. Icon can be specified like "i|Text", where i is: x error, ! warning, i info, v shield, a app.</param>
            <param name="title">Title bar text. If omitted, null or "", uses <see cref="P:Au.AuDialog.Options.DefaultTitle"/>.</param>
            <param name="checkBox">If not empty, shows a check box with this text. To make it checked, append "|true", "|check" or "|checked".</param>
            <param name="radioButtons">Adds radio buttons. A list of strings "id text" separated by |, like "1 One|2 Two|3 Three".</param>
            <param name="x">X position in <see cref="P:Au.AuDialog.Screen"/>. If null (default) - screen center. You also can use Coord.Reverse etc.</param>
            <param name="y">Y position in <see cref="P:Au.AuDialog.Screen"/>. If null (default) - screen center. You also can use Coord.Reverse etc.</param>
            <param name="secondsTimeout">If not 0, auto-close the dialog after this time, number of seconds.</param>
            <param name="onLinkClick">Enables hyperlinks in small-font text. A link-clicked event handler function, like with <see cref="M:Au.AuDialog.ShowEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.</param>
            <param name="buttons">You can use this to add more buttons. A list of strings "id text" separated by |, like "1 OK|2 Cancel|10 Browse...". See <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String)"/>.</param>
            <param name="onButtonClick">
            A button-clicked event handler function, eg lambda.
            Examples:
            <code><![CDATA[
            AuDialog.ShowTextInputEx("Example", flags: DFlags.CommandLinks, buttons: "OK|Cancel|10 Browse\nSets edit control text.",
            	onButtonClick: e => { if(e.Button == 10) { e.EditText = "text"; e.DoNotCloseDialog = true; } });
            
            AuDialog.ShowTextInputEx("Example", "Try to click OK while text is empty.", onButtonClick: e =>
            {
            	if(e.Button == 1 && Empty(e.EditText)) {
            		AuDialog.Show("Text cannot be empty.", owner: e.hwnd);
            		e.dialog.EditControl.FocusControlOfThisThread();
            		e.DoNotCloseDialog = true;
            	}
            });
            ]]></code>
            </param>
            <remarks>
            This function allows you to use most of the dialog features, but not all. Alternatively you can create a AuDialog class instance, set properties and call ShowDialog. Example in <see cref="T:Au.AuDialog"/> class help.
            </remarks>
            <example>
            <code><![CDATA[
            var r = AuDialog.ShowTextInputEx("Example", "Comments.", checkBox: "Check");
            if(r.Button != 1) return;
            Print(r.EditText);
            Print(r.IsChecked);
            ]]></code>
            </example>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowTextInput(System.String@,System.String,System.String,Au.Types.DEdit,System.Object,Au.Types.DFlags,Au.Types.DOwner)">
            <summary>
            Shows dialog with a text edit field and buttons OK and Cancel, and gets that text.
            Returns true if selected OK, false if Cancel.
            </summary>
            <param name="s">Variable that receives the text.</param>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Read-only text below main instruction, above the edit field.</param>
            <param name="editType">Edit field type.</param>
            <param name="editText">Initial edit field text. If editType is DEdit.Combo, it can be a string array, List or IEnumerable; the first item sets combo-box editable text, other items - combo box drop-down list items.</param>
            <param name="flags"></param>
            <param name="owner">Owner window or null. See <see cref="M:Au.AuDialog.SetOwnerWindow(Au.Types.DOwner,System.Boolean,System.Boolean)"/>.</param>
            <remarks>
            Calls <see cref="M:Au.AuDialog.ShowTextInputEx(System.String,System.String,Au.Types.DEdit,System.Object,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.String,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs},System.String,System.Action{Au.Types.DEventArgs})"/>.
            </remarks>
            <example>
            <code><![CDATA[
            string s;
            if(!AuDialog.ShowTextInput(out s, "Example")) return;
            Print(s);
            
            //or you can declare the variable like this
            if(!AuDialog.ShowTextInput(out string s2, "Example")) return;
            Print(s2);
            ]]></code>
            </example>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowNumberInput(System.Int32@,System.String,System.String,Au.Types.DEdit,System.Object,Au.Types.DFlags,Au.Types.DOwner)">
            <summary>
            Shows dialog with a number edit field and buttons OK and Cancel, and gets that number.
            Returns true if selected OK, false if Cancel.
            </summary>
            <param name="i">Variable that receives the number.</param>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Read-only text below main instruction, above the edit field.</param>
            <param name="editType">Edit field type.</param>
            <param name="editText">Initial edit field text.</param>
            <param name="flags"></param>
            <param name="owner">Owner window or null. See <see cref="M:Au.AuDialog.SetOwnerWindow(Au.Types.DOwner,System.Boolean,System.Boolean)"/>.</param>
            <remarks>
            Calls <see cref="M:Au.AuDialog.ShowTextInputEx(System.String,System.String,Au.Types.DEdit,System.Object,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.String,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs},System.String,System.Action{Au.Types.DEventArgs})"/>.
            </remarks>
            <example>
            <code><![CDATA[
            int i;
            if(!AuDialog.ShowNumberInput(out i, "Example")) return;
            Print(i);
            ]]></code>
            </example>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowListEx(System.Object,System.String,System.String,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})">
            <summary>
            Shows dialog with a list of command-link buttons.
            Returns results packed in a <see cref="T:Au.Types.DResult"/> variable. Its Button property is id of the selected button, which is its 1-based index in the list; it is 0 if clicked the X (close window) button or pressed Esc.
            The return value can be assigned to an int variable or used in switch; then it is the id (1-based index or 0).
            </summary>
            <param name="list">List items (buttons). Can be string like "One|Two|Three" or string array/List/IEnumerable. See <see cref="M:Au.AuDialog.SetButtons(System.String,System.Boolean,System.Object)"/>.</param>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Text below main instruction.</param>
            <param name="flags"></param>
            <param name="owner">Owner window or null. See <see cref="M:Au.AuDialog.SetOwnerWindow(Au.Types.DOwner,System.Boolean,System.Boolean)"/>.</param>
            <param name="expandedText">Text that the user can show and hide.</param>
            <param name="footerText">Text at the bottom of the dialog. Icon can be specified like "i|Text", where i is: x error, ! warning, i info, v shield, a app.</param>
            <param name="title">Title bar text. If omitted, null or "", uses <see cref="P:Au.AuDialog.Options.DefaultTitle"/>.</param>
            <param name="checkBox">If not empty, shows a check box with this text. To make it checked, append "|true", "|check" or "|checked".</param>
            <param name="defaultButton">id (1-based index) of button that responds to the Enter key.</param>
            <param name="x">X position in <see cref="P:Au.AuDialog.Screen"/>. If null (default) - screen center. You also can use Coord.Reverse etc.</param>
            <param name="y">Y position in <see cref="P:Au.AuDialog.Screen"/>. If null (default) - screen center. You also can use Coord.Reverse etc.</param>
            <param name="secondsTimeout">If not 0, auto-close the dialog after this time, number of seconds.</param>
            <param name="onLinkClick">Enables hyperlinks in small-font text. A link-clicked event handler function, like with <see cref="M:Au.AuDialog.ShowEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.</param>
            <remarks>
            This function allows you to use most of the dialog features, but not all. Alternatively you can create a AuDialog class instance, set properties and call ShowDialog. Example in <see cref="T:Au.AuDialog"/> class help.
            </remarks>
            <example>
            <code><![CDATA[
            int r = AuDialog.ShowListEx("One|Two|Three", "Example", y: -1, secondsTimeout: 15);
            if(r <= 0) return; //X/Esc or timeout
            Print(r);
            ]]></code>
            </example>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowList(System.Object,System.String,System.String,Au.Types.DFlags,Au.Types.DOwner)">
            <summary>
            Shows dialog with a list of command-link buttons.
            Returns 1-based index of the selected button. Returns 0 if clicked the X (close window) button or pressed Esc.
            </summary>
            <param name="list">List items (buttons). Can be string like "One|Two|Three" or IEnumerable&lt;string&gt;. See <see cref="M:Au.AuDialog.SetButtons(System.String,System.Boolean,System.Object)"/>.</param>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Text below main instruction.</param>
            <param name="flags"></param>
            <param name="owner">Owner window or null. See <see cref="M:Au.AuDialog.SetOwnerWindow(Au.Types.DOwner,System.Boolean,System.Boolean)"/>.</param>
            <remarks>
            Calls <see cref="M:Au.AuDialog.ShowListEx(System.Object,System.String,System.String,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </remarks>
            <example>
            <code><![CDATA[
            int r = AuDialog.ShowList("One|Two|Three", "Example");
            if(r == 0) return; //X/Esc
            Print(r);
            ]]></code>
            </example>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowProgressEx(System.Boolean,System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.String,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})">
            <summary>
            Shows dialog with progress bar.
            Creates dialog in new thread and returns without waiting until it is closed.
            Returns <see cref="T:Au.AuDialog"/> variable that can be used to communicate with the dialog using these methods and properties: <see cref="P:Au.AuDialog.IsOpen"/>, <see cref="M:Au.AuDialog.ThreadWaitForClosed"/>, <see cref="P:Au.AuDialog.Result"/> (when closed), <see cref="P:Au.AuDialog.DialogWindow"/>, <see cref="P:Au.AuDialog.Send"/>; through the Send property you can set progress, modify controls and close the dialog (see example).
            Most parameters are the same as with <see cref="M:Au.AuDialog.ShowEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </summary>
            <param name="marquee">Let the progress bar animate without indicating a percent of work done.</param>
            <remarks>
            This function allows you to use most of the dialog features, but not all. Alternatively you can create a AuDialog class instance, set properties and call <see cref="M:Au.AuDialog.ShowDialogNoWait"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var pd = AuDialog.ShowProgressEx(false, "Working", buttons: "1 Stop", y: -1);
            for(int i = 1; i <= 100; i++) {
            	if(!pd.IsOpen) { Print(pd.Result); break; } //if the user closed the dialog
            	pd.Send.Progress(i); //don't need this if marquee
            	Thread.Sleep(50); //do something in the loop
            }
            pd.Send.Close();
            ]]></code>
            </example>
            <exception cref="T:Au.Types.AuException">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowProgress(System.Boolean,System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DOwner,Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Shows dialog with progress bar.
            Creates dialog in other thread and returns without waiting until it is closed.
            Returns <see cref="T:Au.AuDialog"/> variable that can be used to communicate with the dialog using these methods and properties: <see cref="P:Au.AuDialog.IsOpen"/>, <see cref="M:Au.AuDialog.ThreadWaitForClosed"/>, <see cref="P:Au.AuDialog.Result"/> (when closed), <see cref="P:Au.AuDialog.DialogWindow"/>, <see cref="P:Au.AuDialog.Send"/>; through the Send property you can set progress, modify controls and close the dialog (see example).
            All parameters except marquee are the same as with <see cref="M:Au.AuDialog.ShowEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </summary>
            <param name="marquee">Let the progress bar animate without indicating a percent of work done.</param>
            <remarks>
            Calls <see cref="M:Au.AuDialog.ShowProgressEx(System.Boolean,System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.String,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var pd = AuDialog.ShowProgress(false, "Working");
            for(int i = 1; i <= 100; i++) {
            	if(!pd.IsOpen) { Print(pd.Result); break; } //if the user closed the dialog
            	pd.Send.Progress(i); //don't need this if marquee
            	Thread.Sleep(50); //do something in the loop
            }
            pd.Send.Close();
            ]]></code>
            </example>
            <exception cref="T:Au.Types.AuException">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowNoWaitEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})">
            <summary>
            Shows dialog like <see cref="M:Au.AuDialog.ShowEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/> but does not wait.
            Creates dialog in other thread and returns without waiting until it is closed.
            Returns <see cref="T:Au.AuDialog"/> variable that can be used to communicate with the dialog using these methods and properties: <see cref="P:Au.AuDialog.IsOpen"/>, <see cref="M:Au.AuDialog.ThreadWaitForClosed"/>, <see cref="P:Au.AuDialog.Result"/> (when closed), <see cref="P:Au.AuDialog.DialogWindow"/>, <see cref="P:Au.AuDialog.Send"/>; through the Send property you can modify controls and close the dialog (see example).
            Parameters are the same as with <see cref="M:Au.AuDialog.ShowEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </summary>
            <remarks>
            This function allows you to use most of the dialog features, but not all. Alternatively you can create a AuDialog class instance, set properties and call <see cref="M:Au.AuDialog.ShowDialogNoWait"/>.
            </remarks>
            <example>
            <code><![CDATA[
            AuDialog.ShowNoWait("Simple example");
            
            var d = AuDialog.ShowNoWaitEx("Another example", "text", "1 OK|2 Cancel", y: -1, secondsTimeout: 30);
            2.s(); //do something while the dialog is open
            d.Send.ChangeText2("new text", false);
            2.s(); //do something while the dialog is open
            d.ThreadWaitClosed(); Print(d.Result); //wait until the dialog is closed and get result. Optional, just an example.
            ]]></code>
            </example>
            <exception cref="T:System.AggregateException">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.AuDialog.ShowNoWait(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner)">
            <summary>
            Shows dialog like <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String)"/> but does not wait.
            Creates dialog in other thread and returns without waiting until it is closed.
            Returns <see cref="T:Au.AuDialog"/> variable that can be used to communicate with the dialog using these methods and properties: <see cref="P:Au.AuDialog.IsOpen"/>, <see cref="M:Au.AuDialog.ThreadWaitForClosed"/>, <see cref="P:Au.AuDialog.Result"/> (when closed), <see cref="P:Au.AuDialog.DialogWindow"/>, <see cref="P:Au.AuDialog.Send"/>; through the Send property you can modify controls and close the dialog (see <see cref="M:Au.AuDialog.ShowNoWaitEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})">example</see>).
            Parameters are the same as with <see cref="M:Au.AuDialog.Show(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String)"/>.
            </summary>
            <remarks>
            Calls <see cref="M:Au.AuDialog.ShowNoWaitEx(System.String,System.String,System.String,Au.Types.DIcon,Au.Types.DFlags,Au.Types.DOwner,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </remarks>
            <exception cref="T:System.AggregateException">Failed to show dialog.</exception>
        </member>
        <member name="T:Au.CsvTable">
            <summary>
            Parses and composes CSV text. Stores CSV table data in memory as a List of string arrays.
            CSV is a text format used to store a single table of data in human-readable/editable way.
            It is a list of lines (called rows or records) containing one or more values (called fields or cells) separated by a separator character.
            There is no strictly defined CSV standard. CsvTable uses these rules:
            	Fields containg <see cref="P:Au.CsvTable.Separator"/> characters (default ','), <see cref="P:Au.CsvTable.Quote"/> characters (default '"') and multiple lines must be enclosed in <see cref="P:Au.CsvTable.Quote"/> characters. Example: "ab, cd".
            	Each Quote character in such fields must be escaped (replaced) with two <see cref="P:Au.CsvTable.Quote"/> characters. Example: "ab ""cd"" ef".
            	Fields that start or end with ASCII space or tab characters must be enclosed in <see cref="P:Au.CsvTable.Quote"/> characters, unless <see cref="P:Au.CsvTable.TrimSpaces"/> is false. Example: " ab ".
            	Rows in CSV text can have different field count.
            </summary>
        </member>
        <member name="M:Au.CsvTable.#ctor">
            
        </member>
        <member name="M:Au.CsvTable.#ctor(System.String)">
            <summary>
            Initializes a new <see cref="T:Au.CsvTable"/> instance and parses CSV text, the same as <see cref="M:Au.CsvTable.FromString(System.String)"/>.
            Uses default <see cref="P:Au.CsvTable.Separator"/>, <see cref="P:Au.CsvTable.Quote"/> and <see cref="P:Au.CsvTable.TrimSpaces"/> values (',', '"', true).
            </summary>
            <param name="csv">CSV text.</param>
            <exception cref="T:Au.Types.AuException">Invalid CSV, eg contains incorrectly enclosed fields.</exception>
        </member>
        <member name="P:Au.CsvTable.Data">
            <summary>
            Gets the internal List containing rows as string arrays.
            It's not a copy; changing it will change the data of this CsvTable variable.
            You can do anything with the List. For example, sort it, find rows containing certain field values, get/set field values directly, add/remove rows directly.
            All row arrays have Length equal to <see cref="P:Au.CsvTable.ColumnCount"/>, and it must remain so; you can change Length, but then need to call <c>ColumnCount=newLength</c>.
            </summary>
            <example><code>x.Data.Sort((a,b) => string.CompareOrdinal(a[0], b[0]));</code></example>
        </member>
        <member name="P:Au.CsvTable.Separator">
            <summary>
            Sets or gets the field separator character used when parsing and composing CSV text.
            Initially it is ','.
            </summary>
        </member>
        <member name="P:Au.CsvTable.Quote">
            <summary>
            Sets or gets the quote character used when parsing and composing CSV text.
            Initially it is '"'.
            </summary>
        </member>
        <member name="P:Au.CsvTable.TrimSpaces">
            <summary>
            Whether to ignore ASCII space and tab characters at the beginning and end of fields when parsing CSV.
            Initially true.
            </summary>
        </member>
        <member name="M:Au.CsvTable.FromString(System.String)">
            <summary>
            Parses CSV text and stores all data in internal List of string arrays.
            Depends on these properties: <see cref="P:Au.CsvTable.Separator"/> (initially ','), <see cref="P:Au.CsvTable.Quote"/> (initially '"'), <see cref="P:Au.CsvTable.TrimSpaces"/> (initially true).
            </summary>
            <param name="csv">
            CSV text.
            If rows in CSV text have different field count, the longest row sets the <see cref="P:Au.CsvTable.ColumnCount"/> property and all row array lenghts; array elements of missing CSV fields will be null.
            </param>
            <exception cref="T:Au.Types.AuException">Invalid CSV, eg contains incorrectly enclosed fields.</exception>
        </member>
        <member name="M:Au.CsvTable.ToString">
            <summary>
            Composes CSV text from the internal List of string arrays.
            Depends on these properties: <see cref="P:Au.CsvTable.Separator"/> (initially ','), <see cref="P:Au.CsvTable.Quote"/> (initially '"').
            </summary>
        </member>
        <member name="P:Au.CsvTable.RowCount">
            <summary>
            Gets or sets row count.
            The 'get' function simply returns the Count property of the internal List of string arrays.
            The 'set' function can add new rows or remove rows at the end.
            </summary>
        </member>
        <member name="P:Au.CsvTable.ColumnCount">
            <summary>
            Gets or sets column count.
            The 'get' function returns the length of all string arrays in the internal List.
            The 'set' function can add new columns or remove columns at the right.
            </summary>
        </member>
        <member name="P:Au.CsvTable.Item(System.Int32,System.Int32)">
            <summary>
            Gets or sets a field.
            </summary>
            <param name="row">0-based row index. With the 'set' function it can be negative or equal to <see cref="P:Au.CsvTable.RowCount"/>; then adds new row.</param>
            <param name="column">0-based column index. With the 'set' function it can be &gt;= <see cref="P:Au.CsvTable.ColumnCount"/> and &lt; 1000; then makes ColumnCount = column + 1.</param>
        </member>
        <member name="P:Au.CsvTable.Item(System.Int32)">
            <summary>
            Gets or sets fields in a row.
            The 'get' function gets the row array. It's not a copy; changing its elements will change the data of this CsvTable variable.
            The 'set' function sets the row array. Does not copy the array, unless its Length is less than <see cref="P:Au.CsvTable.ColumnCount"/>.
            </summary>
            <param name="row">0-based row index. With the 'set' function it can be negative or equal to <see cref="P:Au.CsvTable.RowCount"/>; then adds new row.</param>
        </member>
        <member name="M:Au.CsvTable.InsertRow(System.Int32,System.String[])">
            <summary>
            Inserts new row and sets its fields.
            </summary>
            <param name="index">0-based row index. If negative or equal to <see cref="P:Au.CsvTable.RowCount"/>, adds to the end.</param>
            <param name="fields">Row fields. Can be a string array or multiple string arguments. Does not copy the array, unless its Length is less than <see cref="P:Au.CsvTable.ColumnCount"/>. Adds new columns if array Length (or the number of string arguments) is greater than ColumnCount.</param>
        </member>
        <member name="M:Au.CsvTable.InsertRow(System.Int32)">
            <summary>
            Inserts new empty row.
            </summary>
            <param name="index">0-based row index. If negative or equal to <see cref="P:Au.CsvTable.RowCount"/>, adds to the end.</param>
        </member>
        <member name="M:Au.CsvTable.RemoveRow(System.Int32,System.Int32)">
            <summary>
            Removes one or more rows.
            </summary>
            <param name="index">0-based row index.</param>
            <param name="count">How many rows to remove, default 1.</param>
        </member>
        <member name="M:Au.CsvTable.FromFile(System.String)">
            <summary>
            Loads and parses a CSV file.
            Calls <see cref="M:System.IO.File.ReadAllText(System.String)"/> and <see cref="M:Au.CsvTable.FromString(System.String)"/>.
            </summary>
            <param name="file"></param>
        </member>
        <member name="M:Au.CsvTable.ToFile(System.String)">
            <summary>
            Composes CSV and saves to file.
            Calls <see cref="M:Au.CsvTable.ToString"/> and <see cref="M:System.IO.File.WriteAllText(System.String,System.String)"/>.
            </summary>
        </member>
        <member name="M:Au.CsvTable.SetInt(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sets an int number field.
            </summary>
            <param name="row"><see cref="P:Au.CsvTable.Item(System.Int32,System.Int32)"/></param>
            <param name="column"><see cref="P:Au.CsvTable.Item(System.Int32,System.Int32)"/></param>
            <param name="value">The number.</param>
            <param name="hex">Let the number be in hexadecimal format, like 0x3A.</param>
        </member>
        <member name="M:Au.CsvTable.GetInt(System.Int32,System.Int32)">
            <summary>
            Gets an int number field.
            </summary>
            <param name="row"><see cref="P:Au.CsvTable.Item(System.Int32,System.Int32)"/></param>
            <param name="column"><see cref="P:Au.CsvTable.Item(System.Int32,System.Int32)"/></param>
        </member>
        <member name="M:Au.CsvTable.SetDouble(System.Int32,System.Int32,System.Double)">
            <summary>
            Sets a double number field.
            </summary>
            <param name="row"><see cref="P:Au.CsvTable.Item(System.Int32,System.Int32)"/></param>
            <param name="column"><see cref="P:Au.CsvTable.Item(System.Int32,System.Int32)"/></param>
            <param name="value">The number.</param>
        </member>
        <member name="M:Au.CsvTable.GetDouble(System.Int32,System.Int32)">
            <summary>
            Gets a double number field.
            </summary>
            <param name="row"><see cref="P:Au.CsvTable.Item(System.Int32,System.Int32)"/></param>
            <param name="column"><see cref="P:Au.CsvTable.Item(System.Int32,System.Int32)"/></param>
        </member>
        <member name="T:Au.Time">
            <summary>
            Time functions. Get, wait, doevents, timer, precision.
            </summary>
        </member>
        <member name="P:Au.Time.Microseconds">
            <summary>
            Gets the number of microseconds elapsed since Windows startup.
            The precision is 1 microsecond.
            </summary>
            <remarks>
            Uses API <msdn>QueryPerformanceCounter</msdn>.
            Includes the computer sleep/hibernate time (see also <see cref="P:Au.Time.MillisecondsWithoutComputerSleepTime"/>). Independent of computer clock time changes.
            MSDN article: <msdn>Acquiring high-resolution time stamps</msdn>.
            </remarks>
        </member>
        <member name="P:Au.Time.Milliseconds">
            <summary>
            Gets the number of milliseconds elapsed since Windows startup.
            The precision is 1 millisecond.
            See also <see cref="P:Au.Time.Microseconds"/>.
            </summary>
            <remarks>
            Includes the computer sleep/hibernate time (see also <see cref="P:Au.Time.MillisecondsWithoutComputerSleepTime"/>). Independent of computer clock time changes.
            Unlike Environment.TickCount, this function is more precise and returns a 64-bit value that will not roll over in 100 years.
            </remarks>
        </member>
        <member name="P:Au.Time.MillisecondsWithoutComputerSleepTime">
            <summary>
            Gets the number of milliseconds elapsed since Windows startup, not including time the system spends in sleep or hibernation.
            The precision is 1-16 milliseconds.
            </summary>
            <remarks>
            Uses API <msdn>QueryUnbiasedInterruptTime</msdn>.
            Independent of computer clock time changes.
            This function can be used to implement a timeout in 'wait for' functions, when repeatedly checking a condition.
            </remarks>
        </member>
        <member name="M:Au.Time.WaitS(System.Double)">
            <summary>
            Suspends this thread for the specified amount of time.
            The same as <see cref="M:Au.Time.Sleep(System.Int32)"/>, but uses seconds, not milliseconds.
            </summary>
            <param name="seconds">
            Time to wait, seconds.
            The smallest value is 0.001 (1 ms).
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">seconds is less than 0 or greater than 2147483 (int.MaxValue/1000, 24.8 days).</exception>
            <remarks>
            Calls <see cref="M:System.Threading.Thread.Sleep(System.Int32)"/>.
            Does not process events and messages, therefore should not be used in threads with windows, timers or COM events. Supports asynchronous procedure calls.
            If the computer goes to sleep or hibernate during that time, the real time is seconds + the sleep/hibernate time.
            Tip: code <c>5.s();</c> is the same as <c>Time.WaitS(5);</c>.
            </remarks>
        </member>
        <member name="M:Au.Time.Sleep(System.Int32)">
            <summary>
            Suspends this thread for the specified amount of time.
            The same as <see cref="M:Au.Time.WaitS(System.Double)"/>, but uses milliseconds, not seconds; and supports Timeout.Infinite.
            </summary>
            <param name="milliseconds">
            Time to wait, milliseconds.
            If 0, can wait briefly if another busy thread runs on the same logical CPU, which happens not often on modern multi-core CPU.
            Also can be <see cref="F:System.Threading.Timeout.Infinite"/>.
            </param>
            <remarks>
            Calls <see cref="M:System.Threading.Thread.Sleep(System.Int32)"/>.
            Does not process events and messages, therefore should not be used with big milliseconds in threads with windows, timers or COM events. Supports asynchronous procedure calls.
            If the computer goes to sleep or hibernate during that time, the real time is milliseconds + the sleep/hibernate time.
            Tip: code <c>50.ms();</c> is the same as <c>Time.Sleep(50);</c>.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">milliseconds is negative and not Timeout.Infinite.</exception>
        </member>
        <member name="M:Au.Time.SleepDoEvents(System.Int32)">
            <summary>
            Partially suspends this thread for the specified amount of time, during which processes events and messages.
            </summary>
            <param name="milliseconds">
            The number of milliseconds to wait.
            The smallest value is 1.
            Also can be <see cref="F:System.Threading.Timeout.Infinite"/>.
            </param>
            <remarks>
            Unlike <see cref="M:Au.Time.Sleep(System.Int32)"/>, this function retrieves and dispatches all Windows messages, including posted (key/mouse input, window paint, timer and other). Also calls event handlers, hook procedures, etc. Supports asynchronous procedure calls.
            This function can be used in threads with windows. However usually there are better ways, for example timer, other thread, async/await/Task. Be careful, this function is as dangerous as <see cref="M:System.Windows.Forms.Application.DoEvents"/>. In some places does not work as expected, for example in Form/Control mouse event handlers .NET blocks other mouse events.
            In threads without windows and timers usually don't need to process posted messages, but in some cases need to process sent messages, some events, hooks etc. Then you can instead use <see cref="M:System.Threading.Thread.Join(System.Int32)"/>, like <c>Thread.CurrentThread.Join(1000);</c>.
            Calls API <msdn>MsgWaitForMultipleObjectsEx</msdn> and <see cref="M:Au.Time.DoEvents"/>.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">milliseconds is negative and not Timeout.Infinite.</exception>
            <exception cref="T:System.Exception">Any exceptions thrown by functions that are executed while waiting (event handlers etc).</exception>
            <seealso cref="T:Au.Util.MessageLoop"/>
        </member>
        <member name="M:Au.Time.DoEvents">
            <summary>
            Retrieves and dispatches messages from the message queue of current thread.
            </summary>
            <remarks>
            If this thread has a .NET message loop (<see cref="P:System.Windows.Forms.Application.MessageLoop"/>), calls <see cref="M:System.Windows.Forms.Application.DoEvents"/>.
            Else uses more lightweight API functions <msdn>PeekMessage</msdn>, <msdn>TranslateMessage</msdn> and <msdn>DispatchMessage</msdn>.
            Be careful, this function is as dangerous as <see cref="M:System.Windows.Forms.Application.DoEvents"/>.
            </remarks>
            <exception cref="T:System.Exception">Any exceptions thrown by functions that are executed while dispatching messages (event handlers etc).</exception>
        </member>
        <member name="M:Au.Time.s(System.Int32)">
            <summary>
            Calls <see cref="M:Au.Time.WaitS(System.Double)"/>.
            Example: <c>5.s();</c> is the same as <c>Time.WaitS(5);</c>.
            </summary>
        </member>
        <member name="M:Au.Time.s(System.Double)">
            <summary>
            Calls <see cref="M:Au.Time.WaitS(System.Double)"/>.
            Example: <c>2.5.s();</c> is the same as <c>Time.WaitS(2.5);</c>.
            </summary>
        </member>
        <member name="M:Au.Time.ms(System.Int32)">
            <summary>
            Calls <see cref="M:Au.Time.Sleep(System.Int32)"/>.
            Example: <c>50.ms();</c> is the same as <c>Time.Sleep(50);</c>.
            </summary>
        </member>
        <member name="T:Au.Time.LibSleepPrecision">
            <summary>
            Temporarily changes the time resolution/precision of Thread.Sleep and some other functions.
            </summary>
            <remarks>
            Uses API <msdn>timeBeginPeriod</msdn>, which requests a time resolution for various system timers and wait functions. Actually it is the system thread scheduling timer period.
            Normal resolution on Windows 7-10 is 15.625 ms. It means that, for example, <c>Thread.Sleep(1);</c> sleeps not 1 but 1-15 ms. If you set resolution 1, it sleeps 1-2 ms.
            The new resolution is revoked (<msdn>timeEndPeriod</msdn>) when disposing the LibSleepPrecision variable or when this process ends. See example. See also <see cref="M:Au.Time.LibSleepPrecision.TempSet1(System.Int32)"/>.
            The resolution is applied to all threads and processes. Other applications can change it too. For example, often web browsers temporarily set resolution 1 ms when opening a web page.
            The system uses the smallest period (best resolution) that currently is set by any application. You cannot make it bigger than current value.
            <note>It is not recommended to keep small period (high resolution) for a long time. It can be bad for power saving.</note>
            Don't need this for Time.Sleep, Time.WaitS, Time.SleepDoEvents and functions that use them (Mouse.Click etc). They call <see cref="M:Au.Time.LibSleepPrecision.TempSet1(System.Int32)"/> when the sleep time is 1-99 ms.
            This does not change the minimal period of <see cref="T:Au.Timer_"/> and System.Windows.Forms.Timer.
            </remarks>
            <example>
            <code><![CDATA[
            _Test("before");
            using(new Time.LibSleepPrecision(2)) {
            	_Test("in");
            }
            _Test("after");
            
            void _Test(string name)
            {
            	Print(name);
            	Perf.First();
            	for(int i = 0; i < 8; i++) { Thread.Sleep(1); Perf.Next(); }
            	Perf.Write();
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Time.LibSleepPrecision.#ctor(System.Int32)">
            <summary>
            Calls API <msdn>timeBeginPeriod</msdn>.
            </summary>
            <param name="periodMS">
            New system timer period, milliseconds.
            Should be 1. Other values may stuck and later cannot be made smaller due to bugs in OS or some applications; this bug would impact many functions of this library.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">periodMS &lt;= 0.</exception>
        </member>
        <member name="M:Au.Time.LibSleepPrecision.Dispose">
            <summary>
            Calls API <msdn>timeEndPeriod</msdn>.
            </summary>
        </member>
        <member name="M:Au.Time.LibSleepPrecision.Finalize">
            
        </member>
        <member name="P:Au.Time.LibSleepPrecision.Current">
            <summary>
            Gets current actual system time resolution (period).
            The return value usually is between 0.5 and 15.625 milliseconds. Returns 0 if fails.
            </summary>
        </member>
        <member name="M:Au.Time.LibSleepPrecision.TempSet1(System.Int32)">
            <summary>
            Temporarily sets the system wait precision to 1 ms. It will be revoked after the specified time or when this appdomain ends.
            If already set, just updates the revoking time.
            </summary>
            <param name="endAfterMS">Revoke after this time, milliseconds.</param>
            <example>
            <code><![CDATA[
            Print(Time.LibSleepPrecision.Current); //probably 15.625
            Time.LibSleepPrecision.TempSet1(500);
            Print(Time.LibSleepPrecision.Current); //1
            Thread.Sleep(600);
            Print(Time.LibSleepPrecision.Current); //probably 15.625 again
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Time.LibSleepPrecision.LibTempSet1(System.Int32)">
            <summary>
            Calls TempSetMax if sleepTimeMS is 1-99.
            </summary>
            <param name="sleepTimeMS">milliseconds of the caller 'sleep' function.</param>
        </member>
        <member name="T:Au.Timer_">
            <summary>
            Timer that uses API <msdn>SetTimer</msdn> and API <msdn>KillTimer</msdn>.
            Similar to System.Windows.Forms.Timer, but more lightweight, for example does not create a hidden window.
            Use in UI threads (need a message loop).
            </summary>
            <example>
            <code><![CDATA[
            //this example sets 3 timers
            Timer_.After(500, t => Print("simple one-time timer"));
            Timer_.Every(1000, t => Print("simple periodic timer"));
            var t3 = new Timer_(t => Print("with Timer_ object")); t3.Start(3000, true); //the same as Timer_.After
            MessageBox.Show("");
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Timer_.Tag">
            <summary>
            Some object or value attached to this Timer_ variable.
            </summary>
        </member>
        <member name="M:Au.Timer_.#ctor(System.Action{Au.Timer_},System.Object)">
            <summary>
            Initializes a new <see cref="T:Au.Timer_"/> instance.
            </summary>
        </member>
        <member name="M:Au.Timer_.Start(System.Int32,System.Boolean)">
            <summary>
            Starts timer. If already started, resets and changes its period.
            </summary>
            <param name="intervalMS">Time interval (period) of calling the callback function, milliseconds.</param>
            <param name="singlePeriod">Call the callback function once, not repeatedly. The timer will be stopped before calling the callback function.</param>
            <remarks>
            If already started, this function must be called in same thread.
            </remarks>
            <exception cref="T:System.ComponentModel.Win32Exception">API <msdn>SetTimer</msdn> returned 0. Unlikely.</exception>
        </member>
        <member name="M:Au.Timer_.Stop">
            <summary>
            Stops the timer.
            </summary>
            <remarks>
            Your callback function will never be called after this, even if a timer period is elapsed.
            Later you can call Start() again.
            Calling Stop() is optional.
            Must be called in same thread.
            </remarks>
        </member>
        <member name="M:Au.Timer_.After(System.Int32,System.Action{Au.Timer_},System.Object)">
            <summary>
            Sets new one-time timer.
            Returns new <see cref="T:Au.Timer_"/> object that can be used to modify timer properties if you want to do it not in the callback function; usually don't need it.
            </summary>
            <param name="milliseconds">Time after which will be called the callback function, milliseconds. Can be 1 to int.MaxValue. The actual minimal time usually is 10-20.</param>
            <param name="callback">A callback function (delegate), for example lambda.</param>
            <param name="tag">Something to pass to the callback function as Timer_.Tag.</param>
            <remarks>
            The callback function will be called in this thread.
            This thread must must get/dispatch posted messages, eg call Application.Run() or Form.ShowModal() or AuDialog.Show(). The callback function is not called while this thread does not do it.
            </remarks>
        </member>
        <member name="M:Au.Timer_.Every(System.Int32,System.Action{Au.Timer_},System.Object)">
            <summary>
            Sets new periodic timer.
            Returns new <see cref="T:Au.Timer_"/> object that can be used to modify timer properties if you want to do it not in the callback function; usually don't need it.
            </summary>
            <param name="periodMS">Time interval (period) of calling the callback function, milliseconds. Can be 1 to int.MaxValue. The actual minimal period usually is 10-20.</param>
            <param name="callback">A callback function (delegate), for example lambda.</param>
            <param name="tag">Something to pass to the callback function as Timer_.Tag.</param>
            <remarks>
            The callback function will be called in this thread.
            This thread must must get/dispatch posted messages, eg call Application.Run() or Form.ShowModal() or AuDialog.Show(). The callback function is not called while this thread does not do it.
            </remarks>
        </member>
        <member name="T:Au.WaitFor">
            <summary>
            Contains functions to wait for a condition, such as 'window exists'.
            </summary>
            <remarks>
            All functions have a <i>secondsTimeout</i> parameter. It is the maximal time to wait, seconds. If it is 0, waits indefinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, after that time interval stops waiting and returns default value (false, default(Wnd), etc).
            
            While waiting, messages and events are not processed. For example, if used in a Form/Control event handler, the form would stop responding. Then need to use another thread, for example async/await/Task, like in the example.
            </remarks>
            <example>
            <code><![CDATA[
            Wnd w = WaitFor.WindowExists(10, "* Notepad");
            Print(w);
            ]]></code>
            Using in a Form/Control event handler.
            <code><![CDATA[
            var f = new Form();
            f.Click += async (unu, sed) =>
              {
            	  Print("waiting for Notepad...");
            	  Wnd w = await Task.Run(() => WaitFor.WindowExists(-10, "* Notepad"));
            	  if(w.Is0) Print("timeout"); else Print(w);
              };
            f.ShowDialog();
            ]]></code>
            </example>
        </member>
        <member name="T:Au.WaitFor.LibTimeout">
            <summary>
            Can be used to easily implement timeout in wait-for functions.
            See how it is used eg in <see cref="M:Au.WaitFor.Condition(System.Double,System.Func{System.Object,System.Boolean},System.Object,System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="P:Au.WaitFor.LibTimeout.Period">
            <summary>
            Current period, milliseconds.
            Initially it is constructor->initPeriod (default 10). The Sleep method increments it until reached MaxPeriod.
            </summary>
        </member>
        <member name="P:Au.WaitFor.LibTimeout.MaxPeriod">
            <summary>
            Maximal period, milliseconds.
            It is constructor->maxPeriod (default 500).
            </summary>
        </member>
        <member name="P:Au.WaitFor.LibTimeout.TimeRemaining">
            <summary>
            Remaining time, milliseconds.
            </summary>
        </member>
        <member name="M:Au.WaitFor.LibTimeout.IsTimeout">
            <summary>
            If the timeout is not expired, returns false.
            Else if constructor->secondsTimeout was negative, returns true.
            Else throws TimeoutException.
            Also gets current time and updates private fields, if need.
            </summary>
        </member>
        <member name="M:Au.WaitFor.LibTimeout.Sleep">
            <summary>
            If IsTimeout(), returns false.
            Else sleeps for Period milliseconds, increments Period if it is less than MaxPeriod, and returns true.
            </summary>
        </member>
        <member name="M:Au.WaitFor.Condition(System.Double,System.Func{System.Object,System.Boolean},System.Object,System.Int32,System.Int32)">
            <summary>
            Waits for an user-defined condition.
            Returns true. On timeout returns false if <paramref name="secondsTimeout"/> is negative; else exception.
            </summary>
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits indefinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, after that time interval returns false.
            </param>
            <param name="condition">Callback function (eg lambda). It is called repeatedly, until returns true.</param>
            <param name="param">Something to pass to the callback function.</param>
            <param name="minPeriod">The initial period of calling the callback function, in milliseconds.</param>
            <param name="maxPeriod">The maximal period of calling the callback function, in milliseconds. The period is incremented by 1 millisecond in each loop until it reaches maxPeriod. It gives a good response time initially, and small CPU usage after some time.</param>
            <exception cref="T:System.TimeoutException"><paramref name="secondsTimeout"/> time has expired (if &gt; 0).</exception>
            <exception cref="T:System.ArgumentException">minPeriod &lt; 1 or maxPeriod &lt; minPeriod.</exception>
            <exception cref="T:System.Exception">Exceptions thrown by the condition callback function.</exception>
        </member>
        <member name="M:Au.WaitFor.NoModifierKeys(System.Double,System.Windows.Forms.Keys)">
            <summary>
            Waits while some modifier keys (Ctrl, Shift, Alt, Win) are in pressed state.
            Returns true. On timeout returns false if <paramref name="secondsTimeout"/> is negative; else exception.
            </summary>
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits indefinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, after that time interval returns false.
            </param>
            <param name="modifierKeys">Wait only for these keys. One or more of these flags: Keys.Control, Keys.Shift, Keys.Menu, Keys_.Windows. Default - all.</param>
            <exception cref="T:System.TimeoutException"><paramref name="secondsTimeout"/> time has expired (if &gt; 0).</exception>
            <exception cref="T:System.ArgumentException">modifierKeys is 0 or contains non-modifier keys.</exception>
            <seealso cref="M:Au.Input.IsModified(System.Windows.Forms.Keys)"/>
        </member>
        <member name="M:Au.WaitFor.NoMouseButtons(System.Double,System.Windows.Forms.MouseButtons)">
            <summary>
            Waits while some mouse buttons are in pressed state.
            Returns true. On timeout returns false if <paramref name="secondsTimeout"/> is negative; else exception.
            </summary>
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits indefinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, after that time interval returns false.
            </param>
            <param name="buttons">Wait only for these buttons. Default - all.</param>
            <exception cref="T:System.TimeoutException"><paramref name="secondsTimeout"/> time has expired (if &gt; 0).</exception>
            <seealso cref="M:Au.Mouse.IsPressed(System.Windows.Forms.MouseButtons)"/>
        </member>
        <member name="M:Au.WaitFor.NoModifierKeysAndMouseButtons(System.Double,System.Windows.Forms.Keys,System.Windows.Forms.MouseButtons)">
            <summary>
            Waits while some modifier keys (Ctrl, Shift, Alt, Win) or mouse buttons are in pressed state.
            Returns true. On timeout returns false if <paramref name="secondsTimeout"/> is negative; else exception.
            </summary>
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits indefinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, after that time interval returns false.
            </param>
            <param name="modifierKeys">Wait only for these keys. One or more of these flags: Keys.Control, Keys.Shift, Keys.Menu, Keys_.Windows. Default - all.</param>
            <param name="buttons">Wait only for these buttons. Default - all.</param>
            <exception cref="T:System.TimeoutException"><paramref name="secondsTimeout"/> time has expired (if &gt; 0).</exception>
            <exception cref="T:System.ArgumentException">modifierKeys is 0 or contains non-modifier keys.</exception>
            <seealso cref="M:Au.Input.IsModified(System.Windows.Forms.Keys)"/>
        </member>
        <member name="M:Au.WaitFor.WindowExists(System.Double,System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object,System.Boolean)">
            <summary>
            Waits until window exists and (optionally) is visible. Or the opposite, if <paramref name="not"/> is true.
            Returns window handle. On timeout returns default(Wnd) if <paramref name="secondsTimeout"/> is negative; else exception.
            All undocumented parameters etc are the same as <see cref="M:Au.Wnd.Find(System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>.
            </summary>
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits indefinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, after that time interval returns default(Wnd).
            </param>
            <param name="name"></param>
            <param name="className"></param>
            <param name="programEtc"></param>
            <param name="flags"></param>
            <param name="also"></param>
            <param name="contains"></param>
            <param name="not">
            Do the opposite - wait until no such windows exist.
            The return value is opposite too. If succeeded - default(Wnd). If timeout - a matching window (if no exception).
            If you have a window's Wnd variable, use <see cref="M:Au.WaitFor.WindowClosed(Au.Wnd,System.Double)"/> or <see cref="M:Au.WaitFor.WindowVisible(Au.Wnd,System.Double,System.Boolean)"/> instead.
            </param>
            <exception cref="T:System.TimeoutException"><paramref name="secondsTimeout"/> time has expired.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Wnd.Find(System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>.</exception>
            <remarks>
            By default ignores invisible windows. Use flag HiddenToo if need.
            </remarks>
            <example>
            <code><![CDATA[
            Wnd w = WaitFor.WindowExists(10, "* Notepad");
            Print(w);
            ]]></code>
            Using in a Form/Control event handler.
            <code><![CDATA[
            var f = new Form();
            f.Click += async (unu, sed) =>
              {
            	  Print("waiting for Notepad...");
            	  Wnd w = await Task.Run(() => WaitFor.WindowExists(-10, "* Notepad"));
            	  if(w.Is0) Print("timeout"); else Print(w);
              };
            f.ShowDialog();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.WaitFor.WindowExists(Au.Wnd.Finder,System.Double,System.Boolean)">
            <summary>
            The same as <see cref="M:Au.WaitFor.WindowExists(System.Double,System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object,System.Boolean)"/>, just arguments are passed differently.
            </summary>
            <param name="f">Window properties etc.</param>
            <param name="secondsTimeout"></param>
            <param name="not"></param>
            <exception cref="T:System.TimeoutException"><paramref name="secondsTimeout"/> time has expired.</exception>
        </member>
        <member name="M:Au.WaitFor.WindowActive(System.Double,System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object,System.Boolean)">
             <summary>
             Waits until window exists and is the active window. Or the opposite, if <paramref name="not"/> is true.
             Returns window handle. On timeout returns default(Wnd) if <paramref name="secondsTimeout"/> is negative; else exception.
             All undocumented parameters etc are the same as <see cref="M:Au.Wnd.Find(System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>.
             If you have a window's Wnd, use <see cref="M:Au.WaitFor.WindowActive(Au.Wnd,System.Double,System.Boolean)"/> instead.
             </summary>
             <param name="secondsTimeout"></param>
             <param name="name"></param>
             <param name="className"></param>
             <param name="programEtc"></param>
             <param name="flags"></param>
             <param name="also"></param>
             <param name="contains"></param>
             <param name="not">
             Do the opposite - wait until the window is not the active window or does not exist.
             The return value is always default(Wnd).
             </param>
             <exception cref="T:System.TimeoutException"><paramref name="secondsTimeout"/> time has expired.</exception>
             <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Wnd.Find(System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>.</exception>
             <remarks>
             Hidden and minimized windows also can be active. This function by default waits until the window is active and visible. To ignore visibility, use flag <see cref="F:Au.Types.WFFlags.HiddenToo"/>. To wait until the window also is not minimized, use the 'also' parameter, like in the example.
            
             More examples: see <see cref="M:Au.WaitFor.WindowExists(System.Double,System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object,System.Boolean)"/>.
             </remarks>
             <example>
             <code><![CDATA[
             Wnd w = WaitFor.WindowActive(60, "*- Notepad", also: t => !t.IsMinimized);
             Print(w);
             ]]></code>
             </example>
        </member>
        <member name="M:Au.WaitFor.WindowActive(Au.Wnd.Finder,System.Double,System.Boolean)">
            <summary>
            The same as <see cref="M:Au.WaitFor.WindowActive(System.Double,System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object,System.Boolean)"/>, just arguments are passed differently.
            </summary>
            <param name="f">Window properties etc.</param>
            <param name="secondsTimeout"></param>
            <param name="not"></param>
            <exception cref="T:System.TimeoutException"><paramref name="secondsTimeout"/> time has expired.</exception>
        </member>
        <member name="M:Au.WaitFor.WindowActive(Au.Wnd,System.Double,System.Boolean)">
            <summary>
            Waits until the window is the active window. Or the opposite, if <paramref name="not"/> is true.
            Returns true. On timeout returns false if <paramref name="secondsTimeout"/> is negative; else exception.
            Uses <see cref="P:Au.Wnd.IsActive"/>.
            </summary>
            <param name="w">A window or control.</param>
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits indefinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, after that time interval returns false.
            </param>
            <param name="not">Do the opposite - wait until the window is inactive or closed (no exception if closed/default(Wnd)/invalid).</param>
            <exception cref="T:System.TimeoutException"><paramref name="secondsTimeout"/> time has expired.</exception>
            <exception cref="T:Au.Types.WndException">w is default(Wnd)/invalid or the window was closed while waiting.</exception>
        </member>
        <member name="M:Au.WaitFor.WindowVisible(Au.Wnd,System.Double,System.Boolean)">
            <summary>
            Waits until the window is visible. Or the opposite, if <paramref name="not"/> is true.
            Returns true. On timeout returns false if <paramref name="secondsTimeout"/> is negative; else exception.
            Uses <see cref="P:Au.Wnd.IsVisibleEx"/>.
            For 'exists and is visible' use <see cref="M:Au.WaitFor.WindowExists(System.Double,System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object,System.Boolean)"/>. With default flags it waits for visible window and ignores invisible windows.
            </summary>
            <param name="w">A window or control.</param>
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits indefinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, after that time interval returns false.
            </param>
            <param name="not">Do the opposite - wait until the window is invisible or closed (no exception if closed/default(Wnd)/invalid).</param>
            <exception cref="T:System.TimeoutException"><paramref name="secondsTimeout"/> time has expired.</exception>
            <exception cref="T:Au.Types.WndException">w is default(Wnd)/invalid or the window was closed while waiting.</exception>
        </member>
        <member name="M:Au.WaitFor.WindowEnabled(Au.Wnd,System.Double,System.Boolean)">
            <summary>
            Waits until the window is enabled (not disabled). Or the opposite, if <paramref name="not"/> is true.
            Returns true. On timeout returns false if <paramref name="secondsTimeout"/> is negative; else exception.
            Uses <see cref="P:Au.Wnd.IsEnabled"/>.
            </summary>
            <param name="w">A window or control.</param>
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits indefinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, after that time interval returns false.
            </param>
            <param name="not">Do the opposite - wait until the window is disabled or closed (no exception if closed/default(Wnd)/invalid).</param>
            <exception cref="T:System.TimeoutException"><paramref name="secondsTimeout"/> time has expired.</exception>
            <exception cref="T:Au.Types.WndException">w is default(Wnd)/invalid or the window was closed while waiting.</exception>
        </member>
        <member name="M:Au.WaitFor.WindowClosed(Au.Wnd,System.Double)">
            <summary>
            Waits until the window handle is invalid.
            Returns true. On timeout returns false if <paramref name="secondsTimeout"/> is negative; else exception.
            Uses <see cref="P:Au.Wnd.IsAlive"/>.
            </summary>
            <param name="w">A window or control. Can be default(Wnd)/invalid.</param>
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits indefinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, after that time interval returns false.
            </param>
            <exception cref="T:System.TimeoutException"><paramref name="secondsTimeout"/> time has expired.</exception>
        </member>
        <member name="M:Au.WaitFor.WindowChildExists(Au.Wnd,Au.Wnd.ChildFinder,System.Double,System.Boolean)">
            <summary>
            Waits until control (child window) exists in the window. Or the opposite, if <paramref name="not"/> is true.
            Returns the control. On timeout returns default(Wnd) if <paramref name="secondsTimeout"/> is negative; else exception.
            Uses <see cref="P:Au.Wnd.IsEnabled"/>.
            </summary>
            <param name="w">Direct or indirect parent window.</param>
            <param name="control">Control properties.</param>
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits indefinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, after that time interval returns default(Wnd).
            </param>
            <param name="not">
            Do the opposite - wait until the control not found, or until the window closed (no exception if closed/default(Wnd)/invalid).
            The return value is opposite too. If succeeded - default(Wnd). If timeout - a matching control (if no exception).
            If you have a control's Wnd variable, use <see cref="M:Au.WaitFor.WindowClosed(Au.Wnd,System.Double)"/> or <see cref="M:Au.WaitFor.WindowVisible(Au.Wnd,System.Double,System.Boolean)"/> instead.
            </param>
            <exception cref="T:System.TimeoutException"><paramref name="secondsTimeout"/> time has expired.</exception>
            <exception cref="T:Au.Types.WndException">w is default(Wnd)/invalid or the window was closed while waiting.</exception>
            <example>
            <code><![CDATA[
            Wnd w = Wnd.Find("Options");
            var f = new Wnd.ChildFinder("Password*", "Static"); //control properties
            Wnd c = WaitFor.WindowChildExists(w, f);
            Print(c);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.WaitFor.WindowCondition(Au.Wnd,System.Func{Au.Wnd,System.Boolean},System.Double,System.Boolean)">
            <summary>
            Waits for an user-defined condition of an existing window.
            Returns true. On timeout returns false if <paramref name="secondsTimeout"/> is negative; else exception.
            </summary>
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits indefinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, after that time interval returns false.
            </param>
            <param name="w">An existing window. It is passed to the callback function.</param>
            <param name="condition">Callback function (eg lambda). It is called repeatedly, until returns true.</param>
            <param name="doNotThrowIfClosed">
            Do not throw exception if w is invalid or the window was closed while waiting.
            In such case the callback function must return false. If need, it can use <see cref="P:Au.Wnd.IsAlive"/>, like in the example. Else the exception is thrown (with a small delay) to prevent infinite waiting.
            </param>
            <exception cref="T:System.TimeoutException"><paramref name="secondsTimeout"/> time has expired.</exception>
            <exception cref="T:Au.Types.WndException">w is invalid or the window was closed while waiting.</exception>
            <example>
            <code><![CDATA[
            Wnd w = Wnd.Find("* Notepad");
            
            //wait max 30 s until window w is active. Exception on timeout or if closed.
            WaitFor.WindowCondition(w, t => t.IsActive); //the same as WaitFor.WindowActive(w, 30);
            Print("active");
            
            //wait indefinitely until window w is minimized or closed
            WaitFor.WindowCondition(w, t => t.IsMinimized || !t.IsAlive, 0, true);
            if(!w.IsAlive) { Print("closed"); return; }
            Print("minimized");
            ]]></code>
            </example>
        </member>
        <member name="T:Au.Wnd">
            <summary>
            A variable of Wnd type represents a window or control. It is a window handle, also known as HWND.
            Wnd functions can be used with windows and controls of any process/thread.
            Wnd functions also can be used with .NET form/control and WPF window class variables, like <c>Wnd w=(Wnd)form; w.Method(...);</c> or <c>((Wnd)form).Method(...);</c>.
            </summary>
            <remarks>
            There are two main types of windows - top-level windows and controls. Controls are child windows of top-level windows.
            
            More functions are in the nested classes - <see cref="T:Au.Wnd.Misc"/>, <see cref="T:Au.Wnd.Misc.Desktop"/> etc. They are used mostly in programming, rarely in automation scripts.
            
            What happens when a Wnd function fails:
            <list type="bullet">
            <item>Functions that get window properties don't throw exceptions. They return false/0/null/empty. Most of them support <see cref="M:Au.Types.Native.GetError"/>, and it is mentioned in function documentation.</item>
            <item>Many functions that change window properties throw exception. Exceptions are listed in function documentation. Almost all these functions throw only <see cref="T:Au.Types.WndException"/>.</item>
            <item>Other functions that change window properties return false. They are more often used in programming than in automation scripts.</item>
            <item>When a 'find' function does not find the window or control, it returns default(Wnd) (window handle 0). Then <see cref="P:Au.Wnd.Is0"/> will return true.</item>
            <item>If a function does not follow these rules, it is mentioned in function documentation.</item>
            </list>
            
            Many functions fail if the window's process has a higher <see cref="T:Au.Process_.UacInfo">UAC integrity level</see> (aministrator, uiAccess) than this process, unless this process has uiAccess level. Especially the functions that change window properties. Some functions that still work: Activate, ActivateLL, ShowMinimized, ShowNotMinimized, ShowNotMinMax, Close.
            
            The Wnd type can be used with native Windows API functions without casting. Use Wnd for the parameter type in the declaration, like <c>[DllImport(...)] static extern bool NativeFunction(Wnd hWnd, ...)</c>.
            
            See also: MSDN article <msdn>Window Features</msdn>.
            </remarks>
            <example>
            <code><![CDATA[
            Wnd w = Wnd.Find("* - Notepad");
            if(w.Is0) { Print("window not found"); return; }
            w.Activate();
            Wnd c = w.Child(className: "Edit");
            Print(c.Name);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Wnd.op_Explicit(System.Windows.Forms.Control)~Au.Wnd">
            <summary>
            Gets the window handle as Wnd from a System.Windows.Forms.Control (or Form etc) variable.
            Returns default(Wnd) if c is null.
            If the handle is still not created, the Control auto-creates it (hidden window).
            </summary>
        </member>
        <member name="M:Au.Wnd.op_Explicit(System.Windows.Window)~Au.Wnd">
            <summary>
            Gets the window handle as Wnd from a System.Windows.Window variable (WPF window).
            Returns default(Wnd) if w is null or the handle is still not created.
            </summary>
        </member>
        <member name="M:Au.Wnd.op_Equality(Au.Wnd,Au.Wnd)">
            <summary>Compares window handles.</summary>
        </member>
        <member name="M:Au.Wnd.op_Inequality(Au.Wnd,Au.Wnd)">
            <summary>Compares window handles.</summary>
        </member>
        <member name="M:Au.Wnd.op_UnaryPlus(Au.Wnd)">
            <summary>
            If x is not default(Wnd), returns x, else throws <see cref="T:Au.Types.NotFoundException"/>.
            Alternatively you can use <see cref="M:Au.Types.ExtensionMethods.OrThrow(Au.Wnd)"/>. Examples are there.
            </summary>
            <exception cref="T:Au.Types.NotFoundException">x is default(Wnd).</exception>
        </member>
        <member name="M:Au.Wnd.Equals(Au.Wnd)">
            <summary>
            Returns true if w == this.
            </summary>
        </member>
        <member name="M:Au.Wnd.Equals(System.Nullable{Au.Wnd})">
            <summary>
            Returns true if w != null and w.Value == this.
            </summary>
        </member>
        <member name="M:Au.Wnd.Equals(System.Object)">
            <summary>
            Returns true if obj is this Wnd.
            </summary>
        </member>
        <member name="M:Au.Wnd.GetHashCode">
            
        </member>
        <member name="P:Au.Wnd.Handle">
            <summary>
            Gets window handle as IntPtr.
            Code <c>w.Handle</c> is the same as <c>(IntPtr)w</c> .
            </summary>
        </member>
        <member name="M:Au.Wnd.ToString">
            <summary>
            Formats string $"{handle}  {ClassName}  \"{Name}\"  {ProcessName}  {Rect}".
            </summary>
        </member>
        <member name="M:Au.Wnd.Send(System.UInt32,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>
            Calls API <msdn>SendMessage</msdn>.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.SendS(System.UInt32,Au.Types.LPARAM,System.String)">
            <summary>
            Calls API <msdn>SendMessage</msdn> where lParam is string.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.SendS(System.UInt32,Au.Types.LPARAM,System.Char[])">
            <summary>
            Calls API <msdn>SendMessage</msdn> where lParam is char[].
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.SendTimeout(System.Int32,System.UInt32,Au.Types.LPARAM,Au.Types.LPARAM,System.UInt32)">
            <summary>
            Calls API <msdn>SendMessageTimeout</msdn>.
            Returns its return value (false if failed). Supports <see cref="M:Au.Types.Native.GetError"/>.
            flags can be Native.SMTO_.
            </summary>
        </member>
        <member name="M:Au.Wnd.SendTimeout(System.Int32,Au.Types.LPARAM@,System.UInt32,Au.Types.LPARAM,Au.Types.LPARAM,System.UInt32)">
            <summary>
            Calls API <msdn>SendMessageTimeout</msdn> and gets the result of the message processing.
            Returns its return value (false if failed). Supports <see cref="M:Au.Types.Native.GetError"/>.
            flags can be Native.SMTO_.
            </summary>
        </member>
        <member name="M:Au.Wnd.SendTimeoutS(System.Int32,Au.Types.LPARAM@,System.UInt32,Au.Types.LPARAM,System.String,System.UInt32)">
            <summary>
            Calls API <msdn>SendMessageTimeout</msdn> where lParam is string.
            Returns its return value (false if failed). Supports <see cref="M:Au.Types.Native.GetError"/>.
            flags can be Native.SMTO_.
            </summary>
        </member>
        <member name="M:Au.Wnd.SendTimeoutS(System.Int32,Au.Types.LPARAM@,System.UInt32,Au.Types.LPARAM,System.Char[],System.UInt32)">
            <summary>
            Calls API <msdn>SendMessageTimeout</msdn> where lParam is char[].
            Returns its return value (false if failed). Supports <see cref="M:Au.Types.Native.GetError"/>.
            flags can be Native.SMTO_.
            </summary>
        </member>
        <member name="M:Au.Wnd.SendNotify(System.UInt32,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>
            Calls API <msdn>SendNotifyMessage</msdn>.
            Returns its return value (false if failed). Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
        </member>
        <member name="M:Au.Wnd.Post(System.UInt32,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>
            Calls API <msdn>PostMessage</msdn>.
            Returns its return value (false if failed). Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <seealso cref="M:Au.Wnd.Misc.PostThreadMessage(System.UInt32,Au.Types.LPARAM,Au.Types.LPARAM)"/>
        </member>
        <member name="T:Au.Wnd.Misc">
            <summary>
            Contains miscellaneous static window-related functions and classes, rarely used or useful only for programmers.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.PostThreadMessage(System.UInt32,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>
            Posts a message to the message queue of this thread.
            Calls API <msdn>PostMessage</msdn> with default(Wnd). 
            Returns its return value (false if failed). Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.PostThreadMessage(System.UInt32,System.UInt32,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>
            Posts a message to the message queue of the specified thread.
            Calls API <msdn>PostThreadMessage</msdn>. 
            Returns its return value (false if failed). Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.WaitForAnActiveWindow">
            <summary>
            Waits while there is no active window.
            It sometimes happens after closing, minimizing or switching the active window, briefly until another window becomes active.
            Waits max 500 ms, then returns false if there is no active window.
            Processes Windows messages that are in the message queue of this thread.
            Don't need to call this after calling functions of this library.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.EnableActivate">
            <summary>
            Temporarily enables this process to activate windows with API <msdn>SetForegroundWindow</msdn>.
            Returns false if fails (unlikely).
            In some cases you may need this function because Windows often disables SetForegroundWindow to not allow applications to activate their windows while the user is working (using keyboard/mouse) with the currently active window. Then SetForegroundWindow just makes the window's taskbar button flash which indicates that the windows wants attention. More info: <msdn>SetForegroundWindow</msdn>.
            Usually you don't call SetForegroundWindow directly. It is called by some other functions, for example Form.Show.
            Don't need to call this function before calling Wnd.Activate and other functions of this library that activate windows.
            </summary>
        </member>
        <member name="T:Au.Wnd.Misc.TaskbarButton">
            <summary>
            Taskbar button flash, progress, add/delete.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.TaskbarButton.Flash(Au.Wnd,System.Int32)">
            <summary>
            Starts or stops flashing the taskbar button.
            </summary>
            <param name="w">Window.</param>
            <param name="count">The number of times to flash. If 0, stops flashing.</param>
        </member>
        <member name="T:Au.Wnd.Misc.TaskbarButton.ProgressState">
            <summary>
            Used by <see cref="M:Au.Wnd.Misc.TaskbarButton.SetProgressState(Au.Wnd,Au.Wnd.Misc.TaskbarButton.ProgressState)"/>.
            </summary>
            <tocexclude />
        </member>
        <member name="M:Au.Wnd.Misc.TaskbarButton.SetProgressState(Au.Wnd,Au.Wnd.Misc.TaskbarButton.ProgressState)">
            <summary>
            Sets the state of the progress indicator displayed on the taskbar button.
            Calls <msdn>ITaskbarList3.SetProgressState</msdn>.
            </summary>
            <param name="w">Button's window.</param>
            <param name="state">Progress indicator state and color.</param>
        </member>
        <member name="M:Au.Wnd.Misc.TaskbarButton.SetProgressValue(Au.Wnd,System.Int32,System.Int32)">
            <summary>
            Sets the value of the progress indicator displayed on the taskbar button.
            Calls <msdn>ITaskbarList3.SetProgressValue</msdn>.
            </summary>
            <param name="w">Button's window.</param>
            <param name="progressValue">Progress indicator value, 0 to progressTotal.</param>
            <param name="progressTotal">Max progress indicator value.</param>
        </member>
        <member name="M:Au.Wnd.Misc.TaskbarButton.Add(Au.Wnd)">
            <summary>
            Adds taskbar button.
            Calls <msdn>ITaskbarList.AddTab</msdn>.
            </summary>
            <param name="w">Button's window.</param>
        </member>
        <member name="M:Au.Wnd.Misc.TaskbarButton.Delete(Au.Wnd)">
            <summary>
            Deletes taskbar button.
            Calls <msdn>ITaskbarList.DeleteTab</msdn>.
            </summary>
            <param name="w">Button's window.</param>
        </member>
        <member name="T:Au.Wnd.Misc.Desktop">
            <summary>
            Arranges windows, shows/hides desktop.
            The same as the taskbar right-click menu commands.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.Desktop.ToggleShowDesktop">
            <summary>
            Shows or hides desktop.
            If there are non-minimized main windows, minimizes them. Else restores windows recently minimized by this function.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.Desktop.MinimizeWindows">
            <summary>
            Minimizes main windows.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.Desktop.CascadeWindows">
            <summary>
            Cascades non-minimized main windows.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.Desktop.TileWindows(System.Boolean)">
            <summary>
            Arranges non-minimized main windows horizontally or vertically.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.Desktop.UndoMinimizeEtc">
            <summary>
            Restores windows recently minimized, cascaded or tiled with other functions of this class.
            </summary>
        </member>
        <member name="T:Au.Wnd.Misc.WinFormsControlNames">
            <summary>
            Gets programming names of .NET Windows Forms controls.
            Usually each control has a unique name. It is useful to identify controls without a classic name/text.
            Control id of these controls is not constant and cannot be used.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.WinFormsControlNames.Dispose">
            
        </member>
        <member name="M:Au.Wnd.Misc.WinFormsControlNames.#ctor(Au.Wnd)">
            <summary>
            Prepares to get control names.
            </summary>
            <param name="w">Any top-level or child window of that process.</param>
            <exception cref="T:Au.Types.WndException">w invalid.</exception>
            <exception cref="T:Au.Types.AuException">Failed to allocate process memory (see <see cref="T:Au.Process_.Memory"/>) needed to get control names, usually because of UAC.</exception>
        </member>
        <member name="M:Au.Wnd.Misc.WinFormsControlNames.GetControlName(Au.Wnd)">
            <summary>
            Gets control name.
            Returns null if fails or the name is empty.
            </summary>
            <param name="c">The control. Can be a top-level window too. Must be of the same process as the window specified in the constructor.</param>
        </member>
        <member name="M:Au.Wnd.Misc.WinFormsControlNames.IsWinFormsControl(Au.Wnd)">
            <summary>
            Returns true if window class name starts with "WindowsForms".
            Usually it means that we can get Windows Forms control name of w and its child controls.
            </summary>
            <param name="w">The window. Can be top-level or control.</param>
        </member>
        <member name="M:Au.Wnd.Misc.WinFormsControlNames.GetSingleControlName(Au.Wnd)">
            <summary>
            Gets the programming name of a Windows Forms control.
            Returns null if it is not a Windows Forms control or if fails.
            </summary>
            <param name="c">The control. Can be top-level window too.</param>
            <remarks>This function is easy to use and does not throw excaptions. However, when you need names of multiple controls of a single window, better create a WinFormsControlNames instance (once) and for each control call its GetControlNameOrText method, it will be faster.</remarks>
        </member>
        <member name="T:Au.Wnd.Misc.MyWindow">
            <summary>
            Creates window and allows your derived class to replace its window procedure.
            Similar to <see cref="T:System.Windows.Forms.NativeWindow"/>, but more lightweight and does not change the class name.
            Can register a new window class or extend (subclass) an existing class.
            </summary>
        </member>
        <member name="P:Au.Wnd.Misc.MyWindow.Handle">
            <summary>
            Native window handle.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.MyWindow.Create(System.String,System.String,System.UInt32,System.UInt32,System.Int32,System.Int32,System.Int32,System.Int32,Au.Wnd,Au.Types.LPARAM)">
            <summary>
            Creates window.
            Calls API <msdn>CreateWindowEx</msdn>.
            Returns false if failed, for example className is not registered.
            </summary>
            <param name="className">The name of any window class existing in this process. You can register a class with <see cref="M:Au.Wnd.Misc.MyWindow.RegisterClass(System.String,Au.Wnd.Misc.MyWindow.WndClassEx)"/> or use any other class.</param>
            <param name="name">Window name or null.</param>
            <param name="style">One or more Native.WS_ constants, like <c>Native.WS_OVERLAPPEDWINDOW|Native.WS_VISIBLE.</c></param>
            <param name="exStyle">One or more Native.WS_EX_ constants.</param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="parent">Owner or parent window, or default.</param>
            <param name="controlId">Control id or 0.</param>
            <remarks>
            Your derived class should override <see cref="M:Au.Wnd.Misc.MyWindow.WndProc(Au.Wnd,System.UInt32,Au.Types.LPARAM,Au.Types.LPARAM)"/>, which calls the window procedure of window class <paramref name="className"/>.
            The window will be destroyed in these cases: 1. Called <see cref="M:Au.Wnd.Misc.MyWindow.Destroy"/>. 2. Closed by the user or some program/script. 3. When this thread ends. 4. This function called again (then destroys old window and creates new).
            </remarks>
        </member>
        <member name="M:Au.Wnd.Misc.MyWindow.CreateMessageWindow(System.String)">
            <summary>
            Creates <msdn>message-only window</msdn>.
            Styles: WS_POPUP, WS_EX_NOACTIVATE.
            More info: <see cref="M:Au.Wnd.Misc.MyWindow.Create(System.String,System.String,System.UInt32,System.UInt32,System.Int32,System.Int32,System.Int32,System.Int32,Au.Wnd,Au.Types.LPARAM)"/>.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.MyWindow.Destroy">
            <summary>
            Destroys the window.
            Calls API <msdn>DestroyWindow</msdn>.
            Does nothing if the window is already destroyed, for example closed by the user.
            If the window is not destroyed explicitly, the system destroys it when its thread ends.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.MyWindow.WndProc(Au.Wnd,System.UInt32,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>
            Calls the window procedure of the window class (see <see cref="M:Au.Wnd.Misc.MyWindow.Create(System.String,System.String,System.UInt32,System.UInt32,System.Int32,System.Int32,System.Int32,System.Int32,Au.Wnd,Au.Types.LPARAM)"/>) and manages the lifetime of this variable.
            Your derived class should override this function. Your WndProc must call it (base.WndProc) and return its return value, except when don't need default processing. Always call it on WM_NCCREATE and WM_NCDESTROY.
            More info: <msdn>Window Procedures</msdn>.
            </summary>
            <seealso cref="M:Au.Wnd.Misc.PrintMsg(Au.Wnd,System.UInt32,Au.Types.LPARAM,Au.Types.LPARAM,System.UInt32[])"/>
        </member>
        <member name="M:Au.Wnd.Misc.MyWindow.RegisterClass(System.String,Au.Wnd.Misc.MyWindow.WndClassEx)">
            <summary>
            Registers new window class.
            Returns class atom.
            </summary>
            <param name="className">Class name.</param>
            <param name="ex">
            Can be used to specify more fields of <msdn>WNDCLASSEX</msdn> that is passed to <msdn>RegisterClassEx</msdn>.
            Defaults: hCursor = arrow; hbrBackground = COLOR_BTNFACE+1; style = CS_GLOBALCLASS; others = 0/null/default.
            This function also adds CS_GLOBALCLASS style.
            </param>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed, for example if the class already exists and was registered not with this function.</exception>
            <remarks>
            Calls API <msdn>RegisterClassEx</msdn>.
            The class then can be used in all appdomains of this process. To create windows, use <see cref="M:Au.Wnd.Misc.MyWindow.Create(System.String,System.String,System.UInt32,System.UInt32,System.Int32,System.Int32,System.Int32,System.Int32,Au.Wnd,Au.Types.LPARAM)"/>.
            Each class derived from MyWindow provides its own window procedure (overrides <see cref="M:Au.Wnd.Misc.MyWindow.WndProc(Au.Wnd,System.UInt32,Au.Types.LPARAM,Au.Types.LPARAM)"/>). Windows created not with <see cref="M:Au.Wnd.Misc.MyWindow.Create(System.String,System.String,System.UInt32,System.UInt32,System.Int32,System.Int32,System.Int32,System.Int32,Au.Wnd,Au.Types.LPARAM)"/> use API <msdn>DefWindowProc</msdn> as window procedure, and therefore are not useful.
            The window class remains registered until this process ends. Don't need to unregister.
            This function can be called multiple times for the same class, for example called once in each appdomain. Next time it just returns class atom.
            Thread-safe.
            <note type="note">Don't use code like <c>static ushort _atom = Wnd.Misc.MyWindow.RegisterClass("MyClass");</c>, because in Release configuration compiler removes this code if _atom is not used. Instead you can call this function in a static constructor.</note>
            </remarks>
        </member>
        <member name="T:Au.Wnd.Misc.MyWindow.WndClassEx">
            <summary>
            Used with <see cref="M:Au.Wnd.Misc.MyWindow.RegisterClass(System.String,Au.Wnd.Misc.MyWindow.WndClassEx)"/>.
            </summary>
            <tocexclude />
        </member>
        <member name="M:Au.Wnd.Misc.AllWindows(System.Boolean,System.Boolean)">
            <summary>
            Gets top-level windows.
            Returns array containing 0 or more window handles as Wnd.
            </summary>
            <param name="onlyVisible">Need only visible windows.</param>
            <param name="sortFirstVisible">Place all array elements of hidden windows at the end of the array, even if the hidden windows are before some visible windows in the Z order.</param>
            <remarks>
            Calls API <msdn>EnumWindows</msdn>.
            <note>The list can be bigger than you expect, because there are many invisible windows, tooltips, etc. See also <see cref="M:Au.Wnd.Misc.MainWindows(System.Boolean)">MainWindows</see>.</note>
            By default array elements are sorted to match the Z order.
            On Windows 8 and later gets only desktop windows, not Windows Store app Metro-style windows (on Windows 10 only few such windows exist), unless this process has UAC integrity level uiAccess; to get such windows you can use <see cref="M:Au.Wnd.FindFast(System.String,System.String,Au.Wnd)">FindFast</see>.
            </remarks>
        </member>
        <member name="M:Au.Wnd.Misc.ThreadWindows(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Gets top-level windows of a thread.
            Returns array containing 0 or more window handles as Wnd.
            </summary>
            <param name="threadId">
            Unmanaged thread id.
            See <see cref="P:Au.Process_.CurrentThreadId"/>, <see cref="P:Au.Wnd.ThreadId"/>.
            If 0, throws exception. If other invalid value (ended thread?), returns empty list. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </param>
            <param name="onlyVisible">Need only visible windows.</param>
            <param name="sortFirstVisible">Place all array elements of hidden windows at the end of the array, even if the hidden windows are before some visible windows in the Z order.</param>
            <exception cref="T:System.ArgumentException">0 threadId.</exception>
            <remarks>
            Calls API <msdn>EnumThreadWindows</msdn>.
            </remarks>
        </member>
        <member name="M:Au.Wnd.Misc.FindMessageWindow(System.String,System.String,Au.Wnd)">
            <summary>
            Finds a message-only window and returns its handle as Wnd. Returns default(Wnd) if not found.
            Calls API <msdn>FindWindowEx</msdn>.
            Faster than <see cref="M:Au.Wnd.Find(System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)">Find</see>, which does not find message-only windows.
            Can be used only when you know full name and/or class name.
            Finds hidden windows too.
            </summary>
            <param name="name">
            Name.
            Use null to match any.
            Full, case-insensitive. Wildcard etc not supported.
            </param>
            <param name="className">
            Class name.
            Use null to match any. Cannot be "".
            Full, case-insensitive. Wildcard etc not supported.
            </param>
            <param name="wAfter">If used, starts searching from the next window in the Z order.</param>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="P:Au.Wnd.Misc.WndActiveOfThisThread">
            <summary>
            Gets the active window of this thread.
            Calls API <msdn>GetActiveWindow</msdn>.
            </summary>
        </member>
        <member name="P:Au.Wnd.Misc.WndTop">
            <summary>
            Gets the very first top-level window in the Z order.
            Usually it is a topmost window.
            Calls API <msdn>GetTopWindow</msdn>(default(Wnd)).
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.WndLastActiveOwnedOrThis(Au.Wnd,System.Boolean)">
            <summary>
            Gets the most recently active window in the chain of windows owned by w, or w itself if there are no such windows.
            </summary>
            <param name="w"></param>
            <param name="includeOwners">Can return an owner (or owner's owner and so on) of w too.</param>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="M:Au.Wnd.Misc.WndRootOwnerOrThis(Au.Wnd,System.Boolean)">
            <summary>
            Gets the most bottom owner window in the chain of owner windows of w.
            If w is not owned, returns w. If w is invalid, returns default(Wnd).
            </summary>
            <param name="w"></param>
            <param name="supportControls">If w is a child window, use its top-level parent window instead.</param>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.Misc.WndRoot">
            <summary>
            Gets the virtual parent window of all top-level windows.
            Calls API <msdn>GetDesktopWindow</msdn>.
            <note>It is not the visible desktop window (see <see cref="P:Au.Wnd.Misc.WndDesktop"/>)</note>.
            </summary>
        </member>
        <member name="P:Au.Wnd.Misc.WndShell">
            <summary>
            Gets a window of the shell process (usually process "explorer", class name "Progman").
            Calls API <msdn>GetShellWindow</msdn>.
            <note>In most cases it is not the window that contains desktop icons (see <see cref="P:Au.Wnd.Misc.WndDesktop"/>). But it belongs to the same thread.</note>
            </summary>
        </member>
        <member name="P:Au.Wnd.Misc.WndDesktop">
            <summary>
            Gets the desktop window.
            It displays desktop icons and wallpaper in its child control <see cref="P:Au.Wnd.Misc.WndDesktopControl"/>. The "Show Desktop" command (Win+D) activates it.
            <note>It is not the same as API <msdn>GetDesktopWindow</msdn> (see <see cref="P:Au.Wnd.Misc.WndRoot"/>)</note>.
            <note>This function is not very reliable. May stop working on a new Windows version or don't work with a custom shell.</note>
            </summary>
        </member>
        <member name="P:Au.Wnd.Misc.WndDesktopControl">
            <summary>
            Gets the control of "SysListView32" class that contains desktop icons and wallpaper. It is a child of <see cref="P:Au.Wnd.Misc.WndDesktop"/>.
            <note>This function is not very reliable. May stop working on a new Windows version or don't work with a custom shell.</note>
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.IsMainWindow(Au.Wnd,System.Boolean,System.Boolean)">
            <summary>
            Returns true if window w is considered a main window, ie probably is in the Windows taskbar.
            Returns false if it is invisible, cloaked, owned, toolwindow, menu, etc.
            </summary>
            <param name="w"></param>
            <param name="allDesktops">On Windows 10 include (return true for) windows on all virtual desktops. On Windows 8 include Windows Store apps (only if this process has UAC integrity level uiAccess).</param>
            <param name="skipMinimized">Return false if w is minimized.</param>
        </member>
        <member name="M:Au.Wnd.Misc.MainWindows(System.Boolean)">
            <summary>
            Gets main windows, ie those that probably are in the Windows taskbar.
            Returns array containing 0 or more Wnd.
            </summary>
            <param name="allDesktops">On Windows 10 include windows on all virtual desktops. On Windows 8 include Windows Store apps (only if this process has UAC integrity level uiAccess).</param>
            <remarks>
            Uses <see cref="M:Au.Wnd.Misc.IsMainWindow(Au.Wnd,System.Boolean,System.Boolean)"/>.
            Does not match the order of buttons in the Windows taskbar.
            </remarks>
        </member>
        <member name="M:Au.Wnd.Misc.WndNextMain(Au.Wnd,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets next window in the Z order, skipping invisible and other windows that probably are not in the Windows taskbar.
            Returns default(Wnd) if there are no such windows.
            </summary>
            <param name="w">Start from this window. If default(Wnd), starts from the top of the Z order.</param>
            <param name="allDesktops">On Windows 10 include windows on all virtual desktops. On Windows 8 include Windows Store apps (only if this process has UAC integrity level uiAccess).</param>
            <param name="skipMinimized">Skip minimized windows.</param>
            <param name="retryFromTop">If w is not default(Wnd) and there are no matching windows after it, retry from the top of the Z order. Then can return w.</param>
            <remarks>
            Uses <see cref="M:Au.Wnd.Misc.IsMainWindow(Au.Wnd,System.Boolean,System.Boolean)"/>.
            This function is quite slow. Does not match the order of buttons in the Windows taskbar.
            </remarks>
        </member>
        <member name="M:Au.Wnd.Misc.SwitchActiveWindow">
            <summary>
            Activates next non-minimized main window, like with Alt+Tab.
            Returns true if activated, false if there is no such window or failed to activate.
            </summary>
            <remarks>
            Uses <see cref="M:Au.Wnd.Misc.WndNextMain(Au.Wnd,System.Boolean,System.Boolean,System.Boolean)"/>, <see cref="M:Au.Wnd.Misc.WndLastActiveOwnedOrThis(Au.Wnd,System.Boolean)"/>, <see cref="M:Au.Wnd.Activate"/>.
            An alternative way - send Alt+Tab keys, but it works not everywhere.
            </remarks>
        </member>
        <member name="M:Au.Wnd.Misc.WindowRectFromClientRect(Au.Types.RECT@,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Calculates window rectangle from client area rectangle and style.
            Calls API <msdn>AdjustWindowRectEx</msdn>.
            </summary>
            <param name="r">Input - client area rectangle in screen. Output - window rectangle in screen.</param>
            <param name="style">Native.WS_ styles.</param>
            <param name="exStyle">Native.WS_EX_ styles.</param>
            <param name="hasMenu"></param>
            <remarks>
            Ignores styles WS_VSCROLL, WS_HSCROLL and wrapped menu bar.
            </remarks>
        </member>
        <member name="M:Au.Wnd.Misc.BorderWidth(System.UInt32,System.UInt32)">
            <summary>
            Calculates window border width from style.
            </summary>
            <param name="style">Native.WS_ styles.</param>
            <param name="exStyle">Native.WS_EX_ styles.</param>
        </member>
        <member name="M:Au.Wnd.Misc.BorderWidth(Au.Wnd)">
            <summary>
            Gets window border width.
            </summary>
            <param name="w"></param>
        </member>
        <member name="M:Au.Wnd.Misc.GetGUIThreadInfo(Au.Types.Native.GUITHREADINFO@,System.Int32)">
            <summary>
            Calls API <msdn>GetGUIThreadInfo</msdn>, which can get some GUI info, eg mouse capturing, menu mode, move/size mode, focus, caret.
            </summary>
            <param name="g">Variable that receives the info.</param>
            <param name="idThread">Thread id. If 0 - the foreground (active window) thread. See <see cref="P:Au.Wnd.ThreadId"/>.</param>
        </member>
        <member name="M:Au.Wnd.Misc.CreateWindow(System.String,System.String,System.UInt32,System.UInt32,System.Int32,System.Int32,System.Int32,System.Int32,Au.Wnd,Au.Types.LPARAM,System.IntPtr,Au.Types.LPARAM)">
            <summary>
            Creates native/unmanaged window.
            Calls API <msdn>CreateWindowEx</msdn>.
            Later call <see cref="M:Au.Wnd.Misc.DestroyWindow(Au.Wnd)"/> or <see cref="M:Au.Wnd.Close(System.Boolean,System.Boolean)"/>.
            For style and exStyle you can use Native.WS_ constants.
            Usually don't need to specify hInstance.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.CreateWindowAndSetFont(System.String,System.String,System.UInt32,System.UInt32,System.Int32,System.Int32,System.Int32,System.Int32,Au.Wnd,Au.Types.LPARAM,System.IntPtr,Au.Types.LPARAM,System.IntPtr)">
            <summary>
            Creates native/unmanaged window like <see cref="M:Au.Wnd.Misc.CreateWindow(System.String,System.String,System.UInt32,System.UInt32,System.Int32,System.Int32,System.Int32,System.Int32,Au.Wnd,Au.Types.LPARAM,System.IntPtr,Au.Types.LPARAM)"/> and sets font.
            If customFontHandle not specified, sets the system UI font, usually it is Segoe UI, 9.
            Later call <see cref="M:Au.Wnd.Misc.DestroyWindow(Au.Wnd)"/> or <see cref="M:Au.Wnd.Close(System.Boolean,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.CreateMessageWindow(System.String)">
            <summary>
            Creates native/unmanaged <msdn>message-only window</msdn>.
            Styles: WS_POPUP, WS_EX_NOACTIVATE.
            Later call <see cref="M:Au.Wnd.Misc.DestroyWindow(Au.Wnd)"/> or <see cref="M:Au.Wnd.Close(System.Boolean,System.Boolean)"/>.
            </summary>
            <param name="className">Window class name. Can be any existing class.</param>
        </member>
        <member name="M:Au.Wnd.Misc.DestroyWindow(Au.Wnd)">
            <summary>
            Destroys a native window of this thread.
            Calls API <msdn>DestroyWindow</msdn>.
            Returns false if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <seealso cref="M:Au.Wnd.Close(System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.Wnd.Misc.GetWindowsStoreAppId(Au.Wnd,System.Boolean,System.Boolean)">
            <summary>
            Gets window Windows Store app user model id, like "Microsoft.WindowsCalculator_8wekyb3d8bbwe!App".
            Returns null if fails or if called on Windows 7.
            </summary>
            <param name="w"></param>
            <param name="prependShellAppsFolder">Prepend @"shell:AppsFolder\" (to run or get icon).</param>
            <param name="getExePathIfNotWinStoreApp">Get program path if it is not a Windows Store app.</param>
            <remarks>
            Windows Store app window class name can be "Windows.UI.Core.CoreWindow" or "ApplicationFrameWindow".
            </remarks>
        </member>
        <member name="M:Au.Wnd.Misc.SetFontHandle(Au.Wnd,System.IntPtr)">
            <summary>
            Sets native font handle.
            Sends message API <msdn>WM_SETFONT</msdn> with lParam 1.
            Does not copy the font; don't dispose it while the window is alive.
            Use this function only with windows of current process.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.GetFontHandle(Au.Wnd)">
            <summary>
            Gets native font handle.
            Sends message API <msdn>WM_GETFONT</msdn>.
            Does not copy the font; don't need to dispose.
            Use this function only with windows of current process.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.SetIconHandle(Au.Wnd,System.IntPtr,System.Boolean)">
            <summary>
            Sets native icon handle.
            Sends message API <msdn>WM_SETICON</msdn>.
            Does not copy the icon; don't dispose it while the window is alive.
            Use this function only with windows of current process.
            </summary>
            <seealso cref="T:Au.Icons"/>
        </member>
        <member name="M:Au.Wnd.Misc.GetIconHandle(Au.Wnd,System.Boolean)">
            <summary>
            Gets icon that is displayed in window title bar and in its taskbar button.
            Returns icon handle if successful, else default(IntPtr). Later call <see cref="M:Au.Icons.DestroyIconHandle(System.IntPtr)"/> or <see cref="M:Au.Icons.HandleToImage(System.IntPtr)"/>.
            </summary>
            <param name="w"></param>
            <param name="size32">Get 32x32 icon. If false, gets 16x16 icon.</param>
            <remarks>
            Icon size depends on DPI (text size, can be changed in Control Panel). By default small is 16, large 32.
            This function can be used with windows of any process.
            </remarks>
            <seealso cref="T:Au.Icons"/>
        </member>
        <member name="M:Au.Wnd.Misc.GetClassLong(Au.Wnd,System.Int32)">
            <summary>
            Calls API <msdn>GetClassLong</msdn> if current process is 32-bit, GetClassLongPtr if 64-bit.
            </summary>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            All Native.GCL_/GCW_ values are the same in 32-bit and 64-bit process.
            </remarks>
        </member>
        <member name="M:Au.Wnd.Misc.GetClassAtom(System.String,System.IntPtr)">
            <summary>
            Gets atom of a window class.
            To get class atom when you have a window w, use <c>Wnd.Misc.GetClassLong(w, Native.GCW_ATOM)</c>.
            </summary>
            <param name="className">Class name.</param>
            <param name="moduleHandle">Native module handle of the exe or dll that registered the class. Don't use if it is a global class (CS_GLOBALCLASS style).</param>
        </member>
        <member name="M:Au.Wnd.Misc.UacEnableMessages(System.UInt32[])">
            <summary>
            Calls API <msdn>ChangeWindowMessageFilter</msdn> for each message in the list of messages.
            It allows processes of lower UAC integrity level to send these messages to this process.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.InterProcessEnableReceivingWM_COPYDATA">
            <summary>
            Calls API <msdn>ChangeWindowMessageFilter</msdn> to enable receiving WM_COPYDATA message from lower UAC integrity level processes, for example if you'll use <see cref="M:Au.Wnd.Misc.InterProcessGetData(Au.Types.LPARAM,System.Int32@)"/>.
            Call this once in process.
            </summary>
        </member>
        <member name="M:Au.Wnd.Misc.InterProcessSendData(Au.Wnd,System.Int32,System.String,Au.Wnd)">
            <summary>
            Sends data to a window of another process using message <msdn>WM_COPYDATA</msdn>.
            Returns true if the window received the message and returned true from its window procedure.
            See also: <see cref="M:Au.Wnd.Misc.InterProcessGetData(Au.Types.LPARAM,System.Int32@)"/>.
            </summary>
            <param name="w">The window of that process that will receive the message.</param>
            <param name="stringId">An integer identifier of the string, to store in COPYDATASTRUCT.dwData.</param>
            <param name="s">String containing data of any format. Can have '\0' characters.</param>
            <param name="wSender">Optional. A window of this process that sends the message. The receiving window procedure receives it in wParam.</param>
            <seealso cref="T:Au.Util.SharedMemory"/>
        </member>
        <member name="M:Au.Wnd.Misc.InterProcessGetData(Au.Types.LPARAM,System.Int32@)">
            <summary>
            Gets data stored in <msdn>COPYDATASTRUCT</msdn> structure received by a window procedure with <msdn>WM_COPYDATA</msdn> message.
            See also: <see cref="M:Au.Wnd.Misc.InterProcessSendData(Au.Wnd,System.Int32,System.String,Au.Wnd)"/>, <see cref="M:Au.Wnd.Misc.InterProcessEnableReceivingWM_COPYDATA"/>.
            </summary>
            <param name="lParam">lParam of the window procedure when it received WM_COPYDATA message. It is COPYDATASTRUCT pointer.</param>
            <param name="stringId">Receives string id stored in COPYDATASTRUCT.dwData.</param>
            <remarks>
            <note type="note">UAC blocks messages sent from processes of lower integrity level. Call <see cref="M:Au.Wnd.Misc.InterProcessEnableReceivingWM_COPYDATA"/> before (once).</note>
            </remarks>
        </member>
        <member name="M:Au.Wnd.Misc.StringRemoveUnderlineAmpersand(System.String)">
            <summary>
            Removes '&amp;' characters from string.
            Replaces "&amp;&amp;" to "&amp;".
            Returns new string if s has '&amp;' characters, else returns s.
            </summary>
            <remarks>
            Character '&amp;' is used to underline next character in displayed text of dialog controls and menu items. Two '&amp;' are used to display single '&amp;'.
            The underline is displayed when using the keyboard (eg Alt key) to select dialog controls and menu items.
            </remarks>
        </member>
        <member name="M:Au.Wnd.Misc.PrintMsg(System.Windows.Forms.Message@,System.UInt32[])">
            <summary>
            Writes a Windows message to the output.
            </summary>
            <param name="m"></param>
            <param name="ignore">Messages to not show.</param>
        </member>
        <member name="M:Au.Wnd.Misc.PrintMsg(Au.Wnd,System.UInt32,Au.Types.LPARAM,Au.Types.LPARAM,System.UInt32[])">
            <summary>
            Writes a Windows message to the output.
            </summary>
            <param name="w"></param>
            <param name="msg"></param>
            <param name="wParam"></param>
            <param name="lParam"></param>
            <param name="ignore">Messages to not show.</param>
        </member>
        <member name="M:Au.Wnd.Misc.PrintMsg(Au.Types.Native.MSG@,System.UInt32[])">
            <summary>
            Writes a Windows message to the output.
            </summary>
            <param name="m"></param>
            <param name="ignore">Messages to not show.</param>
        </member>
        <member name="M:Au.Wnd.Misc.SetWindowSubclass(Au.Wnd,Au.Types.SUBCLASSPROC,Au.Types.LPARAM,System.IntPtr)">
            <summary>API <msdn>SetWindowSubclass</msdn></summary>
        </member>
        <member name="M:Au.Wnd.Misc.GetWindowSubclass(Au.Wnd,Au.Types.SUBCLASSPROC,Au.Types.LPARAM,System.IntPtr@)">
            <summary>API <msdn>GetWindowSubclass</msdn></summary>
        </member>
        <member name="M:Au.Wnd.Misc.RemoveWindowSubclass(Au.Wnd,Au.Types.SUBCLASSPROC,Au.Types.LPARAM)">
            <summary>API <msdn>RemoveWindowSubclass</msdn></summary>
        </member>
        <member name="M:Au.Wnd.Misc.DefSubclassProc(Au.Wnd,System.UInt32,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>API <msdn>DefSubclassProc</msdn></summary>
        </member>
        <member name="M:Au.Wnd.Misc.DefWindowProc(Au.Wnd,System.UInt32,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>API <msdn>DefWindowProc</msdn></summary>
        </member>
        <member name="M:Au.Wnd.ThrowIf0">
            <summary>
            If <see cref="P:Au.Wnd.Is0"/>, throws <see cref="T:Au.Types.WndException"/>.
            </summary>
            <exception cref="T:Au.Types.WndException"></exception>
        </member>
        <member name="M:Au.Wnd.ThrowIfInvalid">
            <summary>
            If <see cref="P:Au.Wnd.Is0"/> or !<see cref="P:Au.Wnd.IsAlive"/>, throws <see cref="T:Au.Types.WndException"/>.
            </summary>
            <exception cref="T:Au.Types.WndException"></exception>
        </member>
        <member name="M:Au.Wnd.ThrowUseNative">
            <summary>
            Throws <see cref="T:Au.Types.WndException"/> that uses the last Windows API error (code and message).
            Also the message depends on whether the window handle is 0/invalid.
            </summary>
            <exception cref="T:Au.Types.WndException"></exception>
        </member>
        <member name="M:Au.Wnd.ThrowUseNative(System.String)">
            <summary>
            Throws <see cref="T:Au.Types.WndException"/> that uses mainMessage and the last Windows API error (code and message).
            Also the message depends on whether the window handle is 0/invalid.
            </summary>
            <exception cref="T:Au.Types.WndException"></exception>
        </member>
        <member name="M:Au.Wnd.ThrowUseNative(System.Int32,System.String)">
            <summary>
            Throws <see cref="T:Au.Types.WndException"/> that uses mainMessage and the specified Windows API error code.
            Also the message depends on whether the window handle is 0/invalid.
            </summary>
            <exception cref="T:Au.Types.WndException"></exception>
        </member>
        <member name="M:Au.Wnd.ThrowNoNative(System.String)">
            <summary>
            Throws <see cref="T:Au.Types.WndException"/> that uses mainMessage and does not use the last Windows API error.
            Also the message depends on whether the window handle is 0/invalid.
            </summary>
            <exception cref="T:Au.Types.WndException"></exception>
        </member>
        <member name="P:Au.Wnd.Is0">
            <summary>
            Returns true if the <see cref="T:Au.Wnd">handle</see> is 0.
            </summary>
            <example>
            <code><![CDATA[
            Wnd w = Wnd.Find("Window*");
            if(w.Is0) { Print("window not found"); return; }
            ]]></code>
            </example>
            <seealso cref="P:Au.Wnd.IsAlive"/>
        </member>
        <member name="P:Au.Wnd.IsAlive">
            <summary>
            Returns true if the <see cref="T:Au.Wnd">handle</see> identifies an existing window.
            Returns false if the handle is 0 or invalid.
            Invalid non-0 handle usually means that the window is closed/destroyed.
            </summary>
            <remarks>
            Calls <see cref="P:Au.Wnd.Is0"/> and API <msdn>IsWindow</msdn>.
            Although a Wnd variable holds a window handle, which is like a reference to a window, it does not prevent closing that window and making the handle invalid. After closing the window, the OS can even assign the same handle value to a new window, although normally it can happen only after long time.
            <note>Use this carefully with windows of other applications or threads. The window can be closed at any moment, even when your thread is still in this function.</note>
            </remarks>
        </member>
        <member name="P:Au.Wnd.IsVisible">
            <summary>
            Returns true if the window is visible.
            Returns false if is invisible or is a child of invisible parent.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <remarks>
            Calls API <msdn>IsWindowVisible</msdn>. Does not call <see cref="P:Au.Wnd.IsCloaked"/>.
            
            Even when this function returns true, the window may be actually invisible. It can be cloaked, on an inactive Windows 10 virtual desktop (cloaked), inactive Windows Store app (cloaked), transparent, zero-size, minimized, off-screen, covered by other windows or can have zero-size window region.
            </remarks>
            <seealso cref="P:Au.Wnd.IsVisibleEx"/>
            <seealso cref="P:Au.Wnd.IsCloaked"/>
            <seealso cref="P:Au.Wnd.IsVisibleAndNotCloaked"/>
            <seealso cref="M:Au.Wnd.Show(System.Boolean)"/>
            <seealso cref="M:Au.Wnd.Activate"/>
        </member>
        <member name="P:Au.Wnd.IsVisibleEx">
            <summary>
            Returns true if the window is visible.
            Returns false if is invisible or is a child of invisible parent.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <remarks>
            Returns false if API <msdn>IsWindowVisible</msdn> returns false.
            Also returns false if <see cref="P:Au.Wnd.IsCloaked"/> returns true, but only for some popup windows that usually are useless and could cause problems if considered visible.
            Else returns true.
            
            Even when this function returns true, the window may be actually invisible. It can be cloaked (excepth the above case), on an inactive Windows 10 virtual desktop (cloaked), inactive Windows Store app (cloaked), transparent, zero-size, minimized, off-screen, covered by other windows or can have zero-size window region.
            </remarks>
            <seealso cref="P:Au.Wnd.IsVisible"/>
            <seealso cref="P:Au.Wnd.IsCloaked"/>
            <seealso cref="P:Au.Wnd.IsVisibleAndNotCloaked"/>
            <seealso cref="M:Au.Wnd.Show(System.Boolean)"/>
            <seealso cref="M:Au.Wnd.Activate"/>
        </member>
        <member name="P:Au.Wnd.IsVisibleAndNotCloaked">
            <summary>
            Returns true if <see cref="P:Au.Wnd.IsVisible"/> returns true and <see cref="P:Au.Wnd.IsCloaked"/> returns false.
            </summary>
            <seealso cref="P:Au.Wnd.IsVisibleEx"/>
        </member>
        <member name="M:Au.Wnd.Show(System.Boolean)">
            <summary>
            Shows (if hidden) or hides this window.
            Does not activate/deactivate/zorder.
            With windows of current thread usually it's better to use <see cref="M:Au.Wnd.ShowLL(System.Boolean)">ShowLL</see>.
            </summary>
            <remarks>
            Calls API <msdn>ShowWindow</msdn> with SW_SHOWNA or SW_HIDE.
            </remarks>
            <exception cref="T:Au.Types.WndException"/>
        </member>
        <member name="M:Au.Wnd.ShowLL(System.Boolean)">
            <summary>
            Shows (if hidden) or hides this window.
            Does not activate/deactivate/zorder.
            </summary>
            <remarks>
            This library has two similar functions - <see cref="M:Au.Wnd.Show(System.Boolean)">Show</see> and <b>ShowLL</b>. <b>Show</b> is better to use in automation scripts, with windows of any process/thread. <b>ShowLL</b> usually is better to use in programming, with windows of current thread.
            <b>ShowLL</b> is more low-level. Does not throw exception when fails, and does not add a delay; <b>Show</b> adds a small delay when the window is of other thread.
            
            Calls API <msdn>ShowWindow</msdn> with SW_SHOWNA or SW_HIDE.
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="P:Au.Wnd.IsEnabled">
            <summary>
            Gets the enabled state.
            Returns true if the window is enabled.
            Returns false if is disabled or is a child of disabled parent.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="M:Au.Types.Native.GetError"/>.
            Calls API <msdn>IsWindowEnabled</msdn>.
            </summary>
        </member>
        <member name="M:Au.Wnd.Enable(System.Boolean)">
            <summary>
            Enables or disables the window.
            Calls API <msdn>EnableWindow</msdn>.
            </summary>
            <param name="enable">Enable or disable.</param>
            <exception cref="T:Au.Types.WndException"/>
        </member>
        <member name="P:Au.Wnd.IsCloakedGetState">
            <summary>
            Gets the cloaked state.
            Returns 0 if not cloaked or if failed.
            Else returns flags: 1 cloaked by its application, 2 cloaked by Windows, 4 cloaked because its owner window is cloaked.
            On Windows 7 returns 0 because there is no "cloaked window" feature.
            </summary>
            <seealso cref="P:Au.Wnd.IsCloaked"/>
        </member>
        <member name="P:Au.Wnd.IsCloaked">
            <summary>
            Returns true if the window is cloaked.
            Returns false if not cloaked or if failed.
            On Windows 7 returns false because there is no "cloaked window" feature.
            Windows 10 uses window cloaking mostly to hide windows on inactive desktops. Windows 8 - mostly to hide Metro app windows.
            </summary>
            <seealso cref="P:Au.Wnd.IsCloakedGetState"/>
        </member>
        <member name="P:Au.Wnd.IsMinimized">
            <summary>
            Returns true if minimized, false if not.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="M:Au.Types.Native.GetError"/>.
            Calls API <msdn>IsIconic</msdn>.
            </summary>
        </member>
        <member name="P:Au.Wnd.IsMaximized">
            <summary>
            Returns true if maximized, false if not.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="M:Au.Types.Native.GetError"/>.
            Calls API <msdn>IsZoomed</msdn>.
            </summary>
        </member>
        <member name="M:Au.Wnd.ShowMinimized(System.Boolean)">
            <summary>
            If not minimized, minimizes.
            Also unhides.
            </summary>
            <param name="noAnimation">Visually fast, without animation.</param>
            <exception cref="T:Au.Types.WndException">The API call failed. No exception if the window did not obey.</exception>
        </member>
        <member name="M:Au.Wnd.ShowMaximized(System.Boolean)">
            <summary>
            If not minimized, minimizes.
            Also unhides.
            </summary>
            <param name="noAnimation">Visually fast, without animation.</param>
            <exception cref="T:Au.Types.WndException">The API call failed. No exception if the window did not obey.</exception>
        </member>
        <member name="M:Au.Wnd.ShowNotMinMax(System.Boolean)">
            <summary>
            If maximized or minimized, makes normal (not min/max).
            Also unhides.
            </summary>
            <param name="noAnimation">Visually fast, without animation.</param>
            <exception cref="T:Au.Types.WndException">The API call failed. No exception if the window did not obey.</exception>
        </member>
        <member name="M:Au.Wnd.ShowNotMinimized(System.Boolean)">
            <summary>
            If minimized, restores previous non-minimized state (maximized or normal).
            Also unhides.
            </summary>
            <param name="noAnimation">Visually fast, without animation.</param>
            <exception cref="T:Au.Types.WndException">The API call failed. No exception if the window did not obey.</exception>
        </member>
        <member name="M:Au.Wnd._MinMaxRes(System.Int32,System.Boolean)">
            <summary>
            Sets window min/max/normal/restore state.
            Also unhides.
            </summary>
            <param name="state">Must be SW_MINIMIZE, SW_RESTORE (restores to normal/max if minimized), SW_SHOWNORMAL or SW_SHOWMAXIMIZED.</param>
            <param name="noAnimation">Use SetWindowPlacement (no animation).</param>
            <exception cref="T:Au.Types.WndException"/>
        </member>
        <member name="M:Au.Wnd.LibGetWindowPlacement(Au.Types.Api.WINDOWPLACEMENT@,System.String)">
            <summary>
            Initializes a WINDOWPLACEMENT struct and calls API <msdn>GetWindowPlacement</msdn>.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
            <exception cref="T:Au.Types.WndException">Failed. Throws, only if errStr!=null, else returns false.</exception>
        </member>
        <member name="M:Au.Wnd.LibSetWindowPlacement(Au.Types.Api.WINDOWPLACEMENT@,System.String)">
            <summary>
            Sets WINDOWPLACEMENT length field and calls API <msdn>SetWindowPlacement</msdn>.
            </summary>
            <exception cref="T:Au.Types.WndException">Failed. Throws, only if errStr!=null, else returns false.</exception>
        </member>
        <member name="T:Au.Wnd.Lib">
            <summary>
            Internal static functions.
            </summary>
        </member>
        <member name="M:Au.Wnd.Lib.EnableActivate(System.Boolean)">
            <summary>
            No exceptions.
            </summary>
        </member>
        <member name="M:Au.Wnd.Lib._EnableActivate_SendKey(System.Boolean)">
            <summary>
            Sends a key (VK_0 up). It allows to activate now.
            Later this process can always activate easily (without key etc). It works even with higher IL windows.
            Don't know why is this behavior. Tested on all OS from XP to 10.
            Does not work if the foreground process has higher UAC IL.
            </summary>
        </member>
        <member name="M:Au.Wnd.Lib._EnableActivate_MinRes">
            <summary>
            Creates a temporary minimized window and restores it. It activates the window and allows us to activate.
            Then sets 'no active window' to prevent auto-activating another window when destroying the temporary window.
            </summary>
        </member>
        <member name="M:Au.Wnd.Lib._EnableActivate_AllowSetFore">
            <summary>
            Calls Api.AllowSetForegroundWindow(Api.GetCurrentProcessId()).
            </summary>
        </member>
        <member name="F:Au.Wnd.Lib.ActivateFlags.NoThrowIfInvalid">
            <summary>
            Don't call ThrowIfInvalid at the very start (ie called ensures it is valid).
            </summary>
        </member>
        <member name="F:Au.Wnd.Lib.ActivateFlags.NoGetWndWindow">
            <summary>
            Don't call WndWindow (ie caller ensures it's a top-level window, not control).
            </summary>
        </member>
        <member name="F:Au.Wnd.Lib.ActivateFlags.IgnoreIfNoActivateStyleEtc">
            <summary>
            Don't activate if has WS_EX_NOACTIVATE style or is toolwindow without caption, unless cloaked.
            Then just calls ZorderTop(), which in most cases does not work (inactive window).
            </summary>
        </member>
        <member name="F:Au.Wnd.Lib.ActivateFlags.ForScreenCapture">
            <summary>
            Wait for window animations to end. Eg when switching Win10 desktops.
            </summary>
        </member>
        <member name="M:Au.Wnd.Lib.MoveInScreen(System.Boolean,Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.Wnd,Au.Types.RECT@,System.Object,System.Boolean,System.Boolean)">
            <summary>
            Used directly by MoveInScreen, EnsureInScreen, RECT.MoveInScreen, RECT.EnsureInScreen.
            </summary>
        </member>
        <member name="T:Au.Wnd.Lib.WinFlags">
            <summary>
            Calls API SetProp/GetProp to set/get window flags <see cref="T:Au.Wnd.Lib.WFlags"/>.
            </summary>
        </member>
        <member name="T:Au.Wnd.Lib.EnumCallback">
            <summary>
            For EnumWindows2.
            </summary>
        </member>
        <member name="M:Au.Wnd.Lib.EnumWindows2(Au.Wnd.Lib.EnumWindowsAPI,System.Boolean,System.Boolean,Au.Wnd,System.Boolean,System.Int32,Au.Wnd.Lib.EnumCallback,System.Object)">
            <summary>
            This version creates much less garbage (the garbage would be the returned managed array).
            The caller must dispose the returned LibArrayBuilder.
            </summary>
        </member>
        <member name="M:Au.Wnd.LibActivate(Au.Wnd.Lib.ActivateFlags)">
            <summary>
            Activates this window (brings to the foreground).
            The same as <see cref="M:Au.Wnd.Activate"/>, but has some options.
            Returns false if does not activate because of flag IgnoreIfNoActivateStyleEtc.
            </summary>
            <exception cref="T:Au.Types.WndException"/>
        </member>
        <member name="M:Au.Wnd.Activate">
            <summary>
            Activates this window (brings to the foreground).
            Also unhides, restores minimized etc, to ensure that the window is ready to receive sent keys, mouse clicks ect.
            </summary>
            <remarks>
            Activating a window usually also uncloaks it, for example switches to its virtual desktop on Windows 10.
            Fails (throws exception) if cannot activate this window, except:
            <list type="number">
            <item>If this is a control, activates its top-level parent window.</item>
            <item>If this is <see cref="P:Au.Wnd.Misc.WndRoot"/>, just deactivates the currently active window.</item>
            <item>When the target application instead activates another window of the same thread.</item>
            </list>
            </remarks>
            <exception cref="T:Au.Types.WndException"/>
            <seealso cref="M:Au.Wnd.ActivateLL"/>
            <seealso cref="P:Au.Wnd.IsActive"/>
            <seealso cref="P:Au.Wnd.WndActive"/>
            <seealso cref="M:Au.Wnd.Misc.SwitchActiveWindow"/>
        </member>
        <member name="M:Au.Wnd.ActivateLL">
            <summary>
            Low-level version of <see cref="M:Au.Wnd.Activate"/>.
            Just calls <see cref="M:Au.Wnd.Misc.EnableActivate"/>, API <msdn>SetForegroundWindow</msdn> and makes sure that it actually worked, but does not check whether it activated exactly this window.
            No exceptions, does not unhide, does not restore minimized, does not check is it a top-level window or control, etc.
            Returns false if fails.
            </summary>
        </member>
        <member name="M:Au.Wnd.Focus">
            <summary>
            Sets the keyboard input focus to this control or window.
            Also activetes its top-level parent window (see <see cref="M:Au.Wnd.Activate"/>).
            Can belong to any process/thread. With controls of this thread you can use the more lightweight function <see cref="M:Au.Wnd.FocusLocal"/>.
            </summary>
            <remarks>
            Can instead focus a child control. For example, if this is a ComboBox, it will focus its child Edit control. Then does not throw exception.
            </remarks>
            <exception cref="T:Au.Types.WndException">
            Invalid handle; disabled; failed to set focus; failed to activate parent window.
            Fails to set focus when the target process is admin and this process isn't.
            </exception>
            <seealso cref="P:Au.Wnd.WndFocused"/>
            <seealso cref="P:Au.Wnd.IsFocused"/>
        </member>
        <member name="P:Au.Wnd.WndFocused">
            <summary>
            Gets the control or window that has the keyboard input focus.
            It can belong to any process/thread. With controls of this thread you can use the more lightweight function <see cref="P:Au.Wnd.WndFocusedLocal"/>.
            Calls API <msdn>GetGUIThreadInfo</msdn>.
            </summary>
            <seealso cref="M:Au.Wnd.Focus"/>
            <seealso cref="P:Au.Wnd.IsFocused"/>
        </member>
        <member name="P:Au.Wnd.IsFocused">
            <summary>
            Returns true if this is the control or window that has the keyboard input focus.
            Can belong to any process/thread. With controls of this thread you can use the more lightweight function <see cref="P:Au.Wnd.IsFocusedLocal"/>.
            Calls <see cref="P:Au.Wnd.WndFocused"/>.
            </summary>
            <seealso cref="M:Au.Wnd.Focus"/>
        </member>
        <member name="M:Au.Wnd.FocusLocal">
            <summary>
            Calls API <msdn>SetFocus</msdn>, which sets the keyboard input focus to this control or window, which must be of this thread.
            Fails if it belongs to another thread or is invalid or disabled.
            Returns false if fails. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <remarks>
            Can instead focus a child control. For example, if this is a ComboBox, it will focus its child Edit control. Then returns true.
            </remarks>
            <seealso cref="P:Au.Wnd.WndFocusedLocal"/>
            <seealso cref="P:Au.Wnd.IsFocusedLocal"/>
        </member>
        <member name="P:Au.Wnd.WndFocusedLocal">
            <summary>
            Gets the control or window of this thread that has the keyboard input focus.
            Calls API <msdn>GetFocus</msdn>.
            </summary>
            <seealso cref="M:Au.Wnd.FocusLocal"/>
            <seealso cref="P:Au.Wnd.IsFocusedLocal"/>
        </member>
        <member name="P:Au.Wnd.IsFocusedLocal">
            <summary>
            Returns true if this is the control or window of this thread that has the keyboard input focus.
            Calls API <msdn>GetFocus</msdn>.
            </summary>
            <seealso cref="M:Au.Wnd.FocusLocal"/>
            <seealso cref="P:Au.Wnd.WndFocusedLocal"/>
        </member>
        <member name="M:Au.Wnd.GetRect(Au.Types.RECT@)">
            <summary>
            Gets rectangle (position and size) in screen coordinates.
            The same as the <see cref="P:Au.Wnd.Rect"/> property.
            </summary>
            <param name="r">Receives the rectangle. Will be empty if failed.</param>
            <remarks>
            Calls API <msdn>GetWindowRect</msdn> and returns its return value.
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="M:Au.Wnd.GetSize(System.Drawing.Size@)">
            <summary>
            Gets width and height.
            The same as the <see cref="P:Au.Wnd.Size"/> property.
            </summary>
            <param name="z">Receives width and height. Will be empty if failed.</param>
            <remarks>
            Calls API <msdn>GetWindowRect</msdn> and returns its return value.
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="P:Au.Wnd.Rect">
            <summary>
            Gets rectangle (position and size) in screen coordinates.
            </summary>
            <remarks>
            Calls <see cref="M:Au.Wnd.GetRect(Au.Types.RECT@)"/>. Returns empty RECT if fails (eg window closed).
            </remarks>
        </member>
        <member name="P:Au.Wnd.Size">
            <summary>
            Gets width and height.
            </summary>
            <remarks>
            Calls <see cref="M:Au.Wnd.GetSize(System.Drawing.Size@)"/>. Returns empty Size if fails (eg window closed).
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="P:Au.Wnd.X">
            <summary>
            Gets horizontal position in screen coordinates.
            </summary>
            <remarks>Calls <see cref="M:Au.Wnd.GetRect(Au.Types.RECT@)"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.Y">
            <summary>
            Gets vertical position in screen coordinates.
            </summary>
            <remarks>Calls <see cref="M:Au.Wnd.GetRect(Au.Types.RECT@)"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.Width">
            <summary>
            Gets width.
            </summary>
            <remarks>Calls <see cref="M:Au.Wnd.GetRect(Au.Types.RECT@)"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.Height">
            <summary>
            Gets height.
            </summary>
            <remarks>Calls <see cref="M:Au.Wnd.GetRect(Au.Types.RECT@)"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.GetClientRect(Au.Types.RECT@)">
            <summary>
            Gets client area rectangle.
            The same as the <see cref="P:Au.Wnd.ClientRect"/> property.
            The same as <see cref="M:Au.Wnd.GetClientSize(System.Drawing.Size@)"/>, just the parameter type is different.
            </summary>
            <param name="r">Receives the rectangle. Will be empty if failed.</param>
            <remarks>
            Calls API <msdn>GetClientRect</msdn> and returns its return value.
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="M:Au.Wnd.GetClientSize(System.Drawing.Size@)">
            <summary>
            Gets client area width and height.
            The same as the <see cref="P:Au.Wnd.ClientSize"/> property.
            The same as <see cref="M:Au.Wnd.GetClientRect(Au.Types.RECT@)"/>, just the parameter type is different.
            </summary>
            <param name="z">Receives width and height. Will be empty if failed.</param>
            <remarks>
            Calls API <msdn>GetClientRect</msdn> and returns its return value.
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="P:Au.Wnd.ClientRect">
            <summary>
            Gets client area rectangle (width and height).
            The same as <see cref="P:Au.Wnd.ClientSize"/>, just the return type is different.
            </summary>
            <remarks>
            The left and top fields are always 0. The right and bottom fields are the width and height of the client area.
            Calls <see cref="M:Au.Wnd.GetClientRect(Au.Types.RECT@)"/>. Returns empty rectangle if fails (eg window closed).
            </remarks>
        </member>
        <member name="P:Au.Wnd.ClientSize">
            <summary>
            Gets client area width and height.
            The same as <see cref="P:Au.Wnd.ClientRect"/>, just the return type is different.
            </summary>
            <remarks>
            Calls <see cref="M:Au.Wnd.GetClientSize(System.Drawing.Size@)"/>. Returns empty Size value if fails (eg window closed).
            </remarks>
        </member>
        <member name="P:Au.Wnd.ClientWidth">
            <summary>
            Gets client area width.
            </summary>
            <remarks>Calls <see cref="M:Au.Wnd.GetClientSize(System.Drawing.Size@)"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.ClientHeight">
            <summary>
            Gets client area height.
            </summary>
            <remarks>Calls <see cref="M:Au.Wnd.GetClientSize(System.Drawing.Size@)"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.SetClientSize(System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Calculates and sets window rectangle from the specified client area rectangle.
            Calls <see cref="M:Au.Wnd.ResizeLL(System.Int32,System.Int32)">ResizeLL</see>.
            </summary>
            <param name="width">Width. Use null to not change.</param>
            <param name="height">Height. Use null to not change.</param>
            <exception cref="T:Au.Types.WndException"/>
        </member>
        <member name="M:Au.Wnd.LibGetWindowInfo(Au.Types.Api.WINDOWINFO@)">
            <summary>
            Calls API <msdn>GetWindowInfo</msdn>.
            </summary>
            <param name="wi">Receives window/client rectangles, styles etc.</param>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.GetWindowAndClientRectInScreen(Au.Types.RECT@,Au.Types.RECT@)">
            <summary>
            Gets window rectangle and client area rectangle, both in screen coordinates.
            </summary>
            <param name="rWindow">Receives window rectangle.</param>
            <param name="rClient">Receives client area rectangle.</param>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.ClientRectInScreen">
            <summary>
            Gets client area rectangle in screen coordinates.
            </summary>
            <remarks>
            Calls <see cref="M:Au.Wnd.GetWindowAndClientRectInScreen(Au.Types.RECT@,Au.Types.RECT@)"/>. Returns empty rectangle if fails (eg window closed).
            </remarks>
        </member>
        <member name="M:Au.Wnd.MapClientToClientOf(Au.Wnd,Au.Types.RECT@)">
            <summary>
            Converts coordinates relative to the client area of this window to coordinates relative to the client area of window w.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.MapClientToClientOf(Au.Wnd,System.Drawing.Point@)">
            <summary>
            Converts coordinates relative to the client area of this window to coordinates relative to the client area of window w.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.MapClientToScreen(Au.Types.RECT@)">
            <summary>
            Converts coordinates relative to the client area of this window to coordinates relative to the screen.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.MapClientToScreen(System.Drawing.Point@)">
            <summary>
            Converts coordinates relative to the client area of this window to coordinates relative to the screen.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.MapScreenToClient(Au.Types.RECT@)">
            <summary>
            Converts coordinates relative to the screen to coordinates relative to the client area of this window.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.MapScreenToClient(System.Drawing.Point@)">
            <summary>
            Converts coordinates relative to the screen to coordinates relative to the client area of this window.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.MapClientToWindow(System.Drawing.Point@)">
            <summary>
            Converts coordinates relative to the client area of this window to coordinates relative to the top-left corner of this window.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.MapClientToWindow(Au.Types.RECT@)">
            <summary>
            Converts coordinates relative to the client area of this window to coordinates relative to the top-left corner of this window.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.MapWindowToClient(System.Drawing.Point@)">
            <summary>
            Converts coordinates relative to the top-left corner of this window to coordinates relative to the client area of this window.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.MapWindowToClient(Au.Types.RECT@)">
            <summary>
            Converts coordinates relative to the top-left corner of this window to coordinates relative to the client area of this window.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.MapWindowToScreen(System.Drawing.Point@)">
            <summary>
            Converts coordinates relative to the top-left corner of this window to screen coordinates.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.MapWindowToScreen(Au.Types.RECT@)">
            <summary>
            Converts coordinates relative to the top-left corner of this window to screen coordinates.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.GetRectInClientOf(Au.Wnd,Au.Types.RECT@)">
            <summary>
            Gets rectangle of this window (usually control) relative to the client area of another window (usually the parent).
            </summary>
            <param name="w">The returned rectangle will be relative to the client area of window w. If w is default(Wnd), gets rectangle in screen.</param>
            <param name="r">Receives the rectangle.</param>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
            <seealso cref="P:Au.Wnd.RectInParent"/>
        </member>
        <member name="P:Au.Wnd.RectInParent">
            <summary>
            Gets or sets child window rectangle in parent window's client area.
            </summary>
            <remarks>
            Calls <see cref="M:Au.Wnd.GetRectInClientOf(Au.Wnd,Au.Types.RECT@)">GetRectInClientOf</see>. Returns empty rectangle if fails (eg window closed).
            </remarks>
        </member>
        <member name="M:Au.Wnd.GetRectNotMinMax(Au.Types.RECT@)">
            <summary>
            Gets rectangle of normal (restored) window even if currently it is minimized or maximized.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.MouseClientXY">
            <summary>
            Returns mouse pointer position relative to the client area of this window.
            </summary>
        </member>
        <member name="M:Au.Wnd.ContainsScreenXY(Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)">
            <summary>
            Returns true if this window (its rectangle) contains the specified point in primary screen coordinates.
            </summary>
            <param name="x">X coordinate in screen. Not used if null.</param>
            <param name="y">Y coordinate in screen. Not used if null.</param>
            <param name="co">Allows to specify screen (see <see cref="M:Au.Screen_.FromObject(System.Object)"/>) and/or whether to use the work area.</param>
        </member>
        <member name="M:Au.Wnd.ContainsWindowXY(Au.Wnd,Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Returns true if this control (its rectangle) contains the specified point in parent window.
            </summary>
            <param name="parent">
            Direct or indirect parent window. The coordinates are relative to its client area.
            Actually this and parent can be any windows or controls, the function does not check whether this is a child of parent.
            </param>
            <param name="x">X coordinate. Not used if null.</param>
            <param name="y">Y coordinate. Not used if null.</param>
        </member>
        <member name="M:Au.Wnd.ContainsWindowXY(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            This overload calls <see cref="M:Au.Wnd.ContainsWindowXY(Au.Wnd,Au.Types.Coord,Au.Types.Coord)">ContainsWindowXY</see>(WndWindow, x, y).
            </summary>
        </member>
        <member name="M:Au.Wnd.SetWindowPos(System.UInt32,System.Int32,System.Int32,System.Int32,System.Int32,Au.Wnd)">
            <summary>
            Calls API <msdn>SetWindowPos</msdn>.
            </summary>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            For swpFlags you can use Native.SWP_NOMOVE etc.
            For wndInsertAfter you can use SpecHwnd.HWND_TOPMOST etc.
            </remarks>
        </member>
        <member name="M:Au.Wnd.MoveLL(System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32)">
            <summary>
            Moves and resizes.
            </summary>
            <remarks>
            See also <see cref="M:Au.Wnd.Move(Au.Types.Coord,Au.Types.Coord,Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)"/>. It is better to use in automation scripts, with windows of any process/thread. It throws exceptions, supports optional/reverse/fractional/workarea coordinates, restores if min/max, does not support SWP_ flags.
            This function is low-level, it just calls API <msdn>SetWindowPos</msdn> with flags SWP_NOZORDER|SWP_NOOWNERZORDER|SWP_NOACTIVATE|swpFlagsToAdd. It is better to use in programming, with windows of current thread.
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            
            For top-level windows use screen coordinates. For controls - direct parent client coordinates.
            </remarks>
            <seealso cref="M:Au.Wnd.SetWindowPos(System.UInt32,System.Int32,System.Int32,System.Int32,System.Int32,Au.Wnd)"/>
        </member>
        <member name="M:Au.Wnd.MoveLL(System.Int32,System.Int32)">
            <summary>
            Moves.
            </summary>
            <remarks>
            See also <see cref="M:Au.Wnd.Move(Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)"/>. It is better to use in automation scripts, with windows of any process/thread. It throws exceptions, supports optional/reverse/fractional/workarea coordinates, restores if min/max.
            This function is low-level, it just calls API <msdn>SetWindowPos</msdn> with flags SWP_NOSIZE|SWP_NOZORDER|SWP_NOOWNERZORDER|SWP_NOACTIVATE. It is better to use in programming, with windows of current thread.
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            
            For top-level windows use screen coordinates. For controls - direct parent client coordinates.
            </remarks>
            <seealso cref="M:Au.Wnd.SetWindowPos(System.UInt32,System.Int32,System.Int32,System.Int32,System.Int32,Au.Wnd)"/>
        </member>
        <member name="M:Au.Wnd.ResizeLL(System.Int32,System.Int32)">
            <summary>
            Resizes.
            </summary>
            <remarks>
            See also <see cref="M:Au.Wnd.Resize(Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)"/>. It is better to use in automation scripts, with windows of any process/thread. It throws exceptions, supports optional/reverse/fractional/workarea coordinates, restores if min/max.
            This function is low-level, it just calls API <msdn>SetWindowPos</msdn> with flags SWP_NOMOVE|SWP_NOZORDER|SWP_NOOWNERZORDER|SWP_NOACTIVATE. It is better to use in programming, with windows of current thread.
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
            <seealso cref="M:Au.Wnd.SetWindowPos(System.UInt32,System.Int32,System.Int32,System.Int32,System.Int32,Au.Wnd)"/>
        </member>
        <member name="M:Au.Wnd.Move(Au.Types.Coord,Au.Types.Coord,Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)">
            <summary>
            Moves and/or resizes.
            With windows of current thread usually it's better to use <see cref="M:Au.Wnd.MoveLL(System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32)"/>.
            </summary>
            <param name="x">Left. If null, does not move in X axis.</param>
            <param name="y">Top. If null, does not move in Y axis.</param>
            <param name="width">Width. If null, does not change width.</param>
            <param name="height">Height. If null, does not change height.</param>
            <param name="co">Allows to specify screen (see <see cref="M:Au.Screen_.FromObject(System.Object)"/>) and/or whether to use the work area. Not used when this is a child window. For width/height used when width or height is Coord.Reverse etc.</param>
            <remarks>
            Also restores the visible top-level window if it is minimized or maximized.
            For top-level windows use screen coordinates. For controls - direct parent client coordinates.
            </remarks>
            <exception cref="T:Au.Types.WndException"/>
        </member>
        <member name="M:Au.Wnd.Move(Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)">
            <summary>
            Moves.
            Calls Move(x, y, null, null, workArea).
            With windows of current thread usually it's better to use <see cref="M:Au.Wnd.MoveLL(System.Int32,System.Int32)"/>.
            </summary>
            <param name="x">Left. If null, does not move in X axis.</param>
            <param name="y">Top. If null, does not move in Y axis.</param>
            <param name="co">Allows to specify screen (see <see cref="M:Au.Screen_.FromObject(System.Object)"/>) and/or whether to use the work area. Not used when this is a child window.</param>
            <exception cref="T:Au.Types.WndException"/>
            <remarks>
            Also restores the visible top-level window if it is minimized or maximized.
            For top-level windows use screen coordinates. For controls - direct parent client coordinates.
            </remarks>
        </member>
        <member name="M:Au.Wnd.Resize(Au.Types.Coord,Au.Types.Coord,Au.Types.CoordOptions)">
            <summary>
            Resizes.
            Calls Move(null, null, width, height, workArea).
            With windows of current thread usually it's better to use <see cref="M:Au.Wnd.ResizeLL(System.Int32,System.Int32)"/>.
            </summary>
            <param name="width">Width. If null, does not change width.</param>
            <param name="height">Height. If null, does not change height.</param>
            <param name="co">Allows to specify screen (see <see cref="M:Au.Screen_.FromObject(System.Object)"/>) and/or whether to use the work area. Used when width or height is Coord.Reverse etc. Not used when this is a child window.</param>
            <exception cref="T:Au.Types.WndException"/>
            <remarks>
            Also restores the visible top-level window if it is minimized or maximized.
            </remarks>
        </member>
        <member name="M:Au.Wnd.MoveInScreen(Au.Types.Coord,Au.Types.Coord,System.Object,System.Boolean,System.Boolean)">
            <summary>
            Moves this window to coordinates x y in specified screen, and ensures that entire window is in screen.
            </summary>
            <param name="x">X coordinate in the specified screen. If null - screen center. You also can use Coord.Reverse etc.</param>
            <param name="y">Y coordinate in the specified screen. If null - screen center. You also can use Coord.Reverse etc.</param>
            <param name="screen">Move to this screen (see <see cref="M:Au.Screen_.FromObject(System.Object)"/>). If null (default), use screen of this window.</param>
            <param name="workArea">Use the work area, not whole screen. Default true.</param>
            <param name="ensureInScreen">If part of window is not in screen, move and/or resize it so that entire window would be in screen. Default true.</param>
            <exception cref="T:Au.Types.WndException"/>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid screen index.</exception>
            <remarks>
            If the window is maximized, minimized or hidden, it will have the new position and size when restored, not immediately, except when moving maximized to another screen.
            </remarks>
            <seealso cref="M:Au.Types.RECT.MoveInScreen(Au.Types.Coord,Au.Types.Coord,System.Object,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.Wnd.EnsureInScreen(System.Object,System.Boolean)">
            <summary>
            Moves this window if need, to ensure that entire window is in screen.
            </summary>
            <param name="screen">
            Move to this screen (see <see cref="M:Au.Screen_.FromObject(System.Object)"/>). If null (default), uses screen of this window.
            If screen index is invalid, shows warning, no exception. Then uses screen of this window.
            </param>
            <param name="workArea">Use the work area, not whole screen. Default true.</param>
            <exception cref="T:Au.Types.WndException"/>
            <remarks>
            If the window is maximized, minimized or hidden, it will have the new position and size when restored, not immediately.
            </remarks>
            <seealso cref="M:Au.Types.RECT.EnsureInScreen(System.Object,System.Boolean)"/>
        </member>
        <member name="M:Au.Wnd.MoveToScreenCenter(System.Object)">
            <summary>
            Moves this window to the center of the screen.
            Calls ShowNotMinMax(true) and MoveInScreen(null, null, screen, true, true).
            </summary>
            <param name="screen">Move to this screen (see <see cref="M:Au.Screen_.FromObject(System.Object)"/>). If null (default), uses screen of this window.</param>
            <exception cref="T:Au.Types.WndException"/>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid screen index.</exception>
            <seealso cref="M:Au.Types.RECT.MoveInScreen(Au.Types.Coord,Au.Types.Coord,System.Object,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:Au.Wnd.Screen">
            <summary>
            Gets <see cref="T:System.Windows.Forms.Screen"/> object of the screen that contains this window (the biggest part of it) or is nearest to it.
            If this window handle is default(Wnd) or invalid, gets the primary screen.
            Calls <see cref="M:Au.Screen_.FromWindow(Au.Wnd)"/>.
            </summary>
        </member>
        <member name="M:Au.Wnd.ZorderAbove(Au.Wnd)">
            <summary>
            Places this window before window w in the Z order.
            Also can make this window topmost or non-topmost, depending on where w is in the Z order.
            This window and w can be both top-level windows or both controls of same parent.
            May not work with top-level windows when it would move an inactive window above the active window.
            If w is default(Wnd), calls <see cref="M:Au.Wnd.ZorderBottom"/>.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.ZorderBelow(Au.Wnd)">
            <summary>
            Places this window after window w in the Z order.
            Also can make this window topmost or non-topmost, depending on where w is in the Z order.
            This window and w can be both top-level windows or both controls of same parent.
            May not work with top-level windows when it would move an inactive window above the active window.
            If w is default(Wnd), calls <see cref="M:Au.Wnd.ZorderTop"/>.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.ZorderTop">
            <summary>
            Places this window or control at the top of the Z order.
            If the window was topmost, it will be at the top of topmost windows, else at the top of non-topmost windows (after topmost windows).
            Does not activate.
            In most cases does not work with top-level inactive windows, although returns true; instead use <see cref="M:Au.Wnd.ActivateLL"/>.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.ZorderBottom">
            <summary>
            Places this window or control at the bottom of the Z order.
            If the window was topmost, makes it and its owner window non-topmost.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.ZorderTopmost">
            <summary>
            Makes this window topmost (always on top of non-topmost windows in the Z order).
            Does not activate.
            If this window has an owner window, the owner does not become topmost.
            This cannot be a control.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.ZorderNoTopmost(System.Boolean)">
            <summary>
            Makes this window non-topmost.
            If this window has an owner window, makes the owner window non-topmost too.
            This cannot be a control.
            </summary>
            <param name="afterActiveWindow">Also place this window after the active nontopmost window in the Z order, unless the active window is its owner.</param>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.IsTopmost">
            <summary>
            Returns true if this is a topmost (always-on-top) window.
            </summary>
        </member>
        <member name="M:Au.Wnd.ZorderIsBefore(Au.Wnd)">
            <summary>
            Returns true if this window is above window w in the Z order.
            </summary>
        </member>
        <member name="P:Au.Wnd.Style">
            <summary>
            Gets window style.
            </summary>
            <value>One or more Native.WS_ flags (not WS_EX_) and/or class-specific style flags. Reference: <msdn>window styles</msdn>.</value>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
            <seealso cref="M:Au.Wnd.HasStyle(System.UInt32)"/>
            <seealso cref="M:Au.Wnd.SetStyle(System.UInt32,Au.Types.SetAddRemove,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:Au.Wnd.ExStyle">
            <summary>
            Gets window extended style.
            </summary>
            <value>One or more Native.WS_EX_ flags. Reference: <msdn>extended window styles</msdn>.</value>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
            <seealso cref="M:Au.Wnd.HasExStyle(System.UInt32)"/>
            <seealso cref="M:Au.Wnd.SetExStyle(System.UInt32,Au.Types.SetAddRemove,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.Wnd.HasStyle(System.UInt32)">
            <summary>
            Returns true if the window has all specified style flags (see <see cref="P:Au.Wnd.Style"/>).
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.HasExStyle(System.UInt32)">
            <summary>
            Returns true if the window has all specified extended style flags (see <see cref="P:Au.Wnd.ExStyle"/>).
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.SetStyle(System.UInt32,Au.Types.SetAddRemove,System.Boolean,System.Boolean)">
            <summary>
            Changes window style.
            </summary>
            <param name="style">One or more Native.WS_ flags (not WS_EX_) and/or class-specific style flags. Reference: <msdn>window styles</msdn>.</param>
            <param name="how"></param>
            <param name="updateNC">Update non-client area (frame, title bar).</param>
            <param name="updateClient">Update client area.</param>
            <exception cref="T:Au.Types.WndException"/>
            <seealso cref="P:Au.Wnd.Style"/>
        </member>
        <member name="M:Au.Wnd.SetExStyle(System.UInt32,Au.Types.SetAddRemove,System.Boolean,System.Boolean)">
            <summary>
            Changes window extended style.
            </summary>
            <param name="style">One or more Native.WS_EX_ flags. Reference: <msdn>extended window styles</msdn>.</param>
            <param name="how"></param>
            <param name="updateNC">Update non-client area (frame, title bar).</param>
            <param name="updateClient">Update client area.</param>
            <exception cref="T:Au.Types.WndException"/>
            <seealso cref="P:Au.Wnd.ExStyle"/>
        </member>
        <member name="P:Au.Wnd.IsPopupWindow">
            <summary>
            Returns true if has Native.WS_POPUP style.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.IsToolWindow">
            <summary>
            Returns true if has Native.WS_EX_TOOLWINDOW style.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.IsResizable">
            <summary>
            Returns true if has Native.WS_THICKFRAME style.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.GetWindowLong(System.Int32)">
            <summary>
            Calls API GetWindowLong if this process is 32-bit, GetWindowLongPtr if 64-bit.
            </summary>
            <remarks>
            All Native.GWL_ values are the same in 32-bit and 64-bit process. Some Native.DWL_ values are different, use Native.DWLP_ instead.
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="M:Au.Wnd.SetWindowLong(System.Int32,Au.Types.LPARAM)">
            <summary>
            Calls API <msdn>SetWindowLong</msdn> if this process is 32-bit, SetWindowLongPtr if 64-bit.
            </summary>
            <remarks>
            All Native.GWL_ values are the same in 32-bit and 64-bit process. Some Native.DWL_ values are different, use Native.DWLP_ instead.
            </remarks>
            <exception cref="T:Au.Types.WndException"/>
        </member>
        <member name="P:Au.Wnd.ControlId">
            <summary>
            Gets or sets id of this control.
            The 'get' function supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <exception cref="T:Au.Types.WndException">Failed (only 'set' function).</exception>
        </member>
        <member name="P:Au.Wnd.Prop">
            <summary>
            Returns an object that manages window properties using API <msdn>SetProp</msdn> and co.
            </summary>
            <example>
            <code><![CDATA[
            var w = Wnd.Find("* Explorer");
            w.Prop.Set("example", 5);
            Print(w.Prop["example"]);
            Print(w.Prop); //shows all w properties
            w.Prop.Remove("example"); //you should always remove window properties if don't want to see unrelated applications crashing after some time. And don't use many unique property names.
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Wnd.GetThreadProcessId(System.Int32@)">
            <summary>
            Calls API <msdn>GetWindowThreadProcessId</msdn>.
            Returns thread id and also gets process id.
            Returns 0 if fails. Supports <see cref="M:Au.Types.Native.GetError"/>.
            <note>It is native thread id, not Thread.ManagedThreadId.</note>
            </summary>
        </member>
        <member name="P:Au.Wnd.ThreadId">
            <summary>
            Calls API <msdn>GetWindowThreadProcessId</msdn> and returns thread id.
            Returns 0 if fails. Supports <see cref="M:Au.Types.Native.GetError"/>.
            <note>It is native thread id, not Thread.ManagedThreadId.</note>
            </summary>
        </member>
        <member name="P:Au.Wnd.ProcessId">
            <summary>
            Calls API <msdn>GetWindowThreadProcessId</msdn> and returns process id.
            Returns 0 if fails. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
        </member>
        <member name="P:Au.Wnd.IsOfThisThread">
            <summary>
            Returns true if this window belongs to the current thread, false if to another thread.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="M:Au.Types.Native.GetError"/>.
            Calls API <msdn>GetWindowThreadProcessId</msdn>.
            </summary>
        </member>
        <member name="P:Au.Wnd.IsOfThisProcess">
            <summary>
            Returns true if this window belongs to the current process, false if to another process.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="M:Au.Types.Native.GetError"/>.
            Calls API <msdn>GetWindowThreadProcessId</msdn>.
            </summary>
        </member>
        <member name="P:Au.Wnd.IsUnicode">
            <summary>
            Returns true if the window is a Unicode window, false if ANSI.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="M:Au.Types.Native.GetError"/>.
            Calls API <msdn>IsWindowUnicode</msdn>.
            </summary>
        </member>
        <member name="P:Au.Wnd.Is64Bit">
            <summary>
            Returns true if the window is of a 64-bit process, false if of a 32-bit process.
            Also returns false if fails. Supports <see cref="M:Au.Types.Native.GetError"/>.
            If <see cref="P:Au.Ver.Is64BitOS"/> is true, calls API <msdn>GetWindowThreadProcessId</msdn>, <msdn>OpenProcess</msdn> and <msdn>IsWow64Process</msdn>.
            <note>If you know that the window belongs to current process, instead use <see cref="P:System.Environment.Is64BitProcess"/> or <c>IntPtr.Size==8</c>. This function is much slower.</note>
            </summary>
        </member>
        <member name="P:Au.Wnd.IsHung">
            <summary>
            Returns true if thread of this window is considered hung (not responding).
            Calls API <msdn>IsHungAppWindow</msdn>.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.IsHungGhost">
            <summary>
            Returns true if the window is a ghost window that the system creates over a hung (not responding) window to allow the user to minimally interact with it.
            </summary>
        </member>
        <member name="P:Au.Wnd.IsConsole">
            <summary>
            Returns true if this is a console window (class name "ConsoleWindowClass").
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.IsUacAccessDenied">
            <summary>
            Returns true if UAC would not allow to automate the window.
            It happens when current process has lower UAC integrity level and is not uiAccess, unless UAC is turned off.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.ClassName">
            <summary>
            Gets class name.
            Returns null if fails, eg if the window is closed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
        </member>
        <member name="M:Au.Wnd.ClassNameIs(System.String)">
            <summary>
            Returns true if the class name of this window matches className. Else returns false.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <param name="className">Class name. Case-insensitive <see cref="M:Au.String_.Like_(System.String,System.String,System.Boolean)">wildcard</see>. Cannot be null.</param>
        </member>
        <member name="M:Au.Wnd.ClassNameIs(System.String[])">
            <summary>
            If the class name of this window matches one of strings in classNames, returns 1-based index of the string. Else returns 0.
            Also returns 0 if fails to get class name (probably window closed or 0 handle). Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <param name="classNames">Class names. Case-insensitive <see cref="M:Au.String_.Like_(System.String,System.String,System.Boolean)">wildcard</see>. The array and strings cannot be null.</param>
        </member>
        <member name="P:Au.Wnd.Name">
            <summary>
            Gets window or control name.
            Returns "" if no name. Returns null if fails, eg if the window is closed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <remarks>
            <note>It is not the .NET Control.Name property. To get it you can use <see cref="P:Au.Wnd.NameWinForms"/>.</note>
            Top-level window name usually its title bar text.
            Control name usually is its text that does not change, for example button or static (label) control text.
            Unlike <see cref="P:Au.Wnd.ControlText"/>, this function usually does not get variable text, for example Edit control editable text, ComboBox control selected item text, status bar text.
            Calls <see cref="M:Au.Wnd.GetText(System.Nullable{System.Boolean},System.Boolean)"/>(false, true).
            </remarks>
            <seealso cref="M:Au.Wnd.SetText(System.String)"/>
            <seealso cref="P:Au.Wnd.ControlText"/>
            <seealso cref="P:Au.Wnd.NameAcc"/>
            <seealso cref="P:Au.Wnd.NameWinForms"/>
        </member>
        <member name="P:Au.Wnd.ControlText">
            <summary>
            Gets control text.
            Returns "" if no text. Returns null if fails, eg if the window is closed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <remarks>
            Unlike <see cref="P:Au.Wnd.Name"/>, this function prefers variable text, for example Edit control editable text, ComboBox control selected item text, status bar text.
            For controls that cannot have such text (eg button, static), it usually gets the same text as <b>Name</b>. For example button and static (label) controls.
            Much slower than <b>Name</b>. Fails if the window is hung.
            Calls <see cref="M:Au.Wnd.GetText(System.Nullable{System.Boolean},System.Boolean)"/>(true, false).
            </remarks>
            <seealso cref="M:Au.Wnd.SetText(System.String)"/>
            <seealso cref="P:Au.Wnd.Name"/>
        </member>
        <member name="M:Au.Wnd.GetText(System.Nullable{System.Boolean},System.Boolean)">
            <summary>
            Gets window/control name or control text.
            Returns "" if it is empty.
            Returns null if fails, eg if the window is closed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            This is a low-level function. You can instead use <see cref="P:Au.Wnd.Name"/> and <see cref="P:Au.Wnd.ControlText"/>.
            </summary>
            <param name="getText">
            false - use API function <msdn>InternalGetWindowText</msdn>. It is fast and usually does not get variable text. This is used by <see cref="P:Au.Wnd.Name"/>.
            true - use API message <msdn>WM_GETTEXT</msdn>. It is slow and prefers variable text. This is used by <see cref="P:Au.Wnd.ControlText"/>. Fails if the window is hung.
            null - try InternalGetWindowText. If it gets "", and this is a control, then try WM_GETTEXT.
            </param>
            <param name="removeUnderlineAmpersand">
            Remove the invisible '&amp;' characters that are used to underline keyboard shortcuts with the Alt key.
            Removes only if this is a control (has style Native.WS_CHILD).
            Calls <see cref="M:Au.Wnd.Misc.StringRemoveUnderlineAmpersand(System.String)"/>.
            </param>
            <seealso cref="M:Au.Wnd.SetText(System.String)"/>
            <seealso cref="P:Au.Wnd.NameAcc"/>
            <seealso cref="P:Au.Wnd.NameWinForms"/>
        </member>
        <member name="M:Au.Wnd._GetTextFast(System.Boolean)">
            <summary>
            Gets text.
            Returns "" if it is empty.
            Returns null if fails, eg if the control is destroyed or its thread is hung. Supports <see cref="M:Au.Types.Native.GetError"/>.
            Calls API InternalGetWindowText. If it fails, and getControlTextIfEmpty==true, and this is a control, calls _GetTextSlow, which uses WM_GETTEXT.
            </summary>
        </member>
        <member name="M:Au.Wnd._GetTextSlow">
            <summary>
            Gets text.
            Returns "" if it is empty.
            Returns null if fails, eg if the control is destroyed or its thread is hung. Supports <see cref="M:Au.Types.Native.GetError"/>.
            Uses WM_GETTEXT.
            </summary>
        </member>
        <member name="M:Au.Wnd.SetText(System.String)">
            <summary>
            Sets window/control name or control text.
            </summary>
            <param name="text">Text. Can be null, it is the same as "".</param>
            <remarks>
            Uses API <msdn>WM_SETTEXT</msdn>.
            Top-level window name usually its title bar text.
            For variable-text controls (edit, combo box, status bar, ...) this usually is the text that <see cref="P:Au.Wnd.ControlText"/> would get.
            For other controls (button, static, ...) and top-level windows this usually is the text that <see cref="P:Au.Wnd.Name"/> would get.
            </remarks>
            <exception cref="T:Au.Types.WndException">Failed, for example the window is closed.</exception>
            <seealso cref="M:Au.Wnd.GetText(System.Nullable{System.Boolean},System.Boolean)"/>
            <seealso cref="P:Au.Wnd.Name"/>
            <seealso cref="P:Au.Wnd.ControlText"/>
        </member>
        <member name="P:Au.Wnd.NameAcc">
            <summary>
            Gets <see cref="P:Au.Acc.Name"/> of the accessible object (role WINDOW) of this window or control.
            Returns "" if the object has no name or failed to get it. Returns null if invalid window handle.
            </summary>
        </member>
        <member name="P:Au.Wnd.NameWinForms">
            <summary>
            Gets Control.Name property of a .NET Windows Forms control.
            Returns null if it is not a Windows Forms control or if fails.
            <note>Use this with controls of other processes. Don't use with your controls, when you have a Control object.</note>
            <note>This is slow when getting names of multiple controls in a window. Instead create a <see cref="T:Au.Wnd.Misc.WinFormsControlNames"/> instance and call its <see cref="M:Au.Wnd.Misc.WinFormsControlNames.GetControlName(Au.Wnd)"/> method for each control.</note>
            </summary>
            <seealso cref="M:Au.Wnd.Misc.WinFormsControlNames.IsWinFormsControl(Au.Wnd)"/>
        </member>
        <member name="P:Au.Wnd.ProcessName">
            <summary>
            Gets filename (without ".exe") of process executable file.
            Return null if fails.
            Calls <see cref="P:Au.Wnd.ProcessId"/> and <see cref="M:Au.Process_.GetProcessName(System.Int32,System.Boolean,System.Boolean)">Process_.GetProcessName</see>.
            </summary>
        </member>
        <member name="P:Au.Wnd.ProcessPath">
            <summary>
            Gets full path of process executable file.
            Return null if fails.
            Calls <see cref="P:Au.Wnd.ProcessId"/> and <see cref="M:Au.Process_.GetProcessName(System.Int32,System.Boolean,System.Boolean)">Process_.GetProcessName</see>.
            </summary>
        </member>
        <member name="M:Au.Wnd.Close(System.Boolean,System.Boolean)">
            <summary>
            Closes the window.
            Returns true if successfuly closed or if it was already closed (the handle is 0 or invalid) or if noWait==true.
            </summary>
            <param name="noWait">
            If false (default), waits a while until the window is destroyed or disabled. But does not wait indefinitely.
            If true, does not wait.
            </param>
            <param name="useXButton">
            If false (default), uses API message <msdn>WM_CLOSE</msdn>.
            If true, uses API message <msdn>WM_SYSCOMMAND SC_CLOSE</msdn>, like when the user clicks the X button in the title bar.
            Most windows can be closed with any of these messages, but some respond properly only to one of them. For example, some applications on WM_CLOSE don't exit, although the main window is closed. Some applications don't respond to WM_SYSCOMMAND if it is posted soon after opening the window, for example Internet Explorer.
            </param>
            <remarks>
            The window may refuse to be closed. For example, it may be hung, or hide itself instead, or display a "Save?" message box, or is a dialog without X button, or just need more time to close it.
            If the window is of this thread, just calls <see cref="M:Au.Wnd.Send(System.UInt32,Au.Types.LPARAM,Au.Types.LPARAM)">Send</see> (if noWait==false) or <see cref="M:Au.Wnd.Post(System.UInt32,Au.Types.LPARAM,Au.Types.LPARAM)">Post</see> (if noWait==true) and returns true.
            </remarks>
            <example>
            <code><![CDATA[
            //close all Notepad windows
            Wnd.FindAll("* Notepad", "Notepad").ForEach(t => t.Close());
            ]]></code>
            </example>
        </member>
        <member name="T:Au.Wnd.ChildFinder">
            <summary>
            Contains control (child window) properties and is used to find the control.
            Can be used instead of <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/> or <see cref="M:Au.Wnd.ChildAll(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean})"/>.
            Also can be used to find window that contains certain control, like in the example.
            </summary>
            <example>
            Find window that contains certain control, and get the control too.
            <code><![CDATA[
            var f = new Wnd.ChildFinder("Password*", "Static"); //control properties
            Wnd w = Wnd.Find(className: "#32770", also: t => f.Find(t));
            Print(w);
            Print(f.Result);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Wnd.ChildFinder.#ctor(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)">
            <summary>
            See <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)">Wnd.Child</see>.
            </summary>
            <exception cref="T:System.ArgumentException">
            className is "". To match any, use null.
            Invalid wildcard expression ("**options " or regular expression).
            </exception>
        </member>
        <member name="P:Au.Wnd.ChildFinder.Result">
            <summary>
            The found control.
            </summary>
        </member>
        <member name="M:Au.Wnd.ChildFinder.Find(Au.Wnd)">
            <summary>
            Finds the specified child control, like <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/>.
            Returns true if found.
            The <see cref="P:Au.Wnd.ChildFinder.Result"/> property will be the control.
            </summary>
            <param name="wParent">Direct or indirect parent window. Can be top-level window or control.</param>
            <exception cref="T:Au.Types.WndException">Invalid wParent.</exception>
        </member>
        <member name="M:Au.Wnd.ChildFinder.FindInList(System.Collections.Generic.IEnumerable{Au.Wnd},Au.Wnd)">
            <summary>
            Finds the specified control in a list of controls.
            Returns 0-based index, or -1 if not found.
            The <see cref="P:Au.Wnd.ChildFinder.Result"/> property will be the control.
            </summary>
            <param name="a">List of controls, for example returned by <see cref="M:Au.Wnd.AllChildren(System.Boolean,System.Boolean,System.Boolean)"/>.</param>
            <param name="wParent">Direct or indirect parent window. Used only for flag DirectChild.</param>
        </member>
        <member name="M:Au.Wnd.ChildFinder.FindAll(Au.Wnd)">
            <summary>
            Finds all matching child controls, like <see cref="M:Au.Wnd.ChildAll(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean})"/>.
            Returns array containing 0 or more control handles as Wnd.
            </summary>
            <param name="wParent">Direct or indirect parent window. Can be top-level window or control.</param>
            <exception cref="T:Au.Types.WndException">Invalid wParent.</exception>
        </member>
        <member name="M:Au.Wnd.ChildFinder.FindAllInList(System.Collections.Generic.IEnumerable{Au.Wnd},Au.Wnd)">
            <summary>
            Finds all matching controls in a list of controls.
            Returns array containing 0 or more control handles as Wnd.
            </summary>
            <param name="a">List of controls, for example returned by <see cref="M:Au.Wnd.AllChildren(System.Boolean,System.Boolean,System.Boolean)"/>.</param>
            <param name="wParent">Direct or indirect parent window. Used only for flag DirectChild.</param>
        </member>
        <member name="M:Au.Wnd.ChildFinder._FindInList(Au.Wnd,Au.Wnd._WndList,System.Action{Au.Wnd})">
            <summary>
            Returns index of matching element or -1.
            Returns -1 if using getAll.
            </summary>
            <param name="wParent">Parent window. Can be default(Wnd) if inList is true and no DirectChild flag and not using winforms name.</param>
            <param name="a">List of Wnd. Does not dispose it.</param>
            <param name="getAll">If not null, calls it for all matching and returns -1.</param>
        </member>
        <member name="M:Au.Wnd.ChildFinder.IsMatch(Au.Wnd,Au.Wnd)">
            <summary>
            Returns true if control c properties match the specified properties.
            </summary>
            <param name="c">A control. Can be 0/invalid, then returns false.</param>
            <param name="wParent">Direct or indirect parent window. If used, returns false if it isn't parent (also depends on flag DirectChild).</param>
        </member>
        <member name="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)">
            <summary>
            Finds a child control and returns its handle as Wnd.
            Returns default(Wnd) if not found. See also: <see cref="P:Au.Wnd.Is0"/>, <see cref="M:Au.Types.ExtensionMethods.OrThrow(Au.Wnd)"/>, <see cref="M:Au.Wnd.op_UnaryPlus(Au.Wnd)"/>.
            </summary>
            <param name="name">
            Control name.
            By default the function gets control names with <see cref="P:Au.Wnd.Name"/>.
            Can start with these prefix strings:
            <list type="bullet">
            <item>
            "**text:" - use <see cref="P:Au.Wnd.ControlText"/>.
            It is slower and can be less reliable (because can get editable text), especially if className not used. It does not remove the invisible '&amp;' characters that are used to underline keyboard shortcuts with the Alt key.
            </item>
            <item>
            "**accName:" - use <see cref="P:Au.Wnd.NameAcc"/>.
            Useful when the control itself does not have a name but an adjacent Static text control is used as its name. Examples - Edit controls in dialogs. Slower.
            </item>
            <item>
            "**wfName:" - use .NET Windows Forms Control Name property.
            To get it this function uses <see cref="T:Au.Wnd.Misc.WinFormsControlNames"/>. It is slower and can fail because of UAC.
            </item>
            <item>
            "**id:" (like "**id:15") - use control id.
            To get it this function uses <see cref="P:Au.Wnd.ControlId"/>.
            Cannot be wildcard expression.
            You can instead use <see cref="M:Au.Wnd.Kid(System.Int32,Au.Types.WCFlags)"/>, it is faster than <b>Child</b>.</item>
            </list>
            String format (not including the prefix): <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">wildcard expression</conceptualLink>.
            null means 'can be any'. "" means 'must not have name'.
            </param>
            <param name="className">
            Control class name.
            String format: <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">wildcard expression</conceptualLink>.
            null means 'can be any'. Cannot be "".
            </param>
            <param name="flags"></param>
            <param name="also">
            Lambda etc callback function to call for each matching control.
            It can evaluate more properties of the control and return true when they match.
            Example: <c>also: t =&gt; t.IsEnabled</c>
            </param>
            <param name="skip">
            0-based index of matching control.
            For example, if 1, the function skips the first matching control and returns the second.
            </param>
            <exception cref="T:Au.Types.WndException">This variable is invalid (window not found, closed, etc).</exception>
            <exception cref="T:System.ArgumentException">
            className is "". To match any, use null.
            Invalid wildcard expression ("**options " or regular expression).
            </exception>
        </member>
        <member name="M:Au.Wnd.HasChild(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)">
            <summary>
            Returns true if this window contains the specified control.
            Calls <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/>.
            <note type="note">
            Using this function many times with same parameters is inefficient. Instead create new <see cref="T:Au.Wnd.ChildFinder"/> and call <see cref="M:Au.Wnd.ChildFinder.Find(Au.Wnd)"/> or <see cref="M:Au.Wnd.HasChild(Au.Wnd.ChildFinder)"/>. See example.
            </note>
            </summary>
            <exception cref="T:Au.Types.WndException"/>
            <exception cref="T:System.ArgumentException"/>
            <example>
            <code><![CDATA[
            //find window that contains certain control, and get the control too
            var f = new Wnd.ChildFinder("Password*", "Static"); //control properties
            Wnd w = Wnd.Find(className: "#32770", also: t => t.HasChild(f));
            Print(w);
            Print(f.Result);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Wnd.HasChild(Au.Wnd.ChildFinder)">
            <summary>
            Returns true if this window contains the specified control.
            Calls <see cref="M:Au.Wnd.ChildFinder.Find(Au.Wnd)"/>.
            </summary>
            <exception cref="T:Au.Types.WndException"/>
            <example>
            Find window that contains certain control, and get the control too.
            <code><![CDATA[
            var cf = new Wnd.ChildFinder("Password*", "Static"); //control properties
            Wnd w = Wnd.Find(className: "#32770", also: t => t.HasChild(cf));
            Print(w);
            Print(f.Result);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Wnd.HasAcc(Au.Acc.Finder)">
            <summary>
            Returns true if this window contains the specified accessible object.
            Calls <see cref="M:Au.Acc.Finder.Find(Au.Wnd,Au.Wnd.ChildFinder)"/>.
            </summary>
            <exception cref="T:Au.Types.WndException"/>
            <example>
            Find window that contains certain accessible object (AO), and get the AO too.
            <code><![CDATA[
            var af = new Acc.Finder("BUTTON", "OK"); //AO properties
            Wnd w = Wnd.Find(className: "#32770", also: t => t.HasAcc(af));
            Print(w);
            Print(f.Result);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Wnd.Kid(System.Int32,Au.Types.WCFlags)">
            <summary>
            Finds a child control by its id and returns its handle as Wnd.
            Returns default(Wnd) if not found. See also: <see cref="P:Au.Wnd.Is0"/>, <see cref="M:Au.Types.ExtensionMethods.OrThrow(Au.Wnd)"/>, <see cref="M:Au.Wnd.op_UnaryPlus(Au.Wnd)"/>.
            </summary>
            <param name="id">Control id.</param>
            <param name="flags">This function supports flags DirectChild and HiddenToo. If both are set, it is much faster because uses API <msdn>GetDlgItem</msdn>. Else uses API <msdn>EnumChildWindows</msdn>, like <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/>.</param>
            <remarks>
            Not all controls have a useful id. If control id is 0 or different in each window instance, this function is not useful.
            </remarks>
            <exception cref="T:Au.Types.WndException">This variable is invalid (window not found, closed, etc).</exception>
        </member>
        <member name="M:Au.Wnd.ChildAll(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean})">
            <summary>
            Finds all matching child controls.
            Returns List containing 0 or more control handles as Wnd.
            Everything except the return type is the same as with <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)">Child</see>.
            </summary>
            <exception cref="T:Au.Types.WndException"/>
            <exception cref="T:System.ArgumentException"/>
            <remarks>
            In the returned list, hidden controls (when using WCFlags.HiddenToo) are always after visible controls.
            </remarks>
        </member>
        <member name="M:Au.Wnd.ChildFast(System.String,System.String,Au.Wnd)">
            <summary>
            Finds a direct child control and returns its handle as Wnd.
            Returns default(Wnd) if not found. See also: <see cref="P:Au.Wnd.Is0"/>, <see cref="M:Au.Types.ExtensionMethods.OrThrow(Au.Wnd)"/>, <see cref="M:Au.Wnd.op_UnaryPlus(Au.Wnd)"/>.
            Calls API <msdn>FindWindowEx</msdn>.
            Faster than <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)">Child</see>, which uses API <msdn>EnumChildWindows</msdn>.
            Can be used only when you know full name and/or class name.
            Finds hidden controls too.
            </summary>
            <param name="name">
            Name.
            Use null to match any. "" matches "" (no name).
            Full, case-insensitive. Wildcard etc not supported.
            Must include the invisible '&amp;' characters that are used to underline keyboard shortcuts with the Alt key.
            </param>
            <param name="className">
            Class name.
            Use null to match any. Cannot be "".
            Full, case-insensitive. Wildcard etc not supported.
            </param>
            <param name="wAfter">If used, starts searching from the next control in the Z order.</param>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            </remarks>
        </member>
        <member name="M:Au.Wnd.AllChildren(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets child controls.
            Returns array containing 0 or more control handles as Wnd.
            </summary>
            <param name="directChild">Need only direct children, not grandchildren.</param>
            <param name="onlyVisible">Need only visible controls.</param>
            <param name="sortFirstVisible">Place all array elements of hidden controls at the end of the array.</param>
            <exception cref="T:Au.Types.WndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            Calls API <msdn>EnumChildWindows</msdn>.
            </remarks>
        </member>
        <member name="T:Au.Wnd.WButton">
            <summary>
            Like <see cref="T:Au.Wnd"/>, but has only button, check box and radio button functions - Click, Check etc.
            </summary>
        </member>
        <member name="P:Au.Wnd.WButton.W">
            <summary>
            Button handle as Wnd.
            </summary>
        </member>
        <member name="M:Au.Wnd.WButton.op_Implicit(Au.Wnd.WButton)~Au.Wnd">
            <summary>
            Implicit cast Wnd=WButton.
            </summary>
        </member>
        <member name="M:Au.Wnd.WButton.op_Explicit(Au.Wnd)~Au.Wnd.WButton">
            <summary>
            Explicit cast WButton=(WButton)Wnd.
            </summary>
        </member>
        <member name="M:Au.Wnd.WButton.ToString">
            
        </member>
        <member name="M:Au.Wnd.WButton.Click(System.Boolean)">
            <summary>
            Sends a "click" message to this button control. Does not use the mouse.
            </summary>
            <param name="useAcc">Use <see cref="M:Au.Acc.DoAction"/>. If false (default), posts <msdn>BM_CLICK</msdn> message.</param>
            <exception cref="T:Au.Types.WndException">This window is invalid.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Works not with all button controls. Sometimes does not work if the window is inactive.
            Check boxes and radio buttons also are buttons. This function can click them.
            </remarks>
            <example>
            <code><![CDATA[
            Wnd.Find("Options").Child("Cancel").AsButton.Click();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Wnd.WButton.Check(System.Boolean,System.Boolean)">
            <summary>
            Checks or unchecks this check box. Does not use the mouse.
            Calls <see cref="M:Au.Wnd.WButton.SetCheckState(System.Int32,System.Boolean)"/> with state 0 or 1.
            </summary>
            <param name="on">Checks if true, unchecks if false.</param>
            <param name="useAcc"></param>
            <exception cref="T:Au.Types.WndException">This window is invalid.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Works not with all button controls. Sometimes does not work if the window is inactive.
            If this is a radio button, does not uncheck other radio buttons in its group.
            </remarks>
        </member>
        <member name="M:Au.Wnd.WButton.SetCheckState(System.Int32,System.Boolean)">
            <summary>
            Sets checkbox state. Does not use the mouse.
            </summary>
            <param name="state">0 unchecked, 1 checked, 2 indeterminate.</param>
            <param name="useAcc">Use <see cref="M:Au.Acc.DoAction"/>. If false (default), posts <msdn>BM_SETCHECK</msdn> message and also BN_CLICKED notification to the parent window; if that is not possible, instead uses <msdn>BM_CLICK</msdn> message.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid state.</exception>
            <exception cref="T:Au.Types.WndException">This window is invalid.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Does nothing if the check box already has the specified check state (if can get it).
            Works not with all button controls. Sometimes does not work if the window is inactive.
            If this is a radio button, does not uncheck other radio buttons in its group.
            </remarks>
        </member>
        <member name="M:Au.Wnd.WButton.IsChecked(System.Boolean)">
            <summary>
            Gets check state of this check box or radio button.
            Calls <see cref="M:Au.Wnd.WButton.GetCheckState(System.Boolean)"/> and returns true if it returns 1.
            </summary>
        </member>
        <member name="M:Au.Wnd.WButton.GetCheckState(System.Boolean)">
            <summary>
            Gets check state of this check box or radio button.
            Returns 0 if unchecked, 1 if checked, 2 if indeterminate. Also returns 0 if this is not a button or if failed to get state.
            </summary>
            <param name="useAcc">Use <see cref="P:Au.Acc.State"/>. If false (default) and this button has a standard checkbox style, uses API <msdn>BM_GETCHECK</msdn>.</param>
        </member>
        <member name="P:Au.Wnd.AsButton">
            <summary>
            Casts this to <see cref="T:Au.Wnd.WButton"/>.
            </summary>
        </member>
        <member name="M:Au.Wnd.ButtonClick(System.Int32,System.Boolean)">
            <summary>
            Finds a child button by id and sends a "click" message. Does not use the mouse.
            Calls <see cref="M:Au.Wnd.WButton.Click(System.Boolean)"/>.
            </summary>
            <param name="buttonId">Control id of the button. This function calls <see cref="M:Au.Wnd.Kid(System.Int32,Au.Types.WCFlags)"/> to find the button.</param>
            <param name="useAcc">Use <see cref="M:Au.Acc.DoAction"/>. If false (default), posts <msdn>BM_CLICK</msdn> message.</param>
            <exception cref="T:Au.Types.NotFoundException">Button not found.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Wnd.Kid(System.Int32,Au.Types.WCFlags)"/> and <see cref="M:Au.Wnd.WButton.Click(System.Boolean)"/>.</exception>
            <example>
            <code><![CDATA[
            Wnd.Find("Options").ButtonClick(2);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Wnd.ButtonClick(System.String,System.String,System.Boolean)">
            <summary>
            Finds a child button by name and sends a "click" message. Does not use the mouse.
            Calls <see cref="M:Au.Wnd.WButton.Click(System.Boolean)"/>.
            </summary>
            <param name="buttonName">Button name. This function calls <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/> to find the button.</param>
            <param name="className">Button class name to pass to <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/>.</param>
            <param name="useAcc">Use <see cref="M:Au.Acc.DoAction"/>. If false (default), posts <msdn>BM_CLICK</msdn> message.</param>
            <exception cref="T:Au.Types.NotFoundException">Button not found.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/> and <see cref="M:Au.Wnd.WButton.Click(System.Boolean)"/>.</exception>
            <example>
            <code><![CDATA[
            Wnd.Find("Options").ButtonClick("Cancel");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Wnd.MenuClick(System.Int32,System.Boolean)">
            <summary>
            Posts a "menu item clicked" notification (<msdn>WM_COMMAND</msdn>) as if that menu item was clicked. Does not use the mouse.
            </summary>
            <param name="itemId">Menu item id. Must be in range 1 to 0xffff.</param>
            <param name="systemMenu">The menu item is in the title bar's context menu, not in the menu bar. Posts <msdn>WM_SYSCOMMAND</msdn> instead.</param>
            <exception cref="T:Au.Types.WndException">Invalid window.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid itemId.</exception>
            <remarks>
            Works only with standard (classic) menus. The drop-down menu window class name must be "#32768". Works with menu items in window menu bar, system menu and some context menus.
            Does not use the menu itself. Just posts WM_COMMAND or WM_SYSCOMMAND message. Even if a menu item with this id does not exist.
            This variable is the window that contains the menu bar or system menu. Or the drop-down menu window (class "#32768") that contains the menu item.
            </remarks>
        </member>
        <member name="M:Au.Wnd.FromXY(Au.Types.Coord,Au.Types.Coord,Au.Types.WXYFlags,Au.Types.CoordOptions)">
            <summary>
            Gets visible top-level window or control from point.
            By default the coordinates are relative to the primary screen.
            </summary>
            <param name="x">X coordinate in screen.</param>
            <param name="y">Y coordinate in screen.</param>
            <param name="flags"></param>
            <param name="co">Can be used to specify screen (see <see cref="M:Au.Screen_.FromObject(System.Object)"/>) and/or whether x y are relative to the work area.</param>
            <remarks>
            Alternatively can be used API <msdn>WindowFromPoint</msdn>, <msdn>ChildWindowFromPointEx</msdn> or <msdn>RealChildWindowFromPoint</msdn>, but all they have various limitations and are not very useful in automation scripts.
            This function gets non-transparent controls that are behind (in the Z order) transparent controls (group button, tab control etc); supports more control types than <msdn>RealChildWindowFromPoint</msdn>. Also does not skip disabled controls. All this is not true with flag Raw.
            This function is not very fast. Fastest when used flag NeedWindow. Flag Raw also makes it faster.
            x and y can be Coord.Reverse etc; cannot be null.
            </remarks>
        </member>
        <member name="M:Au.Wnd.FromXY(System.Drawing.Point,Au.Types.WXYFlags)">
            <summary>
            Gets visible top-level window or control from point.
            More info: <see cref="M:Au.Wnd.FromXY(Au.Types.Coord,Au.Types.Coord,Au.Types.WXYFlags,Au.Types.CoordOptions)"/>.
            </summary>
            <param name="p">X Y in screen coordinates.</param>
            <param name="flags"></param>
        </member>
        <member name="M:Au.Wnd.FromMouse(Au.Types.WXYFlags)">
            <summary>
            Gets visible top-level window or control from mouse cursor position.
            More info: <see cref="M:Au.Wnd.FromXY(Au.Types.Coord,Au.Types.Coord,Au.Types.WXYFlags,Au.Types.CoordOptions)"/>.
            </summary>
        </member>
        <member name="M:Au.Wnd.ChildFromXY(Au.Types.Coord,Au.Types.Coord,System.Boolean,System.Boolean)">
            <summary>
            Gets child control from point.
            Returns default(Wnd) if the point is not in a child control or not in the client area of this window.
            </summary>
            <param name="x">X coordinate in the client area of this window.</param>
            <param name="y">Y coordinate in the client area of this window.</param>
            <param name="directChild">Get direct child, not a child of a child and so on.</param>
            <param name="screenXY">x y are relative to the pimary screen, not to the client area.</param>
            <exception cref="T:Au.Types.WndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            x y can be Coord.Reverse etc; cannot be null.
            </remarks>
        </member>
        <member name="M:Au.Wnd.SetTransparency(System.Boolean,System.Nullable{System.Double},System.Nullable{Au.Types.ColorInt})">
            <summary>
            Sets transparency.
            On Windows 7 works only with top-level windows, on newer OS also with controls.
            </summary>
            <param name="allowTransparency">Set or remove WS_EX_LAYERED style that is required for transparency. If false, other parameters are not used.</param>
            <param name="opacity">Opacity from 0.0 (completely transparent) to 1.0 (opaque). If null, sets default value (opaque).</param>
            <param name="colorRGB">Make pixels painted with this color completely transparent. If null, sets default value (no transparent color). The alpha byte is not used.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">opacity is less than 0.0 or greater than 1.0.</exception>
            <exception cref="T:Au.Types.WndException"/>
        </member>
        <member name="P:Au.Wnd.IsFullScreen">
            <summary>
            Returns true if this is a full-screen window and not desktop.
            </summary>
        </member>
        <member name="P:Au.Wnd.LibIsOfShellThread">
            <summary>
            Returns true if this belongs to GetShellWindow's thread (usually it is the desktop window).
            </summary>
        </member>
        <member name="P:Au.Wnd.LibIsOfShellProcess">
            <summary>
            Returns true if this belongs to GetShellWindow's process (eg a folder window, desktop, taskbar).
            </summary>
        </member>
        <member name="P:Au.Wnd.IsWindows8MetroStyle">
            <summary>
            Returns true if this window has Metro style, ie is not a classic desktop window.
            On Windows 8/8.1 most Windows Store app windows and many shell windows have Metro style.
            On Windows 10 few windows have Metro style.
            On Windows 7 there are no Metro style windows.
            </summary>
            <seealso cref="M:Au.Wnd.Misc.GetWindowsStoreAppId(Au.Wnd,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:Au.Wnd.IsWindows10StoreApp">
            <summary>
            Returns non-zero if this window is a Windows 10 Store app window: 1 if class name is "ApplicationFrameWindow", 2 if "Windows.UI.Core.CoreWindow".
            </summary>
            <seealso cref="M:Au.Wnd.Misc.GetWindowsStoreAppId(Au.Wnd,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.Wnd.SavePositionSizeState(System.Boolean)">
            <summary>
            Gets window position, size and state stored in a string that can be used with <see cref="M:Au.Wnd.RestorePositionSizeState(System.String,System.Boolean,System.Boolean)"/>.
            Returns null if failed. Supports <see cref="M:Au.Types.Native.GetError"/>.
            </summary>
            <param name="canBeMinimized">If now the window is minimized, let RestorePositionSizeState make it minimized. If false, RestorePlacement will restore it to the most recent non-minimized state.</param>
        </member>
        <member name="M:Au.Wnd.RestorePositionSizeState(System.String,System.Boolean,System.Boolean)">
            <summary>
            Restores window position, size and state that is stored in a string created by <see cref="M:Au.Wnd.SavePositionSizeState(System.Boolean)"/>.
            </summary>
            <param name="s">The string. Can be null/"".</param>
            <param name="ensureInScreen">Call <see cref="M:Au.Wnd.EnsureInScreen(System.Object,System.Boolean)"/>. Even when s is null/"".</param>
            <param name="showActivate">Call <see cref="M:Au.Wnd.Show(System.Boolean)">Show</see>(true) and <see cref="M:Au.Wnd.ActivateLL"/>. Even when s is null/"".</param>
            <exception cref="T:Au.Types.WndException"/>
        </member>
        <member name="M:Au.Wnd.LibMinimalSleepIfOtherThread">
            <summary>
            if(!IsOfThisThread) { Thread.Sleep(15); SendTimeout(1000, 0); }
            </summary>
        </member>
        <member name="M:Au.Wnd.LibMinimalSleepNoCheckThread">
            <summary>
            Thread.Sleep(15); SendTimeout(1000, 0);
            </summary>
        </member>
        <member name="M:Au.Wnd._GetWindowsStoreAppId(Au.Wnd,System.String@,System.Boolean,System.Boolean)">
            <summary>
            Gets window Windows Store app user model id, like "Microsoft.WindowsCalculator_8wekyb3d8bbwe!App".
            Returns 1 if gets user model id, 2 if gets path, 0 if fails.
            </summary>
            <param name="w">Window.</param>
            <param name="appId">Receives app ID.</param>
            <param name="prependShellAppsFolder">Prepend @"shell:AppsFolder\" (to run or get icon).</param>
            <param name="getExePathIfNotWinStoreApp">Get program path if it is not a Windows Store app.</param>
        </member>
        <member name="M:Au.Wnd._WindowsStoreAppFrameChild(Au.Wnd)">
            <summary>
            On Win10+, if w is "ApplicationFrameWindow", returns the real app window "Windows.UI.Core.CoreWindow" hosted by w.
            If w is minimized, cloaked (eg on other desktop) or the app is starting, the "Windows.UI.Core.CoreWindow" is not its child. Then searches for a top-level window named like w. It is unreliable, but MS does not provide API for this.
            Info: "Windows.UI.Core.CoreWindow" windows hosted by "ApplicationFrameWindow" belong to separate processes. All "ApplicationFrameWindow" windows belong to a single process.
            </summary>
        </member>
        <member name="T:Au.Wnd.Finder">
            <summary>
            Contains top-level window properties and can be used to find the window.
            Can be used instead of <see cref="M:Au.Wnd.Find(System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/> or <see cref="M:Au.Wnd.FindAll(System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>.
            These codes are equivalent:
            <code>Wnd w = Wnd.Find(a, b, c, d, e); if(!w.Is0) Print(w);</code>
            <code>var p = new Wnd.Finder(a, b, c, d, e); if(p.Find()) Print(p.Result);</code>
            Also can find in a list of windows.
            </summary>
        </member>
        <member name="M:Au.Wnd.Finder.#ctor(System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)">
            <summary>
            See <see cref="M:Au.Wnd.Find(System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>.
            </summary>
            <exception cref="T:System.ArgumentException">
            className is "". To match any, use null.
            programEtc is "" or contains an empty/0 value or unknown property. To match any, use null.
            Invalid wildcard expression ("**options " or regular expression).
            </exception>
        </member>
        <member name="P:Au.Wnd.Finder.Result">
            <summary>
            The found window.
            </summary>
        </member>
        <member name="M:Au.Wnd.Finder.Find">
            <summary>
            Finds the specified window, like <see cref="M:Au.Wnd.Find(System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)">Wnd.Find</see>.
            Returns true if found.
            The <see cref="P:Au.Wnd.Finder.Result"/> property will be the window.
            </summary>
        </member>
        <member name="M:Au.Wnd.Finder.FindInList(System.Collections.Generic.IEnumerable{Au.Wnd})">
            <summary>
            Finds the specified window in a list of windows.
            Returns 0-based index, or -1 if not found.
            The <see cref="P:Au.Wnd.Finder.Result"/> property will be the window.
            </summary>
            <param name="a">Array or list of windows, for example returned by <see cref="M:Au.Wnd.Misc.AllWindows(System.Boolean,System.Boolean)"/>.</param>
        </member>
        <member name="M:Au.Wnd.Finder.FindAll">
            <summary>
            Finds all matching windows, like <see cref="M:Au.Wnd.FindAll(System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)">Wnd.FindAll</see>.
            Returns array containing 0 or more window handles as Wnd.
            </summary>
        </member>
        <member name="M:Au.Wnd.Finder.FindAllInList(System.Collections.Generic.IEnumerable{Au.Wnd})">
            <summary>
            Finds all matching windows in a list of windows.
            Returns array containing 0 or more window handles as Wnd.
            </summary>
            <param name="a">Array or list of windows, for example returned by <see cref="M:Au.Wnd.Misc.AllWindows(System.Boolean,System.Boolean)"/>.</param>
        </member>
        <member name="M:Au.Wnd.Finder._FindInList(Au.Wnd._WndList,System.Action{Au.Wnd})">
            <summary>
            Returns index of matching element or -1.
            Returns -1 if using getAll.
            </summary>
            <param name="a">List of Wnd. Does not dispose it.</param>
            <param name="getAll">If not null, calls it for all matching and returns -1.</param>
        </member>
        <member name="M:Au.Wnd.Finder.IsMatch(Au.Wnd)">
            <summary>
            Returns true if window w properties match the specified properties.
            </summary>
            <param name="w">A top-level window. Can be 0/invalid, then returns false.</param>
        </member>
        <member name="M:Au.Wnd.Find(System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)">
             <summary>
             Finds a top-level window and returns its handle as Wnd.
             Returns default(Wnd) if not found. See also: <see cref="P:Au.Wnd.Is0"/>, <see cref="M:Au.Types.ExtensionMethods.OrThrow(Au.Wnd)"/>, <see cref="M:Au.Wnd.op_UnaryPlus(Au.Wnd)"/>. See examples.
             </summary>
             <param name="name">
             Window name. Usually it is the title bar text.
             String format: <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">wildcard expression</conceptualLink>.
             null means 'can be any'. "" means 'must not have name'.
             </param>
             <param name="className">
             Window class name.
             String format: <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">wildcard expression</conceptualLink>.
             null means 'can be any'. Cannot be "".
             </param>
             <param name="programEtc">
             Program file name without ".exe".
             String format: <conceptualLink target="0248143b-a0dd-4fa1-84f9-76831db6714a">wildcard expression</conceptualLink>.
             null means 'can be any'. Cannot be "". Cannot be path.
             
             Or a list of the following properties. Format: one or more "name=value", separated with "\0" or "\0 ". Names must match case. Values of string properties are wildcard expressions.
             <list type="bullet">
             <item>"program" - program file name. Example: <c>"program=notepad"</c>. Useful when need multiple properties or when file name contains character '='.</item>
             <item>"pid" - process id. See <see cref="P:Au.Wnd.ProcessId"/>, <see cref="P:Au.Process_.CurrentProcessId"/>. Example: <c>$"pid={pidVar}"</c>.</item>
             <item>"tid" - thread id. See <see cref="P:Au.Wnd.ThreadId"/>, <see cref="P:Au.Process_.CurrentThreadId"/>. Example: <c>"tid=" + tidVar</c>.</item>
             <item>"owner" - owner window handle. See <see cref="P:Au.Wnd.WndOwner"/>. Example: <c>$"owner={w1.Handle}"</c>.</item>
             </list>
             </param>
             <param name="flags"></param>
             <param name="also">
             Lambda etc callback function to call for each matching window.
             It can evaluate more properties of the window and return true when they match.
             Example: <c>also: t =&gt; !t.IsPopupWindow</c>.
             </param>
             <param name="contains">
             Text, image or other object in the client area of the window. Depends on type:
             string - name of an accessible object (<see cref="T:Au.Acc"/>) that must be in the window. Wildcard expression, the same as the <i>name</i> parameter of <see cref="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,Au.Wnd.ChildFinder)"/>.
             <see cref="T:Au.Acc.Finder"/> - arguments for <see cref="M:Au.Acc.Find(Au.Wnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.Acc,System.Boolean},System.Int32,Au.Wnd.ChildFinder)"/>. Defines an accessible object that must be in the window.
             <see cref="T:Au.Wnd.ChildFinder"/> - arguments for <see cref="M:Au.Wnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.Wnd,System.Boolean},System.Int32)"/>. Defines a child control that must be in the window.
             <see cref="T:System.Drawing.Image"/> or <see cref="T:System.Drawing.Bitmap"/> - image that must be visible in the window. To find it, this function calls <see cref="M:Au.WinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.WinImage,System.Boolean})"/> with flag <see cref="F:Au.Types.WIFlags.WindowDC"/>. See also <see cref="M:Au.WinImage.LoadImage(System.String)"/>.
            
             This parameter is evaluated after <paramref name="also"/>.
             </param>
             <remarks>
             If there are multiple matching windows, gets the first in the Z order matching window, preferring visible windows.
             On Windows 8 and later finds only desktop windows, not Windows Store app Metro-style windows (on Windows 10 only few such windows exist), unless this process has uiAccess; to find such windows you can use <see cref="M:Au.Wnd.FindFast(System.String,System.String,Au.Wnd)">FindFast</see>.
             To find message-only windows use <see cref="M:Au.Wnd.Misc.FindMessageWindow(System.String,System.String,Au.Wnd)"/> instead.
             </remarks>
             <exception cref="T:System.ArgumentException">
             className is "". To match any, use null.
             programEtc is "" or contains an empty/0 value or unknown property. To match any, use null.
             Invalid wildcard expression ("**options " or regular expression).
             </exception>
             <example>
             Try to find Notepad window. Return if not found.
             <code>
             Wnd w = Wnd.Find("* Notepad");
             if(w.Is0) { Print("not found"); return; }
             </code>
             Try to find Notepad window. Throw NotFoundException if not found.
             <code>
             Wnd w1 = Wnd.Find("* Notepad").OrThrow();
             Wnd w2 = +Wnd.Find("* Notepad"); //the same
             </code>
             </example>
        </member>
        <member name="P:Au.Wnd.LastFind">
            <summary>
            Gets arguments and result of this thread's last call to <see cref="M:Au.Wnd.Find(System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/> or <see cref="M:Au.Wnd.FindAll(System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>.
            </summary>
            <remarks>
            <b>WaitFor.WindowActive</b> and similar functions don't change this property. <see cref="M:Au.Wnd.FindOrRun(System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object,System.Func{System.Int32},System.Double,System.Boolean)"/> and some other functions of this library change this property because they call <see cref="M:Au.Wnd.Find(System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/> internally.
            </remarks>
            <example>
            This example is similar to what FindOrRun does.
            <code><![CDATA[
            Wnd w = Wnd.Find("*- Notepad", "Notepad");
            if(w.Is0) { Shell.Run("notepad.exe"); w = WaitFor.WindowActive(Wnd.LastFind); }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Wnd.FindAll(System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)">
            <summary>
            Finds all matching windows.
            Returns array containing 0 or more window handles as Wnd.
            Everything except the return type is the same as with <see cref="M:Au.Wnd.Find(System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>.
            </summary>
            <exception cref="T:System.ArgumentException"/>
            <remarks>
            The list is sorted to match the Z order, however hidden windows (when using WFFlags.HiddenToo) are always after visible windows.
            </remarks>
        </member>
        <member name="M:Au.Wnd.FindFast(System.String,System.String,Au.Wnd)">
            <summary>
            Finds a top-level window and returns its handle as Wnd.
            Returns default(Wnd) if not found. To check it you can use <see cref="P:Au.Wnd.Is0"/> or <see cref="M:Au.Types.ExtensionMethods.OrThrow(Au.Wnd)"/>.
            Calls API <msdn>FindWindowEx</msdn>.
            Faster than <see cref="M:Au.Wnd.Find(System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)">Find</see>, which uses API <msdn>EnumWindows</msdn>.
            Can be used only when you know full name and/or class name.
            Finds hidden windows too.
            </summary>
            <param name="name">
            Name.
            Use null to match any.
            Full, case-insensitive. Wildcard etc not supported.
            </param>
            <param name="className">
            Class name.
            Use null to match any. Cannot be "".
            Full, case-insensitive. Wildcard etc not supported.
            </param>
            <param name="wAfter">If used, starts searching from the next window in the Z order.</param>
            <remarks>
            To find message-only windows use <see cref="M:Au.Wnd.Misc.FindMessageWindow(System.String,System.String,Au.Wnd)"/> instead.
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            It is not recommended to use this function in a loop to enumerate windows. It would be unreliable because window positions in the Z order can be changed while enumerating. Also then it would be slower than <b>Find</b> and <b>FindAll</b>.
            </remarks>
        </member>
        <member name="M:Au.Wnd.FindOrRun(System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object,System.Func{System.Int32},System.Double,System.Boolean)">
            <summary>
            Finds a top-level window. If found, activates (optionally), else calls callback function that should open the window (eg call <see cref="M:Au.Shell.Run(System.String,System.String,Au.Types.SRFlags,Au.Types.SRMore)"/>) and waits for the window.
            Returns window handle as Wnd. Returns default(Wnd) if not found (if runWaitTimeoutS is negative; else exception).
            The first 5 parameters are the same as <see cref="M:Au.Wnd.Find(System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>.
            </summary>
            <param name="name"></param>
            <param name="className"></param>
            <param name="programEtc"></param>
            <param name="flags"></param>
            <param name="also"></param>
            <param name="contains"></param>
            <param name="run">Callback function's delegate. See example.</param>
            <param name="runWaitS">How long to wait for the window after calling the callback function. Seconds. Default 60. See <see cref="M:Au.WaitFor.WindowActive(System.Double,System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object,System.Boolean)"/>.</param>
            <param name="needActiveWindow">Finally the window must be active. For more info see the algorithm in Remarks.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.Wnd.Find(System.String,System.String,System.String,Au.Types.WFFlags,System.Func{Au.Wnd,System.Boolean},System.Object)"/>.</exception>
            <exception cref="T:System.TimeoutException">runWaitTimeoutS time has expired.</exception>
            <remarks>
            The algorithm is:
            <code>
            var w=Wnd.Find(...);
            if(!w.Is0) { if(needActiveWindow) w.Activate(); }
            else if(run!=null) { run(); if(needActiveWindow) w = WaitFor.WindowActive(..., runWaitTimeoutS); else WaitFor.WindowExists(..., runWaitTimeoutS); }
            return w;
            </code>
            </remarks>
            <example>
            <code><![CDATA[
            Wnd w = Wnd.FindOrRun("* Notepad", run: () => Shell.Run("notepad.exe"));
            Print(w);
            ]]></code>
            </example>
        </member>
        <member name="T:Au.Wnd._WndList">
            <summary>
            An enumerable list of Wnd for <see cref="M:Au.Wnd.Finder._FindInList(Au.Wnd._WndList,System.Action{Au.Wnd})"/> and <see cref="M:Au.Wnd.ChildFinder._FindInList(Au.Wnd,Au.Wnd._WndList,System.Action{Au.Wnd})"/>.
            Holds Util.LibArrayBuilder or IEnumerator or single Wnd or none.
            Must be disposed if it is Util.LibArrayBuilder or IEnumerator, else disposing is optional.
            </summary>
        </member>
        <member name="P:Au.Wnd.WndOwner">
            <summary>
            Gets or sets the owner window of this top-level window.
            </summary>
            <exception cref="T:Au.Types.WndException">Failed (only 'set' function).</exception>
            <remarks>
            A window that has an owner window is always on top of its owner window.
            Don't call this for controls, they don't have an owner window.
            The 'get' function returns default(Wnd) if this window isn't owned or is invalid. Supports <see cref="M:Au.Types.Native.GetError"/>.
            The 'set' function can fail, eg if the owner's process has higher UAC integrity level.
            </remarks>
        </member>
        <member name="P:Au.Wnd.WndWindow">
            <summary>
            Gets the top-level parent window of this control.
            If this is a top-level window, returns this. Returns default(Wnd) if this window is invalid.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.IsChildWindow">
            <summary>
            Returns true if this is a child window (control), false if top-level window.
            </summary>
            <remarks>
            Supports <see cref="M:Au.Types.Native.GetError"/>.
            Uses <see cref="P:Au.Wnd.WndDirectParent"/>.
            Another way is <c>w.HasStyle(Native.WS_CHILD)</c>. It is faster but less reliable, because some top-level windows have WS_CHILD style and some child windows don't.
            </remarks>
        </member>
        <member name="M:Au.Wnd.IsChildOf(Au.Wnd)">
            <summary>
            Returns true if this is a direct or indirect child (descendant) of window w.
            Calls API <msdn>IsChild</msdn>.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.WndDirectParent">
            <summary>
            Gets the window or control that is the direct parent of this control.
            Returns default(Wnd) if this is a top-level window.
            If you need the top-level parent window, use <see cref="P:Au.Wnd.WndWindow"/> instead.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.WndDirectParentOrOwner">
            <summary>
            Gets the window or control that is the direct parent of this control or owner of this top-level window.
            Calls API <msdn>GetParent</msdn>. Faster than <see cref="P:Au.Wnd.WndDirectParent"/>.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.WndFirstSibling">
            <summary>
            Gets the window of the same type that is highest in the Z order.
            If this is a top-level window, gets first top-level window, else gets first control of the same direct parent.
            If this is the first, returns this, not default(Wnd).
            Calls API <msdn>GetWindow</msdn>(this, GW_HWNDFIRST).
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.WndLastSibling">
            <summary>
            Gets the window of the same type that is lowest in the Z order.
            If this is a top-level window, gets last top-level window, else gets last control of the same direct parent.
            If this is the last, returns this, not default(Wnd).
            Calls API <msdn>GetWindow</msdn>(this, GW_HWNDLAST).
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.WndNext">
            <summary>
            Gets the window of the same type that is next (below this) in the Z order.
            If this is a top-level window, gets next top-level window, else gets next control of the same direct parent.
            If this is the last, returns default(Wnd).
            Calls API <msdn>GetWindow</msdn>(this, GW_HWNDNEXT).
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.WndPrev">
            <summary>
            Gets the window of the same type that is previous (above this) in the Z order.
            If this is a top-level window, gets previous top-level window, else gets previous control of the same direct parent.
            If this is the first, returns default(Wnd).
            Calls API <msdn>GetWindow</msdn>(this, GW_HWNDPREV).
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.WndFirstChild">
            <summary>
            Gets the child control at the top of the Z order.
            Returns default(Wnd) if no children.
            The same as <see cref="M:Au.Wnd.WndChild(System.Int32)">WndChild</see>(0).
            Calls API <msdn>GetWindow</msdn>(this, GW_CHILD).
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.WndLastChild">
            <summary>
            Gets the child control at the bottom of the Z order.
            Returns default(Wnd) if no children.
            </summary>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="M:Au.Wnd.WndChild(System.Int32)">
            <summary>
            Gets the child control at the specified position in the Z order.
            Returns default(Wnd) if no children or if index is invalid.
            </summary>
            <param name="index">0-based index of the child control in the Z order.</param>
            <remarks>Supports <see cref="M:Au.Types.Native.GetError"/>.</remarks>
        </member>
        <member name="P:Au.Wnd.WndActive">
            <summary>
            Gets the active (foreground) window.
            Calls API <msdn>GetForegroundWindow</msdn>.
            Returns default(Wnd) if there is no active window; more info: <see cref="M:Au.Wnd.Misc.WaitForAnActiveWindow"/>.
            </summary>
        </member>
        <member name="P:Au.Wnd.IsActive">
            <summary>
            Returns true if this window is the active (foreground) window.
            </summary>
        </member>
        <member name="P:Au.Wnd.LibIsActiveOrNoActiveAndThisIsWndRoot">
            <summary>
            Returns true if this window is the active (foreground) window.
            If this is <see cref="P:Au.Wnd.Misc.WndRoot"/>, returns true if there is no active window.
            </summary>
        </member>
        <member name="M:Au.Wnd.IsSpecHwnd(Au.Wnd)">
            <summary>
            Returns true if w contains a non-zero special handle value (see <see cref="T:Au.Types.SpecHwnd"/>).
            Note that HWND_TOP is 0.
            </summary>
        </member>
        <member name="T:Au.Registry_">
            <summary>
            Registry functions.
            Extends Microsoft.Win32.Registry.
            </summary>
        </member>
        <member name="F:Au.Registry_.AuKey">
            <summary>
            Default registry key, used when the key argument is null or @"\" or starts with @"\".
            </summary>
        </member>
        <member name="M:Au.Registry_.ParseKeyString(System.String@)">
            <summary>
            Parses registry key string and returns hive as RegistryKey.
            If key starts with "HKEY_", removes hive name from it and returns that hive. For example, if key is @"HKEY_LOCAL_MACHINE\Software\Test", sets key=@"Software\Test" and returns Registry.LocalMachine.
            Else if key is null or @"\", sets key=Registry_.AuKey (@"Software\Au") and returns Registry.CurrentUser.
            Else if key starts with @"\", prepends Registry_.AuKey (@"Software\Au") and returns Registry.CurrentUser.
            Else just returns Registry.CurrentUser.
            Valid hive names: "HKEY_CURRENT_USER", "HKEY_LOCAL_MACHINE", "HKEY_CLASSES_ROOT", "HKEY_USERS", "HKEY_PERFORMANCE_DATA" or "HKEY_CURRENT_CONFIG".
            </summary>
            <param name="key">Registry key. Can start with a hive name.</param>
            <exception cref="T:System.ArgumentException">'key' starts with "HKEY_" but it is an invalid hive name.</exception>
        </member>
        <member name="M:Au.Registry_.Open(System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Opens a key for read access.
            Returns null if the key does not exist.
            Uses <see cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String)"/>.
            </summary>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", the function just returns parentKeyOrHive.</param>
            <exception cref="T:System.ArgumentException">'key' starts with "HKEY_" but it is an invalid hive name.</exception>
            <exception cref="T:System.ObjectDisposedException">'parentKeyOrHive' is a closed key handle.</exception>
            <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to read the registry key.</exception>
        </member>
        <member name="M:Au.Registry_.CreateOrOpen(System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Creates a new key or opens an existing key for write access.
            Uses <see cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)"/>.
            </summary>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", the function just returns parentKeyOrHive.</param>
            <exception cref="T:System.ArgumentException">'key' starts with "HKEY_" but it is an invalid hive name.</exception>
            <exception cref="T:System.ObjectDisposedException">'parentKeyOrHive' is a closed key handle.</exception>
            <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create or open the registry key.</exception>
            <exception cref="T:System.UnauthorizedAccessException">parentKeyOrHive was not opened with write access.</exception>
            <exception cref="T:System.IO.IOException">See <see cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)"/>.</exception>
        </member>
        <member name="M:Au.Registry_.CanOpen(System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Returns true if key exists and you can open it to read.
            Uses <see cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String)"/>.
            </summary>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/>.</param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive.</param>
            <exception cref="T:System.ArgumentException">'key' starts with "HKEY_" but it is an invalid hive name.</exception>
            <exception cref="T:System.ObjectDisposedException">'parentKeyOrHive' is a closed key handle.</exception>
        </member>
        <member name="M:Au.Registry_.GetInt(System.Int32@,System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Gets value of REG_DWORD type.
            Returns false if the value or key does not exist.
            </summary>
            <param name="data">Receives data.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.ArgumentException">'key' starts with "HKEY_" but it is an invalid hive name.</exception>
            <exception cref="T:System.ObjectDisposedException">'parentKeyOrHive' is a closed key handle.</exception>
            <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to read the registry key.</exception>
            <exception cref="T:System.IO.IOException">The key has been marked for deletion.</exception>
            <exception cref="T:System.InvalidCastException">Wrong value type.</exception>
        </member>
        <member name="M:Au.Registry_.GetLong(System.Int64@,System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Gets value of REG_QWORD type.
            Returns false if the value or key does not exist.
            </summary>
            <param name="data">Receives data.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.Exception">Exceptions are listed in <see cref="M:Au.Registry_.GetInt(System.Int32@,System.String,System.String,Microsoft.Win32.RegistryKey)">GetInt</see> topic.</exception>
        </member>
        <member name="M:Au.Registry_.GetString(System.String@,System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Gets string value of REG_SZ or REG_EXPAND_SZ type.
            Returns false if the value or key does not exist.
            </summary>
            <param name="data">Receives data.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.Exception">Exceptions are listed in <see cref="M:Au.Registry_.GetInt(System.Int32@,System.String,System.String,Microsoft.Win32.RegistryKey)">GetInt</see> topic.</exception>
        </member>
        <member name="M:Au.Registry_.GetStringArray(System.String[]@,System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Gets string value of REG_MULTI_SZ type.
            Returns false if the value or key does not exist.
            </summary>
            <param name="data">Receives data.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.Exception">Exceptions are listed in <see cref="M:Au.Registry_.GetInt(System.Int32@,System.String,System.String,Microsoft.Win32.RegistryKey)">GetInt</see> topic.</exception>
        </member>
        <member name="M:Au.Registry_.SetInt(System.Int32,System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Sets value of REG_DWORD type.
            Creates key and value if don't exist.
            </summary>
            <param name="data">Data.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.ArgumentException">'key' starts with "HKEY_" but it is an invalid hive name.</exception>
            <exception cref="T:System.ObjectDisposedException">'parentKeyOrHive' is a closed key handle.</exception>
            <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create, open or modify the registry key.</exception>
            <exception cref="T:System.UnauthorizedAccessException">parentKeyOrHive was not opened with write access.</exception>
            <exception cref="T:System.IO.IOException">See <see cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)"/>.</exception>
        </member>
        <member name="M:Au.Registry_.SetLong(System.Int64,System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Sets value of REG_QWORD type.
            Creates key and value if don't exist.
            </summary>
            <param name="data">Data.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.Exception">Exceptions are listed in <see cref="M:Au.Registry_.SetInt(System.Int32,System.String,System.String,Microsoft.Win32.RegistryKey)">SetInt</see> topic.</exception>
        </member>
        <member name="M:Au.Registry_.SetString(System.String,System.String,System.String,Microsoft.Win32.RegistryKey,System.Boolean)">
            <summary>
            Sets string value of REG_SZ or REG_EXPAND_SZ type.
            Creates key and value if don't exist.
            </summary>
            <param name="data">Data.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <param name="REG_EXPAND_SZ">Let the registry value type be REG_EXPAND_SZ.</param>
            <exception cref="T:System.Exception">Exceptions are listed in <see cref="M:Au.Registry_.SetInt(System.Int32,System.String,System.String,Microsoft.Win32.RegistryKey)">SetInt</see> topic.</exception>
        </member>
        <member name="M:Au.Registry_.SetStringArray(System.String[],System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Sets string value of REG_MULTI_SZ type.
            Creates key and value if don't exist.
            </summary>
            <param name="data">Data.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.Exception">Exceptions are listed in <see cref="M:Au.Registry_.SetInt(System.Int32,System.String,System.String,Microsoft.Win32.RegistryKey)">SetInt</see> topic.</exception>
        </member>
        <member name="M:Au.Registry_.SetBinary(System.Void*,System.Int32,System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Sets value of REG_BINARY type.
            Creates key and value if don't exist.
            </summary>
            <param name="data">Data. For example a struct variable (unsafe address).</param>
            <param name="size">Data size. For example, Marshal.SizeOf(variable) or Marshal.SizeOf(typeof(DATA)).</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.Exception">Exceptions thrown by <see cref="M:Au.Registry_.CreateOrOpen(System.String,Microsoft.Win32.RegistryKey)">CreateOrOpen</see>.</exception>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to write the value to the key.</exception>
        </member>
        <member name="M:Au.Registry_.GetBinary(System.Void*,System.Int32,System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Gets binary data. The registry value type can be REG_BINARY or any other.
            Returns registry data size that the function copied into the 'data' memory.
            Returns 0 if the key or value does not exist.
            </summary>
            <param name="data">Receives data. For example a struct variable (unsafe address).</param>
            <param name="size">data memory size. For example, Marshal.SizeOf(variable). Must be &gt;= registry data size.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.Registry_.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.Exception">Exceptions thrown by <see cref="M:Au.Registry_.Open(System.String,Microsoft.Win32.RegistryKey)">Open</see>.</exception>
            <exception cref="T:System.ComponentModel.Win32Exception">The value exists but failed to get it, for example the specified size is smaller than registry data size.</exception>
        </member>
        <member name="T:Au.Icons">
            <summary>
            Gets icons for files etc.
            </summary>
        </member>
        <member name="M:Au.Icons.GetFileIconImage(System.String,System.Int32,Au.Types.GIFlags)">
            <summary>
            Gets file icon.
            Extracts icon directly from the file, or gets shell icon, depending on file type, icon index, flags etc.
            Calls <see cref="M:Au.Icons.GetFileIconHandle(System.String,System.Int32,Au.Types.GIFlags)"/> and converts to Bitmap. Returns null if failed, for example if the file does not exist.
            Later call Dispose().
            </summary>
            <param name="file">
            Can be:
            Path of any file or folder.
            URL, like "http://..." or "mailto:a@b.c" or "file:///path".
            ITEMIDLIST like ":: HexEncodedITEMIDLIST". It can be of any file, folder, URL or virtual object like Control Panel. See <see cref="M:Au.Shell.Pidl.ToHexString"/>.
            Shell object parsing name, like @"::{CLSID-1}\::{CLSID-2}" or "shell:AppsFolder\WinStoreAppId".
            File type like ".txt" or URL protocol like "http:".
            If it is a file containing multiple icons (eg exe, dll), can be specified icon index like "path,index" or native icon resource id like "path,-id".
            If not full path, the function will look in <see cref="P:Au.Folders.ThisAppImages"/>.
            Supports environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>).
            </param>
            <param name="size">Icon width and height. Also can be enum <see cref="T:Au.Icons.ShellSize"/>, cast to int.</param>
            <param name="flags"></param>
        </member>
        <member name="M:Au.Icons.GetPidlIconImage(Au.Shell.Pidl,System.Int32)">
            <summary>
            Gets icon of a file or other shell object specified as ITEMIDLIST.
            Calls <see cref="M:Au.Icons.GetPidlIconHandle(Au.Shell.Pidl,System.Int32)"/> and converts to Bitmap. Returns null if failed.
            Later call Dispose.
            </summary>
            <param name="pidl">ITEMIDLIST pointer (PIDL).</param>
            <param name="size">Icon width and height. Also can be enum <see cref="T:Au.Icons.ShellSize"/>, cast to int.</param>
        </member>
        <member name="M:Au.Icons.HandleToImage(System.IntPtr)">
            <summary>
            Converts unmanaged icon to Bitmap object and destroys the unmanaged icon.
            Returns null if hi is default(IntPtr) or if fails to convert.
            </summary>
            <param name="hi">Icon handle.</param>
        </member>
        <member name="M:Au.Icons.GetFileIconHandle(System.String,System.Int32,Au.Types.GIFlags)">
            <summary>
            Gets file icon.
            Extracts icon directly from the file, or gets shell icon, depending on file type, icon index, flags etc.
            Returns native icon handle. Returns default(IntPtr) if failed, for example if the file does not exist.
            Later call <see cref="M:Au.Icons.DestroyIconHandle(System.IntPtr)"/> or <see cref="M:Au.Icons.HandleToImage(System.IntPtr)"/>. Or instead use <see cref="M:Au.Icons.GetFileIconImage(System.String,System.Int32,Au.Types.GIFlags)"/>.
            </summary>
            <param name="file">
            Can be:
            Path of any file or folder.
            URL, like "http://..." or "mailto:a@b.c" or "file:///path".
            ITEMIDLIST like ":: HexEncodedITEMIDLIST". It can be of any file, folder, URL or virtual object like Control Panel. See <see cref="M:Au.Shell.Pidl.ToHexString"/>.
            Shell object parsing name, like @"::{CLSID-1}\::{CLSID-2}" or "shell:AppsFolder\WinStoreAppId".
            File type like ".txt" or URL protocol like "http:".
            If it is a file containing multiple icons (eg exe, dll), can be specified icon index like "path,index" or native icon resource id like "path,-id".
            If not full path, the function will look in <see cref="P:Au.Folders.ThisAppImages"/>.
            Supports environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>).
            </param>
            <param name="size">Icon width and height. Also can be enum <see cref="T:Au.Icons.ShellSize"/>, cast to int.</param>
            <param name="flags"></param>
            <seealso cref="M:Au.Wnd.Misc.GetIconHandle(Au.Wnd,System.Boolean)"/>
        </member>
        <member name="M:Au.Icons.GetPidlIconHandle(Au.Shell.Pidl,System.Int32)">
            <summary>
            Gets icon of a file or other shell object specified as ITEMIDLIST.
            Returns native icon handle. Returns default(IntPtr) if failed.
            Later call <see cref="M:Au.Icons.DestroyIconHandle(System.IntPtr)"/> or <see cref="M:Au.Icons.HandleToImage(System.IntPtr)"/>. Or instead use <see cref="M:Au.Icons.GetPidlIconImage(Au.Shell.Pidl,System.Int32)"/>.
            </summary>
            <param name="pidl">ITEMIDLIST pointer (PIDL).</param>
            <param name="size">Icon width and height. Also can be enum <see cref="T:Au.Icons.ShellSize"/>, cast to int.</param>
        </member>
        <member name="T:Au.Icons.ShellSize">
            <summary>
            Standard icon sizes.
            </summary>
            <tocexclude />
        </member>
        <member name="F:Au.Icons.ShellSize.SysSmall">
            <summary>
            Icons displayed in window title bar and system notification area (tray). Usually 16x16 when normal DPI, the same as Small.
            </summary>
        </member>
        <member name="F:Au.Icons.ShellSize.Small">
            <summary>
            Small icons displayed in Explorer folders. Usually 16x16 when normal DPI.
            </summary>
        </member>
        <member name="F:Au.Icons.ShellSize.Large">
            <summary>
            Large icons displayed in Explorer folders. Usually 32x32 when normal DPI.
            </summary>
        </member>
        <member name="F:Au.Icons.ShellSize.ExtraLarge">
            <summary>
            Extra large icons displayed in Explorer folders. Usually 48x48 when normal DPI.
            </summary>
        </member>
        <member name="F:Au.Icons.ShellSize.Jumbo">
            <summary>
            256x256 icons displayed in Explorer folders.
            </summary>
        </member>
        <member name="M:Au.Icons.GetShellIconSize(Au.Icons.ShellSize)">
            <summary>
            Gets the width and height of shell icons of standard sizes - small, large, extra large and jumbo.
            Jumbo is always 256. Others depend on text size (DPI) that can be changed in Control Panel. If text size is 100%, they usually are 16, 32, 48.
            </summary>
            <param name="shellSize"><see cref="T:Au.Icons.ShellSize"/></param>
        </member>
        <member name="M:Au.Icons.GetFileIconHandleRaw(System.String,System.Int32,System.Int32)">
            <summary>
            Extracts icon directly from file that contains it.
            Returns icon handle. Returns default(IntPtr) if failed.
            Later call <see cref="M:Au.Icons.DestroyIconHandle(System.IntPtr)"/> or <see cref="M:Au.Icons.HandleToImage(System.IntPtr)"/>.
            </summary>
            <param name="file">.ico, .exe, .dll or other file that contains one or more icons. Also supports cursor files - .cur, .ani. Must be full path, without icon index. Supports environment variables (see <see cref="M:Au.Path_.ExpandEnvVar(System.String)"/>).</param>
            <param name="index">Icon index or negative icon resource id in the .exe/.dll file.</param>
            <param name="size">Icon width and height. Also can be enum <see cref="T:Au.Icons.ShellSize"/>, cast to int.</param>
        </member>
        <member name="M:Au.Icons.GetShellStockIconHandle(Au.Types.Native.SHSTOCKICONID,System.Int32)">
            <summary>
            Gets a shell stock icon handle.
            Later call <see cref="M:Au.Icons.DestroyIconHandle(System.IntPtr)"/> or <see cref="M:Au.Icons.HandleToImage(System.IntPtr)"/>.
            </summary>
            <param name="icon">Shell stock icon id. For example Native.SHSTOCKICONID.SIID_APPLICATION.</param>
            <param name="size">Icon width and height. Also can be enum <see cref="T:Au.Icons.ShellSize"/>, cast to int.</param>
        </member>
        <member name="M:Au.Icons.GetAppIconHandle(System.Int32)">
            <summary>
            Gets the first native icon handle of the entry assembly of this appdomain.
            Returns default(IntPtr) if there are no icons.
            It is not an icon from managed resources.
            The icon is cached and protected from destroying, therefore don't need to destroy it, and not error to do it.
            </summary>
            <param name="size">Icon width and height. Also can be enum <see cref="T:Au.Icons.ShellSize"/>, cast to int.</param>
        </member>
        <member name="M:Au.Icons.GetProcessExeIconHandle(System.Int32)">
            <summary>
            Gets the first native icon handle of the program file of this process.
            Returns default(IntPtr) if there are no icons.
            It is not an icon from managed resources.
            The icon is cached and protected from destroying, therefore don't need to destroy it, and not error to do it.
            </summary>
            <param name="size">Icon width and height. Also can be enum <see cref="T:Au.Icons.ShellSize"/>, cast to int.</param>
        </member>
        <member name="M:Au.Icons.CreateBlankIcon(System.Int32,System.Int32)">
            <summary>
            Creates completely transparent monochrome icon.
            Returns icon handle.
            Later call <see cref="M:Au.Icons.DestroyIconHandle(System.IntPtr)"/> or <see cref="M:Au.Icons.HandleToImage(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="M:Au.Icons.DestroyIconHandle(System.IntPtr)">
            <summary>
            Destroys native icon.
            Calls API <msdn>DestroyIcon</msdn>. Does nothing if iconHandle is default.
            </summary>
        </member>
        <member name="M:Au.Icons.ParseIconLocation(System.String@,System.Int32@)">
            <summary>
            Parses icon location string.
            Returns true if it includes icon index or resource id.
            </summary>
            <param name="s">Icon location. Can be "path,index" or "path,-id" or just path. Receives path.</param>
            <param name="index">Receives the number or 0.</param>
            <remarks>Also supports path enclosed in double quotes like "\"path\",index", and spaces between comma and index like "path, index".</remarks>
        </member>
        <member name="T:Au.Icons.AsyncIn">
            <summary>
            For <see cref="M:Au.Icons.AsyncIcons.Add(System.Collections.Generic.IEnumerable{Au.Icons.AsyncIn})"/>. 
            </summary>
            <tocexclude />
        </member>
        <member name="T:Au.Icons.AsyncResult">
            <summary>
            For <see cref="T:Au.Icons.AsyncCallback"/>. 
            </summary>
            <tocexclude />
        </member>
        <member name="F:Au.Icons.AsyncResult.file">
            <summary>file passed to AsyncIcons.Add().</summary>
        </member>
        <member name="F:Au.Icons.AsyncResult.obj">
            <summary>obj passed to AsyncIcons.Add().</summary>
        </member>
        <member name="F:Au.Icons.AsyncResult.hIcon">
            <summary>Icon handle. You can use <see cref="M:Au.Icons.HandleToImage(System.IntPtr)"/> if need Image; else finally call <see cref="M:Au.Icons.DestroyIconHandle(System.IntPtr)"/>. Can be default(IntPtr).</summary>
        </member>
        <member name="M:Au.Icons.AsyncResult.#ctor(System.String,System.Object)">
            <summary>Icon converted to Image object, if used IconFlags.NeedImage and the thread pool decided to convert handle to Image. You should call Dispose() when finished using it. Can be null.</summary>
        </member>
        <member name="T:Au.Icons.AsyncCallback">
            <summary>
            For <see cref="M:Au.Icons.AsyncIcons.GetAllAsync(Au.Icons.AsyncCallback,System.Int32,Au.Types.GIFlags,System.Object)"/>. 
            </summary>
            <param name="result">Contains icon Image or handle, as well as the input parameters. <see cref="T:Au.Icons.AsyncResult"/></param>
            <param name="objCommon">objCommon passed to <see cref="M:Au.Icons.AsyncIcons.GetAllAsync(Au.Icons.AsyncCallback,System.Int32,Au.Types.GIFlags,System.Object)">GetAllAsync</see>.</param>
            <param name="nLeft">How many icons is still to get. Eg 0 if this is the last icon.</param>
            <tocexclude />
        </member>
        <member name="T:Au.Icons.AsyncIcons">
            <summary>
            Gets file icons asynchronously.
            Use to avoid waiting until all icons are extracted before displaying them in a UI (menu etc).
            Instead you show the UI without icons, and then asynchronously receive icons when they are extracted.
            At first call <see cref="M:Au.Icons.AsyncIcons.Add(System.String,System.Object)"/> for each file. Then call <see cref="M:Au.Icons.AsyncIcons.GetAllAsync(Au.Icons.AsyncCallback,System.Int32,Au.Types.GIFlags,System.Object)">GetAllAsync</see>.
            Create a callback function of type <see cref="T:Au.Icons.AsyncCallback"/> and pass its delegate to GetAllAsync.
            </summary>
        </member>
        <member name="M:Au.Icons.AsyncIcons.Add(System.String,System.Object)">
            <summary>
            Adds a file path to an internal collection.
            </summary>
            <param name="file">File path etc to pass to <see cref="M:Au.Icons.GetFileIconHandle(System.String,System.Int32,Au.Types.GIFlags)"/>.</param>
            <param name="obj">Something to pass to your callback function together with icon handle for this file.</param>
        </member>
        <member name="M:Au.Icons.AsyncIcons.Add(System.Collections.Generic.IEnumerable{Au.Icons.AsyncIn})">
            <summary>
            Adds multiple file paths to an internal collection.
            The same as calling Add(string, object) multiple times.
            This function copies the list.
            </summary>
        </member>
        <member name="P:Au.Icons.AsyncIcons.Count">
            <summary>
            Gets the number of items added with Add().
            GetAllAsync() sets it = 0.
            </summary>
        </member>
        <member name="M:Au.Icons.AsyncIcons.GetAllAsync(Au.Icons.AsyncCallback,System.Int32,Au.Types.GIFlags,System.Object)">
            <summary>
            Starts getting icons of files added with Add().
            After this function returns, icons are asynchronously extracted with <see cref="M:Au.Icons.GetFileIconHandle(System.String,System.Int32,Au.Types.GIFlags)"/>, and callback called with icon handle (or default(IntPtr) if failed).
            The callback is called in this thread. This thread must have a message loop (eg Application.Run()).
            If you'll need more icons, you can call Add() and GetAllAsync() again with the same AsyncIcons instance, even if getting old icons if still not finished.
            </summary>
            <param name="callback">A callback function delegate.</param>
            <param name="iconSize">Icon width and height. Also can be enum <see cref="T:Au.Icons.ShellSize"/>, cast to int.</param>
            <param name="flags"><see cref="T:Au.Types.GIFlags"/></param>
            <param name="objCommon">Something to pass to callback functions.</param>
        </member>
        <member name="M:Au.Icons.AsyncIcons.Clear">
            <summary>
            Clears the internal collection of file paths added with Add().
            </summary>
        </member>
        <member name="M:Au.Icons.AsyncIcons.Cancel">
            <summary>
            Stops getting icons and calling callback functions.
            </summary>
        </member>
        <member name="M:Au.Icons.AsyncIcons.Dispose">
            <summary>
            Calls <see cref="M:Au.Icons.AsyncIcons.Cancel"/>.
            </summary>
        </member>
        <member name="M:Au.Icons.AsyncIcons.Finalize">
            
        </member>
        <member name="T:Au.Icons.FileIconCache">
            <summary>
            Gets file icons.
            Uses 2-level cache - memory and file.
            </summary>
            <remarks>
            Can be used as static variables.
            </remarks>
        </member>
        <member name="M:Au.Icons.FileIconCache.#ctor(System.String,System.Int32)">
            <summary>
            Remembers cacheFile and iconSize.
            </summary>
            <param name="cacheFile"></param>
            <param name="iconSize"></param>
        </member>
        <member name="M:Au.Icons.FileIconCache.Finalize">
            
        </member>
        <member name="M:Au.Icons.FileIconCache.Dispose">
            <summary>
            Calls <see cref="M:Au.Icons.FileIconCache.SaveCacheFileNow"/>.
            </summary>
        </member>
        <member name="M:Au.Icons.FileIconCache.SaveCacheFileNow">
            <summary>
            Saves to the cache file now, if need.
            Don't need to call this explicitly. It is called by Dispose.
            </summary>
        </member>
        <member name="M:Au.Icons.FileIconCache.ClearCache">
            <summary>
            Clears the memory cache and deletes the cache file.
            </summary>
        </member>
        <member name="M:Au.Icons.FileIconCache.GetImage(System.String,System.Boolean)">
            <summary>
            Gets file icon as Bitmap.
            If it is in the memory cache, gets it from there.
            Else if it is in the file cache, gets it from there and adds to the memory cache.
            Else gets from file (uses <see cref="M:Au.Icons.GetFileIconImage(System.String,System.Int32,Au.Types.GIFlags)"/> and adds to the file cache and to the memory cache.
            Returns null if GetFileIconImage failed, eg file does not exist.
            </summary>
            <param name="file">Any file or folder.</param>
            <param name="useExt">
            Get file type icon, depending on filename extension. Use this to avoid getting separate image object for each file of same type.
            This is ignored if filename extension is ".ico" or ".exe" or starts with ".exe," or ".dll,".
            </param>
            <remarks>
            Thread-safe. The variable can be static, and this function can be called from any thread without locking.
            </remarks>
        </member>
        <member name="T:Au.Script">
            <summary>
            Base class of user main script class. Manages script options, calling script methods on launch/trigger, etc.
            </summary>
        </member>
        <member name="M:Au.Script.CallFirstMethod">
            <summary>
            Calls the first non-static method of the derived class.
            The method must have 0 parameters.
            </summary>
        </member>
        <member name="M:Au.Script.CallTriggerMethod(System.String,System.Object)">
            <summary>
            Calls a non-static method of the derived class by name.
            </summary>
            <param name="name">Method name. The method must have 0 or 1 parameter.</param>
            <param name="eventData">An argument.</param>
        </member>
        <member name="T:Au.Perf">
            <summary>
            Code speed measurement.
            Easier to use than System.Stopwatch class.
            Stores data in shared memory, therefore works across appdomains.
            </summary>
        </member>
        <member name="T:Au.Perf.Inst">
            <summary>
            The same as Perf class, but allows to have multiple independent speed measurements.
            Stores data int the variable, not in shared memory like Perf class.
            </summary>
        </member>
        <member name="P:Au.Perf.Inst.Incremental">
            <summary>
            If true, times of each new First/Next/Next... measurement are added to previous measurement times.
            Finally you can call Write() or Times to get the sums.
            Usually used to measure code in loops. See example.
            </summary>
            <example><code>
            var perf = new Perf.Inst();
            perf.Incremental = true;
            for(int i = 0; i &lt; 5; i++) {
            	Thread.Sleep(100); //not included in the measurement
            	perf.First();
            	Thread.Sleep(30); //will make sum ~150000
            	perf.Next();
            	Thread.Sleep(10); //will make sum ~50000
            	perf.Next();
            	Thread.Sleep(100); //not included in the measurement
            }
            perf.Write(); //speed:  154317  51060  (205377)
            perf.Incremental = false;
            </code></example>
        </member>
        <member name="M:Au.Perf.Inst.First">
            <summary>
            Stores current time in the first element of an internal array.
            </summary>
        </member>
        <member name="M:Au.Perf.Inst.First(System.Int32)">
            <summary>
            Calls <see cref="M:Au.Perf.Inst.SpinCPU(System.Int32,System.Action[])">SpinCPU</see>(spinCpuMS) and <see cref="M:Au.Perf.Inst.First"/>.
            </summary>
        </member>
        <member name="M:Au.Perf.Inst.First(System.Int32,System.Action[])">
            <summary>
            Calls <see cref="M:Au.Perf.Inst.SpinCPU(System.Int32,System.Action[])">SpinCPU</see>(spinCpuMS, codes) and <see cref="M:Au.Perf.Inst.First"/>.
            </summary>
        </member>
        <member name="M:Au.Perf.Inst.Next(System.Char)">
            <summary>
            Stores current time in next element of an internal array.
            Don't call Next() more than 16 times after First(), because the array has fixed size.
            </summary>
            <param name="cMark">A character to mark that time in the results string, like "A=150".</param>
        </member>
        <member name="M:Au.Perf.Inst.Write">
            <summary>
            Formats a string from time values collected by calling First() and Next(), and shows it in the output.
            The string contains the number of microseconds of each code execution between calling First() and each Next().
            </summary>
        </member>
        <member name="M:Au.Perf.Inst.NW(System.Char)">
            <summary>
            Calls <see cref="M:Au.Perf.Inst.Next(System.Char)"/> and <see cref="M:Au.Perf.Inst.Write"/>.
            </summary>
            <param name="cMark">A character to mark that time in the results string, like "A=150".</param>
        </member>
        <member name="P:Au.Perf.Inst.Times">
            <summary>
            Formats a string from time values collected by calling First() and Next().
            The string contains the number of microseconds of each code execution between calling First() and each Next().
            </summary>
        </member>
        <member name="P:Au.Perf.Inst.TimeTotal">
            <summary>
            Gets the number of microseconds between First() and the last Next().
            </summary>
        </member>
        <member name="M:Au.Perf.Inst.Execute(System.Int32,System.Action)">
            <summary>
            Executes code (lambda) nTimes times, and then calls Next().
            </summary>
        </member>
        <member name="M:Au.Perf.Inst.ExecuteMulti(System.Int32,System.Int32,System.Action[])">
            <summary>
            nTimesAll times executes this code: <c>First(); foreach(Action a in codes) Execute(nTimesEach, a); Write();</c>.
            </summary>
        </member>
        <member name="M:Au.Perf.Inst.SpinCPU(System.Int32,System.Action[])">
            <summary>
            Repeatedly executes codes (zero or more lambda functions) for the specified number of milliseconds.
            </summary>
        </member>
        <member name="P:Au.Perf.Incremental">
            <summary>
            If true, times of each new First/Next/Next... measurement are added to previous measurement times.
            Finally you can call Write() or Times to get the sums.
            Usually used to measure code in loops. See example.
            </summary>
            <example><code>
            Perf.Incremental = true;
            for(int i = 0; i &lt; 5; i++) {
            	Thread.Sleep(100); //not included in the measurement
            	Perf.First();
            	Thread.Sleep(30); //will make sum ~150000
            	Perf.Next();
            	Thread.Sleep(10); //will make sum ~50000
            	Perf.Next();
            	Thread.Sleep(100); //not included in the measurement
            }
            Perf.Write(); //speed:  154317  51060  (205377)
            Perf.Incremental = false;
            </code></example>
        </member>
        <member name="M:Au.Perf.First">
            <summary>
            Stores current time in the first element of an internal array.
            </summary>
        </member>
        <member name="M:Au.Perf.First(System.Int32)">
            <summary>
            Calls <see cref="M:Au.Perf.SpinCPU(System.Int32,System.Action[])"/>(spinCpuMS) and <see cref="M:Au.Perf.First"/>.
            </summary>
        </member>
        <member name="M:Au.Perf.First(System.Int32,System.Action[])">
            <summary>
            Calls <see cref="M:Au.Perf.SpinCPU(System.Int32,System.Action[])"/>(spinCpuMS, codes) and <see cref="M:Au.Perf.First"/>.
            </summary>
        </member>
        <member name="M:Au.Perf.Next(System.Char)">
            <summary>
            Stores current time in next element of an internal array.
            Don't call Next() more than 16 times after First(), because the array has fixed size.
            </summary>
            <param name="cMark">A character to mark that time in the results string, like "A=150".</param>
        </member>
        <member name="M:Au.Perf.Write">
            <summary>
            Formats a string from time values collected by calling First() and Next(), and shows it in the output.
            The string contains the number of microseconds of each code execution between calling First() and each Next().
            Example: <c>Perf.First(100); CODE1; Perf.Next(); CODE2; Perf.Next(); Perf.Write(); //speed: timeOfCODE1 timeOfCODE2</c>.
            </summary>
        </member>
        <member name="M:Au.Perf.NW(System.Char)">
            <summary>
            Calls <see cref="M:Au.Perf.Next(System.Char)"/> and <see cref="M:Au.Perf.Write"/>.
            You can use <c>Perf.NW();</c> instead of <c>Perf.Next(); Perf.Write();</c>.
            </summary>
            <param name="cMark">A character to mark that time in the results string, like "A=150".</param>
        </member>
        <member name="P:Au.Perf.Times">
            <summary>
            Formats a string from time values collected by calling First() and Next().
            The string contains the number of microseconds of each code execution between calling First() and each Next().
            </summary>
        </member>
        <member name="P:Au.Perf.TimeTotal">
            <summary>
            Gets the number of microseconds between First() and the last Next().
            </summary>
        </member>
        <member name="M:Au.Perf.Execute(System.Int32,System.Action)">
            <summary>
            Executes code (lambda) nTimes times, and then calls Next().
            </summary>
        </member>
        <member name="M:Au.Perf.ExecuteMulti(System.Int32,System.Int32,System.Action[])">
            <summary>
            nTimesAll times executes this code: <c>First(); foreach(Action a in codes) Execute(nTimesEach, a); Write();</c>.
            </summary>
        </member>
        <member name="M:Au.Perf.SpinCPU(System.Int32,System.Action[])">
            <summary>
            Repeatedly executes codes (zero or more lambda functions) for the specified number of milliseconds (recommended 100 or more).
            Can be called before measuring code speed, because after some idle time CPU may need to work for some time to gain full speed.
            </summary>
        </member>
        <member name="M:Au.Perf.StartNew">
            <summary>
            Creates/returns new <see cref="T:Au.Perf.Inst"/> variable and calls its <see cref="M:Au.Perf.Inst.First"/>.
            </summary>
        </member>
    </members>
</doc>
