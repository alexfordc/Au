#if true
			internal void DragDockStart()
			{
				//For indicator we create native window, not form, because .NET makes difficult to create form as we want (need unreliable workarounds to set correct visibility, size, prevent activation).
				const string className = "CatDockIndicator";
				Wnd.Misc.WndClass.InterDomainRegister(className, _dragDocWndproc);
				const uint exs = Api.WS_EX_LAYERED | Api.WS_EX_NOACTIVATE | Api.WS_EX_TOOLWINDOW;
				var r = _manager._firstSplit.RectangleInScreen;
				_wDockIndicator = Wnd.Misc.WndClass.InterDomainCreateWindow(exs, className, null, Api.WS_POPUP, r.X, r.Y, r.Width, r.Height, (Wnd)this);
				_wDockIndicator.Transparency(true, 0.3, 0xFFFF);
			}
			static Native.WNDPROC _dragDocWndproc = _DragDocWndproc;
			static LPARAM _DragDocWndproc(Wnd w, uint msg, LPARAM wParam, LPARAM lParam)
			{
				//Util.Debug_.OutMsg(w, msg, wParam, lParam);
				switch(msg) {
				case Api.WM_ERASEBKGND: return 0;
				case Api.WM_PAINT:
					PAINTSTRUCT ps; var dc = BeginPaint(w, out ps);
					var g = Graphics.FromHdc(dc);
					_DragDockPaint(w, g);
					g.Dispose();
					EndPaint(w, ref ps);
					return 0;
				}
				//_Api.CreateSolidBrush(0xFF901E) //Color.DodgerBlue
				return Api.DefWindowProc(w, msg, wParam, lParam);
			}

			unsafe struct PAINTSTRUCT
			{
				public IntPtr hdc;
				public bool fErase;
				public RECT rcPaint;
				public bool fRestore;
				public bool fIncUpdate;
				fixed byte rgbReserved[32];
			}
			[DllImport("user32.dll")]
			static extern IntPtr BeginPaint(Wnd hWnd, out PAINTSTRUCT lpPaint);
			[DllImport("user32.dll")]
			static extern bool EndPaint(Wnd hWnd, [In] ref PAINTSTRUCT lpPaint);

			void _DragDockPaint(Wnd w, Graphics g)
			{

			}
#elif false
			internal void DragDockStart()
			{
				//For indicator we create native window, not form, because .NET makes difficult to create form as we want (need unreliable workarounds to set correct visibility, size, prevent activation).
				const uint exs = Api.WS_EX_LAYERED | Api.WS_EX_NOACTIVATE | Api.WS_EX_TOOLWINDOW;
				_wDockIndicator = Api.CreateWindowEx(exs, "#32770", null, Api.WS_POPUP, 0, 0, 0, 0, (Wnd)this, 0, Zero, 0);
				_wDockIndicator.Transparency(true, 0.3);
				//_wDockIndicator.SetWindowLong(Api.GWL_WNDPROC, Marshal.GetFunctionPointerForDelegate(_dragDocWndproc));
			}
			static Native.WNDPROC _dragDocWndproc = _DragDocWndproc;
			static LPARAM _DragDocWndproc(Wnd w, uint msg, LPARAM wParam, LPARAM lParam)
			{
				//Util.Debug_.OutMsg(w, msg, wParam, lParam);
				//_Api.CreateSolidBrush(0xFF901E) //Color.DodgerBlue
				return Api.DefWindowProc(w, msg, wParam, lParam);
			}
#else
			internal void DragDockStart()
			{
				//For indicator we create native window, not form, because .NET makes difficult to create form as we want (need unreliable workarounds to set correct visibility, size, prevent activation).
				//Could be #32770, but then need to subclass to set background color. We instead create window class with blue background brush.
				const string className = "CatDockIndicator";
				const uint exs = Api.WS_EX_LAYERED | Api.WS_EX_NOACTIVATE | Api.WS_EX_TOOLWINDOW;
				bool retry = false;
				g1:
				_wDockIndicator = Api.CreateWindowEx(exs, className, null, Api.WS_POPUP, 0, 0, 0, 0, (Wnd)this, 0, Zero, 0);
				if(_wDockIndicator.Is0) {
					if(retry) return; retry = true;
					var x = new Api.WNDCLASSEX() { hbrBackground = _Api.CreateSolidBrush(0xFF901E) }; //Color.DodgerBlue
					Wnd.Misc.WndClass.InterDomainRegister(className, null, 0, 0, x); //without custom wndproc, because we need just background color
					goto g1;
				}
				_wDockIndicator.Transparency(true, 0.3);
			}
#endif

			Wnd _wDockIndicator;

			internal void DragDockEnd()
			{
				_wDockIndicator.Destroy();
			}

			internal void DragDockMove(POINT pScreen)
			{
				var p = _manager.PointToClient(pScreen);
				RECT r;
				_DragDockMove(p, out r);
				Wnd w = _wDockIndicator;
				if(r.IsEmpty) {
					w.Visible = false;
				} else {
					//w.Rect = _manager.RectangleToScreen(r);
					w.Visible = true;
					//Print(r);
				}
			}





		/// <summary>
		/// Mostly transparent rectangle (form) with indicators to show where the floating panel can be docked when dragging it.
		/// </summary>
		class GDockIndicator :Form
		{
			GDockPanels _manager;

			internal GDockIndicator(GDockPanels manager, GFloat gfloat)
			{
				_manager = manager;
#if true
				this.SuspendLayout();
				this.FormBorderStyle = FormBorderStyle.None;
				this.StartPosition = FormStartPosition.Manual;
				this.AutoScaleMode = AutoScaleMode.None;
				this.ControlBox = false;
				this.MaximizeBox = false;
				this.MinimizeBox = false;
				this.ShowIcon = false;
				this.ShowInTaskbar = false;
				//this.TopMost = true; //activates
				this.Size=new Size(1,1);
				this.BackColor = Color.DodgerBlue;
				this.Opacity = 0.3;
				this.ResumeLayout(false);
#else
				this.SuspendLayout();
				this.AutoScaleMode = AutoScaleMode.None;
				this.ControlBox = false;
				this.FormBorderStyle = FormBorderStyle.None;
				this.MaximizeBox = false;
				this.MinimizeBox = false;
				this.ShowIcon = false;
				this.ShowInTaskbar = false;
				this.StartPosition = FormStartPosition.Manual;
				this.Bounds = ((Wnd)_manager).Rect;
				//this.TopMost = true; //activates

				this.AllowTransparency = true;
				this.TransparencyKey = Color.Yellow;
				this.BackColor = Color.Yellow;
				this.Opacity = 0.5;

				this.ResumeLayout(false);
#endif
			}

			protected override CreateParams CreateParams
			{
				get
				{
					//This prevents resizing the window 3 times. But need to set FormBorderStyle, or will be wider.
					//note: this func is called several times, first time before ctor
					var p = base.CreateParams;
					//p.Style = unchecked((int)(Api.WS_POPUP | Api.WS_CLIPCHILDREN));
					//p.ExStyle = (int)(Api.WS_EX_TOOLWINDOW);
					PrintList(p.Style.ToString("X"), p.ExStyle.ToString("X"));
					p.Style |= unchecked((int)(Api.WS_POPUP));
					return p;
				}
			}

			internal void OnDragMouseMove(POINT pScreen)
			{
				var p = _manager.PointToClient(pScreen);
				RECT r;
				_OnDragMouseMove(p, out r);
				bool show = !r.IsEmpty;
				//if(!IsHandleCreated) {
				//	if(!show) return;
				//	Show(_manager);
				//}
				//}else if(Visible) {
				//	Visible = false;
				//}
				//indic.
				//((Wnd)indic).ZorderBefore(w);
			}

			void _OnDragMouseMove(POINT p, out RECT r)
			{
				r = new RECT();

				var firstSplit = _manager._firstSplit;
				if(firstSplit.IsHidden || !firstSplit.Bounds.Contains(p)) return;
				//PrintList(pScreen, p);


			}

			protected override bool ShowWithoutActivation { get { return true; } }
		}







	//public static class Control_
	//{
	//	public static void ZorderAfter(this Control t, Control c)
	//	{
	//		_ZorderAfterBefore(t, c, false);
	//	}

	//	public static void ZorderBefore(this Control t, Control c)
	//	{
	//		_ZorderAfterBefore(t, c, true);
	//	}

	//	static void _ZorderAfterBefore(Control t, Control c, bool before)
	//	{
	//		if(c == null) {
	//			if(before) t.SendToBack(); else t.BringToFront();
	//			return;
	//		}
	//		var parent = t.Parent;
	//		if(parent == null) {
	//			if(before) ((Wnd)t).ZorderBefore((Wnd)c);
	//			else ((Wnd)t).ZorderAfter((Wnd)c);
	//			return;
	//		}


	//	}
	//}
